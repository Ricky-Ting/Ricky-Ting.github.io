<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ricky Ting&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/5c8eecd06d08187c73ea49421008f04d</icon>
  <subtitle>当时只道是寻常</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-02-10T08:15:42.338Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Ricky-Ting</name>
    <email>1770048119@qq.com dbr1770048119@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>mac已装软件目录</title>
    <link href="http://yoursite.com/2018/02/10/mac%E5%B7%B2%E8%A3%85%E8%BD%AF%E4%BB%B6%E7%9B%AE%E5%BD%95/"/>
    <id>http://yoursite.com/2018/02/10/mac已装软件目录/</id>
    <published>2018-02-10T07:34:43.000Z</published>
    <updated>2018-02-10T08:15:42.338Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mac已装软件目录-更新至2018-2-10"><a href="#Mac已装软件目录-更新至2018-2-10" class="headerlink" title="Mac已装软件目录(更新至2018.2.10)"></a>Mac已装软件目录(更新至2018.2.10)</h1><p><strong>追随<a href="https://zhengzangw.github.io" target="_blank" rel="noopener">zzw大佬</a>的步伐</strong></p><h2 id="Develop"><a href="#Develop" class="headerlink" title="Develop"></a>Develop</h2><ul><li>Xcode</li><li>PyCharm Edu : for python</li><li>MATLAB_R2016b</li><li>Sublime Text</li><li>Mathematic</li><li><p>iTerm</p><a id="more"></a></li></ul><h2 id="Design"><a href="#Design" class="headerlink" title="Design"></a>Design</h2><ul><li>Adobe Photoshop</li><li>Adobe Premiere Pro</li><li>Adobe Audition CC</li><li>Total Video Converter Lite</li></ul><h2 id="Text"><a href="#Text" class="headerlink" title="Text"></a>Text</h2><ul><li>MacDown</li><li>Evernote</li><li>Texshop</li><li>Pages Keynote Numbers</li></ul><h2 id="Tools"><a href="#Tools" class="headerlink" title="Tools"></a>Tools</h2><ul><li>Chrome</li><li>Firefox</li><li>Parallels Desktop</li><li>EuDic</li><li>iStat Menus</li><li>Baidu Netdisk</li><li>Reeder</li><li>iText</li><li>uTorrent</li><li>WonderPen</li><li>The Unarchiver</li><li>每日英语听力</li><li>XMind</li><li>Reflector 2</li><li>Qlpmsg</li><li>Focusky</li><li>DjView</li><li>CAJCloudViewer</li><li>Blackmagic Disk Speed Test</li><li>1Checker</li><li>1Keyboard</li></ul><h2 id="Entertainment"><a href="#Entertainment" class="headerlink" title="Entertainment"></a>Entertainment</h2><ul><li>youku</li><li>mpv</li><li>aiqiyi</li><li>QQ Music</li><li>Netease Music</li><li>Steam</li><li>Lep’s World 2</li></ul><h2 id="Social-Networking"><a href="#Social-Networking" class="headerlink" title="Social Networking"></a>Social Networking</h2><ul><li>WeChat</li><li>QQ</li></ul><h2 id="Plugins"><a href="#Plugins" class="headerlink" title="Plugins"></a>Plugins</h2><ul><li>Snap</li><li>ShadowsocksX-R</li><li>Irvue</li><li>Alfred 3</li></ul><h2 id="virtual-machine"><a href="#virtual-machine" class="headerlink" title="virtual machine"></a>virtual machine</h2><ul><li>Windows 10</li><li>Ubuntu</li><li>Kail Linux </li></ul><h2 id="待装"><a href="#待装" class="headerlink" title="待装"></a>待装</h2><ul><li>VScode</li><li>SPSS</li><li>Dash</li><li>UltraEdit</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Mac已装软件目录-更新至2018-2-10&quot;&gt;&lt;a href=&quot;#Mac已装软件目录-更新至2018-2-10&quot; class=&quot;headerlink&quot; title=&quot;Mac已装软件目录(更新至2018.2.10)&quot;&gt;&lt;/a&gt;Mac已装软件目录(更新至2018.2.10)&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;追随&lt;a href=&quot;https://zhengzangw.github.io&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;zzw大佬&lt;/a&gt;的步伐&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;Develop&quot;&gt;&lt;a href=&quot;#Develop&quot; class=&quot;headerlink&quot; title=&quot;Develop&quot;&gt;&lt;/a&gt;Develop&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Xcode&lt;/li&gt;
&lt;li&gt;PyCharm Edu : for python&lt;/li&gt;
&lt;li&gt;MATLAB_R2016b&lt;/li&gt;
&lt;li&gt;Sublime Text&lt;/li&gt;
&lt;li&gt;Mathematic&lt;/li&gt;
&lt;li&gt;&lt;p&gt;iTerm&lt;/p&gt;
    
    </summary>
    
    
      <category term="Mac" scheme="http://yoursite.com/tags/Mac/"/>
    
      <category term="软件" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="记录" scheme="http://yoursite.com/tags/%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Python笔记</title>
    <link href="http://yoursite.com/2018/02/09/Python%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/02/09/Python笔记/</id>
    <published>2018-02-09T12:42:21.000Z</published>
    <updated>2018-02-09T12:44:06.714Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python笔记-未完待续"><a href="#Python笔记-未完待续" class="headerlink" title="Python笔记(未完待续)"></a>Python笔记(未完待续)</h1><h2 id="Python特点"><a href="#Python特点" class="headerlink" title="Python特点"></a>Python特点</h2><ul><li>简单</li><li>解释型</li><li>交互式</li><li>可移植</li><li>面向对象</li></ul><h2 id="Python特性"><a href="#Python特性" class="headerlink" title="Python特性"></a>Python特性</h2><ul><li>动态类型</li><li>自动内存管理</li><li>大型程序支持</li><li>内置对象类型</li></ul><h2 id="Python彩蛋"><a href="#Python彩蛋" class="headerlink" title="Python彩蛋"></a>Python彩蛋</h2><p>在交互解释器里输入<code>import this</code></p> <a id="more"></a><h2 id="Python解释器"><a href="#Python解释器" class="headerlink" title="Python解释器"></a>Python解释器</h2><p>有很多种，最常用的是CPython。 </p><p>解释器是输入一行就执行一行</p><p>输入<code>exit()</code>来退出解释器。</p><p>在终端里输入<code>python3 Filename.py</code>来执行python文件</p><p>在Mac和Linux上可以直接运行<code>.py</code>文件，方法是在<code>.py</code>文件的第一行加上一个特殊的注释:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br></pre></td></tr></table></figure><p>然后通过命令给<code>hello.py</code>以执行权限:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ chmod a+x hello.py</span><br></pre></td></tr></table></figure><p>以下一行注释是为了告诉Python解释器，按照UTF-8编码读取源代码，否则可能中文会有乱码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br></pre></td></tr></table></figure><h2 id="Python语法"><a href="#Python语法" class="headerlink" title="Python语法"></a>Python语法</h2><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p><code>print()</code>用<code>,</code>隔开多个输出。<strong>遇到逗号会输出一个空格</strong></p><h4 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h4><h5 id="print-方法"><a href="#print-方法" class="headerlink" title="print()方法"></a>print()方法</h5><table><thead><tr><th>占位符</th><th>替换内容 </th></tr></thead><tbody><tr><td>%d</td><td>整数  </td></tr><tr><td>%f</td><td>浮点数  </td></tr><tr><td>%s</td><td>字符串  </td></tr><tr><td>%x</td><td>十六进制整数</td></tr></tbody></table><h5 id="format-方法"><a href="#format-方法" class="headerlink" title="format()方法"></a>format()方法</h5><p>另一种格式化字符串的方法是使用字符串的format()方法，它会用传入的参数依次替换字符串内的占位符{0}、{1}……，不过这种方式写起来比%要麻烦得多：</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p><code>input()</code>。如:<code>name = input()</code>。又如<code>name = input(&#39;please enter your name&#39;)</code></p><p><code>input()</code>返回的是<code>str</code>类型，要进行转换，如<code>int()</code></p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>以<code>#</code>开头</p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="整数-int"><a href="#整数-int" class="headerlink" title="整数(int)"></a>整数(int)</h4><h4 id="浮点数-float"><a href="#浮点数-float" class="headerlink" title="浮点数(float)"></a>浮点数(float)</h4><h4 id="字符串-str"><a href="#字符串-str" class="headerlink" title="字符串(str)"></a>字符串(str)</h4><p>(<code>&#39;</code>和<code>&quot;</code>都可以) 可以用<code>r&#39;&#39;</code>表示<code>&#39;&#39;</code>里的字符串默认不转义 </p><p><code>ord()</code>获取字符的整数表示，<code>chr()</code>将编码转换为对应的字符 </p><p><code>encode()</code>和<code>decode()</code>方法 </p><p><code>len()</code>函数计算的是<code>str</code>的字符数,如果换成<code>bytes</code>,则计算字节数</p><h4 id="布尔值-bool"><a href="#布尔值-bool" class="headerlink" title="布尔值(bool)"></a>布尔值(bool)</h4><p>(<code>True</code>和<code>False</code>, <code>and</code>、<code>or</code>和<code>not</code>运算)</p><h4 id="空值"><a href="#空值" class="headerlink" title="空值"></a>空值</h4><p>用<code>None</code>表示</p><h4 id="列表-list"><a href="#列表-list" class="headerlink" title="列表(list)"></a>列表(list)</h4><p><code>classmates = [&#39;Michael&#39;, &#39;Bob&#39;, &#39;Tracy&#39;]</code> </p><p>可以用len()函数获取list的元素个数，</p><p>运用索引访问，从0开始，用-1做索引可以直接获取最后一个元素，一次类推，可以获取倒数第2个、倒数第3个···。</p><p>list有序可变：<code>append(element)</code>方法追加至末尾,<code>insert(position,element)</code>方法追插入至指定位置，删除末尾用<code>pop()</code>,删除指定位置的用<code>pop(i)</code>。</p><p>list里的元素可以不同类型，且可嵌套。</p><p>list有<code>sort()</code>方法</p><h4 id="元组-tuple"><a href="#元组-tuple" class="headerlink" title="元组(tuple)"></a>元组(tuple)</h4><p><code>classmates = (&#39;Michael&#39;, &#39;Bob&#39;, &#39;Tracy&#39;)</code></p><p>tuple与list类似，但是tuple一旦初始化就不能修改,即tuple没有append(),insert()方法。</p><p>定义一个只有1个元素的tuple得这样定义:<code>t=(1,)</code>。 </p><p>tuple里嵌套的list可变</p><h4 id="字典-dict"><a href="#字典-dict" class="headerlink" title="字典(dict)"></a>字典(dict)</h4><p>(<code>d = {&#39;Michael&#39;: 95, &#39;Bob&#39;: 75, &#39;Tracy&#39;: 85}</code>)</p><p>在其他语言中也称为map，使用键-值(key-value)储存。</p><p>一个key只能对应一个value，多次放入会把前面的值冲掉。</p><p>用<code>in</code>判断key是否存在如<code>&gt;&gt;&gt; &#39;Thomas&#39; in d</code>。<code>get()</code>方法，</p><p>如果key不存在就返回<code>None</code>,或者自己指定的value，如<code>d.get(&#39;Thomas,-1&#39;)</code></p><p>要删除一个key，用pop(key),对应的value也会从dict中删除。</p><p>dict的key必须是不可变对象，所以list不能作为key</p><p><code>dict</code>的<code>items()</code>可以同时迭代key和value:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for k,v in d.items():</span><br><span class="line">print(k,&apos;=&apos;,v)</span><br></pre></td></tr></table></figure><p>list特点：</p><ol><li>查找和插入的时间随着元素的增加而增加；</li><li>占用空间小，浪费内存很少。</li></ol><p>dict特点：</p><ol><li>找和插入的速度极快，不会随着key的增加而变慢；</li><li>需要占用大量的内存，内存浪费多。</li></ol><h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><p>set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key,重复元素在set中自动被过滤。</p><p>要创建一个set，需要提供一个list作为输入集合：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = set([1, 2, 3])</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">&#123;1, 2, 3&#125;</span><br></pre></td></tr></table></figure><p><code>add(key)</code>方法来添加key，<code>remove(key)</code>方法可以删除元素</p><p><code>s1 &amp; s2</code>：集合交， <code>s1 | s2</code>集合并</p><h4 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h4><p><code>int()</code> <code>float()</code> <code>str()</code> <code>bool()</code></p><p><em>变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言</em><br><em>返回<code>None</code>的时候Python的交互环境不显示结果</em><br><em>常量名常用大写表示，如<code>PI</code></em></p><p><em>Python中有两种除法,<code>/</code>的结果是浮点数，’//‘的结果是整数</em></p><p><em>取余为<code>%</code></em></p><p><em>UTF-8为可变长编码，把一个Unicode字符根据不同的数字大小编码成1-6个字节</em></p><h3 id="程序结构"><a href="#程序结构" class="headerlink" title="程序结构"></a>程序结构</h3><h4 id="分支语句"><a href="#分支语句" class="headerlink" title="分支语句"></a>分支语句</h4><h5 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if &lt;条件判断1&gt;:</span><br><span class="line">    &lt;执行1&gt;</span><br><span class="line">elif &lt;条件判断2&gt;:</span><br><span class="line">    &lt;执行2&gt;</span><br><span class="line">elif &lt;条件判断3&gt;:</span><br><span class="line">    &lt;执行3&gt;</span><br><span class="line">else:</span><br><span class="line">    &lt;执行4&gt;</span><br></pre></td></tr></table></figure><p>判断条件还可以简写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if x:</span><br><span class="line">    print(&apos;True&apos;)</span><br></pre></td></tr></table></figure><p>只要<code>x</code>是非零数值、非空字符串、非空list等，就判断为<code>True</code>，否则为<code>False</code>。</p><h4 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h4><h5 id="for"><a href="#for" class="headerlink" title="for"></a>for</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">names = [&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;]</span><br><span class="line">for name in names:</span><br><span class="line">    print(name)</span><br></pre></td></tr></table></figure><p><em><code>range()</code>函数可以生成一个整数序列，比如<code>range(5)</code>生成的序列是从0开始小于5的整数</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sum = 0</span><br><span class="line">for x in range(101):</span><br><span class="line">    sum = sum + x</span><br><span class="line">print(sum)</span><br></pre></td></tr></table></figure><h5 id="while"><a href="#while" class="headerlink" title="while"></a>while</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sum = 0</span><br><span class="line">n = 99</span><br><span class="line">while n &gt; 0:</span><br><span class="line">    sum = sum + n</span><br><span class="line">    n = n - 2</span><br><span class="line">print(sum)</span><br></pre></td></tr></table></figure><p><em><code>break</code>和<code>continue</code>与C++中类似。</em></p><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”：<code>a = abs</code></p><h5 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def my_abs(x):</span><br><span class="line">    if x &gt;= 0:</span><br><span class="line">        return x</span><br><span class="line">    else:</span><br><span class="line">        return -x</span><br></pre></td></tr></table></figure><p><code>return None</code>可以简写为<code>return</code></p><h6 id="空函数"><a href="#空函数" class="headerlink" title="空函数"></a>空函数</h6><p>可以用<code>pass</code>语句，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def nop():</span><br><span class="line">pass</span><br></pre></td></tr></table></figure><p><code>pass</code>也可以放在其他语句里,如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if condition:</span><br><span class="line">pass</span><br></pre></td></tr></table></figure><h6 id="参数检查"><a href="#参数检查" class="headerlink" title="参数检查"></a>参数检查</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def my_abs(x):</span><br><span class="line">    if not isinstance(x, (int, float)):</span><br><span class="line">        raise TypeError(&apos;bad operand type&apos;)</span><br><span class="line">    if x &gt;= 0:</span><br><span class="line">        return x</span><br><span class="line">    else:</span><br><span class="line">        return -x</span><br></pre></td></tr></table></figure><p>函数可以返回多个值(实质上是tuple)，并可按位置赋给相应的变量</p><h6 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h6><p><code>def power(x,n=2):</code></p><p><em>必选参数在前，默认参数在后。</em><br><em>不按默认顺序提供参数是，需要把参数名写上。</em><br><em>定义默认参数要牢记一点：默认参数必须指向不变对象！不然不同次的调用会出现不同的结果。</em></p><h6 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h6><p><code>def calc(*numbers):</code>相当于传入一个tuple</p><p>若已有list和tuple 可这样调用<code>calc(*nums)</code></p><h6 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h6><p><code>def person(name, age, **kw):</code>:会组建一个dict</p><p>和可变参数类似，也可以先组装出一个dict，然后，把该dict转换为关键字参数传进去：</p><h6 id="命名关键字参数"><a href="#命名关键字参数" class="headerlink" title="命名关键字参数"></a>命名关键字参数</h6><p>如果要限制关键字参数的名字，就可以用命名关键字参数，例如，只接收city和job作为关键字参数。这种方式定义的函数如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def person(name, age, *, city, job):</span><br><span class="line">    print(name, age, city, job)</span><br></pre></td></tr></table></figure><p>和关键字参数<code>**kw</code>不同，命名关键字参数需要一个特殊分隔符<code>*</code>，<code>*</code>后面的参数被视为命名关键字参数。</p><p>如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符*了：</p><p>命名关键字参数必须传入参数名，这和位置参数不同。如果没有传入参数名，调用将报错：</p><p>命名关键字参数可以有缺省值，从而简化调用：</p><h6 id="参数组合"><a href="#参数组合" class="headerlink" title="参数组合"></a>参数组合</h6><p>在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。</p><h5 id="函数递归"><a href="#函数递归" class="headerlink" title="函数递归"></a>函数递归</h5><p><em>尾递归可以进行优化，但大多数编译器和解释器没有进行优化</em></p><h4 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h4><p>可以对list,tuple,str操作，相当于截取，如:<code>l[1:3]</code>取索引为1和2的元素组成一个list，还可以设置间隔如：<code>l[0:100;5]</code>每五个取一个</p><h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><p>for…in 可以迭代任何可迭代的对象(如dict)</p><p>如何判断是否可以迭代：通过collections模块的Iterable类型判断。<br><code>isinstance(&#39;abc&#39;, Iterable)</code></p><p>Python内置的<code>enumerate</code>函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for i,value in enumerate([&apos;A&apos;,&apos;B&apos;,&apos;C&apos;]):</span><br><span class="line">print(i,value)</span><br></pre></td></tr></table></figure><h4 id="列表生成式-List-Comprehension"><a href="#列表生成式-List-Comprehension" class="headerlink" title="列表生成式(List Comprehension)"></a>列表生成式(List Comprehension)</h4><p><code>list(range(1,11))</code>生成<code>[1,2,3,4,5,6,7,8,9,10]</code></p><p><code>[x * x for x in range(1,11)]</code>生成 <code>[1,4,9,16,25,36,49,64,81,100]</code></p><p><code>[x * x for x in range(1,11) if x % 2 == 0]</code>生成<code>[4,16,36,64,100]</code></p><p><code>[m+n for m in &#39;ABC&#39; for n in &#39;XYZ&#39;]</code>生成<code>[&#39;AX&#39;, &#39;AY&#39;, &#39;AZ&#39;, &#39;BX&#39;, &#39;BY&#39;, &#39;BZ&#39;, &#39;CX&#39;, &#39;CY&#39;, &#39;CZ&#39;]</code></p><h4 id="生成器-generator"><a href="#生成器-generator" class="headerlink" title="生成器(generator)"></a>生成器(generator)</h4><p>边循环边计算，把<code>[]</code>变为<code>()</code>就可以了</p><p>可以通过<code>next()</code>打印generator的下一个返回值 </p><p>还可以用for循环迭代</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">g = (x*x for x in range(10))</span><br><span class="line">for n in g:</span><br><span class="line">print(n)</span><br></pre></td></tr></table></figure><p>如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator。generator和函数的执行流程不一样。函数是顺序执行，遇到return语句或者最后一行函数语句就返回。而变成generator的函数，在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行。</p><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>凡是可作用于<code>for</code>循环的对象都是<code>Iterable</code>类型；</p><p>凡是可作用于<code>next()</code>函数的对象都是<code>Iterator</code>类型，它们表示一个惰性计算的序列；</p><p>可以使用<code>isinstance()</code>判断一个对象是否是<code>Iterator</code>对象：</p><p>集合数据类型如<code>list</code>、<code>dict</code>、<code>str</code>等是<code>Iterable</code>但不是<code>Iterator</code>，不过可以通过<code>iter()</code>函数获得一个<code>Iterator</code>对象。</p><p>Python的<code>for</code>循环本质上就是通过不断调用<code>next()</code>函数实现的</p><h4 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h4><h5 id="高阶函数（Higher-order-function）"><a href="#高阶函数（Higher-order-function）" class="headerlink" title="高阶函数（Higher-order-function）"></a>高阶函数（Higher-order-function）</h5><p>函数可以赋值给变量，函数名也是变量</p><p>一个函数接受另一个函数作为参数，这种函数被称为高阶函数。</p><h6 id="map-和reduce-函数"><a href="#map-和reduce-函数" class="headerlink" title="map()和reduce()函数"></a><code>map()</code>和<code>reduce()</code>函数</h6><p><code>map()</code>函数接受两个参数，一个是函数，一个是<code>Iterable</code>,<code>map</code>将传入的函数依次作用到序列的每个元素，并把结果作为新的<code>Iterator</code>返回</p><p><code>reduce()</code>把一个函数作用在一个序列<code>[x1,x2,x3,...]</code>上。<code>reduce</code>把结果继续和序列的下一个元素做累积计算</p><p><code>reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)</code></p><h6 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h6><p>Python内建的<code>filter()</code>函数用于过滤序列。</p><p><code>filter()</code>把传入的函数依次作用于每个元素，然后根据返回值是<code>True</code>还是<code>False</code>决定保留还是丢弃该元素。</p><p><code>filter()</code>函数返回的是一个<code>Iterator</code>，也就是一个惰性序列，所以要强迫<code>filter()</code>完成计算结果，需要用<code>list()</code>函数获得所有结果并返回list。</p><h6 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h6><p><code>sorted()</code>函数也是一个高阶函数，它还可以接收一个<code>key</code>函数来实现自定义的排序,如：</p><p><code>sorted([36, 5, -12, 9, -21], key=abs)</code></p><p>默认情况下，对字符串排序，是按照ASCII的大小比较的，</p><p>要进行反向排序，不必改动key函数，可以传入第三个参数<code>reverse=True</code></p><h5 id="返回函数"><a href="#返回函数" class="headerlink" title="返回函数"></a>返回函数</h5><p>函数作为返回值</p><p>闭包：返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。如果一定要引用循环变量怎么办？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变：</p><p>返回一个函数时，牢记该函数并未执行，返回函数中不要引用任何可能会变化的变量。</p><h5 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h5><p>当我们在传入函数时，有些时候，不需要显式地定义函数，直接传入匿名函数更方便。<code>list(map(lambda x: x * x, [1, 2, 3, 4, 5, 6, 7, 8, 9]))</code></p><p><code>lambda x: x * x</code>实际上就是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def f(x):</span><br><span class="line">return x * x</span><br></pre></td></tr></table></figure><p>关键字<code>lambda</code>表示匿名函数，冒号前面的x表示函数参数。</p><p>匿名函数有个限制，就是只能有一个表达式，不用写<code>return</code>，返回值就是该表达式的结果。</p><h5 id="装饰器-Decorator-在代码运行期间动态增加功能的方式"><a href="#装饰器-Decorator-在代码运行期间动态增加功能的方式" class="headerlink" title="装饰器(Decorator)(在代码运行期间动态增加功能的方式)"></a>装饰器(Decorator)(在代码运行期间动态增加功能的方式)</h5><p>本质上，decorator就是一个返回函数的高阶函数。</p><p><strong>函数也是个对象</strong>，可以通过<code>__name__</code>属性拿到函数的名字</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def log(func):</span><br><span class="line">    def wrapper(*args, **kw):</span><br><span class="line">        print(&apos;call %s():&apos; % func.__name__)</span><br><span class="line">        return func(*args, **kw)</span><br><span class="line">    return wrapper</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@log</span><br><span class="line">def now():</span><br><span class="line">    print(&apos;2018-2-9&apos;)</span><br></pre></td></tr></table></figure><p>三层嵌套的decorator</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def log(text):</span><br><span class="line">    def decorator(func):</span><br><span class="line">        def wrapper(*args, **kw):</span><br><span class="line">            print(&apos;%s %s():&apos; % (text, func.__name__))</span><br><span class="line">            return func(*args, **kw)</span><br><span class="line">        return wrapper</span><br><span class="line">    return decorator</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@log(&apos;execute&apos;)</span><br><span class="line">def now():</span><br><span class="line">    print(&apos;2018-2-9&apos;)</span><br></pre></td></tr></table></figure><p>但此时函数名会出现错误，所以完整写法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import functools</span><br><span class="line"></span><br><span class="line">def log(func):</span><br><span class="line">    @functools.wraps(func)</span><br><span class="line">    def wrapper(*args, **kw):</span><br><span class="line">        print(&apos;call %s():&apos; % func.__name__)</span><br><span class="line">        return func(*args, **kw)</span><br><span class="line">    return wrapper</span><br></pre></td></tr></table></figure><h5 id="偏函数-Partial-function"><a href="#偏函数-Partial-function" class="headerlink" title="偏函数(Partial function)"></a>偏函数(Partial function)</h5><p>与数学意义上的偏函数不一样</p><p>所以，简单总结<code>functools.partial</code>的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单。</p><p><code>functools.partial</code>就是帮助我们创建一个偏函数的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import functools </span><br><span class="line">int2 = functools.partial(int, base=2)</span><br></pre></td></tr></table></figure><p>创建偏函数时，实际上可以接收函数对象、<code>*args</code>和<code>**kw</code>这3个参数</p><h4 id="模块-Module"><a href="#模块-Module" class="headerlink" title="模块(Module)"></a>模块(Module)</h4><p>在Python中，一个.py文件就称之为一个模块（Module）</p><p>为了避免模块名冲突，Python又引入了按目录来组织模块的方法，称为包（Package）。</p><p>方法是选择一个顶层包名，比如<code>mycompany</code>。引入了包以后，只要顶层的包名不与别人冲突，那所有模块都不会与别人冲突。现在，<code>abc.py</code>模块的名字就变成了<code>mycompany.abc</code>，类似的，<code>xyz.py</code>的模块名变成了<code>mycompany.xyz</code>。</p><p>请注意，每一个包目录下面都会有一个<code>__init__.py</code>的文件，这个文件是必须存在的，否则，Python就把这个目录当成普通目录，而不是一个包。<code>__init__.py</code>可以是空文件，也可以有Python代码，因为<code>__init__.py</code>本身就是一个模块，而它的模块名就是<code>mycompany</code>。</p><p>类似的，可以有多级目录，组成多级层次的包结构。</p><h5 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h5><p>正常的函数和变量名是公开的（public），可以被直接引用</p><p>类似<code>__xxx__</code>这样的变量是特殊变量，可以被直接引用，但是有特殊用途</p><p>类似<code>_xxx</code>和<code>__xxx</code>这样的函数或变量就是非公开的（private），不应该被直接引用</p><p>之所以我们说，private函数和变量“不应该”被直接引用，而不是“不能”被直接引用，是因为Python并没有一种方法可以完全限制访问private函数或变量，但是，从编程习惯上不应该引用private函数或变量。</p><h5 id="安装第三方模块"><a href="#安装第三方模块" class="headerlink" title="安装第三方模块"></a>安装第三方模块</h5><p>在Python中，安装第三方模块，是通过包管理工具pip完成的。</p><h4 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h4><p>数据封装、继承和多态是面向对象的三大特点</p><h5 id="类和实例-Class-and-Instance"><a href="#类和实例-Class-and-Instance" class="headerlink" title="类和实例(Class and Instance)"></a>类和实例(Class and Instance)</h5><p>在Python中，定义类是通过<code>class</code>关键字：class后面紧接着是类名，即Student，类名通常是大写开头的单词，紧接着是<code>(object)</code>，表示该类是从哪个类继承下来的,如果没有合适的继承类，就使用object类，这是所有类最终都会继承的类。</p><p>定义好了<code>Student</code>类，就可以根据<code>Student</code>类创建出Student的实例，创建实例是通过类名+()实现的。如:<code>bart = Student()</code></p><p>由于类可以起到模板的作用，因此，可以在创建实例的时候，把一些我们认为必须绑定的属性强制填写进去。通过定义一个特殊的<code>__init__</code>方法，在创建实例的时候，就把<code>name</code>，<code>score</code>等属性绑上去：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self, name, score):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.score = score</span><br></pre></td></tr></table></figure><p>和普通的函数相比，在类中定义的函数只有一点不同，就是第一个参数永远是实例变量self，并且，调用时，不用传递该参数。除此之外，类的方法和普通函数没有什么区别，所以，你仍然可以用默认参数、可变参数、关键字参数和命名关键字参数。</p><h6 id="数据封装"><a href="#数据封装" class="headerlink" title="数据封装"></a>数据封装</h6><p>和静态语言不同，Python允许对实例变量绑定任何数据，也就是说，对于两个实例变量，虽然它们都是同一个类的不同实例，但拥有的变量名称都可能不同：</p><h5 id="访问限制"><a href="#访问限制" class="headerlink" title="访问限制"></a>访问限制</h5><p>如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线<code>__</code>，在Python中，实例的变量名如果以<code>__</code>开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问</p><p>需要注意的是，在Python中，变量名类似<code>__xxx__</code>的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是private变量，所以，不能用<code>__name__</code>、<code>__score__</code>这样的变量名。</p><p>双下划线开头的实例变量是不是一定不能从外部访问呢？其实也不是。不能直接访问<code>__name</code>是因为Python解释器对外把<code>__name</code>变量改成了<code>_Student__name</code>，所以，仍然可以通过<code>_Student__name</code>来访问<code>__name</code>变量：</p><h5 id="继承和多态"><a href="#继承和多态" class="headerlink" title="继承和多态"></a>继承和多态</h5><p>在OOP程序设计中，当我们定义一个class的时候，可以从某个现有的class继承，新的class称为子类（Subclass），而被继承的class称为基类、父类或超类（Base class、Super class）。</p><p>继承有什么好处？最大的好处是子类获得了父类的全部功能。由于<code>Animial</code>实现了<code>run()</code>方法，因此，<code>Dog</code>和<code>Cat</code>作为它的子类，什么事也没干，就自动拥有了<code>run()</code>方法：</p><p>当子类和父类都存在相同的<code>run()</code>方法时，我们说，子类的<code>run()</code>覆盖了父类的<code>run()</code>，在代码运行的时候，总是会调用子类的<code>run()</code>。这样，我们就获得了继承的另一个好处：多态。</p><p>所以，在继承关系中，如果一个实例的数据类型是某个子类，那它的数据类型也可以被看做是父类。但是，反过来就不行</p><h6 id="静态语言-vs-动态语言"><a href="#静态语言-vs-动态语言" class="headerlink" title="静态语言 vs 动态语言"></a>静态语言 vs 动态语言</h6><p>对于静态语言（例如Java）来说，如果需要传入<code>Animal</code>类型，则传入的对象必须是<code>Animal</code>类型或者它的子类，否则，将无法调用<code>run()</code>方法。</p><p>对于Python这样的动态语言来说，则不一定需要传入<code>Animal</code>类型。我们只需要保证传入的对象有一个<code>run()</code>方法就可以了</p><p>这就是动态语言的“鸭子类型”，它并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。</p><p>Python的“file-like object“就是一种鸭子类型。对真正的文件对象，它有一个<code>read()</code>方法，返回其内容。但是，许多对象，只要有<code>read()</code>方法，都被视为“file-like object“。许多函数接收的参数就是“file-like object“，你不一定要传入真正的文件对象，完全可以传入任何实现了<code>read()</code>方法的对象。</p><h5 id="获取对象信息"><a href="#获取对象信息" class="headerlink" title="获取对象信息"></a>获取对象信息</h5><h6 id="使用type"><a href="#使用type" class="headerlink" title="使用type()"></a>使用type()</h6><p>判断对象类型</p><h6 id="使用isinstance"><a href="#使用isinstance" class="headerlink" title="使用isinstance()"></a>使用isinstance()</h6><h6 id="使用dir"><a href="#使用dir" class="headerlink" title="使用dir()"></a>使用dir()</h6><p>如果要获得一个对象的所有属性和方法，可以使用<code>dir()</code>函数，它返回一个包含字符串的list</p><h5 id="实例属性和类属性"><a href="#实例属性和类属性" class="headerlink" title="实例属性和类属性"></a>实例属性和类属性</h5><p>疑惑：<br>python的动态类型是否是用指针实现的</p><p>参考:</p><ol><li><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/00143186738532805c392f2cc09446caf3236c34e3f980f000" target="_blank" rel="noopener">Python教程</a></li><li>《Python学习手册》 by Mark Lutz(O’REILLY Press,2011)</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python笔记-未完待续&quot;&gt;&lt;a href=&quot;#Python笔记-未完待续&quot; class=&quot;headerlink&quot; title=&quot;Python笔记(未完待续)&quot;&gt;&lt;/a&gt;Python笔记(未完待续)&lt;/h1&gt;&lt;h2 id=&quot;Python特点&quot;&gt;&lt;a href=&quot;#Python特点&quot; class=&quot;headerlink&quot; title=&quot;Python特点&quot;&gt;&lt;/a&gt;Python特点&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;简单&lt;/li&gt;
&lt;li&gt;解释型&lt;/li&gt;
&lt;li&gt;交互式&lt;/li&gt;
&lt;li&gt;可移植&lt;/li&gt;
&lt;li&gt;面向对象&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Python特性&quot;&gt;&lt;a href=&quot;#Python特性&quot; class=&quot;headerlink&quot; title=&quot;Python特性&quot;&gt;&lt;/a&gt;Python特性&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;动态类型&lt;/li&gt;
&lt;li&gt;自动内存管理&lt;/li&gt;
&lt;li&gt;大型程序支持&lt;/li&gt;
&lt;li&gt;内置对象类型&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Python彩蛋&quot;&gt;&lt;a href=&quot;#Python彩蛋&quot; class=&quot;headerlink&quot; title=&quot;Python彩蛋&quot;&gt;&lt;/a&gt;Python彩蛋&lt;/h2&gt;&lt;p&gt;在交互解释器里输入&lt;code&gt;import this&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>LaTex笔记(不定期更新)</title>
    <link href="http://yoursite.com/2018/02/06/LaTex%E7%AC%94%E8%AE%B0-%E4%B8%8D%E5%AE%9A%E6%9C%9F%E6%9B%B4%E6%96%B0/"/>
    <id>http://yoursite.com/2018/02/06/LaTex笔记-不定期更新/</id>
    <published>2018-02-06T06:46:11.000Z</published>
    <updated>2018-02-06T10:01:57.214Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Latex-笔记（不定期更新）"><a href="#Latex-笔记（不定期更新）" class="headerlink" title="Latex 笔记（不定期更新）"></a>Latex 笔记（不定期更新）</h1><h2 id="标题，章和节"><a href="#标题，章和节" class="headerlink" title="标题，章和节"></a>标题，章和节</h2><table><thead><tr><th>命令</th><th>效果</th><th>命令</th><th>效果</th></tr></thead><tbody><tr><td>\title</td><td>标题</td><td>\author</td><td>作者</td></tr><tr><td>\date</td><td>日期</td><td>\maketitle</td><td>生成标题</td></tr><tr><td>\section</td><td>节标题</td><td>\subsection</td><td>小节标题</td></tr><tr><td>\subsubsection</td><td>次小节标题</td><td>\paragraph</td><td>段标题</td></tr><tr><td>\subparagraph</td><td>小段标题</td><td>\part</td><td>部分标题</td></tr><tr><td>\appendix</td><td>附录标题</td><td>\tableofcontents</td><td>生成目录</td></tr><tr><td>\listoffigures</td><td>插图目录</td><td>\listoftables</td><td>表格目录</td></tr></tbody></table> <a id="more"></a><h2 id="插入项目符号和编号"><a href="#插入项目符号和编号" class="headerlink" title="插入项目符号和编号"></a>插入项目符号和编号</h2><h3 id="不带序号"><a href="#不带序号" class="headerlink" title="不带序号"></a>不带序号</h3><p>关于{itemize}里序号的形式：latex默认生成的简单列表，默认为一个小圆点，而我们在写文章时可能想要一些不一样的列表符号，比如 -， * 之类的. 我们可以这样写</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;itemize&#125; </span><br><span class="line">\item[-] something</span><br><span class="line">\item[-] something</span><br><span class="line">\end&#123;itemize&#125;</span><br></pre></td></tr></table></figure><h3 id="带序号"><a href="#带序号" class="headerlink" title="带序号"></a>带序号</h3><p> 关于{enumerate}，这是用于带序号的列表。 默认生成 1，2，3。如果想要其他修饰，如(1) (2)….或step-1，step2，需要加载 \usepackage{enumerate}，然后如下使用</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;enumerate&#125;[step 1]</span><br><span class="line">\item something</span><br><span class="line">\item something</span><br><span class="line">\end&#123;enumerate&#125;</span><br></pre></td></tr></table></figure><h2 id="引入参考文献"><a href="#引入参考文献" class="headerlink" title="引入参考文献"></a>引入参考文献</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;thebibliography&#125;&#123;99&#125;</span><br><span class="line">\bibitem&#123;a&#125; something</span><br><span class="line">\bibitem&#123;b&#125; something</span><br><span class="line">\end&#123;thebibliography&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Latex-笔记（不定期更新）&quot;&gt;&lt;a href=&quot;#Latex-笔记（不定期更新）&quot; class=&quot;headerlink&quot; title=&quot;Latex 笔记（不定期更新）&quot;&gt;&lt;/a&gt;Latex 笔记（不定期更新）&lt;/h1&gt;&lt;h2 id=&quot;标题，章和节&quot;&gt;&lt;a href=&quot;#标题，章和节&quot; class=&quot;headerlink&quot; title=&quot;标题，章和节&quot;&gt;&lt;/a&gt;标题，章和节&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;效果&lt;/th&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;效果&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;\title&lt;/td&gt;
&lt;td&gt;标题&lt;/td&gt;
&lt;td&gt;\author&lt;/td&gt;
&lt;td&gt;作者&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\date&lt;/td&gt;
&lt;td&gt;日期&lt;/td&gt;
&lt;td&gt;\maketitle&lt;/td&gt;
&lt;td&gt;生成标题&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\section&lt;/td&gt;
&lt;td&gt;节标题&lt;/td&gt;
&lt;td&gt;\subsection&lt;/td&gt;
&lt;td&gt;小节标题&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\subsubsection&lt;/td&gt;
&lt;td&gt;次小节标题&lt;/td&gt;
&lt;td&gt;\paragraph&lt;/td&gt;
&lt;td&gt;段标题&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\subparagraph&lt;/td&gt;
&lt;td&gt;小段标题&lt;/td&gt;
&lt;td&gt;\part&lt;/td&gt;
&lt;td&gt;部分标题&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\appendix&lt;/td&gt;
&lt;td&gt;附录标题&lt;/td&gt;
&lt;td&gt;\tableofcontents&lt;/td&gt;
&lt;td&gt;生成目录&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\listoffigures&lt;/td&gt;
&lt;td&gt;插图目录&lt;/td&gt;
&lt;td&gt;\listoftables&lt;/td&gt;
&lt;td&gt;表格目录&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
    
      <category term="LaTex" scheme="http://yoursite.com/tags/LaTex/"/>
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Markdown简明语法</title>
    <link href="http://yoursite.com/2018/02/04/Markdown%E7%AE%80%E6%98%8E%E8%AF%AD%E6%B3%95/"/>
    <id>http://yoursite.com/2018/02/04/Markdown简明语法/</id>
    <published>2018-02-04T05:16:50.000Z</published>
    <updated>2018-02-06T06:34:06.175Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Markdown简明语法"><a href="#Markdown简明语法" class="headerlink" title="Markdown简明语法"></a>Markdown简明语法</h1><h2 id="Markdown优点"><a href="#Markdown优点" class="headerlink" title="Markdown优点"></a>Markdown优点</h2><ul><li>纯文本，兼容性强</li><li>语法简单，有较强的可读性</li><li>转换方便 <a id="more"></a></li></ul><h2 id="Markdown语法"><a href="#Markdown语法" class="headerlink" title="Markdown语法"></a>Markdown语法</h2><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><h4 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表:"></a>无序列表:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 文本1</span><br><span class="line">- 文本2</span><br><span class="line">- 文本3</span><br></pre></td></tr></table></figure><p>显示效果为：</p><ul><li>文本1</li><li>文本2</li><li>文本3</li></ul><h4 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表:"></a>有序列表:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 文本1</span><br><span class="line">2. 文本2</span><br><span class="line">3. 文本3</span><br></pre></td></tr></table></figure><p>显示效果为：</p><ol><li>文本1</li><li>文本2</li><li>文本3</li></ol><h3 id="链接和图片"><a href="#链接和图片" class="headerlink" title="链接和图片"></a>链接和图片</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[显示文本](链接地址)</span><br><span class="line">![](图片链接地址)</span><br></pre></td></tr></table></figure><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>在希望引用的文件前面加<code>&gt;</code>就可以 </p><p><code>&gt;</code> 和文本之间要保留一个字符的空格。</p><h3 id="粗体和斜体"><a href="#粗体和斜体" class="headerlink" title="粗体和斜体"></a>粗体和斜体</h3><p>用两个 <code>*</code> 包含一段文本就是粗体的语法，用一个 <code>*</code> 包含一段文本就是斜体的语法</p><h3 id="代码引用"><a href="#代码引用" class="headerlink" title="代码引用"></a>代码引用</h3><p>一行代码用 包住 </p><p>若代码为多行，则用两行(每行三个)包住</p><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| Tables        | Are           | Cool  |</span><br><span class="line">| ------------- |:-------------:| -----:|</span><br><span class="line">| col 3 is      | right-aligned | $1600 |</span><br><span class="line">| col 2 is      | centered      |   $12 |</span><br><span class="line">| zebra stripes | are neat      |    $1 |</span><br></pre></td></tr></table></figure><p>显示效果为:</p><table><thead><tr><th>Tables</th><th style="text-align:center">Are</th><th style="text-align:right">Cool</th></tr></thead><tbody><tr><td>col 3 is</td><td style="text-align:center">right-aligned</td><td style="text-align:right">$1600</td></tr><tr><td>col 2 is</td><td style="text-align:center">centered</td><td style="text-align:right">$12</td></tr><tr><td>zebra stripes</td><td style="text-align:center">are neat</td><td style="text-align:right">$1</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dog | bird | cat</span><br><span class="line">----|------|----</span><br><span class="line">foo | foo  | foo</span><br><span class="line">bar | bar  | bar</span><br><span class="line">baz | baz  | baz</span><br></pre></td></tr></table></figure><p>显示效果为:</p><table><thead><tr><th>dog</th><th>bird</th><th>cat</th></tr></thead><tbody><tr><td>foo</td><td>foo</td><td>foo</td></tr><tr><td>bar</td><td>bar</td><td>bar</td></tr><tr><td>baz</td><td>baz</td><td>baz</td></tr></tbody></table><p>参考：<a href="https://www.jianshu.com/p/q81RER" target="_blank" rel="noopener">献给写作者的 Markdown 新手指南</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Markdown简明语法&quot;&gt;&lt;a href=&quot;#Markdown简明语法&quot; class=&quot;headerlink&quot; title=&quot;Markdown简明语法&quot;&gt;&lt;/a&gt;Markdown简明语法&lt;/h1&gt;&lt;h2 id=&quot;Markdown优点&quot;&gt;&lt;a href=&quot;#Markdown优点&quot; class=&quot;headerlink&quot; title=&quot;Markdown优点&quot;&gt;&lt;/a&gt;Markdown优点&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;纯文本，兼容性强&lt;/li&gt;
&lt;li&gt;语法简单，有较强的可读性&lt;/li&gt;
&lt;li&gt;转换方便
    
    </summary>
    
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="markdown" scheme="http://yoursite.com/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2018/02/02/hello-world/"/>
    <id>http://yoursite.com/2018/02/02/hello-world/</id>
    <published>2018-02-02T05:02:57.299Z</published>
    <updated>2018-02-02T05:02:57.299Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
