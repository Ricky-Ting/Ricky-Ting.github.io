<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ricky Ting&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/5c8eecd06d08187c73ea49421008f04d</icon>
  <subtitle>当时只道是寻常</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-02-16T06:38:57.802Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Ricky-Ting</name>
    <email>1770048119@qq.com dbr1770048119@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Unix Programming Tools</title>
    <link href="http://yoursite.com/2018/02/15/Unix-Programming-Tools/"/>
    <id>http://yoursite.com/2018/02/15/Unix-Programming-Tools/</id>
    <published>2018-02-15T04:43:11.000Z</published>
    <updated>2018-02-16T06:38:57.802Z</updated>
    
    <content type="html"><![CDATA[<p><strong>已弃坑 待更</strong></p><h1 id="gcc"><a href="#gcc" class="headerlink" title="gcc"></a>gcc</h1><p>Gcc can compile C,C++(maybe g++),and objective-C. It is both a compiler and linker.</p><a id="more"></a><p>一步到位：<code>gcc main.c module1.c module2.c -o program</code></p><p>分开：<code>gcc -c main.c</code> <code>gcc -c module1.c</code> <code>gcc -c module2.c</code> <code>gcc main.o module1.o module2.o -o program</code></p><h2 id="command-line-options"><a href="#command-line-options" class="headerlink" title="command-line options"></a>command-line options</h2><p>-c <em>files</em> : Direct gcc to compile the source files into an object files without going through the linking stage. Makefiles (below) use this option to compile files one at a time.</p><p>-o <em>file</em> : Specifies that gcc’s output should be named file. If this option is not specified, then the default name used depends on the context…(a) if compiling a source .c file, the output object file will be named with the same name but with a .o extension. Alternately, (b) if linking to create an executable, the output file will be named a.out. Most often, the -o option is used to specify the output filename when linking an executable, while for compiling, people just let the default .c/.o naming take over.It’s a memorable error if your -o option gets switched around in the command line so it accidentally comes before a source file like “…-o foo.c program” – this can overwrite your source file – bye bye source file!</p><p>-g : Directs the compiler to include extra debugging information in its output. We recommend that you always compile your source with this option set, since we encourage you to gain proficiency using the debugger such as gdb (below).</p><p>-Wall : Give warnings about possible errors in the source code. </p><p>-I<em>dir</em> : Adds the directory dir to the list of directories searched for #include files.</p><p>-l<em>mylib</em> : (lower case ‘L’) Search the library named mylib for unresolved symbols (functions, global variables) when linking. The actual name of the file will be libmylib.a, and must be found in either the default locations for libraries or in a directory added with the -L flag (below).</p><p>-L<em>dir</em> </p><h1 id="make"><a href="#make" class="headerlink" title="make"></a>make</h1><p>The “make” utility automates the process of compiling and linking.</p><p>run make with no arguments in the project directory.and it will search for a file called <code>Makefile</code> or <code>makefile</code> for its build instructions.</p><h2 id="Makefiles"><a href="#Makefiles" class="headerlink" title="Makefiles"></a>Makefiles</h2><p>variable: for example <code>CC=gcc</code></p><p>standard variable names: </p><p>CC: The name of the C compiler, this will default to cc or gcc in most versions of make.</p><p>CFLAGS: A list of options to pass on to the C compiler for all of your source files. This is commonly used to set the include path to include non- standard directories (-I) or build debugging versions (-g).</p><p>LDFLAGS: A list of options to pass on to the linker. This is most commonly used to include application specific library files (-l) and set the library search path (-L).</p><p>To refer to the value of a variable, put a dollar sign ($) followed by the name in parenthesis or curly braces…</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CFLAGS = -g -I/usr/class/cs107/include</span><br><span class="line">$(CC) $(CFLAGS) -c binky.c</span><br></pre></td></tr></table></figure><p>The second major component of a makefile is the dependency/build rule.</p><p>A rule generally consists of two lines: a dependency line followed by a command line.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">binky.o : binky.c binky.h akbar.h </span><br><span class="line">tab$(CC) $(CFLAGS) -c binky.c</span><br></pre></td></tr></table></figure><h1 id="Unix-Shell"><a href="#Unix-Shell" class="headerlink" title="Unix Shell"></a>Unix Shell</h1><h2 id="Directory-Commands"><a href="#Directory-Commands" class="headerlink" title="Directory Commands"></a>Directory Commands</h2><p>cd <em>directory</em>: change directory</p><p>pwd : print working(current) directory</p><p>rm <em>file</em>: delete a file</p><p>mv <em>old</em> <em>new</em> : Rename a file(also works for moving things between directories).If exists, overwritten.</p><p>mkdir <em>name</em> : Create a directory</p><p>rmdir name : Delete a directory(must be empty)</p><h2 id="Shorthand-Notations-amp-Wildcards"><a href="#Shorthand-Notations-amp-Wildcards" class="headerlink" title="Shorthand Notations &amp; Wildcards"></a>Shorthand Notations &amp; Wildcards</h2><p>. : Current Directory</p><p>.. : Parent Directory</p><p>~ : Your home directory</p><p>~/cs107 : The cs107 directory in your home directory</p><p>~<em>user</em> : Home directory of <em>user</em></p><p> 通配符 : Any number of characters(not ‘.’)</p><p>? : Any single character(not ‘.’)</p><h2 id="Miscellaneous-Commands"><a href="#Miscellaneous-Commands" class="headerlink" title="Miscellaneous Commands"></a>Miscellaneous Commands</h2><p>cat <em>file</em> : Print the contents of <em>file</em> to standard output </p><p>more <em>file</em> : Same as <em>cat</em>,but only a page at a time.</p><p>less <em>file</em> : Same as <em>more</em>,but with navigability.</p><p>w : Find out who is on the system and what they are doing.</p><p>ps : List all your processed(use the process id’s in <strong>kill</strong> below)</p><p>jobs : Show jobs that have been suspended(use with fg)</p><p><em>program</em>&amp; : Runs <em>program</em> in the background.</p><p>ctrl-z : Suspend the current program.</p><p>% : Continue last job suspended, or use <strong>fg</strong>(foreground)</p><p>%<em>number</em> : Continue a particular job(the number comes from the <em>jobs</em> list)</p><p>kill <em>process-id</em> : Kill a process</p><p>kill -9 <em>process</em> : Kill a process with extreme prejudice </p><p>grep <em>exp</em> <em>files</em> : Search for an expression in a set of files.</p><p>wc <em>files</em> : Count words,lines and characters in a file</p><p>script : Start saving everything that happens in a file. Type <strong>exit</strong> when done</p><p>lpr <em>file</em> : Print <em>file</em> to the default printer</p><p>lpr -Pinky <em>file</em> : Print <em>file</em> to the printer named <em>inky</em></p><p>diff <em>file1</em> <em>file2</em> Show the differences between two files.</p><p>telnet <em>hostname</em> : Log on to another machine</p><p>source <em>file</em> : Execute the lines in the given file as if they were typed to the shell</p><h2 id="Getting-Help"><a href="#Getting-Help" class="headerlink" title="Getting Help"></a>Getting Help</h2><p>man <em>subject</em> : Read the manual entry on a particular subject</p><p>man -k keyword : Show all the manual pages for a particular keyword</p><h2 id="History"><a href="#History" class="headerlink" title="History"></a>History</h2><p>history : Show the most recent commands executed</p><p>!! : Re-execute the last command (or type up-arrow with modern shells)</p><p>!number : Re-execute a particular command by number</p><p>!<em>string</em> : Re-execute the last command beginning with string </p><p>^wrong^right^ : Re-execute the last command, substituting right for wrong</p><p>ctrl-P : Scroll backwards through previous commands</p><h2 id="Pipes"><a href="#Pipes" class="headerlink" title="Pipes"></a>Pipes</h2><p>a &gt; b : Redirect a’s standard output to overwrite file b</p><p>a &gt;&gt; b : Redirect a’s standard output to append to the file b</p><p>a &gt;&amp; b : Redirect a’s error output to overwrite file b</p><p>a &lt; b : Redirect a’s standard input to read from the file b</p><p>a | b : Redirect a’s standard output to b’s standard input</p><p>参考:<a href="http://cslibrary.stanford.edu/107/UnixProgrammingTools.pdf" target="_blank" rel="noopener">Unix Programming Tools from Standford Univer</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;已弃坑 待更&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;gcc&quot;&gt;&lt;a href=&quot;#gcc&quot; class=&quot;headerlink&quot; title=&quot;gcc&quot;&gt;&lt;/a&gt;gcc&lt;/h1&gt;&lt;p&gt;Gcc can compile C,C++(maybe g++),and objective-C. It is both a compiler and linker.&lt;/p&gt;
    
    </summary>
    
    
      <category term="Unix" scheme="http://yoursite.com/tags/Unix/"/>
    
      <category term="Tools" scheme="http://yoursite.com/tags/Tools/"/>
    
      <category term="Programming" scheme="http://yoursite.com/tags/Programming/"/>
    
  </entry>
  
  <entry>
    <title>2017秋寒假待学习内容(这是一篇flag) 2018.2</title>
    <link href="http://yoursite.com/2018/02/13/2017%E7%A7%8B%E5%AF%92%E5%81%87%E5%BE%85%E5%AD%A6%E4%B9%A0%E5%86%85%E5%AE%B9-%E8%BF%99%E6%98%AF%E4%B8%80%E7%AF%87flag-2018-2/"/>
    <id>http://yoursite.com/2018/02/13/2017秋寒假待学习内容-这是一篇flag-2018-2/</id>
    <published>2018-02-13T05:14:08.000Z</published>
    <updated>2018-02-13T05:19:21.685Z</updated>
    
    <content type="html"><![CDATA[<ul><li>机器学习</li><li>编写可读代码的艺术</li><li>离散数学及其应用</li><li>配置软件</li><li>github学习</li><li>git学习</li><li>向zzw大佬学习</li><li>…</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;机器学习&lt;/li&gt;
&lt;li&gt;编写可读代码的艺术&lt;/li&gt;
&lt;li&gt;离散数学及其应用&lt;/li&gt;
&lt;li&gt;配置软件&lt;/li&gt;
&lt;li&gt;github学习&lt;/li&gt;
&lt;li&gt;git学习&lt;/li&gt;
&lt;li&gt;向zzw大佬学习&lt;/li&gt;
&lt;li&gt;…&lt;/li&gt;
&lt;/ul&gt;

      
    
    </summary>
    
    
      <category term="flag" scheme="http://yoursite.com/tags/flag/"/>
    
      <category term="计划" scheme="http://yoursite.com/tags/%E8%AE%A1%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>机器学习(周志华)笔记</title>
    <link href="http://yoursite.com/2018/02/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%91%A8%E5%BF%97%E5%8D%8E-%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/02/13/机器学习-周志华-笔记/</id>
    <published>2018-02-13T03:38:41.000Z</published>
    <updated>2018-02-14T04:55:59.093Z</updated>
    
    <content type="html"><![CDATA[<h1 id="机器学习笔记-学习中-进度堪忧"><a href="#机器学习笔记-学习中-进度堪忧" class="headerlink" title="机器学习笔记(学习中 进度堪忧)"></a>机器学习笔记(学习中 进度堪忧)</h1><h2 id="第1章-绪论"><a href="#第1章-绪论" class="headerlink" title="第1章 绪论"></a>第1章 绪论</h2><h3 id="1-1-引言"><a href="#1-1-引言" class="headerlink" title="1.1 引言"></a>1.1 引言</h3><p>通过对经验的利用，就能对新情况做出有效的决策。计算机在这方面可以帮忙。</p><p>机器学习致力于研究如何通过计算的手段，利用经验来改善系统自身的性能。机器学习所研究的主要内容，是关于在计算机上从数据中产生“模型”(model)的算法，即”学习算法”(learning algorithm).</p> <a id="more"></a><h3 id="1-2-基本术语"><a href="#1-2-基本术语" class="headerlink" title="1.2 基本术语"></a>1.2 基本术语</h3><p>一组记录的集合称为一个“数据集”(data set),其中每条记录是关于一个事件或对象的描述，称为一个“示例”(instance)或”样本”(sample)</p><p>反映事件或对象在某方面的表现或性质的事项称为”属性”(attribute)或”特征”(feature).属性上的取值称为”属性值”(attribute value).属性张成的空间称为”属性空间”(attribute space)、”样本空间”(sample space)或”输入空间”.我们也把一个示例称为一个”特征向量”(feature vector).</p><p>每个示例由d个属性描述,d称为样本的”维数”(dimensionality).</p><p>从数据中学得模型的过程称为”学习”(learning)或”训练”(training)</p><p>训练中使用的数据称为”训练数据”(training data),其中每个样本称为一个”训练样本”(training sample),训练样本组成的集合称为”训练集”(training set)</p><p>学得模型对应了关于数据的某种潜在的规律，因此亦称”假设”(hypothesis);这种潜在规律自身，则称为”真相”或”真实”(ground-truth).有时将模型称为”学习器”(learner),可以看作学习算法在给定数据和参数空间上的实例化.</p><p>标记(label);拥有了标记信息的示例,则称为”样例”(example).所有标记的集合称为”标记空间”(label space)或”输出空间”.</p><p>(<strong>x</strong>i,yi)表示第i个样例,<strong>x</strong>i是d维向量.</p><p>若欲预测的是离散值，此类学习任务称为”分类”(classification);若欲预测的是连续值,此类学习任务称为”回归”(regression).</p><p>对于只涉及两个类别的“二分类”(binary classification)任务，通常称其中一个类为”正类”(positive class),另一个类为”反类”(negative class)；涉及多个类别时,则称为“多分类”(multi-class classification)任务。</p><p>学得模型后，使用其进行预测的过程称为“测试”(testing),被预测的样本称为”测试样本”(testing sample) .</p><p>聚类(clustering),即将训练中的示例分成若干组，每组称为一个”簇”(cluster);这些自动形成的簇可能对应一些潜在的概念划分.这样的学习过程有助于我们了解数据内在的规律，能为更深入地分析数据建立基础.</p><p>根据训练数据是否拥有标记信息，学习任务可大致划分为两大类:”监督学习”(supervised learning)和”无监督学习”(unsupervised learning),分类和回归是前者的代表,而聚类则是后者的代表.</p><p>机器学习的目标是使学得的模型能更好地适用于”新样本”，而不是仅仅在训练样本上工作得好.学得模型适用于新样本的能力,称为”泛化”(generalization)能力.</p><p>通常假设样本空间中全体样本服从一个未知”分布”(distribution)<em>D</em>,我们获得的每个样本都是独立地从这个分布上采样获得的,即”独立同分布”(independent and identically distributed,简称<em>i.i.d</em>)</p><h3 id="1-3-假设空间"><a href="#1-3-假设空间" class="headerlink" title="1.3 假设空间"></a>1.3 假设空间</h3><p><em>归纳(induction)和演绎(deduction)科学推理的两大基本手段</em></p><p>归纳学习(inductive learning).狭义的归纳学习要求从训练数据中学得概念(concept),亦称为”概念学习”或”概念形成”.概念学习技术目前研究、应用都比较少，因为要学得泛化性能好且语义明确的概念实在太困难了,现实常用的技术大多是产生”黑箱”模型。</p><p>概念学习中最基本的是布尔概念学习.</p><p>“记住”训练样本，就是所谓的”机械学习”.</p><p>我们可以把学习过程看作一个在所有假设(hypothesis)组成的空间中进行搜索的过程,搜索目标是找到与训练集”匹配”(fit)的假设.现实问题中我们常面临很大的假设空间,但学习过程是基于有限样本训练集进行的,因此，可能有多个假设与训练集一致,即存在着一个与训练集一致的”假设集合”,我们称之为”版本空间”(version space)</p><h3 id="1-4-归纳偏好"><a href="#1-4-归纳偏好" class="headerlink" title="1.4 归纳偏好"></a>1.4 归纳偏好</h3><p>当有多个模型(假设)时，应该采纳哪一个.这时,学习算法本身的”偏好”就会起到关键的作用.</p><p>机器学习算法在学习过程中对某种类型假设的偏好,称为”归纳偏好”(inductive bias),或简称为”偏好”.</p><p>任何一个有效的机器学习算法必有其归纳偏好.</p><p>归纳偏好可看作学习算法自身在一个很庞大的假设空间中对假设进行选择的启发式或”价值观”.“奥卡姆剃刀”(Occam’s razor)是一种常用的、自然科学研究中最基本的原则，即“若有多个假设与观察一致，则选最简单的那个”</p><p>算法的归纳偏好是否与问题本身匹配，大多数时候直接决定了算法能否取得好的性能.</p><p>对于一个学习算法A,若它在某些问题上比学习算法B好,则必然存在另一些问题,在那里B比A好.这个结论对任何算法均成立.<strong>证明待看</strong></p><p>NFL定理(No Free Lunch Theorem)[Wolpert,1996;Wolpert and Macready,1995]</p><p>NFL的最重要寓意，是让我们清楚地认识到,脱离具体问题,空泛地谈论”什么学习算法更好”毫无意义。学习算法自身的归纳偏好与问题是否相配,往往会起到决定性的作用.</p><h3 id="1-5-发展历程"><a href="#1-5-发展历程" class="headerlink" title="1.5 发展历程"></a>1.5 发展历程</h3><p>二十世纪五十年代到七十年代初,人工智能研究处于”推理期”,那时认为人们只要能赋予机器逻辑推理能力，机器就能具有智能.人们逐渐认识到,仅具有逻辑推理能力是远远实现不了人工智能的.后来认为，要使机器具有智能，就必须设法使机器拥有知识.从二十世纪七十年代中期开始,人工智能研究进入了”知识期”。大量专家系统问世。但逐渐的专家系统面临”知识工程瓶颈”，简单地说，就是由人来把知识总结出来再教给计算机是相当困难的.</p><p>二十世纪五十年代初已有机器学习的相关研究,五十年代中后期，基于神经网络的”连接主义”(connectionism)学习开始出现。在六七十年代，基于逻辑表示的“符号主义”(symbolism)学习技术蓬勃发展,以决策理论为基础的学习技术以及强化学习技术等也得到发展。</p><p>总的来看，二十世纪八十年代是机器学习成为一个独立学科领域、各种机器学习技术百花初绽的时期。</p><p>在二十世纪八十年代，“从样例中学习”的一大主流是符号主义学习，其代表包括决策树(decision tree)和基于逻辑的学习.典型的决策树学习以信息论为基础，以信息熵的最小化为目标，直接模拟了人类对概念进行判定的树形流程.决策树学习技术由于简单易用,到今天仍是最常用的机器学习技术之一.</p><p>BP一直是被应用得最广泛的机器学习算法之一.连接主义学习的最大局限是其”试错性”</p><p>二十世纪九十年代中期,”统计学习”(statistical learning)闪亮登场并迅速占据主流舞台,代表性技术是支持向量机(Support Vector Machine,简称SVM)以及更一般的“核方法”(kernel methods).在支持向量机被普遍接受后,核技巧被人们用到了机器学习的几乎每一个角落，核方法(kernel trick)也逐渐成为机器学习的基本内容之一.</p><p>二十一世纪初,连接主义又卷土重来,掀起了以”深度学习”为名的热潮.所谓深度学习，狭义地说就是”很多层”的神经网络.</p><h3 id="1-6-应用现状"><a href="#1-6-应用现状" class="headerlink" title="1.6 应用现状"></a>1.6 应用现状</h3><h2 id="第二章-模型评估与选择"><a href="#第二章-模型评估与选择" class="headerlink" title="第二章 模型评估与选择"></a>第二章 模型评估与选择</h2><h3 id="2-1-经验误差与过拟合"><a href="#2-1-经验误差与过拟合" class="headerlink" title="2.1 经验误差与过拟合"></a>2.1 经验误差与过拟合</h3><p>“错误率”(error rate)：分类错误的样本数占样本总数的比例.</p><p>“精度”(accuracy)：精度 = 1-错误率</p><p>“误差”(error)：学习器的实际预测输出与样本的真实输出之间的差异</p><p>“训练误差”(training error)或”经验误差”(empirical error):学习器在训练集上的误差</p><p>“泛化误差”(generalization error)：学习器在新样本上的误差</p><p>我们希望得到泛化误差小的学习器.然而，我们事先并不知道新样本是什么样的,实际能做的是努力使经验误差最小化.</p><p>“过拟合”(overfitting):当学习器把训练样本学得”太好”了的时候,很可能已经把训练样本本身的一些特点当做了所有潜在样本都会具有的一般性质,这样就会导致泛化性能下降.</p><p>“欠拟合”(underfitting):指对训练样本的一般性质尚未学好。</p><p>欠拟合比较容易克服,例如在决策树学习中扩展分支、在神经网络学习中增加训练轮数等</p><p>过拟合是机器学习面临的关键障碍,过拟合是无法彻底避免的,我们所能做的只是”缓解”.只要相信P $\not=$ NP,过拟合就不可避免.</p><p>机器学习中的”模型选择”(model selection)问题,如何进行模型评估与选择呢？</p><p><strong>疑惑：这里的评估是对学习算法在这特定问题上表现的评估吧？</strong></p><h3 id="2-2-评估方法"><a href="#2-2-评估方法" class="headerlink" title="2.2 评估方法"></a>2.2 评估方法</h3><p>通常，我们可通过实验测试来对学习器的泛化误差进行评估并进而做出选择.为此，需使用一个“测试集”(testing set)来测试学习器对新样本的判别能力,然后以测试集上的“测试误差”(testing error)作为泛化误差的近似.测试集应该尽可能与训练集互斥.</p><p>有限的数据集,如何产生训练集<em>S</em>和测试集<em>T</em>.下面是几种常见的做法</p><h4 id="2-2-1-留出法-hold-out"><a href="#2-2-1-留出法-hold-out" class="headerlink" title="2.2.1 留出法(hold-out)"></a>2.2.1 留出法(hold-out)</h4><p>直接将数据集<em>D</em>划分为两个互斥的集合。</p><p>训练/测试集的划分要尽可能保持数据分布的一致性,避免因数据划分过程中中引入额外的偏差而对最终结果产生影响.”分层采样”(stratified sampling).</p><p>单次使用留出法得到的估计结果往往不够稳定可靠,在使用留出法时,一般要采用若干次随机划分、重复进行试验评估后取平均值作为留出法的评估结果.</p><p>保真性(fidelity),划分比例过大或过小导致的问题没有完美的解决方案,常见做法是将大约2/3~4/5的样本用于训练，剩余样本用于测试.</p><h4 id="2-2-2-交叉验证法-cross-validation"><a href="#2-2-2-交叉验证法-cross-validation" class="headerlink" title="2.2.2 交叉验证法(cross validation)"></a>2.2.2 交叉验证法(cross validation)</h4><p>将数据集<em>D</em>划分为k个子集,保证每个子集数据分布的一致性(可以通过分层采样).每次用k-1个子集训练，剩下的一个做测试集。这样可以得到k组.最后返回k个测试结果的均值.</p><p>这种方法的稳定性和保真性在很大程度上取决于k的取值，通常把这种方法称为”k折交叉验证”(<em>k</em>-fold cross validation).通常k取10</p><p>把数据集D划分为k个子集存在多种方式,所以为了减小划分不同引入的误差,通常要随机使用不同的划分重复p次,最终的评估结果是这p次k折交叉验证结果的均值.</p><p>假定数据集D中包含m个样本,若令k=m，则得到了交叉验证法的一个特例:留一法(Leave-One-Out,简称LOO)。显然，留一法不受随机样本划分方式的影响.留一法的评估结果往往被认为比较准确.留一法也有缺陷:在数据集比较大时，训练m个模型的计算开销可能是难以忍受的.而且这还是在未考虑算法调参的情况下.留一法的估计结果也未必永远比其他评估方法准确.</p><p>“没有免费午餐”定理对实验评估方法同样适用。</p><h4 id="2-2-3-自助法-bootstrapping-可重复采样"><a href="#2-2-3-自助法-bootstrapping-可重复采样" class="headerlink" title="2.2.3 自助法(bootstrapping)=可重复采样"></a>2.2.3 自助法(bootstrapping)=可重复采样</h4><p>有没有什么办法可以减少训练样本规模不同造成的影响,同时还能比较高效地进行实验估计呢？</p><p>”自助法“是一个比较好的解决方案,它直接以自助采样法(bootstrap sampling)为基础.就是相当于摸小球放回知道摸的次数与小球数相等。</p><p>样本在m次采样中始终不被采到的概率是 $(1-\frac{1}{m})^m$，取极限为 $\frac{1}{e} \approx 0.368$ ,将未被抽中的作为测试集。这样的测试结果，亦称”包外估计”(out-of-bag estimate).</p><p>自助法在数据集较小、难以有效划分训练/测试集时很有用；此时，自助法能从初始数据集中产生多个不同训练集,这对集成学习等学习方法有很大的好处。然而，自助法产生的数据集改变了初始数据集的分布，会引入估计偏差.因此在初始数据量足够时，留出法和交叉验证法更常用一些.</p><h4 id="2-2-4-调参-parameter-tuning-与最终模型"><a href="#2-2-4-调参-parameter-tuning-与最终模型" class="headerlink" title="2.2.4 调参(parameter tuning)与最终模型"></a>2.2.4 调参(parameter tuning)与最终模型</h4><p>参数可能在实数范围内取值，有着极大的调参工作量,以至于在不少应用任务中,参数调的好不好往往对最终模型性能有关键性影响。</p><p>模型选择完成后，学习算法和参数配置已选定,此时应该用数据集<em>D</em>重新训练模型.这才是我们最终提交给用户的模型.</p><p>验证集(validation set)存疑</p><h3 id="2-3-性能度量"><a href="#2-3-性能度量" class="headerlink" title="2.3 性能度量"></a>2.3 性能度量</h3><p>需要有衡量模型泛化能力的评价标准,这就是性能度量(performance measure).面对不同的任务需求，选用不同的性能度量。</p><p>回归任务最常用的性能度量是”均方误差”(mean squared error) <strong>公式待补</strong></p><p>下面主要介绍分类任务中常用的性能度量.</p><h4 id="2-3-1-错误率与精度"><a href="#2-3-1-错误率与精度" class="headerlink" title="2.3.1 错误率与精度"></a>2.3.1 错误率与精度</h4><p>这是分类任务中最常用的两种性能度量，既适用于二分类任务，也适用于多分类任务 <strong>公式待补</strong></p><h4 id="2-3-2-查准率-precision-、查全率-recall-与F1"><a href="#2-3-2-查准率-precision-、查全率-recall-与F1" class="headerlink" title="2.3.2 查准率(precision)、查全率(recall)与F1"></a>2.3.2 查准率(precision)、查全率(recall)与F1</h4><p>对于二分类问题,可将样例根据其真实类别与学习器预测类别的组合划分为真正例(true positive,TP)、假正例(false positive,FP)、真反例(true negative,TN)、假反例(false negative,FN)四种情形。<br>分类结果的”混淆矩阵”(confusion matrix)</p><table><thead><tr><th>真实情况</th><th>预测结果</th><th>预测结果 </th></tr></thead><tbody><tr><td>真实情况</td><td>正例</td><td>反例</td></tr><tr><td>正例</td><td>TP(真正例)</td><td>FN(假反例)</td></tr><tr><td>反例</td><td>FP(假正例)</td><td>TN(真反例)</td></tr></tbody></table><p>查准率P与查全率R分别定义为:<br>$$ P=\frac{TP}{TP+FP} $$</p><p>$$R=\frac{TP}{TP+FN}$$</p><p>查准率和查全率是一对矛盾的度量.一般来说，查准率高时，查全率往往偏低;反之类似.</p><p>查准率-查全率曲线,简称”P-R曲线“，显示该曲线的图称为”P-R图“.</p><p>若一个学习器的P-R曲线被另一个学习器的曲线完全”包住”，则可断言后者的性能优于前者.</p><p>若两个学习器的P-R曲线发生了交叉,则一般难以一般性地断言两者孰优孰劣,只能在具体的查准率或查全率条件下进行比较.仍希望比个高低,这时一个比较合理的判据是比较P-R曲线下面积的大小。</p><p>人们设计了一些综合考察查准率、查全率的性能度量.</p><p>”平衡点“(Break-Even Point,简称BEP)就是这样一个度量,它是”查准率=查全率“时的取值</p><p>但BEP还是过于简化了些，更常用的是F1度量:</p><p>$$F1=\frac{2 \times P \times R}{P+R} = \frac{2 \times TP}{样例总数+TP-TN}$$</p><p>F1是基于查准率与查全率的调和平均(harmonic mean)定义的</p><p>F1的一般形式是$F<em>{\beta}$，能让我们表达出对查准率/查全率的不同偏好,$F</em>{\beta}$是加权调和平均.</p><p>$$F_{\beta} = \frac{1+\beta^2 \times P \times R}{(\beta^2 \times P) + R}$$</p><p>其中$\beta &gt;0$度量了查全率对查准率的相对重要性.$\beta = 1$时退化为标准的F1;$\beta &gt;1$时查全率有更大影响；$\beta &lt;1$时查准率有更大影响</p><p>我们希望在n个二分类混淆矩阵上综合考察查准率和查全率.</p><p>一种直接的做法是先在各混淆矩阵上分别计算出查准率和查全率，然后计算平均值,这样就得到”宏查准率”(macro-P)、”宏查全率”(macro-R),以及相应的”宏F1”(macro-F1):</p><p>还有一种:先将各混淆矩阵的对应的元素进行平均,再基于这些平均值计算出”微查准率”(micro-P)、”微查全率”(micro-R)和”微F1”(micro-F1)</p><h4 id="2-3-3-ROC与AUC"><a href="#2-3-3-ROC与AUC" class="headerlink" title="2.3.3 ROC与AUC"></a>2.3.3 ROC与AUC</h4><p>分类阈值(threshold) 截断点(cut point)</p><p>排序本身的质量好坏,体现了综合考虑学习器在不同任务下的”期望泛化性能”的好坏，或者说，”一般情况下“泛化性能的好坏，ROC曲线则是从这个角度出发来研究学习器泛化性能的有力工具.</p><p>ROC全称是”受试者工作特征“(Receiver Operating Characteristic)曲线</p><p>ROC曲线的纵轴是”真正例率“(True Positive Rate,简称”TPR”),横轴是”假正例率”(False Positive Rate,简称FPR)</p><p>$$TPR = \frac{TP}{TP+FN}$$</p><p>$$FPR = \frac{FP}{TN+FP}$$</p><p>两条ROC曲线的比较类似于P-R曲线类似. ROC曲线下的面积,即AUC(Area Under ROC Curve)</p><p><strong>公式待补</strong></p><p>排序”损失”(loss)的定义为: <strong>公式待补</strong></p><p>$l<em>{rank}$对应的是ROC曲线之上的面积,AUC = 1-$l</em>{rank}$</p><h4 id="2-3-4-代价敏感错误率与代价曲线"><a href="#2-3-4-代价敏感错误率与代价曲线" class="headerlink" title="2.3.4 代价敏感错误率与代价曲线"></a>2.3.4 代价敏感错误率与代价曲线</h4><p>为权衡不同类型错误所造成的不同损失，可为错误赋予”非均等代价”(unequal cost).</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;机器学习笔记-学习中-进度堪忧&quot;&gt;&lt;a href=&quot;#机器学习笔记-学习中-进度堪忧&quot; class=&quot;headerlink&quot; title=&quot;机器学习笔记(学习中 进度堪忧)&quot;&gt;&lt;/a&gt;机器学习笔记(学习中 进度堪忧)&lt;/h1&gt;&lt;h2 id=&quot;第1章-绪论&quot;&gt;&lt;a href=&quot;#第1章-绪论&quot; class=&quot;headerlink&quot; title=&quot;第1章 绪论&quot;&gt;&lt;/a&gt;第1章 绪论&lt;/h2&gt;&lt;h3 id=&quot;1-1-引言&quot;&gt;&lt;a href=&quot;#1-1-引言&quot; class=&quot;headerlink&quot; title=&quot;1.1 引言&quot;&gt;&lt;/a&gt;1.1 引言&lt;/h3&gt;&lt;p&gt;通过对经验的利用，就能对新情况做出有效的决策。计算机在这方面可以帮忙。&lt;/p&gt;
&lt;p&gt;机器学习致力于研究如何通过计算的手段，利用经验来改善系统自身的性能。机器学习所研究的主要内容，是关于在计算机上从数据中产生“模型”(model)的算法，即”学习算法”(learning algorithm).&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>mac已装软件目录</title>
    <link href="http://yoursite.com/2018/02/10/mac%E5%B7%B2%E8%A3%85%E8%BD%AF%E4%BB%B6%E7%9B%AE%E5%BD%95/"/>
    <id>http://yoursite.com/2018/02/10/mac已装软件目录/</id>
    <published>2018-02-10T07:34:43.000Z</published>
    <updated>2018-02-12T04:50:33.284Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mac已装软件目录-更新至2018-2-11"><a href="#Mac已装软件目录-更新至2018-2-11" class="headerlink" title="Mac已装软件目录(更新至2018.2.11)"></a>Mac已装软件目录(更新至2018.2.11)</h1><p><strong>追随<a href="https://zhengzangw.github.io" target="_blank" rel="noopener">zzw大佬</a>的步伐</strong></p><h2 id="Develop"><a href="#Develop" class="headerlink" title="Develop"></a>Develop</h2><ul><li>Xcode</li><li>PyCharm Edu : for python</li><li>MATLAB_R2016b</li><li>Sublime Text</li><li>Mathematic</li><li><p>iTerm</p><a id="more"></a></li></ul><h2 id="Design"><a href="#Design" class="headerlink" title="Design"></a>Design</h2><ul><li>Adobe Photoshop CC</li><li>Adobe Premiere Pro CC</li><li>Adobe Audition CC</li><li>Total Video Converter Lite</li></ul><h2 id="Text"><a href="#Text" class="headerlink" title="Text"></a>Text</h2><ul><li>MacDown</li><li>Evernote</li><li>Texshop</li><li>Pages Keynote Numbers</li></ul><h2 id="Tools"><a href="#Tools" class="headerlink" title="Tools"></a>Tools</h2><ul><li>Chrome</li><li>Firefox</li><li>Parallels Desktop</li><li>EuDic</li><li>iStat Menus</li><li>Baidu Netdisk</li><li>Reeder</li><li>iText</li><li>uTorrent</li><li>WonderPen</li><li>The Unarchiver</li><li>每日英语听力</li><li>XMind</li><li>Reflector 2</li><li>Qlpmsg</li><li>Focusky</li><li>DjView</li><li>CAJCloudViewer</li><li>Blackmagic Disk Speed Test</li><li>1Checker</li><li>1Keyboard</li></ul><h2 id="Entertainment"><a href="#Entertainment" class="headerlink" title="Entertainment"></a>Entertainment</h2><ul><li>youku</li><li>mpv</li><li>aiqiyi</li><li>QQ Music</li><li>Netease Music</li><li>Steam</li><li>Lep’s World 2</li></ul><h2 id="Social-Networking"><a href="#Social-Networking" class="headerlink" title="Social Networking"></a>Social Networking</h2><ul><li>WeChat</li><li>QQ</li></ul><h2 id="Plugins"><a href="#Plugins" class="headerlink" title="Plugins"></a>Plugins</h2><ul><li>Snap</li><li>ShadowsocksX-R</li><li>Irvue</li><li>Alfred 3</li><li>Kap : for screen capturing</li><li>Homebrew</li><li>zsh</li><li>pandoc : File converting</li></ul><h2 id="Virtual-Machine"><a href="#Virtual-Machine" class="headerlink" title="Virtual Machine"></a>Virtual Machine</h2><ul><li>Windows 10</li><li>Ubuntu</li><li>Kail Linux </li></ul><h2 id="待装"><a href="#待装" class="headerlink" title="待装"></a>待装</h2><ul><li>VScode</li><li>SPSS</li><li>Dash</li><li>UltraEdit</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Mac已装软件目录-更新至2018-2-11&quot;&gt;&lt;a href=&quot;#Mac已装软件目录-更新至2018-2-11&quot; class=&quot;headerlink&quot; title=&quot;Mac已装软件目录(更新至2018.2.11)&quot;&gt;&lt;/a&gt;Mac已装软件目录(更新至2018.2.11)&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;追随&lt;a href=&quot;https://zhengzangw.github.io&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;zzw大佬&lt;/a&gt;的步伐&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;Develop&quot;&gt;&lt;a href=&quot;#Develop&quot; class=&quot;headerlink&quot; title=&quot;Develop&quot;&gt;&lt;/a&gt;Develop&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Xcode&lt;/li&gt;
&lt;li&gt;PyCharm Edu : for python&lt;/li&gt;
&lt;li&gt;MATLAB_R2016b&lt;/li&gt;
&lt;li&gt;Sublime Text&lt;/li&gt;
&lt;li&gt;Mathematic&lt;/li&gt;
&lt;li&gt;&lt;p&gt;iTerm&lt;/p&gt;
    
    </summary>
    
    
      <category term="Mac" scheme="http://yoursite.com/tags/Mac/"/>
    
      <category term="软件" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="记录" scheme="http://yoursite.com/tags/%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Python笔记</title>
    <link href="http://yoursite.com/2018/02/09/Python%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/02/09/Python笔记/</id>
    <published>2018-02-09T12:42:21.000Z</published>
    <updated>2018-02-09T12:44:06.714Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python笔记-未完待续"><a href="#Python笔记-未完待续" class="headerlink" title="Python笔记(未完待续)"></a>Python笔记(未完待续)</h1><h2 id="Python特点"><a href="#Python特点" class="headerlink" title="Python特点"></a>Python特点</h2><ul><li>简单</li><li>解释型</li><li>交互式</li><li>可移植</li><li>面向对象</li></ul><h2 id="Python特性"><a href="#Python特性" class="headerlink" title="Python特性"></a>Python特性</h2><ul><li>动态类型</li><li>自动内存管理</li><li>大型程序支持</li><li>内置对象类型</li></ul><h2 id="Python彩蛋"><a href="#Python彩蛋" class="headerlink" title="Python彩蛋"></a>Python彩蛋</h2><p>在交互解释器里输入<code>import this</code></p> <a id="more"></a><h2 id="Python解释器"><a href="#Python解释器" class="headerlink" title="Python解释器"></a>Python解释器</h2><p>有很多种，最常用的是CPython。 </p><p>解释器是输入一行就执行一行</p><p>输入<code>exit()</code>来退出解释器。</p><p>在终端里输入<code>python3 Filename.py</code>来执行python文件</p><p>在Mac和Linux上可以直接运行<code>.py</code>文件，方法是在<code>.py</code>文件的第一行加上一个特殊的注释:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br></pre></td></tr></table></figure><p>然后通过命令给<code>hello.py</code>以执行权限:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ chmod a+x hello.py</span><br></pre></td></tr></table></figure><p>以下一行注释是为了告诉Python解释器，按照UTF-8编码读取源代码，否则可能中文会有乱码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br></pre></td></tr></table></figure><h2 id="Python语法"><a href="#Python语法" class="headerlink" title="Python语法"></a>Python语法</h2><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p><code>print()</code>用<code>,</code>隔开多个输出。<strong>遇到逗号会输出一个空格</strong></p><h4 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h4><h5 id="print-方法"><a href="#print-方法" class="headerlink" title="print()方法"></a>print()方法</h5><table><thead><tr><th>占位符</th><th>替换内容 </th></tr></thead><tbody><tr><td>%d</td><td>整数  </td></tr><tr><td>%f</td><td>浮点数  </td></tr><tr><td>%s</td><td>字符串  </td></tr><tr><td>%x</td><td>十六进制整数</td></tr></tbody></table><h5 id="format-方法"><a href="#format-方法" class="headerlink" title="format()方法"></a>format()方法</h5><p>另一种格式化字符串的方法是使用字符串的format()方法，它会用传入的参数依次替换字符串内的占位符{0}、{1}……，不过这种方式写起来比%要麻烦得多：</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p><code>input()</code>。如:<code>name = input()</code>。又如<code>name = input(&#39;please enter your name&#39;)</code></p><p><code>input()</code>返回的是<code>str</code>类型，要进行转换，如<code>int()</code></p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>以<code>#</code>开头</p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="整数-int"><a href="#整数-int" class="headerlink" title="整数(int)"></a>整数(int)</h4><h4 id="浮点数-float"><a href="#浮点数-float" class="headerlink" title="浮点数(float)"></a>浮点数(float)</h4><h4 id="字符串-str"><a href="#字符串-str" class="headerlink" title="字符串(str)"></a>字符串(str)</h4><p>(<code>&#39;</code>和<code>&quot;</code>都可以) 可以用<code>r&#39;&#39;</code>表示<code>&#39;&#39;</code>里的字符串默认不转义 </p><p><code>ord()</code>获取字符的整数表示，<code>chr()</code>将编码转换为对应的字符 </p><p><code>encode()</code>和<code>decode()</code>方法 </p><p><code>len()</code>函数计算的是<code>str</code>的字符数,如果换成<code>bytes</code>,则计算字节数</p><h4 id="布尔值-bool"><a href="#布尔值-bool" class="headerlink" title="布尔值(bool)"></a>布尔值(bool)</h4><p>(<code>True</code>和<code>False</code>, <code>and</code>、<code>or</code>和<code>not</code>运算)</p><h4 id="空值"><a href="#空值" class="headerlink" title="空值"></a>空值</h4><p>用<code>None</code>表示</p><h4 id="列表-list"><a href="#列表-list" class="headerlink" title="列表(list)"></a>列表(list)</h4><p><code>classmates = [&#39;Michael&#39;, &#39;Bob&#39;, &#39;Tracy&#39;]</code> </p><p>可以用len()函数获取list的元素个数，</p><p>运用索引访问，从0开始，用-1做索引可以直接获取最后一个元素，一次类推，可以获取倒数第2个、倒数第3个···。</p><p>list有序可变：<code>append(element)</code>方法追加至末尾,<code>insert(position,element)</code>方法追插入至指定位置，删除末尾用<code>pop()</code>,删除指定位置的用<code>pop(i)</code>。</p><p>list里的元素可以不同类型，且可嵌套。</p><p>list有<code>sort()</code>方法</p><h4 id="元组-tuple"><a href="#元组-tuple" class="headerlink" title="元组(tuple)"></a>元组(tuple)</h4><p><code>classmates = (&#39;Michael&#39;, &#39;Bob&#39;, &#39;Tracy&#39;)</code></p><p>tuple与list类似，但是tuple一旦初始化就不能修改,即tuple没有append(),insert()方法。</p><p>定义一个只有1个元素的tuple得这样定义:<code>t=(1,)</code>。 </p><p>tuple里嵌套的list可变</p><h4 id="字典-dict"><a href="#字典-dict" class="headerlink" title="字典(dict)"></a>字典(dict)</h4><p>(<code>d = {&#39;Michael&#39;: 95, &#39;Bob&#39;: 75, &#39;Tracy&#39;: 85}</code>)</p><p>在其他语言中也称为map，使用键-值(key-value)储存。</p><p>一个key只能对应一个value，多次放入会把前面的值冲掉。</p><p>用<code>in</code>判断key是否存在如<code>&gt;&gt;&gt; &#39;Thomas&#39; in d</code>。<code>get()</code>方法，</p><p>如果key不存在就返回<code>None</code>,或者自己指定的value，如<code>d.get(&#39;Thomas,-1&#39;)</code></p><p>要删除一个key，用pop(key),对应的value也会从dict中删除。</p><p>dict的key必须是不可变对象，所以list不能作为key</p><p><code>dict</code>的<code>items()</code>可以同时迭代key和value:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for k,v in d.items():</span><br><span class="line">print(k,&apos;=&apos;,v)</span><br></pre></td></tr></table></figure><p>list特点：</p><ol><li>查找和插入的时间随着元素的增加而增加；</li><li>占用空间小，浪费内存很少。</li></ol><p>dict特点：</p><ol><li>找和插入的速度极快，不会随着key的增加而变慢；</li><li>需要占用大量的内存，内存浪费多。</li></ol><h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><p>set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key,重复元素在set中自动被过滤。</p><p>要创建一个set，需要提供一个list作为输入集合：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = set([1, 2, 3])</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">&#123;1, 2, 3&#125;</span><br></pre></td></tr></table></figure><p><code>add(key)</code>方法来添加key，<code>remove(key)</code>方法可以删除元素</p><p><code>s1 &amp; s2</code>：集合交， <code>s1 | s2</code>集合并</p><h4 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h4><p><code>int()</code> <code>float()</code> <code>str()</code> <code>bool()</code></p><p><em>变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言</em><br><em>返回<code>None</code>的时候Python的交互环境不显示结果</em><br><em>常量名常用大写表示，如<code>PI</code></em></p><p><em>Python中有两种除法,<code>/</code>的结果是浮点数，’//‘的结果是整数</em></p><p><em>取余为<code>%</code></em></p><p><em>UTF-8为可变长编码，把一个Unicode字符根据不同的数字大小编码成1-6个字节</em></p><h3 id="程序结构"><a href="#程序结构" class="headerlink" title="程序结构"></a>程序结构</h3><h4 id="分支语句"><a href="#分支语句" class="headerlink" title="分支语句"></a>分支语句</h4><h5 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if &lt;条件判断1&gt;:</span><br><span class="line">    &lt;执行1&gt;</span><br><span class="line">elif &lt;条件判断2&gt;:</span><br><span class="line">    &lt;执行2&gt;</span><br><span class="line">elif &lt;条件判断3&gt;:</span><br><span class="line">    &lt;执行3&gt;</span><br><span class="line">else:</span><br><span class="line">    &lt;执行4&gt;</span><br></pre></td></tr></table></figure><p>判断条件还可以简写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if x:</span><br><span class="line">    print(&apos;True&apos;)</span><br></pre></td></tr></table></figure><p>只要<code>x</code>是非零数值、非空字符串、非空list等，就判断为<code>True</code>，否则为<code>False</code>。</p><h4 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h4><h5 id="for"><a href="#for" class="headerlink" title="for"></a>for</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">names = [&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;]</span><br><span class="line">for name in names:</span><br><span class="line">    print(name)</span><br></pre></td></tr></table></figure><p><em><code>range()</code>函数可以生成一个整数序列，比如<code>range(5)</code>生成的序列是从0开始小于5的整数</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sum = 0</span><br><span class="line">for x in range(101):</span><br><span class="line">    sum = sum + x</span><br><span class="line">print(sum)</span><br></pre></td></tr></table></figure><h5 id="while"><a href="#while" class="headerlink" title="while"></a>while</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sum = 0</span><br><span class="line">n = 99</span><br><span class="line">while n &gt; 0:</span><br><span class="line">    sum = sum + n</span><br><span class="line">    n = n - 2</span><br><span class="line">print(sum)</span><br></pre></td></tr></table></figure><p><em><code>break</code>和<code>continue</code>与C++中类似。</em></p><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”：<code>a = abs</code></p><h5 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def my_abs(x):</span><br><span class="line">    if x &gt;= 0:</span><br><span class="line">        return x</span><br><span class="line">    else:</span><br><span class="line">        return -x</span><br></pre></td></tr></table></figure><p><code>return None</code>可以简写为<code>return</code></p><h6 id="空函数"><a href="#空函数" class="headerlink" title="空函数"></a>空函数</h6><p>可以用<code>pass</code>语句，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def nop():</span><br><span class="line">pass</span><br></pre></td></tr></table></figure><p><code>pass</code>也可以放在其他语句里,如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if condition:</span><br><span class="line">pass</span><br></pre></td></tr></table></figure><h6 id="参数检查"><a href="#参数检查" class="headerlink" title="参数检查"></a>参数检查</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def my_abs(x):</span><br><span class="line">    if not isinstance(x, (int, float)):</span><br><span class="line">        raise TypeError(&apos;bad operand type&apos;)</span><br><span class="line">    if x &gt;= 0:</span><br><span class="line">        return x</span><br><span class="line">    else:</span><br><span class="line">        return -x</span><br></pre></td></tr></table></figure><p>函数可以返回多个值(实质上是tuple)，并可按位置赋给相应的变量</p><h6 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h6><p><code>def power(x,n=2):</code></p><p><em>必选参数在前，默认参数在后。</em><br><em>不按默认顺序提供参数是，需要把参数名写上。</em><br><em>定义默认参数要牢记一点：默认参数必须指向不变对象！不然不同次的调用会出现不同的结果。</em></p><h6 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h6><p><code>def calc(*numbers):</code>相当于传入一个tuple</p><p>若已有list和tuple 可这样调用<code>calc(*nums)</code></p><h6 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h6><p><code>def person(name, age, **kw):</code>:会组建一个dict</p><p>和可变参数类似，也可以先组装出一个dict，然后，把该dict转换为关键字参数传进去：</p><h6 id="命名关键字参数"><a href="#命名关键字参数" class="headerlink" title="命名关键字参数"></a>命名关键字参数</h6><p>如果要限制关键字参数的名字，就可以用命名关键字参数，例如，只接收city和job作为关键字参数。这种方式定义的函数如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def person(name, age, *, city, job):</span><br><span class="line">    print(name, age, city, job)</span><br></pre></td></tr></table></figure><p>和关键字参数<code>**kw</code>不同，命名关键字参数需要一个特殊分隔符<code>*</code>，<code>*</code>后面的参数被视为命名关键字参数。</p><p>如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符*了：</p><p>命名关键字参数必须传入参数名，这和位置参数不同。如果没有传入参数名，调用将报错：</p><p>命名关键字参数可以有缺省值，从而简化调用：</p><h6 id="参数组合"><a href="#参数组合" class="headerlink" title="参数组合"></a>参数组合</h6><p>在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。</p><h5 id="函数递归"><a href="#函数递归" class="headerlink" title="函数递归"></a>函数递归</h5><p><em>尾递归可以进行优化，但大多数编译器和解释器没有进行优化</em></p><h4 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h4><p>可以对list,tuple,str操作，相当于截取，如:<code>l[1:3]</code>取索引为1和2的元素组成一个list，还可以设置间隔如：<code>l[0:100;5]</code>每五个取一个</p><h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><p>for…in 可以迭代任何可迭代的对象(如dict)</p><p>如何判断是否可以迭代：通过collections模块的Iterable类型判断。<br><code>isinstance(&#39;abc&#39;, Iterable)</code></p><p>Python内置的<code>enumerate</code>函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for i,value in enumerate([&apos;A&apos;,&apos;B&apos;,&apos;C&apos;]):</span><br><span class="line">print(i,value)</span><br></pre></td></tr></table></figure><h4 id="列表生成式-List-Comprehension"><a href="#列表生成式-List-Comprehension" class="headerlink" title="列表生成式(List Comprehension)"></a>列表生成式(List Comprehension)</h4><p><code>list(range(1,11))</code>生成<code>[1,2,3,4,5,6,7,8,9,10]</code></p><p><code>[x * x for x in range(1,11)]</code>生成 <code>[1,4,9,16,25,36,49,64,81,100]</code></p><p><code>[x * x for x in range(1,11) if x % 2 == 0]</code>生成<code>[4,16,36,64,100]</code></p><p><code>[m+n for m in &#39;ABC&#39; for n in &#39;XYZ&#39;]</code>生成<code>[&#39;AX&#39;, &#39;AY&#39;, &#39;AZ&#39;, &#39;BX&#39;, &#39;BY&#39;, &#39;BZ&#39;, &#39;CX&#39;, &#39;CY&#39;, &#39;CZ&#39;]</code></p><h4 id="生成器-generator"><a href="#生成器-generator" class="headerlink" title="生成器(generator)"></a>生成器(generator)</h4><p>边循环边计算，把<code>[]</code>变为<code>()</code>就可以了</p><p>可以通过<code>next()</code>打印generator的下一个返回值 </p><p>还可以用for循环迭代</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">g = (x*x for x in range(10))</span><br><span class="line">for n in g:</span><br><span class="line">print(n)</span><br></pre></td></tr></table></figure><p>如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator。generator和函数的执行流程不一样。函数是顺序执行，遇到return语句或者最后一行函数语句就返回。而变成generator的函数，在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行。</p><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>凡是可作用于<code>for</code>循环的对象都是<code>Iterable</code>类型；</p><p>凡是可作用于<code>next()</code>函数的对象都是<code>Iterator</code>类型，它们表示一个惰性计算的序列；</p><p>可以使用<code>isinstance()</code>判断一个对象是否是<code>Iterator</code>对象：</p><p>集合数据类型如<code>list</code>、<code>dict</code>、<code>str</code>等是<code>Iterable</code>但不是<code>Iterator</code>，不过可以通过<code>iter()</code>函数获得一个<code>Iterator</code>对象。</p><p>Python的<code>for</code>循环本质上就是通过不断调用<code>next()</code>函数实现的</p><h4 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h4><h5 id="高阶函数（Higher-order-function）"><a href="#高阶函数（Higher-order-function）" class="headerlink" title="高阶函数（Higher-order-function）"></a>高阶函数（Higher-order-function）</h5><p>函数可以赋值给变量，函数名也是变量</p><p>一个函数接受另一个函数作为参数，这种函数被称为高阶函数。</p><h6 id="map-和reduce-函数"><a href="#map-和reduce-函数" class="headerlink" title="map()和reduce()函数"></a><code>map()</code>和<code>reduce()</code>函数</h6><p><code>map()</code>函数接受两个参数，一个是函数，一个是<code>Iterable</code>,<code>map</code>将传入的函数依次作用到序列的每个元素，并把结果作为新的<code>Iterator</code>返回</p><p><code>reduce()</code>把一个函数作用在一个序列<code>[x1,x2,x3,...]</code>上。<code>reduce</code>把结果继续和序列的下一个元素做累积计算</p><p><code>reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)</code></p><h6 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h6><p>Python内建的<code>filter()</code>函数用于过滤序列。</p><p><code>filter()</code>把传入的函数依次作用于每个元素，然后根据返回值是<code>True</code>还是<code>False</code>决定保留还是丢弃该元素。</p><p><code>filter()</code>函数返回的是一个<code>Iterator</code>，也就是一个惰性序列，所以要强迫<code>filter()</code>完成计算结果，需要用<code>list()</code>函数获得所有结果并返回list。</p><h6 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h6><p><code>sorted()</code>函数也是一个高阶函数，它还可以接收一个<code>key</code>函数来实现自定义的排序,如：</p><p><code>sorted([36, 5, -12, 9, -21], key=abs)</code></p><p>默认情况下，对字符串排序，是按照ASCII的大小比较的，</p><p>要进行反向排序，不必改动key函数，可以传入第三个参数<code>reverse=True</code></p><h5 id="返回函数"><a href="#返回函数" class="headerlink" title="返回函数"></a>返回函数</h5><p>函数作为返回值</p><p>闭包：返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。如果一定要引用循环变量怎么办？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变：</p><p>返回一个函数时，牢记该函数并未执行，返回函数中不要引用任何可能会变化的变量。</p><h5 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h5><p>当我们在传入函数时，有些时候，不需要显式地定义函数，直接传入匿名函数更方便。<code>list(map(lambda x: x * x, [1, 2, 3, 4, 5, 6, 7, 8, 9]))</code></p><p><code>lambda x: x * x</code>实际上就是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def f(x):</span><br><span class="line">return x * x</span><br></pre></td></tr></table></figure><p>关键字<code>lambda</code>表示匿名函数，冒号前面的x表示函数参数。</p><p>匿名函数有个限制，就是只能有一个表达式，不用写<code>return</code>，返回值就是该表达式的结果。</p><h5 id="装饰器-Decorator-在代码运行期间动态增加功能的方式"><a href="#装饰器-Decorator-在代码运行期间动态增加功能的方式" class="headerlink" title="装饰器(Decorator)(在代码运行期间动态增加功能的方式)"></a>装饰器(Decorator)(在代码运行期间动态增加功能的方式)</h5><p>本质上，decorator就是一个返回函数的高阶函数。</p><p><strong>函数也是个对象</strong>，可以通过<code>__name__</code>属性拿到函数的名字</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def log(func):</span><br><span class="line">    def wrapper(*args, **kw):</span><br><span class="line">        print(&apos;call %s():&apos; % func.__name__)</span><br><span class="line">        return func(*args, **kw)</span><br><span class="line">    return wrapper</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@log</span><br><span class="line">def now():</span><br><span class="line">    print(&apos;2018-2-9&apos;)</span><br></pre></td></tr></table></figure><p>三层嵌套的decorator</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def log(text):</span><br><span class="line">    def decorator(func):</span><br><span class="line">        def wrapper(*args, **kw):</span><br><span class="line">            print(&apos;%s %s():&apos; % (text, func.__name__))</span><br><span class="line">            return func(*args, **kw)</span><br><span class="line">        return wrapper</span><br><span class="line">    return decorator</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@log(&apos;execute&apos;)</span><br><span class="line">def now():</span><br><span class="line">    print(&apos;2018-2-9&apos;)</span><br></pre></td></tr></table></figure><p>但此时函数名会出现错误，所以完整写法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import functools</span><br><span class="line"></span><br><span class="line">def log(func):</span><br><span class="line">    @functools.wraps(func)</span><br><span class="line">    def wrapper(*args, **kw):</span><br><span class="line">        print(&apos;call %s():&apos; % func.__name__)</span><br><span class="line">        return func(*args, **kw)</span><br><span class="line">    return wrapper</span><br></pre></td></tr></table></figure><h5 id="偏函数-Partial-function"><a href="#偏函数-Partial-function" class="headerlink" title="偏函数(Partial function)"></a>偏函数(Partial function)</h5><p>与数学意义上的偏函数不一样</p><p>所以，简单总结<code>functools.partial</code>的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单。</p><p><code>functools.partial</code>就是帮助我们创建一个偏函数的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import functools </span><br><span class="line">int2 = functools.partial(int, base=2)</span><br></pre></td></tr></table></figure><p>创建偏函数时，实际上可以接收函数对象、<code>*args</code>和<code>**kw</code>这3个参数</p><h4 id="模块-Module"><a href="#模块-Module" class="headerlink" title="模块(Module)"></a>模块(Module)</h4><p>在Python中，一个.py文件就称之为一个模块（Module）</p><p>为了避免模块名冲突，Python又引入了按目录来组织模块的方法，称为包（Package）。</p><p>方法是选择一个顶层包名，比如<code>mycompany</code>。引入了包以后，只要顶层的包名不与别人冲突，那所有模块都不会与别人冲突。现在，<code>abc.py</code>模块的名字就变成了<code>mycompany.abc</code>，类似的，<code>xyz.py</code>的模块名变成了<code>mycompany.xyz</code>。</p><p>请注意，每一个包目录下面都会有一个<code>__init__.py</code>的文件，这个文件是必须存在的，否则，Python就把这个目录当成普通目录，而不是一个包。<code>__init__.py</code>可以是空文件，也可以有Python代码，因为<code>__init__.py</code>本身就是一个模块，而它的模块名就是<code>mycompany</code>。</p><p>类似的，可以有多级目录，组成多级层次的包结构。</p><h5 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h5><p>正常的函数和变量名是公开的（public），可以被直接引用</p><p>类似<code>__xxx__</code>这样的变量是特殊变量，可以被直接引用，但是有特殊用途</p><p>类似<code>_xxx</code>和<code>__xxx</code>这样的函数或变量就是非公开的（private），不应该被直接引用</p><p>之所以我们说，private函数和变量“不应该”被直接引用，而不是“不能”被直接引用，是因为Python并没有一种方法可以完全限制访问private函数或变量，但是，从编程习惯上不应该引用private函数或变量。</p><h5 id="安装第三方模块"><a href="#安装第三方模块" class="headerlink" title="安装第三方模块"></a>安装第三方模块</h5><p>在Python中，安装第三方模块，是通过包管理工具pip完成的。</p><h4 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h4><p>数据封装、继承和多态是面向对象的三大特点</p><h5 id="类和实例-Class-and-Instance"><a href="#类和实例-Class-and-Instance" class="headerlink" title="类和实例(Class and Instance)"></a>类和实例(Class and Instance)</h5><p>在Python中，定义类是通过<code>class</code>关键字：class后面紧接着是类名，即Student，类名通常是大写开头的单词，紧接着是<code>(object)</code>，表示该类是从哪个类继承下来的,如果没有合适的继承类，就使用object类，这是所有类最终都会继承的类。</p><p>定义好了<code>Student</code>类，就可以根据<code>Student</code>类创建出Student的实例，创建实例是通过类名+()实现的。如:<code>bart = Student()</code></p><p>由于类可以起到模板的作用，因此，可以在创建实例的时候，把一些我们认为必须绑定的属性强制填写进去。通过定义一个特殊的<code>__init__</code>方法，在创建实例的时候，就把<code>name</code>，<code>score</code>等属性绑上去：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self, name, score):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.score = score</span><br></pre></td></tr></table></figure><p>和普通的函数相比，在类中定义的函数只有一点不同，就是第一个参数永远是实例变量self，并且，调用时，不用传递该参数。除此之外，类的方法和普通函数没有什么区别，所以，你仍然可以用默认参数、可变参数、关键字参数和命名关键字参数。</p><h6 id="数据封装"><a href="#数据封装" class="headerlink" title="数据封装"></a>数据封装</h6><p>和静态语言不同，Python允许对实例变量绑定任何数据，也就是说，对于两个实例变量，虽然它们都是同一个类的不同实例，但拥有的变量名称都可能不同：</p><h5 id="访问限制"><a href="#访问限制" class="headerlink" title="访问限制"></a>访问限制</h5><p>如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线<code>__</code>，在Python中，实例的变量名如果以<code>__</code>开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问</p><p>需要注意的是，在Python中，变量名类似<code>__xxx__</code>的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是private变量，所以，不能用<code>__name__</code>、<code>__score__</code>这样的变量名。</p><p>双下划线开头的实例变量是不是一定不能从外部访问呢？其实也不是。不能直接访问<code>__name</code>是因为Python解释器对外把<code>__name</code>变量改成了<code>_Student__name</code>，所以，仍然可以通过<code>_Student__name</code>来访问<code>__name</code>变量：</p><h5 id="继承和多态"><a href="#继承和多态" class="headerlink" title="继承和多态"></a>继承和多态</h5><p>在OOP程序设计中，当我们定义一个class的时候，可以从某个现有的class继承，新的class称为子类（Subclass），而被继承的class称为基类、父类或超类（Base class、Super class）。</p><p>继承有什么好处？最大的好处是子类获得了父类的全部功能。由于<code>Animial</code>实现了<code>run()</code>方法，因此，<code>Dog</code>和<code>Cat</code>作为它的子类，什么事也没干，就自动拥有了<code>run()</code>方法：</p><p>当子类和父类都存在相同的<code>run()</code>方法时，我们说，子类的<code>run()</code>覆盖了父类的<code>run()</code>，在代码运行的时候，总是会调用子类的<code>run()</code>。这样，我们就获得了继承的另一个好处：多态。</p><p>所以，在继承关系中，如果一个实例的数据类型是某个子类，那它的数据类型也可以被看做是父类。但是，反过来就不行</p><h6 id="静态语言-vs-动态语言"><a href="#静态语言-vs-动态语言" class="headerlink" title="静态语言 vs 动态语言"></a>静态语言 vs 动态语言</h6><p>对于静态语言（例如Java）来说，如果需要传入<code>Animal</code>类型，则传入的对象必须是<code>Animal</code>类型或者它的子类，否则，将无法调用<code>run()</code>方法。</p><p>对于Python这样的动态语言来说，则不一定需要传入<code>Animal</code>类型。我们只需要保证传入的对象有一个<code>run()</code>方法就可以了</p><p>这就是动态语言的“鸭子类型”，它并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。</p><p>Python的“file-like object“就是一种鸭子类型。对真正的文件对象，它有一个<code>read()</code>方法，返回其内容。但是，许多对象，只要有<code>read()</code>方法，都被视为“file-like object“。许多函数接收的参数就是“file-like object“，你不一定要传入真正的文件对象，完全可以传入任何实现了<code>read()</code>方法的对象。</p><h5 id="获取对象信息"><a href="#获取对象信息" class="headerlink" title="获取对象信息"></a>获取对象信息</h5><h6 id="使用type"><a href="#使用type" class="headerlink" title="使用type()"></a>使用type()</h6><p>判断对象类型</p><h6 id="使用isinstance"><a href="#使用isinstance" class="headerlink" title="使用isinstance()"></a>使用isinstance()</h6><h6 id="使用dir"><a href="#使用dir" class="headerlink" title="使用dir()"></a>使用dir()</h6><p>如果要获得一个对象的所有属性和方法，可以使用<code>dir()</code>函数，它返回一个包含字符串的list</p><h5 id="实例属性和类属性"><a href="#实例属性和类属性" class="headerlink" title="实例属性和类属性"></a>实例属性和类属性</h5><p>疑惑：<br>python的动态类型是否是用指针实现的</p><p>参考:</p><ol><li><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/00143186738532805c392f2cc09446caf3236c34e3f980f000" target="_blank" rel="noopener">Python教程</a></li><li>《Python学习手册》 by Mark Lutz(O’REILLY Press,2011)</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python笔记-未完待续&quot;&gt;&lt;a href=&quot;#Python笔记-未完待续&quot; class=&quot;headerlink&quot; title=&quot;Python笔记(未完待续)&quot;&gt;&lt;/a&gt;Python笔记(未完待续)&lt;/h1&gt;&lt;h2 id=&quot;Python特点&quot;&gt;&lt;a href=&quot;#Python特点&quot; class=&quot;headerlink&quot; title=&quot;Python特点&quot;&gt;&lt;/a&gt;Python特点&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;简单&lt;/li&gt;
&lt;li&gt;解释型&lt;/li&gt;
&lt;li&gt;交互式&lt;/li&gt;
&lt;li&gt;可移植&lt;/li&gt;
&lt;li&gt;面向对象&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Python特性&quot;&gt;&lt;a href=&quot;#Python特性&quot; class=&quot;headerlink&quot; title=&quot;Python特性&quot;&gt;&lt;/a&gt;Python特性&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;动态类型&lt;/li&gt;
&lt;li&gt;自动内存管理&lt;/li&gt;
&lt;li&gt;大型程序支持&lt;/li&gt;
&lt;li&gt;内置对象类型&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Python彩蛋&quot;&gt;&lt;a href=&quot;#Python彩蛋&quot; class=&quot;headerlink&quot; title=&quot;Python彩蛋&quot;&gt;&lt;/a&gt;Python彩蛋&lt;/h2&gt;&lt;p&gt;在交互解释器里输入&lt;code&gt;import this&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>LaTex笔记(不定期更新)</title>
    <link href="http://yoursite.com/2018/02/06/LaTex%E7%AC%94%E8%AE%B0-%E4%B8%8D%E5%AE%9A%E6%9C%9F%E6%9B%B4%E6%96%B0/"/>
    <id>http://yoursite.com/2018/02/06/LaTex笔记-不定期更新/</id>
    <published>2018-02-06T06:46:11.000Z</published>
    <updated>2018-02-06T10:01:57.214Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Latex-笔记（不定期更新）"><a href="#Latex-笔记（不定期更新）" class="headerlink" title="Latex 笔记（不定期更新）"></a>Latex 笔记（不定期更新）</h1><h2 id="标题，章和节"><a href="#标题，章和节" class="headerlink" title="标题，章和节"></a>标题，章和节</h2><table><thead><tr><th>命令</th><th>效果</th><th>命令</th><th>效果</th></tr></thead><tbody><tr><td>\title</td><td>标题</td><td>\author</td><td>作者</td></tr><tr><td>\date</td><td>日期</td><td>\maketitle</td><td>生成标题</td></tr><tr><td>\section</td><td>节标题</td><td>\subsection</td><td>小节标题</td></tr><tr><td>\subsubsection</td><td>次小节标题</td><td>\paragraph</td><td>段标题</td></tr><tr><td>\subparagraph</td><td>小段标题</td><td>\part</td><td>部分标题</td></tr><tr><td>\appendix</td><td>附录标题</td><td>\tableofcontents</td><td>生成目录</td></tr><tr><td>\listoffigures</td><td>插图目录</td><td>\listoftables</td><td>表格目录</td></tr></tbody></table> <a id="more"></a><h2 id="插入项目符号和编号"><a href="#插入项目符号和编号" class="headerlink" title="插入项目符号和编号"></a>插入项目符号和编号</h2><h3 id="不带序号"><a href="#不带序号" class="headerlink" title="不带序号"></a>不带序号</h3><p>关于{itemize}里序号的形式：latex默认生成的简单列表，默认为一个小圆点，而我们在写文章时可能想要一些不一样的列表符号，比如 -， * 之类的. 我们可以这样写</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;itemize&#125; </span><br><span class="line">\item[-] something</span><br><span class="line">\item[-] something</span><br><span class="line">\end&#123;itemize&#125;</span><br></pre></td></tr></table></figure><h3 id="带序号"><a href="#带序号" class="headerlink" title="带序号"></a>带序号</h3><p> 关于{enumerate}，这是用于带序号的列表。 默认生成 1，2，3。如果想要其他修饰，如(1) (2)….或step-1，step2，需要加载 \usepackage{enumerate}，然后如下使用</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;enumerate&#125;[step 1]</span><br><span class="line">\item something</span><br><span class="line">\item something</span><br><span class="line">\end&#123;enumerate&#125;</span><br></pre></td></tr></table></figure><h2 id="引入参考文献"><a href="#引入参考文献" class="headerlink" title="引入参考文献"></a>引入参考文献</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;thebibliography&#125;&#123;99&#125;</span><br><span class="line">\bibitem&#123;a&#125; something</span><br><span class="line">\bibitem&#123;b&#125; something</span><br><span class="line">\end&#123;thebibliography&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Latex-笔记（不定期更新）&quot;&gt;&lt;a href=&quot;#Latex-笔记（不定期更新）&quot; class=&quot;headerlink&quot; title=&quot;Latex 笔记（不定期更新）&quot;&gt;&lt;/a&gt;Latex 笔记（不定期更新）&lt;/h1&gt;&lt;h2 id=&quot;标题，章和节&quot;&gt;&lt;a href=&quot;#标题，章和节&quot; class=&quot;headerlink&quot; title=&quot;标题，章和节&quot;&gt;&lt;/a&gt;标题，章和节&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;效果&lt;/th&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;效果&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;\title&lt;/td&gt;
&lt;td&gt;标题&lt;/td&gt;
&lt;td&gt;\author&lt;/td&gt;
&lt;td&gt;作者&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\date&lt;/td&gt;
&lt;td&gt;日期&lt;/td&gt;
&lt;td&gt;\maketitle&lt;/td&gt;
&lt;td&gt;生成标题&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\section&lt;/td&gt;
&lt;td&gt;节标题&lt;/td&gt;
&lt;td&gt;\subsection&lt;/td&gt;
&lt;td&gt;小节标题&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\subsubsection&lt;/td&gt;
&lt;td&gt;次小节标题&lt;/td&gt;
&lt;td&gt;\paragraph&lt;/td&gt;
&lt;td&gt;段标题&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\subparagraph&lt;/td&gt;
&lt;td&gt;小段标题&lt;/td&gt;
&lt;td&gt;\part&lt;/td&gt;
&lt;td&gt;部分标题&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\appendix&lt;/td&gt;
&lt;td&gt;附录标题&lt;/td&gt;
&lt;td&gt;\tableofcontents&lt;/td&gt;
&lt;td&gt;生成目录&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\listoffigures&lt;/td&gt;
&lt;td&gt;插图目录&lt;/td&gt;
&lt;td&gt;\listoftables&lt;/td&gt;
&lt;td&gt;表格目录&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
    
      <category term="LaTex" scheme="http://yoursite.com/tags/LaTex/"/>
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Markdown简明语法</title>
    <link href="http://yoursite.com/2018/02/04/Markdown%E7%AE%80%E6%98%8E%E8%AF%AD%E6%B3%95/"/>
    <id>http://yoursite.com/2018/02/04/Markdown简明语法/</id>
    <published>2018-02-04T05:16:50.000Z</published>
    <updated>2018-02-12T04:20:22.615Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Markdown简明语法"><a href="#Markdown简明语法" class="headerlink" title="Markdown简明语法"></a>Markdown简明语法</h1><h2 id="Markdown优点"><a href="#Markdown优点" class="headerlink" title="Markdown优点"></a>Markdown优点</h2><ul><li>纯文本，兼容性强</li><li>语法简单，有较强的可读性</li><li>转换方便 <a id="more"></a></li></ul><h2 id="Markdown语法"><a href="#Markdown语法" class="headerlink" title="Markdown语法"></a>Markdown语法</h2><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><h4 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表:"></a>无序列表:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 文本1</span><br><span class="line">- 文本2</span><br><span class="line">- 文本3</span><br></pre></td></tr></table></figure><p>显示效果为：</p><ul><li>文本1</li><li>文本2</li><li>文本3</li></ul><h4 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表:"></a>有序列表:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 文本1</span><br><span class="line">2. 文本2</span><br><span class="line">3. 文本3</span><br></pre></td></tr></table></figure><p>显示效果为：</p><ol><li>文本1</li><li>文本2</li><li>文本3</li></ol><h3 id="链接和图片"><a href="#链接和图片" class="headerlink" title="链接和图片"></a>链接和图片</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[显示文本](链接地址)</span><br><span class="line">![](图片链接地址)</span><br></pre></td></tr></table></figure><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>在希望引用的文件前面加<code>&gt;</code>就可以 </p><p><code>&gt;</code> 和文本之间要保留一个字符的空格。</p><h3 id="粗体和斜体"><a href="#粗体和斜体" class="headerlink" title="粗体和斜体"></a>粗体和斜体</h3><p>用两个 <code>*</code> 包含一段文本就是粗体的语法，用一个 <code>*</code> 包含一段文本就是斜体的语法</p><h3 id="代码引用"><a href="#代码引用" class="headerlink" title="代码引用"></a>代码引用</h3><p>一行代码用 包住 </p><p>若代码为多行，则用两行(每行三个)包住</p><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| Tables        | Are           | Cool  |</span><br><span class="line">| ------------- |:-------------:| -----:|</span><br><span class="line">| col 3 is      | right-aligned | $1600 |</span><br><span class="line">| col 2 is      | centered      |   $12 |</span><br><span class="line">| zebra stripes | are neat      |    $1 |</span><br></pre></td></tr></table></figure><p>显示效果为:</p><table><thead><tr><th>Tables</th><th style="text-align:center">Are</th><th style="text-align:right">Cool</th></tr></thead><tbody><tr><td>col 3 is</td><td style="text-align:center">right-aligned</td><td style="text-align:right">$1600</td></tr><tr><td>col 2 is</td><td style="text-align:center">centered</td><td style="text-align:right">$12</td></tr><tr><td>zebra stripes</td><td style="text-align:center">are neat</td><td style="text-align:right">$1</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dog | bird | cat</span><br><span class="line">----|------|----</span><br><span class="line">foo | foo  | foo</span><br><span class="line">bar | bar  | bar</span><br><span class="line">baz | baz  | baz</span><br></pre></td></tr></table></figure><p>显示效果为:</p><table><thead><tr><th>dog</th><th>bird</th><th>cat</th></tr></thead><tbody><tr><td>foo</td><td>foo</td><td>foo</td></tr><tr><td>bar</td><td>bar</td><td>bar</td></tr><tr><td>baz</td><td>baz</td><td>baz</td></tr></tbody></table><h3 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h3><p>行内公式: <code>$数学公式$</code></p><p>行间公式: <code>$$数学公式$$</code></p><p>用LaTex语法</p><p>参考：<a href="https://www.jianshu.com/p/q81RER" target="_blank" rel="noopener">献给写作者的 Markdown 新手指南</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Markdown简明语法&quot;&gt;&lt;a href=&quot;#Markdown简明语法&quot; class=&quot;headerlink&quot; title=&quot;Markdown简明语法&quot;&gt;&lt;/a&gt;Markdown简明语法&lt;/h1&gt;&lt;h2 id=&quot;Markdown优点&quot;&gt;&lt;a href=&quot;#Markdown优点&quot; class=&quot;headerlink&quot; title=&quot;Markdown优点&quot;&gt;&lt;/a&gt;Markdown优点&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;纯文本，兼容性强&lt;/li&gt;
&lt;li&gt;语法简单，有较强的可读性&lt;/li&gt;
&lt;li&gt;转换方便
    
    </summary>
    
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="markdown" scheme="http://yoursite.com/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2018/02/02/hello-world/"/>
    <id>http://yoursite.com/2018/02/02/hello-world/</id>
    <published>2018-02-02T05:02:57.299Z</published>
    <updated>2018-02-02T05:02:57.299Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
