<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ricky Ting&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/5c8eecd06d08187c73ea49421008f04d</icon>
  <subtitle>当时只道是寻常</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ricky-ting.github.io/"/>
  <updated>2018-09-03T13:26:47.793Z</updated>
  <id>https://ricky-ting.github.io/</id>
  
  <author>
    <name>Ricky-Ting</name>
    <email>1770048119@qq.com dbr1770048119@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Daily-Records for 2018-Sept</title>
    <link href="https://ricky-ting.github.io/2018/09/01/Daily-Records-for-2018-Sept/"/>
    <id>https://ricky-ting.github.io/2018/09/01/Daily-Records-for-2018-Sept/</id>
    <published>2018-09-01T14:42:22.000Z</published>
    <updated>2018-09-03T13:26:47.793Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Sept-1"><a href="#Sept-1" class="headerlink" title="Sept 1"></a>Sept 1</h1><ul><li>复习汇编</li><li>汇编考试(2:00 pm - 4:00 pm)</li><li>重新搭建Hadoop环境(进度50%),修复了好多bug</li><li><p>装Windows XP 虚拟机(玩了三维弹球)</p><a id="more"></a></li></ul><h1 id="Sept-2"><a href="#Sept-2" class="headerlink" title="Sept 2"></a>Sept 2</h1><ul><li>搭建Hadoop环境完成</li><li>学习java(进度55/689)</li><li>吃火锅</li><li>看big bang(S1E1-S1E3)</li></ul><h1 id="Sept-3-开学第一天"><a href="#Sept-3-开学第一天" class="headerlink" title="Sept 3(开学第一天)"></a>Sept 3(开学第一天)</h1><ul><li>装windows7虚拟机，并安装Quartus，重新做了实验0(数字逻辑电路真好玩 雾)</li></ul><p><img src="/images/dailyrecordfor2018sept/sept3_1.JPG" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Sept-1&quot;&gt;&lt;a href=&quot;#Sept-1&quot; class=&quot;headerlink&quot; title=&quot;Sept 1&quot;&gt;&lt;/a&gt;Sept 1&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;复习汇编&lt;/li&gt;
&lt;li&gt;汇编考试(2:00 pm - 4:00 pm)&lt;/li&gt;
&lt;li&gt;重新搭建Hadoop环境(进度50%),修复了好多bug&lt;/li&gt;
&lt;li&gt;&lt;p&gt;装Windows XP 虚拟机(玩了三维弹球)&lt;/p&gt;
    
    </summary>
    
    
      <category term="记录" scheme="https://ricky-ting.github.io/tags/%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Bug-Fix for hadoop installing</title>
    <link href="https://ricky-ting.github.io/2018/09/01/Bug-Fix-for-hadoop-installing/"/>
    <id>https://ricky-ting.github.io/2018/09/01/Bug-Fix-for-hadoop-installing/</id>
    <published>2018-09-01T14:26:44.000Z</published>
    <updated>2018-09-01T14:39:07.044Z</updated>
    
    <content type="html"><![CDATA[<p>启动守护进程的时候(<code>start-dfs.sh</code>)报错：<code>master: ssh: Could not resolve hostname master: Name or Service not knwon</code>。</p><p>解决方法: 在host文件中添加master解析。</p><p><code>sudo vim /etc/hosts</code></p><p><code>127.0.0.1  master</code></p><p><a href="http://www.powerxing.com/install-hadoop/comment-page-1/" target="_blank" rel="noopener">贴一篇超详细的教程</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;启动守护进程的时候(&lt;code&gt;start-dfs.sh&lt;/code&gt;)报错：&lt;code&gt;master: ssh: Could not resolve hostname master: Name or Service not knwon&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;解决方
      
    
    </summary>
    
    
      <category term="bug" scheme="https://ricky-ting.github.io/tags/bug/"/>
    
  </entry>
  
  <entry>
    <title>shared folder in virtual machine</title>
    <link href="https://ricky-ting.github.io/2018/09/01/shared-folder-in-virtual-machine/"/>
    <id>https://ricky-ting.github.io/2018/09/01/shared-folder-in-virtual-machine/</id>
    <published>2018-09-01T11:35:31.000Z</published>
    <updated>2018-09-01T11:36:14.738Z</updated>
    
    <content type="html"><![CDATA[<h1 id="shared-folder-in-virtual-machine"><a href="#shared-folder-in-virtual-machine" class="headerlink" title="shared folder in virtual machine"></a>shared folder in virtual machine</h1><ol><li>首先在virtual box点击 <code>Insert Guest Additions CD Image</code></li><li>在虚拟机中运行弹出来的窗口</li><li>在Terminal中输入<code>sudo adduser $YourUserName vboxsf</code></li><li>Restart</li></ol><p><a href="https://stackoverflow.com/questions/26740113/virtualbox-shared-folder-permissions" target="_blank" rel="noopener">Stack Overflow相关链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;shared-folder-in-virtual-machine&quot;&gt;&lt;a href=&quot;#shared-folder-in-virtual-machine&quot; class=&quot;headerlink&quot; title=&quot;shared folder in virtual mac
      
    
    </summary>
    
    
      <category term="bug" scheme="https://ricky-ting.github.io/tags/bug/"/>
    
  </entry>
  
  <entry>
    <title>回顾与展望(2018.8.25)</title>
    <link href="https://ricky-ting.github.io/2018/08/25/%E5%9B%9E%E9%A1%BE%E4%B8%8E%E5%B1%95%E6%9C%9B-2018-8-25/"/>
    <id>https://ricky-ting.github.io/2018/08/25/回顾与展望-2018-8-25/</id>
    <published>2018-08-25T02:05:06.000Z</published>
    <updated>2018-08-25T02:21:35.695Z</updated>
    
    <content type="html"><![CDATA[<h2 id="暑假里干的事"><a href="#暑假里干的事" class="headerlink" title="暑假里干的事"></a>暑假里干的事</h2><a id="more"></a><ol><li>看了《数学之美》</li><li>看了《黑客与画家》</li><li>看了《1Q84》</li><li>看完CSAPP前三章，并完成汇编实验和作业，拆炸弹</li><li>进行《挑战程序设计竞赛》里的编程训练</li><li>看完《计算机系统基础》前三章，并看完ICS网课相应部分</li><li>完成《Hadoop技术内幕》的源代码分析环境搭建，并阅读前两章(意识到要先学习java)</li><li>看了n(&gt;20)部电影</li><li>湖北五日游</li><li>练车，过了科三</li><li>社会实践(扬州二日游)</li></ol><p>总结：感觉效率还是不高，在家易涣散。技术学习和课外拓展较少。<del>导师的邮件让我意识到暑假里一事无成,趁着还有几天亡羊补牢吧</del></p><p>思考：</p><ul><li>计算机专业涵盖面太广，想学很多东西，但往往局限于了解。</li><li>其次需要学的多了的时候，易浮躁。</li><li>学会在信息的洪流中认准自己需要的，贪多不易得。</li><li>学习方法需要改进，经常在网上学习新知识的时候，易陷入递归状态，不断地点击超链接和查询新名词，导致经常开了十几个页面，最后只了解了皮毛，自暴自弃把所有页面关了。</li><li>要养成随时学习的习惯，保持对技术和知识的热情。</li><li>在做中学。 </li><li>ddl是第一生产力，没有ddl，就只能靠自己自觉了。</li><li><del>大神们的博客太有趣了，看着看着就荒废了一天。</del></li></ul><h2 id="新学期展望"><a href="#新学期展望" class="headerlink" title="新学期展望"></a>新学期展望</h2><h3 id="需要养成的习惯或改掉的坏习惯"><a href="#需要养成的习惯或改掉的坏习惯" class="headerlink" title="需要养成的习惯或改掉的坏习惯"></a>需要养成的习惯或改掉的坏习惯</h3><ul><li>养成daily record的习惯，追踪自己的进展，不要到最后才发现一事无成。</li><li>并且对短期设立计划。</li><li>进行学习思考。</li><li>不浮躁，用心学习</li></ul><h3 id="新学期要做的事"><a href="#新学期要做的事" class="headerlink" title="新学期要做的事"></a>新学期要做的事</h3><ol><li>多看书 (阅读经典，技术书籍等)</li><li>专业课好好上，实验好好做</li><li>大数据学习和实践(java Hadoop spark)</li><li>广泛涉猎技术</li><li>练科二，争取寒假考过</li></ol><h3 id="大数据、云计算学习方面"><a href="#大数据、云计算学习方面" class="headerlink" title="大数据、云计算学习方面"></a>大数据、云计算学习方面</h3><ol><li>多动手，多找一些示例跑一跑。</li><li>养成借助google、Stack Overflow解决配置、运行时出现的问题</li><li>对源代码进行分析</li><li>学习java</li><li>多读经典paper，广泛涉猎</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;暑假里干的事&quot;&gt;&lt;a href=&quot;#暑假里干的事&quot; class=&quot;headerlink&quot; title=&quot;暑假里干的事&quot;&gt;&lt;/a&gt;暑假里干的事&lt;/h2&gt;
    
    </summary>
    
    
      <category term="计划" scheme="https://ricky-ting.github.io/tags/%E8%AE%A1%E5%88%92/"/>
    
      <category term="记录" scheme="https://ricky-ting.github.io/tags/%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>挑战程序设计竞赛笔记</title>
    <link href="https://ricky-ting.github.io/2018/08/24/%E6%8C%91%E6%88%98%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%E7%AC%94%E8%AE%B0/"/>
    <id>https://ricky-ting.github.io/2018/08/24/挑战程序设计竞赛笔记/</id>
    <published>2018-08-24T11:24:53.000Z</published>
    <updated>2018-08-24T11:26:19.610Z</updated>
    
    <content type="html"><![CDATA[<h2 id="三角形"><a href="#三角形" class="headerlink" title="三角形"></a>三角形</h2><h3 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h3><p>从一堆绳子中找出三根绳子使得围成的三角形的周长最大。</p><a id="more"></a><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><ol><li>穷举，O($n^3$)</li><li>先排序，看最大的三根可不可以，不可以，将最大的一根剔除，然后递归。O($n \log_{}n$)</li></ol><h2 id="Ants-POJ-1852"><a href="#Ants-POJ-1852" class="headerlink" title="Ants(POJ 1852)"></a>Ants(POJ 1852)</h2><h3 id="描述：-1"><a href="#描述：-1" class="headerlink" title="描述："></a>描述：</h3><p>一堆蚂蚁在一根绳子上，不知道初始朝向，两个蚂蚁相遇会各自掉头，给出每个蚂蚁距离左端的距离和绳子，求出所有蚂蚁掉下绳子的最长时间和最短时间。</p><h3 id="题解：-1"><a href="#题解：-1" class="headerlink" title="题解："></a>题解：</h3><p>两个蚂蚁相遇掉头就相当于两个蚂蚁穿过对方继续前进。O(n)</p><h2 id="Lake-Counting-POJ-2386"><a href="#Lake-Counting-POJ-2386" class="headerlink" title="Lake Counting(POJ 2386)"></a>Lake Counting(POJ 2386)</h2><h3 id="描述：-2"><a href="#描述：-2" class="headerlink" title="描述："></a>描述：</h3><p>和W相邻的八个square可以认为是连在一起的，构成水洼，计算有多少块水洼。</p><h3 id="题解：-2"><a href="#题解：-2" class="headerlink" title="题解："></a>题解：</h3><p>用DFS，把和W相邻的变为<code>.</code>,一次DFS解决一块水洼，多少次DFS就有多少块水洼。复杂度：O(8 $\times$ N $\times$ M)</p><h2 id="迷宫的最短路径"><a href="#迷宫的最短路径" class="headerlink" title="迷宫的最短路径"></a>迷宫的最短路径</h2><h3 id="描述：-3"><a href="#描述：-3" class="headerlink" title="描述："></a>描述：</h3><p>寻找迷宫的最短路径</p><h3 id="题解：-3"><a href="#题解：-3" class="headerlink" title="题解："></a>题解：</h3><p>BFS，用数组记录每一点的距离，不断更新，用队列实现BFS。</p><h2 id="硬币问题"><a href="#硬币问题" class="headerlink" title="硬币问题"></a>硬币问题</h2><h3 id="描述：-4"><a href="#描述：-4" class="headerlink" title="描述："></a>描述：</h3><p>1元、5元、十元、50元、100元的硬币，如何找钱是个数最少。</p><h3 id="题解：-4"><a href="#题解：-4" class="headerlink" title="题解："></a>题解：</h3><p>贪心算法，但有条件，所有大的硬币的面额都得是小的硬币的倍数。如果上面加入20元的硬币，贪心算法就无法使用</p><h2 id="区间调度问题"><a href="#区间调度问题" class="headerlink" title="区间调度问题"></a>区间调度问题</h2><h3 id="描述：-5"><a href="#描述：-5" class="headerlink" title="描述："></a>描述：</h3><p>有很多工作区间，同时只能干一件事，要求在一段时间内完成最多的工作(个数)</p><h3 id="题解：-5"><a href="#题解：-5" class="headerlink" title="题解："></a>题解：</h3><p>总是在可选的工作中选取结束时间最早的工作</p><h2 id="Best-Cow-Line-POJ-3617"><a href="#Best-Cow-Line-POJ-3617" class="headerlink" title="Best Cow Line(POJ 3617)"></a>Best Cow Line(POJ 3617)</h2><h3 id="描述：-6"><a href="#描述：-6" class="headerlink" title="描述："></a>描述：</h3><p>每次可以从S的头部或尾部取一个字符加入到T的尾部，使得最终T的字典序最小</p><h3 id="题解：-6"><a href="#题解：-6" class="headerlink" title="题解："></a>题解：</h3><p>比较S和反转后S的字典序，取字典序小的那边，贪心。</p><h2 id="Saruman’s-Army-POJ-3069"><a href="#Saruman’s-Army-POJ-3069" class="headerlink" title="Saruman’s Army (POJ 3069)"></a>Saruman’s Army (POJ 3069)</h2><h3 id="描述：-7"><a href="#描述：-7" class="headerlink" title="描述："></a>描述：</h3><p>点覆盖问题，半径R</p><h3 id="题解：-7"><a href="#题解：-7" class="headerlink" title="题解："></a>题解：</h3><p>贪心</p><h2 id="Fence-Repair-POJ-3253"><a href="#Fence-Repair-POJ-3253" class="headerlink" title="Fence Repair (POJ 3253)"></a>Fence Repair (POJ 3253)</h2><h3 id="描述：-8"><a href="#描述：-8" class="headerlink" title="描述："></a>描述：</h3><p>切木板开销问题</p><h3 id="题解：-8"><a href="#题解：-8" class="headerlink" title="题解："></a>题解：</h3><p>两个最小板应该是一起切得，贪心。</p><h2 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h2><h3 id="描述：-9"><a href="#描述：-9" class="headerlink" title="描述："></a>描述：</h3><p>背包容量有限，拿或不拿。</p><h3 id="题解：-9"><a href="#题解：-9" class="headerlink" title="题解："></a>题解：</h3><p>动态规划</p><h2 id="最长公共子序列问题"><a href="#最长公共子序列问题" class="headerlink" title="最长公共子序列问题"></a>最长公共子序列问题</h2><h3 id="描述：-10"><a href="#描述：-10" class="headerlink" title="描述："></a>描述：</h3><p>求两个字符串的最大公共子序列长度，子序列可不连续</p><h3 id="题解：-10"><a href="#题解：-10" class="headerlink" title="题解："></a>题解：</h3><p>DP</p><h2 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h2><h3 id="描述：-11"><a href="#描述：-11" class="headerlink" title="描述："></a>描述：</h3><p>每种物品可选任意多件</p><h3 id="题解：-11"><a href="#题解：-11" class="headerlink" title="题解："></a>题解：</h3><p>改改递推关系式</p><h2 id="多重部分和关系"><a href="#多重部分和关系" class="headerlink" title="多重部分和关系"></a>多重部分和关系</h2><h3 id="描述：-12"><a href="#描述：-12" class="headerlink" title="描述："></a>描述：</h3><p>有n种不同大小的数字$a_i$,每种各$m_i$个。判断是否可以从这些数字之中选出若干使它们的和恰好为K.</p><h3 id="题解：-12"><a href="#题解：-12" class="headerlink" title="题解："></a>题解：</h3><p>需要记录剩余的数字个数，DP</p><h2 id="最长上升子序列问题"><a href="#最长上升子序列问题" class="headerlink" title="最长上升子序列问题"></a>最长上升子序列问题</h2><h3 id="描述：-13"><a href="#描述：-13" class="headerlink" title="描述："></a>描述：</h3><p>求一个序列的最长上升子序列</p><h3 id="题解：-13"><a href="#题解：-13" class="headerlink" title="题解："></a>题解：</h3><p>DP，记录以$a_i$结尾的最长上升子序列长度</p><h2 id="划分数"><a href="#划分数" class="headerlink" title="划分数"></a>划分数</h2><h3 id="描述：-14"><a href="#描述：-14" class="headerlink" title="描述："></a>描述：</h3><p>有n个无区别的物品，将它们划分成不超过m组，求出划分方法数模M的余数</p><h3 id="题解：-14"><a href="#题解：-14" class="headerlink" title="题解："></a>题解：</h3><p>DP，找出状态转移，设dp[i][j]是j的i划分数，有关系dp[i][j]=dp[i][j-i]+dp[i-1][j]</p><h2 id="多重集组合数"><a href="#多重集组合数" class="headerlink" title="多重集组合数"></a>多重集组合数</h2><h3 id="描述：-15"><a href="#描述：-15" class="headerlink" title="描述："></a>描述：</h3><p>n种物品，第i种有$a_i$个，然后一共取m个，有多少种取法</p><h3 id="题解：-15"><a href="#题解：-15" class="headerlink" title="题解："></a>题解：</h3><p>DP，$dp[i+1][j]=\sum_{k=0}^{min(j,a[i])} dp[i][j-k]$, 可以进一步化简得到: $dp[i+1][j]=dp[i+1][j-1]+dp[i][j]-dp[i][j-1-a_i]$</p><h2 id="Expedition-POJ-2431"><a href="#Expedition-POJ-2431" class="headerlink" title="Expedition (POJ 2431)"></a>Expedition (POJ 2431)</h2><h3 id="描述：-16"><a href="#描述：-16" class="headerlink" title="描述："></a>描述：</h3><p>加油问题，要求次数最少</p><h3 id="题解：-16"><a href="#题解：-16" class="headerlink" title="题解："></a>题解：</h3><p>贪心+优先队列。 不断行驶，当油量为0时，选择经过的最大加油量的加油站。</p><h2 id="食物链-POJ-1182"><a href="#食物链-POJ-1182" class="headerlink" title="食物链 (POJ 1182)"></a>食物链 (POJ 1182)</h2><h3 id="描述：-17"><a href="#描述：-17" class="headerlink" title="描述："></a>描述：</h3><p>有N只动物，分三类，形成循环状的捕食关系，循环给出两种信息：x和y属于同一类和x吃y，一共K条。其中可能出错，求出出错的消息数。</p><h3 id="题解：-17"><a href="#题解：-17" class="headerlink" title="题解："></a>题解：</h3><p>用并查集，维护3*N种状态，看是否有矛盾，进行合并操作和查询操作。</p><h2 id="二分图判定"><a href="#二分图判定" class="headerlink" title="二分图判定"></a>二分图判定</h2><h3 id="描述：-18"><a href="#描述：-18" class="headerlink" title="描述："></a>描述：</h3><p>给定一个n个顶点的图，能否最多用两个颜色染色，相邻顶点颜色不同</p><h3 id="题解：-18"><a href="#题解：-18" class="headerlink" title="题解："></a>题解：</h3><p>用dfs，把相邻的染上不同色，看是否有矛盾</p><h2 id="Minimum-Scalar-Product-GCJ-2008-Round1A-A"><a href="#Minimum-Scalar-Product-GCJ-2008-Round1A-A" class="headerlink" title="Minimum Scalar Product (GCJ 2008 Round1A A)"></a>Minimum Scalar Product (GCJ 2008 Round1A A)</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述:"></a>描述:</h3><p>两个向量，内部换序，使得最后的向量积最小。</p><h3 id="题解：-19"><a href="#题解：-19" class="headerlink" title="题解："></a>题解：</h3><p>设a&lt;b,c&lt;d, 可以证明ad+bc最小。所以只要将两个向量分别排序，最大的和最小的乘就可以。 对于large数据，要用long long</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">long long a[802],b[802];</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">int t,n;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line">long long ans;</span><br><span class="line">for(int i=0;i&lt;t;i++)</span><br><span class="line">&#123;</span><br><span class="line">ans=0;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">for(int j=0;j&lt;n;j++)</span><br><span class="line">cin&gt;&gt;a[j];</span><br><span class="line">for(int j=0;j&lt;n;j++)</span><br><span class="line">cin&gt;&gt;b[j];</span><br><span class="line">sort(a,a+n);</span><br><span class="line">sort(b,b+n);</span><br><span class="line">for(int j=0;j&lt;n;j++)</span><br><span class="line">ans+=(a[j]*b[n-j-1]);</span><br><span class="line">cout&lt;&lt;&quot;Case #&quot;&lt;&lt;i+1&lt;&lt;&quot;: &quot;&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Crazy-Rows-GCJ-2009-Round2-A"><a href="#Crazy-Rows-GCJ-2009-Round2-A" class="headerlink" title="Crazy Rows (GCJ 2009 Round2 A)"></a>Crazy Rows (GCJ 2009 Round2 A)</h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述:"></a>描述:</h3><p>只交换相邻行，使得主对角线上方的元素都是0，求最小交换次数。</p><h3 id="题解：-20"><a href="#题解：-20" class="headerlink" title="题解："></a>题解：</h3><p>对于每一行循环，寻找最近的符合条件的，然后交换</p><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code:"></a>Code:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int a[41];</span><br><span class="line">int t,n;</span><br><span class="line">int counter;</span><br><span class="line">void solve(void);</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line">for(int i=0;i&lt;t;i++)</span><br><span class="line">&#123;</span><br><span class="line">solve();</span><br><span class="line">cout&lt;&lt;&quot;Case #&quot;&lt;&lt;i+1&lt;&lt;&quot;: &quot;&lt;&lt;counter&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void solve(void)</span><br><span class="line">&#123;</span><br><span class="line">counter=0;</span><br><span class="line">string s;</span><br><span class="line">int tmp;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">a[i]=-1;</span><br><span class="line">cin&gt;&gt;s;</span><br><span class="line">for(int j=0;j&lt;n;j++)</span><br><span class="line">if(s[j]==&apos;1&apos;)</span><br><span class="line">a[i]=j;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">int pos=-1;</span><br><span class="line">for(int j=i;j&lt;n;j++)</span><br><span class="line">if(a[j]&lt;=i)</span><br><span class="line">&#123;</span><br><span class="line">pos=j;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">for(int j=pos;j&gt;i;j--)</span><br><span class="line">&#123;</span><br><span class="line">tmp=a[j];</span><br><span class="line">a[j]=a[j-1];</span><br><span class="line">a[j-1]=tmp;</span><br><span class="line">counter++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;三角形&quot;&gt;&lt;a href=&quot;#三角形&quot; class=&quot;headerlink&quot; title=&quot;三角形&quot;&gt;&lt;/a&gt;三角形&lt;/h2&gt;&lt;h3 id=&quot;描述：&quot;&gt;&lt;a href=&quot;#描述：&quot; class=&quot;headerlink&quot; title=&quot;描述：&quot;&gt;&lt;/a&gt;描述：&lt;/h3&gt;&lt;p&gt;从一堆绳子中找出三根绳子使得围成的三角形的周长最大。&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="https://ricky-ting.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>数学之美笔记</title>
    <link href="https://ricky-ting.github.io/2018/08/24/%E6%95%B0%E5%AD%A6%E4%B9%8B%E7%BE%8E%E7%AC%94%E8%AE%B0/"/>
    <id>https://ricky-ting.github.io/2018/08/24/数学之美笔记/</id>
    <published>2018-08-24T11:18:55.000Z</published>
    <updated>2018-08-24T11:23:01.987Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数学之美笔记"><a href="#数学之美笔记" class="headerlink" title="数学之美笔记"></a>数学之美笔记</h1><h2 id="一、统计语言模型"><a href="#一、统计语言模型" class="headerlink" title="一、统计语言模型"></a>一、统计语言模型</h2><p>利用数学犯法来解决自然语言处理问题，而非传统的语法分析。基于概率的模型</p><p>P(S)=P(w1)P(w2|w1)P(w3|w1&amp;w2)…P(wn|w1&amp;w2…&amp;wn-1)</p><p>利用马尔可夫假设，可以简化为：</p><p>P(S)=P(w1)P(w2|w1)P(w3|w2)…P(wi|wi-1)</p><a id="more"></a><h2 id="二、谈谈中文分词"><a href="#二、谈谈中文分词" class="headerlink" title="二、谈谈中文分词"></a>二、谈谈中文分词</h2><p>1.查字典法,最大匹配-&gt;最小分割法。但对于二义性无能为力</p><p>2.最大概率分词法。用统计语言模型计算出每种分词后句子出现的概率，并找出其中概率最大的。</p><p>找到复合词的嵌套结构</p><h2 id="三、隐含马尔科夫模型在语言处理中的应用"><a href="#三、隐含马尔科夫模型在语言处理中的应用" class="headerlink" title="三、隐含马尔科夫模型在语言处理中的应用"></a>三、隐含马尔科夫模型在语言处理中的应用</h2><p>(s1 s2 s3)-&gt;(o1 o2 o3)</p><p>求P(s1,s2,s3|o1,o2,o3)最大，利用贝叶斯公式：</p><p>P(o1,o2,o3,…|s1,s3,s3)*P(s1,s2,s3)</p><p>做两个假设：</p><ol><li>s1,s2,s3,..是一个马尔科夫链,即，si只由si-1决定</li><li>第i时刻的接受信号oi只由发送信号si决定,又称独立输出假设,即P(o1,o2,o3..|s1,s2,s3,..)=P(o1|s1)<em> P(o2|s2) </em> P(o3|s3)…</li></ol><h2 id="四、怎么度量信息？"><a href="#四、怎么度量信息？" class="headerlink" title="四、怎么度量信息？"></a>四、怎么度量信息？</h2><p>香农：信息熵。</p><p>一条信息的信息量大小和它的不确定性有直接关系。它越不确定，信息量越大。</p><p>用bit的概念来度量信息量</p><p>$$ H(X)=- \sum_{x}P(x)\log_2[P(x)] $$</p><p>实际信息的表示和信息熵的差距称作”冗余度”(redundancy)</p><h2 id="五、简单之美：布尔代数和搜索引擎的索引"><a href="#五、简单之美：布尔代数和搜索引擎的索引" class="headerlink" title="五、简单之美：布尔代数和搜索引擎的索引"></a>五、简单之美：布尔代数和搜索引擎的索引</h2><p>最简单的索引是用一个很长的二进制数，每一位代表一个关键词，如果有，则为1，否则为0</p><h2 id="六、图论和网络爬虫"><a href="#六、图论和网络爬虫" class="headerlink" title="六、图论和网络爬虫"></a>六、图论和网络爬虫</h2><p>BFS和DFS</p><p>网络爬虫，通过hash来判断是否爬过</p><h2 id="七、信息论在信息处理中的应用"><a href="#七、信息论在信息处理中的应用" class="headerlink" title="七、信息论在信息处理中的应用"></a>七、信息论在信息处理中的应用</h2><p>不确定性越小，模型越好。信息熵可以直接用于衡量统计语言模型的好坏。</p><p>两个概念：“互信息”(Mutual Information)和”相对熵”(Kullback-Leibler Divergence)</p><ul><li>互信息:是对两个随机事件相关性的度量。可以很好地解决二义性</li><li>相对熵：衡量两个正函数是否相似。对于两个完全相同的函数，它们的相对熵等于零。</li></ul><h2 id="八、贾里尼克的故事和现代语言处理"><a href="#八、贾里尼克的故事和现代语言处理" class="headerlink" title="八、贾里尼克的故事和现代语言处理"></a>八、贾里尼克的故事和现代语言处理</h2><h2 id="九、如何确定网页和查询的相关性"><a href="#九、如何确定网页和查询的相关性" class="headerlink" title="九、如何确定网页和查询的相关性"></a>九、如何确定网页和查询的相关性</h2><p>对关键词次数进行归一化(否则长文章占优),即求频次：称为”关键词频率“或“单文本词汇频率”(Term Frequency)</p><p>还有要去除介词等”应删除词”(Stopwords)，</p><p>对不同的关键词给予不同的权重，如专业词比通用词权重高。有下面两个条件：</p><ol><li><p>一个词预测主题能力越强，权重越大，反之越小</p></li><li><p>应删除词权重为零</p></li></ol><p>使用最多的权重是”逆文本频率指数(Inverse document frequency)“: log(D/Dw),D为全部网页数</p><p>所以计算公式为：TF1 <em> IDF1 + TF2 </em> IDF2+.. + TFN * IDFN</p><p>给定查询，网页的综合排名由相关性和网页排名乘积决定</p><p>IDFN的计算公式为什么取log有待学习</p><h2 id="十、有限状态机和地址识别"><a href="#十、有限状态机和地址识别" class="headerlink" title="十、有限状态机和地址识别"></a>十、有限状态机和地址识别</h2><p>类似于时序逻辑里的状态转移</p><p>为了能进行模糊匹配，提出基于概率的有限状态机，和离散的马尔科夫链基本等效</p><h2 id="十二、余弦定理和新闻的分类"><a href="#十二、余弦定理和新闻的分类" class="headerlink" title="十二、余弦定理和新闻的分类"></a>十二、余弦定理和新闻的分类</h2><p>基于TF/IDF，生成新闻的特征向量，用余弦定理计算它们的夹角，计算它们的相似度。</p><p>疑问：关于同义词、近义词是否有很好的映射工具</p><h2 id="十三、信息指纹及其应用"><a href="#十三、信息指纹及其应用" class="headerlink" title="十三、信息指纹及其应用"></a>十三、信息指纹及其应用</h2><p>其实就是hash函数，如MD5,SHA1等</p><h2 id="十四、浅谈数学模型的重要性"><a href="#十四、浅谈数学模型的重要性" class="headerlink" title="十四、浅谈数学模型的重要性"></a>十四、浅谈数学模型的重要性</h2><ol><li>一个正确的数学模型应当在形式上是简单的。</li><li>一个正确的模型在它开始的时候可能还不如一个精雕细琢的错误的模型来的准确，但是，如果我们认定大方向是对的，就应该坚持下去。</li><li>大量准确的数据对研发很重要。</li><li>正确的模型也可能受噪音干扰，而显得不准确：这时我们不应该用一种凑合的修正方法来弥补它，而是要找到噪音的根源，这也许能通往重大发现。</li></ol><h2 id="十六-上-、不要把所有的鸡蛋放在一个篮子里–谈谈最大熵模型"><a href="#十六-上-、不要把所有的鸡蛋放在一个篮子里–谈谈最大熵模型" class="headerlink" title="十六(上)、不要把所有的鸡蛋放在一个篮子里–谈谈最大熵模型"></a>十六(上)、不要把所有的鸡蛋放在一个篮子里–谈谈最大熵模型</h2><p>最大熵原理：要保留全部的不确定性，将风险降到最小。</p><p>最大熵原理指出，当我们需要对一个随机事件的概率分布进行预测时，我们的预测应当满足全部已知的条件，而对未知的情况不要做任何主观假设。</p><p>希萨证明，对任何一组不自相矛盾的信息，这个最大熵模型不仅存在，而且是唯一的，都有同一个非常简单的形式–指数函数。</p><p>$$ P(w3|w1,w2,subject)=\frac{e^{\lambda_1(w1,w2,w3)+\lambda_2(subject,w3)}}{Z(w1,w2,subject)}$$</p><p>$\lambda$ 和 Z需要通过观测数据训练出来。</p><h2 id="十六-下-、不要把所有的鸡蛋放在一个篮子里–最大熵模型"><a href="#十六-下-、不要把所有的鸡蛋放在一个篮子里–最大熵模型" class="headerlink" title="十六(下)、不要把所有的鸡蛋放在一个篮子里–最大熵模型"></a>十六(下)、不要把所有的鸡蛋放在一个篮子里–最大熵模型</h2><p>最原始的最大熵模型的训练方法是一种称为通用迭代算法GIS(Generalized iterative scaling)的迭代算法。分为以下几个步骤</p><ol><li>假定第零次迭代的初始模型为等概率的均匀分布。</li><li>用第N次迭代的模型来估算每种信息特征在训练数据中的分布，如果超过了实际的，就把相应的模型参数变小；否则，将它们变大。</li><li>重复步骤2直到收敛</li></ol><p>实际应用中很少用，只是通过它了解最大熵模型的算法，迭代时间长，次数多，不太稳定，容易溢出</p><p>后来有很多改进工作</p><h2 id="十七、闪光的不一定是金子，谈谈搜索引擎作弊问题-Search-Engine-Anti-SPAM"><a href="#十七、闪光的不一定是金子，谈谈搜索引擎作弊问题-Search-Engine-Anti-SPAM" class="headerlink" title="十七、闪光的不一定是金子，谈谈搜索引擎作弊问题(Search Engine Anti_SPAM)"></a>十七、闪光的不一定是金子，谈谈搜索引擎作弊问题(Search Engine Anti_SPAM)</h2><p>常见作弊方法：增加关键词，创建专门放链接的网站</p><p>相当于声音中加入了噪音，而混入噪音，在数学上相当于两个信号做卷积。噪音消除的过程就是解卷积的过程。</p><h2 id="十八、矩阵运算和文本处理中的分类问题"><a href="#十八、矩阵运算和文本处理中的分类问题" class="headerlink" title="十八、矩阵运算和文本处理中的分类问题"></a>十八、矩阵运算和文本处理中的分类问题</h2><p>分类需要计算相关性，而用内积方法的话，两两配对，计算量很大</p><p>另一种方法是利用矩阵运算中的奇异值分解(Single Value Decomposition 简称SVD)：大矩阵拆分成小矩阵</p><h2 id="十九、马尔科夫链的扩展–贝叶斯网络-Bayesian-Networks"><a href="#十九、马尔科夫链的扩展–贝叶斯网络-Bayesian-Networks" class="headerlink" title="十九、马尔科夫链的扩展–贝叶斯网络(Bayesian Networks)"></a>十九、马尔科夫链的扩展–贝叶斯网络(Bayesian Networks)</h2><p>把有向图看成一个网络，就是贝叶斯网络，每个圆圈代表状态，状态之间的连线表示它们的因果关系。这些关系都有一个可以量化的可信度(belief)</p><p>贝叶斯网络的训练是NP-complete问题。</p><h2 id="二十一、布隆过滤器-Bloom-Filter"><a href="#二十一、布隆过滤器-Bloom-Filter" class="headerlink" title="二十一、布隆过滤器(Bloom Filter)"></a>二十一、布隆过滤器(Bloom Filter)</h2><p>实际上是一个很长的二进制向量和一系列随机映射函数。</p><p>n个随机函数选择位，然后设为1。</p><p>有误判概率</p><h2 id="二十二、由电视剧《暗算》所想到的-谈谈密码学的数学原理"><a href="#二十二、由电视剧《暗算》所想到的-谈谈密码学的数学原理" class="headerlink" title="二十二、由电视剧《暗算》所想到的-谈谈密码学的数学原理"></a>二十二、由电视剧《暗算》所想到的-谈谈密码学的数学原理</h2><p>RSA加密</p><h2 id="二十三、输入一个汉字需要敲多少个键——谈谈香农第一定律"><a href="#二十三、输入一个汉字需要敲多少个键——谈谈香农第一定律" class="headerlink" title="二十三、输入一个汉字需要敲多少个键——谈谈香农第一定律"></a>二十三、输入一个汉字需要敲多少个键——谈谈香农第一定律</h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数学之美笔记&quot;&gt;&lt;a href=&quot;#数学之美笔记&quot; class=&quot;headerlink&quot; title=&quot;数学之美笔记&quot;&gt;&lt;/a&gt;数学之美笔记&lt;/h1&gt;&lt;h2 id=&quot;一、统计语言模型&quot;&gt;&lt;a href=&quot;#一、统计语言模型&quot; class=&quot;headerlink&quot; title=&quot;一、统计语言模型&quot;&gt;&lt;/a&gt;一、统计语言模型&lt;/h2&gt;&lt;p&gt;利用数学犯法来解决自然语言处理问题，而非传统的语法分析。基于概率的模型&lt;/p&gt;
&lt;p&gt;P(S)=P(w1)P(w2|w1)P(w3|w1&amp;amp;w2)…P(wn|w1&amp;amp;w2…&amp;amp;wn-1)&lt;/p&gt;
&lt;p&gt;利用马尔可夫假设，可以简化为：&lt;/p&gt;
&lt;p&gt;P(S)=P(w1)P(w2|w1)P(w3|w2)…P(wi|wi-1)&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="https://ricky-ting.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>插入代码注意事项</title>
    <link href="https://ricky-ting.github.io/2018/08/03/%E6%8F%92%E5%85%A5%E4%BB%A3%E7%A0%81%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <id>https://ricky-ting.github.io/2018/08/03/插入代码注意事项/</id>
    <published>2018-08-03T08:26:43.000Z</published>
    <updated>2018-08-03T08:28:36.810Z</updated>
    
    <content type="html"><![CDATA[<p>开启mathjax后排版混乱，本来以为是mathjax的锅，后发现```之后多加了一个空格。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;开启mathjax后排版混乱，本来以为是mathjax的锅，后发现```之后多加了一个空格。&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="bug" scheme="https://ricky-ting.github.io/tags/bug/"/>
    
  </entry>
  
  <entry>
    <title>2018 Spring Problem Solving 2</title>
    <link href="https://ricky-ting.github.io/2018/07/08/2018-Spring-Problem-Solving-2/"/>
    <id>https://ricky-ting.github.io/2018/07/08/2018-Spring-Problem-Solving-2/</id>
    <published>2018-07-08T01:12:08.000Z</published>
    <updated>2018-08-03T08:25:50.174Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2018春问题求解笔记"><a href="#2018春问题求解笔记" class="headerlink" title="2018春问题求解笔记"></a>2018春问题求解笔记</h1><h2 id="2-1-算法正确性-2018-3-7"><a href="#2-1-算法正确性-2018-3-7" class="headerlink" title="2-1 算法正确性(2018.3.7)"></a>2-1 算法正确性(2018.3.7)</h2><p>程序和算法不等同</p><p>算法正确性是基础</p> <a id="more"></a><p>“Program testing can be used to show the presence of bugs, but never to show their absence!”</p><p>封闭环境内同一个输入会产生同样的错误，但网络环境以及并行下不一定。错误的难重现</p><p>部分正确性(if terminates)和完全正确性(indeed terminates)</p><p>循环不变式</p><p>show converge</p><p>assertion和checkpoint：我们可以在算法的任意位置，设置assertion，这个“位置”就是check point</p><p>证明就是断言的序列</p><p>一条链</p><p>递归：数学归纳法</p><p>证明多个变量的数学归纳法：$\forall$ m, 对n做归纳</p><h3 id="习题讲解-2018-3-12"><a href="#习题讲解-2018-3-12" class="headerlink" title="习题讲解(2018.3.12)"></a>习题讲解(2018.3.12)</h3><p>totalwork = workdone + worktodo</p><p>(1)-&gt;(2)-&gt;(2’)-&gt;(3)-&gt;(4)</p><h3 id="open-topic"><a href="#open-topic" class="headerlink" title="open topic"></a>open topic</h3><h4 id="1-证明插入排序的完全正确性"><a href="#1-证明插入排序的完全正确性" class="headerlink" title="1.证明插入排序的完全正确性"></a>1.证明插入排序的完全正确性</h4><p>两层循环 内层 外层</p><h4 id="2-证明旋转汉诺塔的完全正确性"><a href="#2-证明旋转汉诺塔的完全正确性" class="headerlink" title="2.证明旋转汉诺塔的完全正确性"></a>2.证明旋转汉诺塔的完全正确性</h4><p>状态数 操作数：操作数&gt;状态数，则非最优解</p><h2 id="2-2-算法的效率"><a href="#2-2-算法的效率" class="headerlink" title="2-2 算法的效率"></a>2-2 算法的效率</h2><h3 id="open-topic-1"><a href="#open-topic-1" class="headerlink" title="open topic"></a>open topic</h3><h4 id="Algorithmic-Gap"><a href="#Algorithmic-Gap" class="headerlink" title="Algorithmic Gap"></a>Algorithmic Gap</h4><p>Decision Tree</p><p>Adversary Argument</p><h2 id="2-3-组合与计数"><a href="#2-3-组合与计数" class="headerlink" title="2-3 组合与计数"></a>2-3 组合与计数</h2><p>计数在算法分析中很重要</p><p>抽象</p><p>加法原理 乘法原理</p><p>kth falling factorial power of n</p><p>Pascal’s triangle</p><p>Pascal relationship</p><p>multiset：放入k个后取</p><p>等价关系用于计数 等价类 商集</p><h2 id="2-4-分治法与递归"><a href="#2-4-分治法与递归" class="headerlink" title="2-4 分治法与递归"></a>2-4 分治法与递归</h2><p>Divide-and-Conquer: 3steps(Divid -&gt; Conquer -&gt; Combine)</p><p>递归中subproblem出现的两种case:recursive case, base case</p><h3 id="three-methods-for-solving-recurrences"><a href="#three-methods-for-solving-recurrences" class="headerlink" title="three methods for solving recurrences:"></a>three methods for solving recurrences:</h3><ul><li>substitution method</li><li>recursion-tree method</li><li>master method</li></ul><h3 id="maximum-subarray-problem"><a href="#maximum-subarray-problem" class="headerlink" title="maximum-subarray problem"></a>maximum-subarray problem</h3><p>consider the daily change in price</p><p>divide-and-conquer解法: 把序列一分为二，然后最长的有三种情况，全在左边一半，全在右边一半，横跨中点。然后重点如何处理第三种情况，在中点向两边分别找，然后合并。复杂度为O(nlogn).</p><p>有O(n)算法 类似于DP</p><h3 id="Strassen’s-algorithm-for-matrix-multiplication"><a href="#Strassen’s-algorithm-for-matrix-multiplication" class="headerlink" title="Strassen’s algorithm for matrix multiplication"></a>Strassen’s algorithm for matrix multiplication</h3><p>$O(n^3) -&gt; O(n^{2.81})[O(n^{lg7})]$</p><h3 id="substituition-method"><a href="#substituition-method" class="headerlink" title="substituition method"></a>substituition method</h3><p>Guess and then prove. Mathematical Induction.</p><ol><li>Guess the form of the solution.</li><li>Use mathemarical induction to find the constants and show that the solution works.</li></ol><p>一些证明中的小技巧:改变起始项，更换变量</p><h3 id="Recursion-tree-method"><a href="#Recursion-tree-method" class="headerlink" title="Recursion-tree method"></a>Recursion-tree method</h3><p>A recursion-tree is best used to generate a good guess.</p><p>Analyse and then sum.</p><h3 id="master-method"><a href="#master-method" class="headerlink" title="master method"></a>master method</h3><p>prove</p><p>为什么分治法能降低时间复杂度？</p><h2 id="2-5-递归及其数学基础"><a href="#2-5-递归及其数学基础" class="headerlink" title="2-5 递归及其数学基础"></a>2-5 递归及其数学基础</h2><p>求解精确解</p><h3 id="Mathematical-Induction"><a href="#Mathematical-Induction" class="headerlink" title="Mathematical Induction"></a>Mathematical Induction</h3><ul><li>base case  </li><li>inductive hypothesis</li><li>inductive step</li><li>inductive conclusion</li></ul><p>The terms weak and strong arise from what is assumed in the inductive hypothesis. Adding more restrictions strengthens an assertion, while removing restrictions weakens the assertion</p><p>recursion和mathematical induction有密切联系<br>一个自上而下(分解问题) 一个自下而上(组合问题)</p><p>structural induction</p><p>triangulated polygon<br>Ear Lemma</p><p>等比数列</p><p>ﬁrst-order linear recurrence ：T(n) = f (n)T(n − 1) + g(n)</p><p>巧用微积分知识</p><p>解一阶线性：直接展开</p><p>解线性齐次：解特征方程</p><h2 id="2-6-算法方法"><a href="#2-6-算法方法" class="headerlink" title="2-6 算法方法"></a>2-6 算法方法</h2><p>问题求解：压缩解空间</p><p>Maximal Polygon Distance问题</p><p>Minimal Spanning Tree</p><p>Greedy DP(本质上还是穷竭搜索 但空间换时间)</p><p>DFS BFS</p><p>Bin packing NPC问题</p><h2 id="2-7-离散概率"><a href="#2-7-离散概率" class="headerlink" title="2-7 离散概率"></a>2-7 离散概率</h2><p>Complementary Probabilities</p><p>The Uniform Probability Distribution</p><p>(Principle of Inclusion and Exclusion for Probability)<br>Proof1: 算P(x)的系数 用二项式定理 Proof2:待理解</p><p>Conditional probability: P(E|F)=P(E \cap F) / P(F) [P(E|F)=P(E) when P(F)=0]</p><p>We say E is independent of F if P(E|F) = P(E). 我认为P(E|F)不是由公式导出的。存疑</p><p><strong>Bayes’ Theorem</strong>：P(E|F)P(F) = P(F|E)P(E).</p><p>product principle for independent probabilities: P(E \cap F) = P(E)P(F)</p><p>independent trials process</p><p>our model of hashing is an independent trials process.</p><p>probability tree</p><p>A random variable for an experiment with a sample space S is a function that assigns a number to each element of S.</p><p>Bernoulli trials process</p><p>expected value</p><p>indicator random variable</p><p>The Number of Trials until the First Success</p><p>指示器随机变量提供了一个便利的工具实现事件A发生的概率和期望之间的转换：求某个随机变量的期望往往可以简化为若干个和该随机变量相关的事件的概率之和</p><h2 id="2-8-概率分析与随机化算法"><a href="#2-8-概率分析与随机化算法" class="headerlink" title="2-8 概率分析与随机化算法"></a>2-8 概率分析与随机化算法</h2><p>conditional expected value</p><p>Randomized Algorithms</p><p>Quicksort分析</p><p>normal curve</p><p>variance</p><p>Central limit theorem.</p><p>normal distribution</p><h2 id="2-9-排序与选择"><a href="#2-9-排序与选择" class="headerlink" title="2-9 排序与选择"></a>2-9 排序与选择</h2><p>The Coupon Collector’s Problem</p><p>$n log n + (m-1)nloglogn + nC_m + o(n), n \rightarrow \infty, m fixed$</p><p>Tony Hoare: Quicksort, Hoare Logic: {P}S{Q}, null pointer “I call it my billion-dollar mistake”.</p><p>证明下界：1. decision tree 2. adversary strategy</p><p>Adversary Argument：证下界</p><p>检测01、同时找最大最小、找第二小，k=3 is still open， 找中间值</p><h2 id="2-10-基本数据结构"><a href="#2-10-基本数据结构" class="headerlink" title="2-10 基本数据结构"></a>2-10 基本数据结构</h2><p>tail指向最后一个元素的后一个 为什么</p><p>Why Numbering Should Start at Zero(EWD831)</p><h2 id="2-11-堆与堆排序"><a href="#2-11-堆与堆排序" class="headerlink" title="2-11 堆与堆排序"></a>2-11 堆与堆排序</h2><h2 id="2-12-Hashing方法"><a href="#2-12-Hashing方法" class="headerlink" title="2-12 Hashing方法"></a>2-12 Hashing方法</h2><h2 id="2-13-搜索树"><a href="#2-13-搜索树" class="headerlink" title="2-13 搜索树"></a>2-13 搜索树</h2><p>A tree is a recursive abstract data type</p><h3 id="Binary-Search-Tree"><a href="#Binary-Search-Tree" class="headerlink" title="Binary Search Tree"></a>Binary Search Tree</h3><p>Operations: Search(用while), Minimum(当子节点不为nil一直下去), Maximum, Predecessor(分两种情况:有右子树 无右子树), Successor, Insert and Delete(分三种情况).  Transplant(不管子节点)</p><p>The expected height of a randomly built binary search tree is $O(\lg{n})$.</p><p>B-trees are particularly good for maintaining databases on secondary(disk) storage</p><h4 id="Binary-search-tree-property"><a href="#Binary-search-tree-property" class="headerlink" title="Binary-search-tree property"></a>Binary-search-tree property</h4><p> If y is a node of left subtree of x, then $y.key \le x.key$.</p><p> If x is a node of right subtree of x, then $y.key \ge x.key$</p><h4 id="tree-walk"><a href="#tree-walk" class="headerlink" title="tree walk"></a>tree walk</h4><p>inorder tree walk   Inorder-tree-walk(T.root)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">INORDER-TREE-WALK(x)</span><br><span class="line">if x!=NIL</span><br><span class="line">INORDER-TREE-WALK(x.left)</span><br><span class="line">print x.key</span><br><span class="line">INORDER-TREE-WALK(x.right)</span><br></pre></td></tr></table></figure><p>如何证明其正确性<br>效率$\Theta(n) 用master直观 用替代法证明$</p><p>preorder tree walk</p><p>postorder tree walk.</p><h4 id="Tree-Search-and-Tree-Insert"><a href="#Tree-Search-and-Tree-Insert" class="headerlink" title="Tree-Search and Tree-Insert"></a>Tree-Search and Tree-Insert</h4><h4 id="Minimum-and-maximum"><a href="#Minimum-and-maximum" class="headerlink" title="Minimum and maximum"></a>Minimum and maximum</h4><h4 id="Successor-and-Predecessor"><a href="#Successor-and-Predecessor" class="headerlink" title="Successor and Predecessor"></a>Successor and Predecessor</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Tree-Successor(x)</span><br><span class="line">if x.right!=NIL</span><br><span class="line">return Tree-Minimum(x.right)</span><br><span class="line">y=x.p</span><br><span class="line">while y!=NIL &amp;&amp; x=y.right</span><br><span class="line">x=y</span><br><span class="line">y=x.p</span><br><span class="line">return y</span><br></pre></td></tr></table></figure><h4 id="Insertion-and-Deletion"><a href="#Insertion-and-Deletion" class="headerlink" title="Insertion and Deletion"></a>Insertion and Deletion</h4><p>插入找空位就可</p><p>删除分三种情况：没有孩子(直接删除)、有一个孩子(直接登基)、有两个孩子(找后继)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Transplant(T,u,v)</span><br><span class="line">if u.p==NIL</span><br><span class="line">T.root=v</span><br><span class="line">elseif u==u.p.left</span><br><span class="line">u.p.left=v</span><br><span class="line">else</span><br><span class="line">u.p.right=v</span><br><span class="line">if v!=NIL</span><br><span class="line">v.p=u.p</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Tree-Delete(T,z)</span><br><span class="line">if z.left==NIL</span><br><span class="line">Transplant(T,z,z.right)</span><br><span class="line">elseif z.right==NIL</span><br><span class="line">Transplant(T,z,z.left)</span><br><span class="line">else</span><br><span class="line">y=Tree-Minimum(z.right)</span><br><span class="line">if y.p!=z</span><br><span class="line">Transplant(T,y,y.right)</span><br><span class="line">y.right=z.right</span><br><span class="line">y.right.p=y</span><br><span class="line">Transplant(T,z,y)</span><br><span class="line">y.left=z.left</span><br><span class="line">y.left.p=y</span><br></pre></td></tr></table></figure><h3 id="Red-Black-Tree"><a href="#Red-Black-Tree" class="headerlink" title="Red Black Tree"></a>Red Black Tree</h3><h4 id="red-black-properties"><a href="#red-black-properties" class="headerlink" title="red-black properties"></a>red-black properties</h4><ol><li>Every node is either red or black</li><li>The root is black</li><li>Every leaf(NIL) is black</li><li>If a node is red, then both its children are black.</li><li>For each node, all simple paths from the node to descendant leaves contain the same number of black nodes.</li></ol><p>A red-black tree with n internal nodes has height at most $2\lg{n+1}$</p><h4 id="Rotations"><a href="#Rotations" class="headerlink" title="Rotations"></a>Rotations</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Left-Rotate(T,x)</span><br><span class="line">y=x.right</span><br><span class="line">x.right=y.left</span><br><span class="line">if y.left!=T.nil</span><br><span class="line">y.left.p=x</span><br><span class="line">y.p=x.p</span><br><span class="line">if x.p==T.nil</span><br><span class="line">T.root=y</span><br><span class="line">elseif x==x.p.left</span><br><span class="line">x.p.left=y</span><br><span class="line">else</span><br><span class="line">x.p.right=y</span><br><span class="line">y.left=x</span><br><span class="line">x.p=y</span><br></pre></td></tr></table></figure><p>In every n-node binary search tree, there are exactly n-1 possible rotations.</p><h4 id="Insertion"><a href="#Insertion" class="headerlink" title="Insertion"></a>Insertion</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">RB-INSERT(T,z)</span><br><span class="line">y=T.nil</span><br><span class="line">x=T.root</span><br><span class="line">while x!=T.nil</span><br><span class="line">y=x</span><br><span class="line">if z.key&lt;x.key</span><br><span class="line">x=x.left</span><br><span class="line">else x=x.right</span><br><span class="line">z.p=y</span><br><span class="line">if y==T.nil</span><br><span class="line">T.root=z</span><br><span class="line">elseif z.key&lt;y.key</span><br><span class="line">y.left=z</span><br><span class="line">else y.right=z</span><br><span class="line">z.left=T.nil</span><br><span class="line">z.right=T.nil</span><br><span class="line">z.color = RED</span><br><span class="line">RB-INSERT-FIXUP(T,z)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">RB-INSERT-FIXUP(T,z)</span><br><span class="line">while z.p.color==RED</span><br><span class="line">if z.p==z.p.p.left</span><br><span class="line">y=z.p.p.right</span><br><span class="line">if y.color==RED</span><br><span class="line">z.p.color=BLACK//case1</span><br><span class="line">y.color=BLACK//case1</span><br><span class="line">z.p.p.color=RED//case1</span><br><span class="line">z=z.p.p//case1</span><br><span class="line">else if z==z.p.right</span><br><span class="line">z=z.p//case2</span><br><span class="line">LEFT-ROTATE(T,z)//case2</span><br><span class="line">z.p.color=BLACK//case3</span><br><span class="line">z.p.p.color=RED//case3</span><br><span class="line">RIGHT-ROTATE(T,z.p.p)//case3</span><br><span class="line">else (same as then clause with &quot;right&quot; and &quot;left&quot; exchanged) </span><br><span class="line">T.root.color=BLACK</span><br></pre></td></tr></table></figure><h2 id="2-14-B树"><a href="#2-14-B树" class="headerlink" title="2-14 B树"></a>2-14 B树</h2><h2 id="Appendix-C"><a href="#Appendix-C" class="headerlink" title="Appendix C"></a>Appendix C</h2><p>Binomial bounds: C_n^k &gt;= (n/k)^k</p><p>对于自然数集N: <code>E[X]=\sum_{i=0}^{\infty} i*Pr{X=i} =\sum_{i=0}^{\infty} i*(Pr{X&gt;=i}-Pr{X&gt;=i+1}) = \sum_{i=1}^{\infty} Pr{X&gt;=i}</code></p><p>Var[X]=E[X^2]-E^2[X]</p><p>Var[aX]=a^2Var[X]</p><p>Var[X+Y]=Var[X]+Var[Y]</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;2018春问题求解笔记&quot;&gt;&lt;a href=&quot;#2018春问题求解笔记&quot; class=&quot;headerlink&quot; title=&quot;2018春问题求解笔记&quot;&gt;&lt;/a&gt;2018春问题求解笔记&lt;/h1&gt;&lt;h2 id=&quot;2-1-算法正确性-2018-3-7&quot;&gt;&lt;a href=&quot;#2-1-算法正确性-2018-3-7&quot; class=&quot;headerlink&quot; title=&quot;2-1 算法正确性(2018.3.7)&quot;&gt;&lt;/a&gt;2-1 算法正确性(2018.3.7)&lt;/h2&gt;&lt;p&gt;程序和算法不等同&lt;/p&gt;
&lt;p&gt;算法正确性是基础&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="https://ricky-ting.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>数字逻辑电路笔记</title>
    <link href="https://ricky-ting.github.io/2018/07/01/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E7%AC%94%E8%AE%B0/"/>
    <id>https://ricky-ting.github.io/2018/07/01/数字逻辑电路笔记/</id>
    <published>2018-07-01T04:55:38.000Z</published>
    <updated>2018-07-01T04:57:25.983Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数字逻辑电路笔记"><a href="#数字逻辑电路笔记" class="headerlink" title="数字逻辑电路笔记"></a>数字逻辑电路笔记</h1><p>给定输入 给出输出 用布尔逻辑实现</p><p>晶体管的开关特性是数字电路研究的重点。</p><p>数字逻辑中考虑电路模拟的特性，如时延问题。</p><p>数字设计中一些层次问题</p> <a id="more"></a><p>数字电路特性：</p><ul><li>稳定性好</li><li>速度快</li><li>集成度高且成本低</li><li>设计容易、功能灵活</li><li>可编程性</li></ul><p>模数转换：取样、量化 数模转换：合成</p><p>传输门？？？</p><p>摩尔定律即电子定律：集成电路的集成度每18个月翻一番（1965年）</p><p>超摩尔定律即光子定律：光纤传输的数据总量每9个月翻一番；</p><p>迈特卡夫Metcalfe定律：网络的价值与联网设备数（用户数）的平方关系成正比</p><p>时序逻辑 组合逻辑</p><h2 id="数制与编码"><a href="#数制与编码" class="headerlink" title="数制与编码"></a>数制与编码</h2><p>按位计数制(positional number system):加权</p><p>二进制八进制互转，二进制十六进制互转。</p><p>十进制转任意进制，任意进制转十进制。</p><p>除以基数去余法：倒序。 乘基数取整法：正序(到fraction为0，或达到最大有效位数)</p><h3 id="通用转换过程："><a href="#通用转换过程：" class="headerlink" title="通用转换过程："></a>通用转换过程：</h3><h4 id="算法1："><a href="#算法1：" class="headerlink" title="算法1："></a>算法1：</h4><p>A进制数N转换成B进制数。</p><ul><li>(a) 用B进制数取代展开序列中的数字，并计算结果，或</li><li>(b) 基于A进制运算，计算B基数的乘除法。</li></ul><h4 id="算法2："><a href="#算法2：" class="headerlink" title="算法2："></a>算法2：</h4><p>A进制数N转换成B进制数。</p><ul><li>(a) 用序列替代法将A进制数转换成10进制。</li><li>(b) 用基数乘除法，将10进制数转换成B进制数。</li></ul><p>各种数制之间的表达能力不一样，是否存在最强表达能力的数制？</p><p>符号位+数值的表示法，正数和负数个数相同，0有两个表示，但电路设计复杂。但一旦做了加法器，减法器就不用再做了。</p><p><strong>补码等于反码加1的证明</strong>：写成 反码=补码-1</p><p>补码 两次取补仍为原数 减去或取反加1 最高位权为负 符号扩展：将符号位扩展(如果是0，全补0，如果是1，全补1) 如果减小位数 从左边减，丢弃的位要与符号位相同。正数表示。</p><p>补码下： -2-(-8) 还是成立的  会不会判溢出？？？？</p><p>反码 ：    取反。对称和易于求反。</p><p>余码: 除符号位相反，对任何数，补码和余码两种表示法中的其他位都是一样的(仅适用于偏离为$2^{m-1}$的情况)。余码表示常用在浮点数系统中。余码表示用在浮点数系统中指数的表示。</p><h3 id="二进制补码的加法与减法"><a href="#二进制补码的加法与减法" class="headerlink" title="二进制补码的加法与减法"></a>二进制补码的加法与减法</h3><h4 id="加法："><a href="#加法：" class="headerlink" title="加法："></a>加法：</h4><p>忽略超过MSB的进位，只要不超过计数系统的范围，该结果就总是正确的和。</p><p>加法中有简便的规则判断溢出：如果加数的符号相同，而和的符号与加数的符号不同，则有加法的溢出。 不同符号的加数不会溢出</p><h4 id="减法："><a href="#减法：" class="headerlink" title="减法："></a>减法：</h4><p>减数取反，初始进位为1</p><h3 id="二进制反码的加法和减法"><a href="#二进制反码的加法和减法" class="headerlink" title="二进制反码的加法和减法"></a>二进制反码的加法和减法</h3><p>计数经过$1111_2$时要额外多加一个1. 循环进位(end-around carry).即符号位有进位则+1</p><p>溢出判断：异号相加不溢出，同号相加结果异号则溢出。或进位和符号位不一致。</p><h3 id="二进制补码的乘法"><a href="#二进制补码的乘法" class="headerlink" title="二进制补码的乘法"></a>二进制补码的乘法</h3><p>要在每一步做符号位扩展，最高位的权为负</p><h3 id="二进制补码的除法？？？"><a href="#二进制补码的除法？？？" class="headerlink" title="二进制补码的除法？？？"></a>二进制补码的除法？？？</h3><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><p>{对象集，码字集，编码方案}</p><h3 id="十进制数的二进制编码"><a href="#十进制数的二进制编码" class="headerlink" title="十进制数的二进制编码"></a>十进制数的二进制编码</h3><p>BCD编码又称8421码</p><p>加法需要修正：超过1001需要修正 要加6</p><p>2421码，是自反码。</p><p>余3码，也是自反码：BCD码+0011</p><p>二五混合码(biquinary code)</p><p>10中取1码(1-out-of-10 code)</p><h3 id="格雷码-Gray-code"><a href="#格雷码-Gray-code" class="headerlink" title="格雷码(Gray code)"></a>格雷码(Gray code)</h3><p>1) 镜像法: 1位格雷码有2个码字：0  1,<br>N+1位格雷码中的前$2^N$个码字是N位格雷码顺序排列，且前面加0。<br>N+1位格雷码中的后$2^N$个码字是N位格雷码逆序排列，且前面加1</p><p>2）相邻异或法: N位二进制数字从右向左，从0到n-1编号；<br>如果第i位和第i+1位相同，则对应格雷码的第i位为0，否则为1。</p><p>编码:{对象集，码字集，编码方案}</p><h3 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h3><p>ASCII</p><h3 id="动作、条件和状态的编码"><a href="#动作、条件和状态的编码" class="headerlink" title="动作、条件和状态的编码"></a>动作、条件和状态的编码</h3><p>n中取1码，n中取m码</p><h3 id="n维体与距离"><a href="#n维体与距离" class="headerlink" title="n维体与距离"></a>n维体与距离</h3><p>寻找Gray code即寻找一条遍历所有点的路径。</p><p>汉明距离(Hamming distance)</p><p>n维体的m维子集(m-subcube)</p><h3 id="检错码和纠错码"><a href="#检错码和纠错码" class="headerlink" title="检错码和纠错码"></a>检错码和纠错码</h3><p>差错模式(error model) 独立差错模式(independent error model):单一物理故障只影响单一的数据位。</p><h4 id="检错码-error-detecting-code"><a href="#检错码-error-detecting-code" class="headerlink" title="检错码(error-detecting code)"></a>检错码(error-detecting code)</h4><p>最小汉明距离$ge$2</p><p>奇偶校验位(parity bit)</p><h4 id="纠错码与多重检错码"><a href="#纠错码与多重检错码" class="headerlink" title="纠错码与多重检错码"></a>纠错码与多重检错码</h4><p>待看课件 不理解 ？？？<br>纠错准则？</p><h4 id="汉明码"><a href="#汉明码" class="headerlink" title="汉明码"></a>汉明码</h4><p>纠1位错 判两位错</p><p>位置是2的幂的那些位都是校验位，其余为信息位。校验矩阵(parity-check matrix) </p><p>偶校验</p><p>最小距离为3的编码</p><p>对于任意i值，可产生2^i-1位的编码，其中包含i个校验位，2^i-i-1个信息位。</p><p>信息位长度D增加时，检验位长度P增长缓慢: 2^P &gt;= P+D+1</p><h4 id="循环冗余校验码-cyclic-redundancy-check-CRC"><a href="#循环冗余校验码-cyclic-redundancy-check-CRC" class="headerlink" title="循环冗余校验码(cyclic-redundancy-check,CRC)"></a>循环冗余校验码(cyclic-redundancy-check,CRC)</h4><p>两个重要的应用是磁盘驱动器和数据网络</p><h4 id="二维码-two-dimensional-code"><a href="#二维码-two-dimensional-code" class="headerlink" title="二维码(two-dimensional code)"></a>二维码(two-dimensional code)</h4><p>一个重要的应用是用在RAID储存系统中。RAID表示(redundant array of inexpensive disks)</p><p>BCD加法减法</p><p>每个位元出现在传输线上的实际信号格式取决于线路码（line code）。</p><h4 id="校验和码"><a href="#校验和码" class="headerlink" title="校验和码"></a>校验和码</h4><h3 id="补充：变长编码-待拓展？？？"><a href="#补充：变长编码-待拓展？？？" class="headerlink" title="补充：变长编码 待拓展？？？"></a>补充：变长编码 待拓展？？？</h3><p>原理：基于概率分布特性,采用可变字长编码.</p><p>Huffman编码：</p><ul><li>每个编码均非其它码的前缀，因此唯一可译</li><li>简单,易实现</li><li>编码效率较高(但还不是最高的，参考JPEG)</li></ul><h2 id="组合逻辑设计原理"><a href="#组合逻辑设计原理" class="headerlink" title="组合逻辑设计原理"></a>组合逻辑设计原理</h2><h3 id="布尔代数"><a href="#布尔代数" class="headerlink" title="布尔代数"></a>布尔代数</h3><p>一致律(冗余项): XY+X’Z+YZ=XY+X’Z  (X+Y)(X’+Z)(Y+Z)=(X+Y)(X’+Z)</p><p>1.代入定理：所谓代入定理，是指在逻辑等式中任何一个变量A，都可以用任意逻辑表达式代入，则等式仍然成立。</p><p>2.反演定理：所谓反演定理，是指对于任意一个逻辑式Y，若将其中所有的“·”与“+”互换，“0”和“1”互换，原变量与反变量互换，则得到的结果就是原函数的反函数  Y’  。</p><p>3.对偶定理： 若两逻辑式相等，则它们的对偶式也相等，这就是对偶定理。所谓对偶式，即：对于任何一个逻辑式Y，若将其中的“·”与“+”互换，“0”和“1”互换，则得到Y的对偶式YD，或者Y与YD互为对偶式。？？？？？？</p><p>逻辑函数化简基本方法：</p><ul><li>并项法: AB+A’B=B</li><li>吸收法: AB+B=B</li><li>消去法: A+A’B=A+B</li><li>配项法: AB+A’C+BC=AB+A’C</li><li>摩根定理</li></ul><h3 id="组合逻辑"><a href="#组合逻辑" class="headerlink" title="组合逻辑"></a>组合逻辑</h3><p>逻辑电路分为两大类：“组合的”和“时序的”. 组合逻辑电路(combinational logic circuit) 和 时序逻辑电路(sequential logic circuit)。</p><p>电路的分析和设计</p><p>正逻辑和负逻辑</p><p>完备归纳法(perfect induction)</p><p>一致性定理有两个重要的应用:在组合逻辑电路中，它可以用来去掉某些定时冒险;也是用于寻找主蕴涵项的迭代一致法的基础。</p><p>与非=非或,可以用CMOS直接实现</p><p>对偶性原理：可以运用对偶性原理证明广义德摩根定理。（待加深 P135）</p><p>逻辑函数的标准表示法：</p><ul><li>文字(literal): 一个自变量或反变量</li><li>乘积项(product term):单个文字或2个以上文字的逻辑积</li><li>“积之和”表达式(sum-of-products expression):是乘积项的逻辑和</li><li>求和项(sum term):单个文字或2个以上文字的逻辑和</li><li>“和之积”表达式(product-of-sum expression):求和项的逻辑积</li><li>标准项(normal term):是一个乘积项或求和项，每个变量当且仅当只出现一次</li><li>n变量最小项(minterm):是具有n个文字的标准乘积项</li><li>n变量最大项(maxterm):是具有n个文字的标准求和项</li><li>主蕴含项</li><li>质主蕴含项</li><li>奇异1：只被单一主蕴含项覆盖的输入组合</li></ul><p>和之积表达式？？？？</p><p>相同变量相同编号的最小项和最大项互为反函数。</p><p>时延问题</p><p>多类门技术中，类似与非门和或非门那样的带取反的门比不取反的门要快。</p><p>证明反演定理，曾考过？？？？ 反演定理是否是对偶定理的一个推论</p><p>ASIC设计和PLD设计中，化简都很重要</p><p>考试可能栽在配项法</p><p>电路分析最后一步：通常情况下描述电路的功能：投票电路，校验电路，加法器</p><p>设计：一般</p><h4 id="卡诺图化简："><a href="#卡诺图化简：" class="headerlink" title="卡诺图化简："></a>卡诺图化简：</h4><ul><li>如何化简逻辑函数——最小化： (主蕴涵项)定理：最简“积之和”是主蕴涵项之和(为什么不是质主蕴含项的和)</li><li>蕴涵项： 任何积项都称为蕴涵项，与卡诺图中的圈对应</li><li>主蕴含项：定义若逻辑函数的积项P再也不能同其它积项合并以组成变量个数更少的积项，则称P为主蕴涵项，对应卡诺图中最大的圈</li><li>质主蕴涵项： 定义：不能被其它蕴涵项代替的主蕴涵项；至少包含一个不能被其它任何主蕴涵项所覆盖的最小项</li><li>覆盖：若逻辑函数的所有最小项被1组蕴涵项所包含，则该组蕴涵项称为函数的1个覆盖</li><li>最小覆盖： 是1个包含最少主蕴涵项和最少符号数的覆盖</li></ul><p>奎因——穆克鲁斯基算法(Quine-McCluskey algorithm)</p><h3 id="定时冒险"><a href="#定时冒险" class="headerlink" title="定时冒险"></a>定时冒险</h3><p>一个信号，以两种形式出现在输出端，因传输时间不同，使二者某段时间不具有相应逻辑关系，造成错误输出，称为冒险或险象（ Hazard ）</p><p>竞争：门电路的两个输入端同时向相反的逻辑电平跳变。</p><h4 id="静态冒险"><a href="#静态冒险" class="headerlink" title="静态冒险"></a>静态冒险</h4><p>静态冒险(Static hazard) ：一个周期内，输出只出现一次瞬时改变。</p><p>静态-1型冒险：在输出1的过程中，出现0尖峰。通常产生于最小项生成电路中</p><p>静态-0型冒险：通常产生于最大项生成电路中</p><p>利用卡诺图发现静态冒险：卡诺图检测：在卡诺图中存在两个质主蕴涵项相切，当从一个质主蕴涵项向另一个转换时，一旦有传递延迟，则产生险态。</p><p>消除冒险：添加一致项consensus:增加新的质蕴涵项，覆盖相切的两个质蕴涵。</p><p>动态冒险：一个输入转变一次而引起输出变化多次。由于多个不同的延迟路径所产生。</p><p>2、3、4变量的卡诺图：不断翻折    </p><h3 id="无关项处理"><a href="#无关项处理" class="headerlink" title="无关项处理"></a>无关项处理</h3><p>禁止态检测电路通常是必须的, 若不影响电路运行,此时可不必刻意区分禁止态和其它状态，可以处理成0，也可以处理成1，按照化简的需要酌情确定。</p><h3 id="QM算法"><a href="#QM算法" class="headerlink" title="QM算法"></a>QM算法</h3><h2 id="组合逻辑设计实践"><a href="#组合逻辑设计实践" class="headerlink" title="组合逻辑设计实践"></a>组合逻辑设计实践</h2><p>有时要求输入变量只能用原变量形式，可作相应的变换</p><h3 id="设计文档"><a href="#设计文档" class="headerlink" title="设计文档"></a>设计文档</h3><p>设计文档是项目设计正确、可维护的重要基础。</p><p>设计文档可以是综合性的单文档描述，也可以是分列的多文档描述形态。</p><ul><li>规格说明书：准确描述电路或系统的输入、输出及功能。主要是外部特性的描述。</li><li>方框图：系统主要功能模块及其基本互连的非正式图示描述。展示系统的输入、输出，功能模块、内部数据通路和重要的控制信号</li><li>原理图：系统的电气元件、元件间互连和构建系统所需的全部细节的正式说明，包括IC类型、参考标志符和引脚编号。（和常说的逻辑图不同）能够生成生产用的材料清单。</li><li>定时图：说明各种逻辑信号的值随时间的变化情况。关键信号之间的因果延迟。</li><li>结构化逻辑器件描述：描述PLD、FPGA或者ASIC的内部功能设计。通常用HDL描述；也可以用逻辑表达式、状态表、状态图等形式。</li><li>电路描述：电路功能设计的描述性文本，和其它文档一起解释电路的工作原理。应该包括设计的假设、限制等。</li></ul><p>方框图：</p><ul><li>能展示最重要的系统元素以及工作原理。</li><li>每个方框图不要超过1页。</li><li>大型系统可以另附页描述子系统。</li><li>重要的控制信号和总线要命名。</li><li>明确表明控制流和数据流。</li><li>不要包含细节。</li></ul><p>圏到圈逻辑设计(目的：使用包含有效电平标识的逻辑符号或信号命名方式使得逻辑电路更容易理解。)</p><h3 id="可编程逻辑器件"><a href="#可编程逻辑器件" class="headerlink" title="可编程逻辑器件"></a>可编程逻辑器件</h3><p>PLA:</p><p>PAL:或门阵列固定、与门阵列可编程、双向输入/输出引脚。</p><p>GAL通用阵列逻辑：GAL16V8是一个时序逻辑器件，但可以编程设置为组合逻辑器件。此时，其结构和PAL16L8类似。多了一个输出极性控制的异或门。</p><p>CPLD复杂可编程逻辑器件：是将多个PLD集成到单个芯片上，并提供可编程的互连和输入/输出结构。可以把CPLD的基本结构看成由可编程逻辑阵列（LAB）、可编程I/O控制模块和可编程内部连线（PIA）等三部分组成。</p><h3 id="译码器"><a href="#译码器" class="headerlink" title="译码器"></a>译码器</h3><p>译码器的输出编码通常比其输入编码位数多</p><p>真值表</p><p>逻辑图</p><p>上低下高</p><p>2-4译码器 3-8译码器 级联二进制译码器：4-16译码器 5-32译码器</p><p>译码器的级联</p><p>七段显示译码器</p><p>半导体显示：LED 液晶显示：LCD</p><h3 id="编码器"><a href="#编码器" class="headerlink" title="编码器"></a>编码器</h3><p>器件的输出编码比其输入编码位数少</p><p>8-3编码器</p><p>3位二进制优先编码器：允许几个信号同时输入，但只对优先级别最高<br>的进行编码</p><h3 id="三态器件"><a href="#三态器件" class="headerlink" title="三态器件"></a>三态器件</h3><p>三态缓冲器</p><p>三态器件允许多个信号源共享单个线路</p><h4 id="三态缓冲器"><a href="#三态缓冲器" class="headerlink" title="三态缓冲器"></a>三态缓冲器</h4><p>三态门进入和离开高阻态的延迟时间不同，会造成输出线路上值的混乱，造成同时驱动的冲突现象。解决的方法：设计控制逻辑，保证一段截止时间（dead time），这段时间不应该有任何器件驱动同线。</p><h3 id="数据选择器-多路选择器"><a href="#数据选择器-多路选择器" class="headerlink" title="数据选择器(多路选择器)"></a>数据选择器(多路选择器)</h3><p>一种多路输入，单路输出的逻辑构件。</p><p>2-1 multiplexer</p><p>n个输入变量 需要m=log n 个控制信号</p><p>多路选择器除完成对多路数据进行选择的基本功能外，在逻辑设计中主要用来实现各种逻辑函数功能。用多路选择器实现分时多路转换电路。(将并行输入的数据转换成串行输出)。</p><p>方法I：用具有n个选择变量的MUX实现n个变量的函数。</p><p>方法Ⅱ：用具有n-1个选择控制变量的MUX实现n个变量函数功能：即从函数的n个变量中任n-1个作为MUX的选择控制变量，并根据所选定的选择控制变量将函数变换成F=∑miDi的形式，以确定各数据输入Di。假定剩余变量为X，则Di的取值只可能是0、1、X或X’四者之一。</p><p>把并行处理的数据放在Di端上。在地址端上，周期性的循环加载 00-&gt;01-&gt;10-&gt;11  如此，在输出端上，顺序地送出原先并行的数据。</p><h3 id="数据分配器-Demultiplexers"><a href="#数据分配器-Demultiplexers" class="headerlink" title="数据分配器(Demultiplexers)"></a>数据分配器(Demultiplexers)</h3><p>其功能和多路数据选择器相反。是一种单路输入，多路输出的逻辑构件。从哪一端输出依赖于当时的地址控制端输入。</p><p>【例】利用DMUX和MUX设计一个实现8路数据传输的逻辑电路。 </p><p>多路分配器常与多路选择器联用，以实现多通道数据分时传送。通常在发送端由MUX将各路数据分时送上公共传输线(总线)，接收端再由DEMUX将公共线上的数据适时分配到相应的输出端。</p><p>大扇出处理：每个输出端增加一个三态缓冲</p><p>扇入系数大会有什么影响？</p><h3 id="校验电路"><a href="#校验电路" class="headerlink" title="校验电路"></a>校验电路</h3><p>异或门和异或非门 用与或非三个门或者用与非门实现</p><p>奇偶校验电路</p><p>奇偶校验器件74x280:9个输入 2个输出</p><p>chapter6-3 ppt 第七张重点</p><p>奇偶校验应用：7位海明码纠错电路。</p><h3 id="比较器"><a href="#比较器" class="headerlink" title="比较器"></a>比较器</h3><p>两种类型：比较器  大小比较器</p><p>大小比较器</p><p>内部电路图</p><p>级联</p><p>74x682 只有相等和大于输出  扩展判断输出</p><h3 id="加法器、减法器和ALU"><a href="#加法器、减法器和ALU" class="headerlink" title="加法器、减法器和ALU"></a>加法器、减法器和ALU</h3><p>ALU:可以根据操作码完成加法、减法等运算功能的电路。</p><p>行波进位加法器 属于迭代电路 延迟： t add = t XYCout + (n-2) tCinCout +tCinS</p><p>用加法器实现减法器</p><p>chapter6-3 第33张ppt存疑</p><p>chapter6-3 第35张ppt存疑 如何化简</p><p>74x283(4位先行进位加法器) ’283的进位信号c0到c4的延迟很短相当于2个反相门，可以级联扩展计算位数，组间串行进位加法器</p><p>74x181 4位ALU</p><p>组间先行进位：不同于组间串行进位，先行进位信号直接由输入的操作数决定，没有组间串行的进位信号。</p><h3 id="组合乘法器"><a href="#组合乘法器" class="headerlink" title="组合乘法器"></a>组合乘法器</h3><p>移位-累加算法的电路实现：最坏20级延迟 延迟估计  进位保留加法(14级延迟)？？？？</p><h2 id="时序逻辑"><a href="#时序逻辑" class="headerlink" title="时序逻辑"></a>时序逻辑</h2><p>时序电路的输出不仅取决于当前的输入，而且取决于过去的输入序列（状态）。</p><p>状态：是一个状态变量集合。包含了在当前输入的基础上预测当前输出的所有的历史信息。</p><p>时序电路的状态个数有限：有限状态机</p><p>有效电平：通常在时钟的触发沿内状态发生改变。</p><p>时钟周期tper、时钟频率、时钟触发沿、占空比</p><h3 id="时序电路的类型"><a href="#时序电路的类型" class="headerlink" title="时序电路的类型"></a>时序电路的类型</h3><ul><li>反馈时序电路：采用普通门电路和反馈回路来实现逻辑电路中的记忆能力，由此构成时序逻辑电路</li><li>时钟同步时序电路：也采用逻辑构件来构建电路，但输入由统一的时钟信号控制。</li><li>其它类型：通用基本型、多脉冲型等</li></ul><h3 id="双稳态器件"><a href="#双稳态器件" class="headerlink" title="双稳态器件"></a>双稳态器件</h3><p>所谓的双稳态元件（或者电路），是指电路有两个稳定的状态，即置位状态和复位状态。Q为1的状态称为置位状态，而Q为0的状态称为复位状态。</p><p>双稳态电路的内在特性(inherent)</p><ul><li>2 稳定点（stable points）</li><li>1亚稳定点（metastable point）</li></ul><p>亚稳态，非有效的逻辑信号，但满足回路方程</p><p>任何时序电路都存在亚稳态现象</p><ul><li>开机：存在亚稳态</li><li>工作：外部激励必须满足最短时间要求, 才能生效, 否则…</li></ul><h3 id="单稳态"><a href="#单稳态" class="headerlink" title="单稳态"></a>单稳态</h3><p>to be or not to be</p><h3 id="锁存器与触发器"><a href="#锁存器与触发器" class="headerlink" title="锁存器与触发器"></a>锁存器与触发器</h3><ul><li>时序电路的基本构件。</li><li>都是双稳态元件。</li><li>锁存器(Latch)：连续地监测其输入，并且独立于时钟信号而在任何时候都可以改变输出</li><li>触发器(Flip-Flop)：连续地监测输入信号，并只在时钟信号所确定的时刻改变其输出</li></ul><h4 id="RS锁存器"><a href="#RS锁存器" class="headerlink" title="RS锁存器"></a>RS锁存器</h4><p>S置位 R 复位  S=R=1时,Q=QN=0   S=R=0时,Q=last Q, QN=last QN  R和S不能同时取消，否则会导致震荡状态或亚稳态</p><p>输入信号宽度必须大于最小脉冲宽度</p><h4 id="R’-S’锁存器"><a href="#R’-S’锁存器" class="headerlink" title="R’-S’锁存器"></a>R’-S’锁存器</h4><p>R非S非锁存器：低态有效的置位和复位，可以用与非门实现。</p><h4 id="具有使能端的RS锁存器"><a href="#具有使能端的RS锁存器" class="headerlink" title="具有使能端的RS锁存器"></a>具有使能端的RS锁存器</h4><p>S-R Latch with Enable, 带使能端的RS锁存器(RS闩锁)<br>受使能信号控制，C为写入条件或指令</p><h4 id="D锁存器"><a href="#D锁存器" class="headerlink" title="D锁存器"></a>D锁存器</h4><p>数据经非门产生一对互补信号，D型锁存器(D Latch)</p><p>建立时间(Set-up time) 保持时间(Hold time)</p><h4 id="如何实现边沿触发"><a href="#如何实现边沿触发" class="headerlink" title="如何实现边沿触发"></a>如何实现边沿触发</h4><p>用 to be or not to be 电路</p><h4 id="边沿触发式-Edge-Triggered-触发器"><a href="#边沿触发式-Edge-Triggered-触发器" class="headerlink" title="边沿触发式(Edge Triggered)触发器"></a>边沿触发式(Edge Triggered)触发器</h4><p>只在时钟信号的上升沿或者下降沿改变状态</p><h4 id="主从D触发器-存疑"><a href="#主从D触发器-存疑" class="headerlink" title="主从D触发器  存疑"></a>主从D触发器  存疑</h4><p>第1个锁存器称为主(master)锁存器，第2个称为从(slave)锁存器。</p><p>传播延迟 (from CLK) 建立时间 (D before CLK) 保持时间 (D after CLK)</p><p>具有预置和清零端的正边沿D触发器</p><p>具有使能端的边沿触发式D触发器</p><h4 id="扫描触发器"><a href="#扫描触发器" class="headerlink" title="扫描触发器"></a>扫描触发器</h4><p>扫描触发器除了D输入端以外，还有两个输入端。</p><p>TI即Test Input，用来输入测试序列（测试向量）。</p><p>TE即Test Enable，用来控制触发器工作状态。</p><h4 id="主从式触发器"><a href="#主从式触发器" class="headerlink" title="主从式触发器"></a>主从式触发器</h4><ul><li>在时钟脉冲信号高电平期间数据进入触发器，在下降沿输出反映输入的变化</li><li>主从式触发器也称为脉冲触发型触发器(Pulse Triggered Flip-flops)</li><li>为了使得输出能正确地反映输入的变化，要求在时钟脉冲信号为高期间，输入不发生变化。</li><li>其特点是数据在第一个边沿锁入触发器，第二个边沿后数据出现在输出端。</li><li>主从式触发器基本上已经被边沿触发式触发器所取代。</li></ul><h4 id="主从式JK触发器"><a href="#主从式JK触发器" class="headerlink" title="主从式JK触发器"></a>主从式JK触发器</h4><p>同时有效则翻转</p><p>在触发脉冲的后沿，JK输入的状态变化可能无效。 使用中，尽量保持JK稳定</p><p>0钳位 1钳位????</p><h4 id="边沿触发式JK触发器"><a href="#边沿触发式JK触发器" class="headerlink" title="边沿触发式JK触发器"></a>边沿触发式JK触发器</h4><p>解决主从JK触发器中1和0钳位的问题。</p><p>在上升沿时采样输入信号。</p><h4 id="T触发器"><a href="#T触发器" class="headerlink" title="T触发器"></a>T触发器</h4><ul><li>T触发器：在每一个时钟脉冲的有效边沿都会改变状态。</li><li>常用在计数器和分频器。</li><li>具有使能端的T触发器</li></ul><h4 id="维持-阻塞D触发器"><a href="#维持-阻塞D触发器" class="headerlink" title="维持-阻塞D触发器"></a>维持-阻塞D触发器</h4><h4 id="锁存器和触发器的描述"><a href="#锁存器和触发器的描述" class="headerlink" title="锁存器和触发器的描述"></a>锁存器和触发器的描述</h4><h5 id="特征方程"><a href="#特征方程" class="headerlink" title="特征方程"></a>特征方程</h5><p>SR锁存器： Q* = S + R’Q</p><p>JK触发器： Q* = JQ’ + K’Q</p><p>T触发器： Q* = Q’</p><p>D触发器： Q* = D</p><h3 id="状态转移图"><a href="#状态转移图" class="headerlink" title="状态转移图"></a>状态转移图</h3><ul><li>用来描述电路状态，也可以对现实世界中任何有状态的事物进行建模</li><li>列举出该事物所有可能的状态，每个状态用一个圈表示</li><li>状态之间可以相互转换。状态转换用带箭头的弧线表示。</li><li>在弧线上标明状态发生变化的条件（即系统的输入）。也可以标明该状态转移导致的结果（输出）。</li></ul><h3 id="时钟控制时序逻辑电路分析"><a href="#时钟控制时序逻辑电路分析" class="headerlink" title="时钟控制时序逻辑电路分析"></a>时钟控制时序逻辑电路分析</h3><p>Sequential-Circuit：组合逻辑+记忆电路</p><ul><li>同步时序电路（Synchronous Sequential Logic）</li><li>异步时序电路（Asynchronous Sequential Logic）</li></ul><p>Synchronous Sequential Logic</p><ul><li>统一时钟驱动，触发时刻更新记忆电路状态</li><li>状态转移图描述</li><li>设计方法、工具相对规范成熟</li></ul><p>Asynchronous Sequential Logic</p><ul><li>状态变化时刻不一致</li><li>状态转移图描述</li><li>异步电路多用在接口电路设计方面</li></ul><h4 id="同步时序电路的类型"><a href="#同步时序电路的类型" class="headerlink" title="同步时序电路的类型"></a>同步时序电路的类型</h4><p>按照输出方程的不同，分为：</p><ul><li>Mealy型电路(Mealy State Machine)： 某时刻输出是该电路当前时刻输入和当前状态的函数</li><li>Moore型电路(Moore State Machine)：某时刻输出仅是该电路当前状态的函数，与当前时刻的输入无关，如某些计数器</li></ul><h4 id="状态机分析的步骤"><a href="#状态机分析的步骤" class="headerlink" title="状态机分析的步骤"></a>状态机分析的步骤</h4><ol><li>确定下一状态函数F和输出函数G</li><li>用F和G构造状态/输出表(state/output table)，列出所有当前状态和输入的组合，指定电路的下一状态和输出</li><li>画出状态图（state diagram）。</li><li>描述电路的功能。</li></ol><h4 id="状态图"><a href="#状态图" class="headerlink" title="状态图"></a>状态图</h4><p>State Diagram(状态图)中，离开某个特定状态的所有转移条件，满足:</p><ul><li>Mutually Exclusive(互斥性)，每种输入组合都有唯一的下一状态。否则相同输入组合对应不同的下一状态(二义性)</li><li>All Inclusion(完备性)，所有输入组合都有确定的下一状态(有时需要根据设计需求，在不违背题意的前提下作出合理安排)</li><li>称为完全确定的时序电路</li></ul><h4 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h4><ul><li>利用转移、状态和输出表，可构造定时图</li><li>定时图：表示出状态机在任何期望的起始状态和输入序列的作用下所产生的行为。</li></ul><h4 id="同步时序电路的分析步骤"><a href="#同步时序电路的分析步骤" class="headerlink" title="同步时序电路的分析步骤"></a>同步时序电路的分析步骤</h4><ol><li>写出各触发器的激励方程。</li><li>把得到的激励方程代入到触发器的特征方程，得到转移方程/次态方程。</li><li>确定输出方程。</li><li>根据转移方程构造转移表，在转移表中对每一种状态/输入组合添加输出值，构成状态/输出表</li><li>利用状态名得到时序电路的状态图。</li><li>画出时序图。</li></ol><h3 id="时钟同步状态机设计"><a href="#时钟同步状态机设计" class="headerlink" title="时钟同步状态机设计"></a>时钟同步状态机设计</h3><ol><li>根据文字描述，构造状态/输出表</li><li>（可选）将状态/输出表中的状态数目最小化</li><li>状态赋值，选择一组状态变量编码组合赋给状态</li><li>将状态变量组合代入状态/输出表，建立转移/输出表。</li><li>选择一种触发器作为状态存储器</li><li>构造激励表</li><li>由激励表推导出激励方程</li><li>由转移/输出表推导出输出方程</li><li>画出逻辑电路图。</li></ol><h4 id="状态化简"><a href="#状态化简" class="headerlink" title="状态化简"></a>状态化简</h4><p>等价状态：设状态S1和S2是完全确定状态表中的两个状态,如果对于所有可能的输入序列，分别从状态S1    和状态S2出发，所得到的输出响应序列完全相同，    则状态S1和S2是等价的，记作(S1, S2) .    或说，状态S1和S2是等价对。等价状态可以合并。</p><p>等价状态具有传递性 </p><p>等价类：彼此等价的状态集合</p><p>状态简化的任务是要在原始状态表中找出全部最大等价类(最大等价类集合)，并将每一个最大等价类用一个状态来表示。</p><p>假定状态S1和S2是完全确定原始状态表中的两个现态，那么S1和S2等价的条件可归纳为在输入的各种取值组合下：</p><ul><li>第一、它们的输出完全相同；</li><li>第二、它们的次态满足下列条件之一，即：(1) 次态相同；(2) 次态交错 (3) 次态循环 (4) 次态对等价</li></ul><p>隐含表法化简</p><h5 id="不完全确定状态表的简化"><a href="#不完全确定状态表的简化" class="headerlink" title="不完全确定状态表的简化"></a>不完全确定状态表的简化</h5><p>不完全确定状态表： 状态表中存在不确定的次态或输出，这些不确定的次态或输出将有利于状态简化。</p><p> 相容状态：设状态S1和S2是不完全确定状态表中    的两个状态，如果对于所有的有效输入序列，分别从状态S1和S2出发，所得到的输出响应序列(除不确定的那些位之外)是完全相同的，那么状态S1和S2是相容的，或者说状    态S1和S2是相容对，记作(S1,S2)。相容状态可以合并。</p><p> 状态相容无传递性</p><p> 相容类：彼此相容的状态集合  最大相容类：不被其他相容类所包含的相容类</p><p>作最小化状态表: 最小化状态表(又称最小闭覆盖) 应满足下列三个条件：</p><ul><li>覆盖性－－所选相容类集合应包含原始状态表中    的全部状态。</li><li>最小性－－所选相容类集合中相容类的个数应最    少。</li><li>闭合性－－所选相容类集合中的任一相容类，在    原始状态表中任一输入条件下产生的次态应    该属于该集合中的某一个相容类。</li></ul><h4 id="状态赋值-状态编码"><a href="#状态赋值-状态编码" class="headerlink" title="状态赋值(状态编码)"></a>状态赋值(状态编码)</h4><ul><li>确定表示状态表的状态需要多少位二进制变量，并且对每一个已命名的状态赋予一个特定的组合（编码）。</li><li>状态编码(coded state)：赋给一个特定状态的二进制数的组合。</li></ul><p>状态分配方案的种数：排列数计算</p><p>如果两种状态分配在实现逻辑时产生相同的结果，则认为它们是等价的。状态编码分配互补，或状态编码左右互换，都是等价的。</p><p>独立状态数: N=(2^K - 1)! / ((2^K-n)!K!)</p><p>在同步时序电路中状态分配目的在于：在逻辑化简时，生成尽可能大的必要质蕴含。状态分配的标准就是使得质蕴含达到最大程度。寻找较好的结果。</p><p>状态编码：从2^n种可能组合中选择S种编码</p><p>遗憾的是：至今没有找到普遍有效的算法实现最佳状态分配，唯一途径是将所有分配方案都试个遍</p><p>次佳状态分配方案：相邻状态分配法，建立通用方程法，减少相关性</p><h5 id="次佳状态分配方案"><a href="#次佳状态分配方案" class="headerlink" title="次佳状态分配方案"></a>次佳状态分配方案</h5><p>相邻状态分配法</p><ul><li>次态相同，现态相邻: 使下一个状态较少依赖于当前状态变量</li><li>同一现态，次态相邻：使下一状态较少依赖于输入变量</li><li>输出相同，现态相邻：使输出较少依赖于当前状态变量</li></ul><h5 id="处理未用状态方法"><a href="#处理未用状态方法" class="headerlink" title="处理未用状态方法"></a>处理未用状态方法</h5><p>最小风险法 最小成本法</p><h4 id="反馈时序电路"><a href="#反馈时序电路" class="headerlink" title="反馈时序电路"></a>反馈时序电路</h4><p>异步时序电路特征：状态变化不受“统一时钟信号控制”</p><p>依电路结构和输入信号形式不同，异步时序电路分类：</p><ul><li>脉冲型Pulsed Asynchronous Circuit(脉冲信号):记忆电路为“触发器”</li><li>电平型Level Asynchronous Circuit(电平信号)：记忆电路为“反馈加延时”</li></ul><p>双稳态电路、锁存器和触发器等都是反馈时序电路。反馈回路是记忆元件，存储0或1。</p><p>基本模式电路，对输入信号的约束：</p><ul><li>不允许两个或两个以上输入同时变化(每时刻仅允许1个输入发生变化)</li><li>仅当电路处于稳态时，允许输入信号发生变化</li></ul><h5 id="反馈时序电路的分析步骤"><a href="#反馈时序电路的分析步骤" class="headerlink" title="反馈时序电路的分析步骤"></a>反馈时序电路的分析步骤</h5><ul><li>切断反馈路径，写出激励函数和输出函数</li><li>列出状态转移表</li><li>作出状态图和时序(间)图</li><li>说明电路的逻辑功能</li></ul><h5 id="反馈时序电路的分析"><a href="#反馈时序电路的分析" class="headerlink" title="反馈时序电路的分析"></a>反馈时序电路的分析</h5><ul><li>现态和次态只是在时间上有延迟，经过一段时间后，现态和次态的值趋于一致。</li><li>总态Total State：用来描述异步时序机的行为。包括输入状态I和次态S，并记为(I，S)。</li><li>稳定状态：如某一现态y在输入x发生变化时，若次态Y和现态y的值相同，则称次态Y为稳定状态；若次态Y和现态y的值不等，则称进入的次态Y为不稳定状态。不稳定状态是不能保持不变，经过一段延迟时间后，现态和次态趋于一致，进入稳定状态，则称为状态迁移。</li><li>状态表：状态命名，且将稳定的总状态用圆圈圈住。</li><li>总态可以是稳定的也可以是不稳定的，不稳定的总态要发生状态迁移，而达到一个稳定的状态或循环不稳态。稳定的总态，如果输入不改变，则始终保存稳定状态，不会发生状态迁移。</li><li>异步电路的基本工作方式是保证电路稳定工作，使电路状态的转移是可以预测的。</li><li>输入状态的改变仅能引起次态在状态表作相邻方格的水平移动。</li><li>二次状态的改变则引起次态在状态表中作垂直方向的移动。</li></ul><p>多反馈回路中，必须断开所有的反馈，设置虚构的缓冲器和状态变量。</p><p>最小割集(cut set)：断点数最少的集合</p><h5 id="竞争"><a href="#竞争" class="headerlink" title="竞争"></a>竞争</h5><p>一个输入信号的变化，引起多个内部状态变量改变，称之为发生了竞争</p><ul><li>非临界竞争(Noncritical race)，最终状态与状态变量变化顺序无关，结果可预测。</li><li>临界竞争(Critical race)，最终状态取决于状态变量变化顺序和速度，结果不可预测。</li></ul><p>对于竞争的处理</p><ul><li>允许非临界竞争</li><li>避免临界竞争</li></ul><h5 id="状态表与流程表"><a href="#状态表与流程表" class="headerlink" title="状态表与流程表"></a>状态表与流程表</h5><ul><li>状态表：状态命名，且将稳定的总状态用圆圈圈住。</li><li>跳程hop：单个输入变量变化时，电路达到新的稳定总状态时所发生的不稳定的状态。</li><li>流程表Flow table：由现态和在不同输入条件下的次态及输出组成。删除状态表中的跳程，只表示出每次转移过程的最终目标，去除未用内部状态的那些行，去掉那些稳定的总状态在单个输入变化时从不会到达的下一状态项。</li></ul><h4 id="反馈时序电路设计"><a href="#反馈时序电路设计" class="headerlink" title="反馈时序电路设计"></a>反馈时序电路设计</h4><ol><li>根据逻辑要求，建立原始流程表</li><li>将原始状态表简化，得到最简流程表</li><li>对最简流程表进行状态分配</li><li>建立激励表和输出表</li><li>列出激励函数和输出函数表达式</li><li>画出逻辑电路图</li></ol><p>原始流程表:每一行含有一个稳态 每个状态决定于上一个状态和输入</p><h5 id="本质冒险"><a href="#本质冒险" class="headerlink" title="本质冒险"></a>本质冒险</h5><p>本质冒险：当输入信号变化时，电路进入错误状态的可能性。：如果最终状态变量的变化被传回到激励电路输入端之前，输入的变化未被所有的激励电路接收到，就会发生错误。</p><p>通俗定义：如果从状态S出发，X的一次变化和三次变化的最终结果状态不一致，就存在本质冒险。</p><p>本质冒险是电路中固有的问题，可通过增加延迟解决问题。</p><h3 id="时序逻辑设计实践"><a href="#时序逻辑设计实践" class="headerlink" title="时序逻辑设计实践"></a>时序逻辑设计实践</h3><p>定时图： </p><p>建立时间容限=tclk-tffpd(max)-tcomb(max)-tsetup&gt;0</p><p>保持时间容限=tffpd(min)+tcomb(min)-thold&gt;0</p><h4 id="开关消颤"><a href="#开关消颤" class="headerlink" title="开关消颤"></a>开关消颤</h4><p>双稳态电路消颤</p><p>锁存器和上拉电阻消颤</p><h4 id="S’-R’锁存器消除击键抖动"><a href="#S’-R’锁存器消除击键抖动" class="headerlink" title="S’-R’锁存器消除击键抖动"></a>S’-R’锁存器消除击键抖动</h4><h4 id="总线保持电路"><a href="#总线保持电路" class="headerlink" title="总线保持电路"></a>总线保持电路</h4><p>在三态总线中，悬空总线的处理方法</p><ul><li>上拉电阻：价格贵、占用印刷电路的面积 大小选择比较困难，过大，转换慢；过小，则消耗过多的电流</li><li>有源总线保持电路：带电阻反馈回路的双稳态电路</li></ul><p>为什么要？？？？</p><h4 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h4><p>共用一个时钟信号的2个或2个以上的D触发器组合在一起，称为寄存器，通常用来存储一组相关的二进制数。</p><p>锁存器和触发器的区别:</p><ul><li>前者是电位信号控制，后者是同步时钟边沿信号控制。</li><li>使用的场合不同：取决于控制方式、控制信号和数据之间的时间关系。：数据有效滞后于控制信息时，使用锁存器。反之，可使用寄存器。</li></ul><h4 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h4><p>计数器：在状态图中包含一个循环的时序电路。</p><p>1.功能：对时钟脉冲 CLK 计数。<br>2.应用：分频、定时、产生节拍脉冲和脉冲序列、进行数字运算等。</p><p>按数制分：二进制计数器 十进制计数器 N进制(任意进制)计数器</p><p>按计数方式分： 加法计数器 减法计数器 可逆计数（Up-Down Counter）</p><h5 id="行波计数器：进位信息像波浪一样由低位向高位，每次传送一次。"><a href="#行波计数器：进位信息像波浪一样由低位向高位，每次传送一次。" class="headerlink" title="行波计数器：进位信息像波浪一样由低位向高位，每次传送一次。"></a>行波计数器：进位信息像波浪一样由低位向高位，每次传送一次。</h5><p>延迟时间很长</p><h5 id="同步计数器"><a href="#同步计数器" class="headerlink" title="同步计数器"></a>同步计数器</h5><p>同步计数器：所有的触发器共用一个CLK信号 使用带有使能端的T触发器</p><p>串行同步4位二进制计数器 并行同步4位二进制计数器(最快的二进制计数器)</p><p>一次状态转移中有2个以上的计数位同时变化，在译码端可能产生尖峰脉冲(glitch)。 属于功能性冒险</p><p>无冒险译码输出：输出延迟一个时钟周期 可使用环形计数器实现</p><p>可逆同步计数器169</p><p>N进制计数器：用触发器和门电路设计或用集成计数器构成。</p><p>十进制异步计数器</p><p>提高归零可靠性？</p><h5 id="移位寄存器"><a href="#移位寄存器" class="headerlink" title="移位寄存器"></a>移位寄存器</h5><p>移位寄存器shift register：是一个n位寄存器，在每一个时钟触发沿到来时就将所存储的数据移一位。</p><ul><li>处理串行数据</li><li>用于rs232,modem通信、以太网连接等</li><li>串入串出</li></ul><p>也可以串入并出、并入串出、并入并出</p><h6 id="移位寄存器的应用"><a href="#移位寄存器的应用" class="headerlink" title="移位寄存器的应用"></a>移位寄存器的应用</h6><ul><li>串并转换是移位寄存器的“数据应用”。</li><li>与组合电路构成具有循环状态图的状态机，“非数据应用”，称为移位寄存器计数器shift-register counter。</li><li>计数顺序既不是升序也不是降序。</li></ul><h5 id="环形计数器"><a href="#环形计数器" class="headerlink" title="环形计数器"></a>环形计数器</h5><h5 id="自校正环形计数器"><a href="#自校正环形计数器" class="headerlink" title="自校正环形计数器"></a>自校正环形计数器</h5><h5 id="Johnson计数器"><a href="#Johnson计数器" class="headerlink" title="Johnson计数器"></a>Johnson计数器</h5><p>扭环计数器，把n位移位寄存器的串行输出取反，得到具有2n种状态的计数器。 有2n-2n个非正常状态，存在健壮性问题。</p><h5 id="线性反馈移位寄存器计数器"><a href="#线性反馈移位寄存器计数器" class="headerlink" title="线性反馈移位寄存器计数器"></a>线性反馈移位寄存器计数器</h5><ul><li>n位线性反馈移位寄存器计数器(n-bit linear feedback shift-register counter,LFSR)有2n-1种有效状态，通常称为最大长度序列发生器(maximum-length sequence generator)。</li><li>基于有限域理论（finite field），对于任意值n，至少可以找到一种反馈方程，使得计数器的计数循环包含所有2n-1种非零状态。</li><li>最大长度序列。</li><li>n大于3，有多个反馈方程可实现最大长度序列。</li><li>用于伪随机数生成器、检错码、纠错码，加扰和解扰通信数据等。</li></ul><h4 id="计数器的应用"><a href="#计数器的应用" class="headerlink" title="计数器的应用"></a>计数器的应用</h4><p>序列信号发生器</p><h4 id="迭代电路与时序电路"><a href="#迭代电路与时序电路" class="headerlink" title="迭代电路与时序电路"></a>迭代电路与时序电路</h4><ul><li>一个由n个模块构成的迭代电路，其功能可以用一个模块加暂存机制构成的时序电路来完成，需经过n个时钟周期才能得到结果。</li><li>数字设计中的空间/时间折中。</li></ul><h2 id="存储器、CPLD和FPGA"><a href="#存储器、CPLD和FPGA" class="headerlink" title="存储器、CPLD和FPGA"></a>存储器、CPLD和FPGA</h2><h3 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h3><h4 id="ROM"><a href="#ROM" class="headerlink" title="ROM"></a>ROM</h4><ul><li>只读存储器简称ROM (read-only memory)：是一种具有n个输入b个输出的组合逻辑电路。</li><li>包含地址输入（地址译码）、数据输出（输出缓冲）和存储矩阵三部分。</li><li>与真正存储器的区别：非易失性存储器(non volatile memory)。即使电源断电，ROM中存储的数据不会丢失。</li><li>ROM = 最小项译码器+ 可编程或矩阵</li><li>ROM = 存真值表的存储器</li></ul><h4 id="ROM的应用"><a href="#ROM的应用" class="headerlink" title="ROM的应用"></a>ROM的应用</h4><ul><li>字符发生器：实现字符发生器的基本原理是:将字符的点阵预先存储在ROM中，然后顺序给出地址码，从存储矩阵中逐行读出字符的点阵，并送入显示器即可显示出字符。</li><li>数学函数表：实现计算机中的运算有两种方法，一种是编写运算程序，存入ROM中，通过计算机执行运算程序。另一种方法是把因变量和自变量的函数关系存在ROM中，好像查函数表一样。</li></ul><h4 id="RAM"><a href="#RAM" class="headerlink" title="RAM"></a>RAM</h4><ul><li>读/写存储器(Read/Write Memory RWM)是指可以在任何时候存储和检索信息的存储器阵列</li><li>现在数字系统中的读写存储器大多数是随机存取存储器（Random-access Memory, RAM），意思说读或写存储器的1个位所花费的时间与该位在RAM中的位置无关。</li><li>静态存储器Static RAM,SRAM：一旦在某个存储位置写入数据，只要电源不被切断，其存储内容保持不变，除非重新写入新内容。</li><li>动态存储器Dynamic RAM,DRAM：必须对存储数据进行周期性读出和写入刷新，否则存储器中的数据将会消失。</li></ul><p>存储器的容量扩展：位扩展 字扩展  字位同时扩展</p><h4 id="CPLD"><a href="#CPLD" class="headerlink" title="CPLD"></a>CPLD</h4><p>基本结构：大多由内部PLD、输入输出块和可编程内部连线组成。</p><h4 id="FPGA"><a href="#FPGA" class="headerlink" title="FPGA"></a>FPGA</h4><ul><li>与CPLD相比，具有更高的集成度、更强的逻辑功能和更大的灵活性</li><li>FPGA属于阵列型PLD</li><li>有三个可编程电路块和一个用于存放编程数据的SRAM组成：可编程逻辑块（CLB）  输入/输出模块（IOB）  可编程互连线（PI）</li></ul><h4 id="FPGA和CPLD的区别"><a href="#FPGA和CPLD的区别" class="headerlink" title="FPGA和CPLD的区别"></a>FPGA和CPLD的区别</h4><ul><li>编程技术与数据易失性：通常FPGA采用SRAM进行功能配置，可以重复编程，但系统掉电后，SRAM中的数据丢失。因此，需在FPGA外加EPROM，将配置数据写入其中，系统每次上电自动将数据引入SRAM中。而一般CPLD器件采用EEPROM存储技术，可重复编程，且系统掉电后，EEPROM中的数据不会丢失，适于数据的保密。</li><li>触发器资源：FPGA器件由于含有丰富的触发器资源，容易实现时序逻辑，若要求实现比较复杂的组合电路则需要几个CLB结合起来实现。CPLD的与或阵列结构，使它更适合于实现大规模的组合逻辑功能，而它的触发器资源相对比较少。</li><li>芯片利用率：FPGA多为细粒度结构。FPGA内部有丰富连线资源，CLB分块比较小，芯片利用率比较高。CPLD多为粗粒度结构。 CPLD宏单元的与或阵列较大，通常不能完全被应用，而且宏单元之间主要通过高速数据通道连接，容量有限，限制了器件的灵活布线，因此CPLD利用率比FPGA低。</li><li>布线结构与延时预测性：FPGA为非连续式布线。FPGA器件在每次编程时实现的逻辑功能一样，但走的路线不同，因此延时难以预测，要求开发软件允许工程师对关键的路线给予限制。CPLD为连续式布线。CPLD每次布线路径一样，其连续式互连结构利用具有同样长度的一些金属线实现逻辑单元之间的互连，消除了分段式互连结构在定时上的差异，并且在逻辑单元之间提供快速而且具有固定延时的通路。另外，CPLD的延时比较小。</li></ul><h2 id="数字系统"><a href="#数字系统" class="headerlink" title="数字系统"></a>数字系统</h2><p>数字系统的基本模型：由输入部件、输出部件及逻辑系统组成。逻辑系统包括存储部件、处理部件、控制部件三大子系统。</p><p>基本子系统：是指构成数字系统时最基本的逻辑功能部件。这些逻辑功能部件有：算术逻辑运算单元ALU、寄存器、RAM、数据总线、控制器。</p><p>ALU：是数字系统中对数据进行加工处理的功能部件。</p><p>寄存器：加法器和ALU均由门电路组成，它们没有记忆功能，因此运算的结果需要寄存器保存起来。而参与运算的两个数也要取自寄存器。寄存器是数字系统中必不可少的逻辑子系统。  寄存器的分类：通用寄存器 、专用寄存器。</p><p>存储器RAM：当存储大量数据时，从经济和成本上考虑，只能使用随机读写的RAM存储器。</p><p>总线的概念 ：在数字系统中，总线是多个逻辑子系统的联系纽带。所谓总线，就是多个信息源分时传送数据到多个目的地的传送通路。单向总线 双向总线</p><p>给不给器件的原理图 ？？？</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数字逻辑电路笔记&quot;&gt;&lt;a href=&quot;#数字逻辑电路笔记&quot; class=&quot;headerlink&quot; title=&quot;数字逻辑电路笔记&quot;&gt;&lt;/a&gt;数字逻辑电路笔记&lt;/h1&gt;&lt;p&gt;给定输入 给出输出 用布尔逻辑实现&lt;/p&gt;
&lt;p&gt;晶体管的开关特性是数字电路研究的重点。&lt;/p&gt;
&lt;p&gt;数字逻辑中考虑电路模拟的特性，如时延问题。&lt;/p&gt;
&lt;p&gt;数字设计中一些层次问题&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="https://ricky-ting.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>BST</title>
    <link href="https://ricky-ting.github.io/2018/06/07/BST/"/>
    <id>https://ricky-ting.github.io/2018/06/07/BST/</id>
    <published>2018-06-07T07:09:17.000Z</published>
    <updated>2018-06-07T07:11:04.225Z</updated>
    
    <content type="html"><![CDATA[<p>下面是基于C++的BST类实现</p> <a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">//  main.cpp</span><br><span class="line">//  debugger</span><br><span class="line">//</span><br><span class="line">//  Created by 丁保荣 on 2018/6/6.</span><br><span class="line">//  Copyright © 2018 丁保荣. All rights reserved.</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">    node * p;</span><br><span class="line">    node * l;</span><br><span class="line">    node * r;</span><br><span class="line">    int key;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class BST</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    node * root;</span><br><span class="line">    node mynil;</span><br><span class="line">    void Initial()</span><br><span class="line">    &#123;</span><br><span class="line">        root=&amp;mynil;</span><br><span class="line">    &#125;</span><br><span class="line">    void Inorder_tree_walk(node * x);</span><br><span class="line">    void Preorder_tree_walk(node * x);</span><br><span class="line">    void Postorder_tree_walk(node * x);</span><br><span class="line">    node * Search(node * x, int k);</span><br><span class="line">    node * Minimum(node * z);</span><br><span class="line">    node * Maximum(node * z);</span><br><span class="line">    node * Successor(node * x);</span><br><span class="line">    node * Predecessor(node * x);</span><br><span class="line">    void Insert(node * z);</span><br><span class="line">    void Transplant(node * u, node * v);</span><br><span class="line">    void Delete(node * z);</span><br><span class="line">    </span><br><span class="line">private:</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void BST::Inorder_tree_walk(node * x)</span><br><span class="line">&#123;</span><br><span class="line">    if(x!=&amp;mynil)</span><br><span class="line">    &#123;</span><br><span class="line">        BST::Inorder_tree_walk((*x).l);</span><br><span class="line">        cout&lt;&lt;(*x).key;</span><br><span class="line">        BST::Inorder_tree_walk((*x).r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void BST::Preorder_tree_walk(node * x)</span><br><span class="line">&#123;</span><br><span class="line">    if(x!=&amp;mynil)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;(*x).key;</span><br><span class="line">        BST::Preorder_tree_walk((*x).l);</span><br><span class="line">        BST::Preorder_tree_walk((*x).r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void BST::Postorder_tree_walk(node * x)</span><br><span class="line">&#123;</span><br><span class="line">    if(x!=&amp;mynil)</span><br><span class="line">    &#123;</span><br><span class="line">        BST::Postorder_tree_walk((*x).l);</span><br><span class="line">        BST::Postorder_tree_walk((*x).r);</span><br><span class="line">        cout&lt;&lt;(*x).key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">node * BST::Search(node * x,int k)</span><br><span class="line">&#123;</span><br><span class="line">    if(x==&amp;mynil || k==(*x).key)</span><br><span class="line">        return x;</span><br><span class="line">    if(k&lt;(*x).key)</span><br><span class="line">        return BST::Search((*x).l,k);</span><br><span class="line">    else</span><br><span class="line">        return BST::Search((*x).r,k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">node * BST::Minimum(node * z)</span><br><span class="line">&#123;</span><br><span class="line">    while((*z).l!=&amp;mynil)</span><br><span class="line">        z=(*z).l;</span><br><span class="line">    return z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">node * BST::Maximum(node * z)</span><br><span class="line">&#123;</span><br><span class="line">    while((*z).r!=&amp;mynil)</span><br><span class="line">        z=(*z).r;</span><br><span class="line">    return z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">node * BST::Successor(node * x)</span><br><span class="line">&#123;</span><br><span class="line">    if((*x).r!=&amp;mynil)</span><br><span class="line">        return BST::Minimum((*x).r);</span><br><span class="line">    node * y=(*x).p;</span><br><span class="line">    while(y!=&amp;mynil &amp;&amp; x==(*y).r)</span><br><span class="line">    &#123;</span><br><span class="line">        x=y;</span><br><span class="line">        y=(*y).p;</span><br><span class="line">    &#125;</span><br><span class="line">    return y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">node * BST::Predecessor(node * x)</span><br><span class="line">&#123;</span><br><span class="line">    if((*x).l!=&amp;mynil)</span><br><span class="line">        return BST::Maximum((*x).l);</span><br><span class="line">    node * y=(*x).p;</span><br><span class="line">    while(y!=&amp;mynil &amp;&amp; x==(*y).l)</span><br><span class="line">    &#123;</span><br><span class="line">        x=y;</span><br><span class="line">        y=(*y).p;</span><br><span class="line">    &#125;</span><br><span class="line">    return y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void BST::Insert(node * z)</span><br><span class="line">&#123;</span><br><span class="line">    node * y=&amp;mynil;</span><br><span class="line">    node * x=root;</span><br><span class="line">    while(x!=&amp;mynil)</span><br><span class="line">    &#123;</span><br><span class="line">        y=x;</span><br><span class="line">        if((*z).key&lt;(*x).key)</span><br><span class="line">            x=(*x).l;</span><br><span class="line">        else</span><br><span class="line">            x=(*x).r;</span><br><span class="line">    &#125;</span><br><span class="line">    (*z).p=y;</span><br><span class="line">    if(y==&amp;mynil)</span><br><span class="line">        root=z;</span><br><span class="line">    else if((*z).key&lt;(*y).key)</span><br><span class="line">        (*y).l=z;</span><br><span class="line">    else</span><br><span class="line">        (*y).r=z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void BST::Transplant(node * u, node * v)</span><br><span class="line">&#123;</span><br><span class="line">    if((*u).p==&amp;mynil)</span><br><span class="line">        root=v;</span><br><span class="line">    else if(u==(*(*u).p).l)</span><br><span class="line">        (*(*u).p).l=v;</span><br><span class="line">    else</span><br><span class="line">        (*(*u).p).r=v;</span><br><span class="line">    if(v!=&amp;mynil)</span><br><span class="line">        (*v).p=(*u).p;</span><br><span class="line">&#125;</span><br><span class="line">void BST::Delete(node * z)</span><br><span class="line">&#123;</span><br><span class="line">    node * y;</span><br><span class="line">    if((*z).l==&amp;mynil)</span><br><span class="line">        BST::Transplant(z,(*z).r);</span><br><span class="line">    else if((*z).r==&amp;mynil)</span><br><span class="line">        BST::Transplant(z,(*z).l);</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        y=BST::Minimum((*z).r);</span><br><span class="line">        if((*y).p!=z)</span><br><span class="line">        &#123;</span><br><span class="line">            BST::Transplant(y,(*y).r);</span><br><span class="line">            (*y).r=(*z).r;</span><br><span class="line">            (*(*y).r).p=y;</span><br><span class="line">        &#125;</span><br><span class="line">        BST::Transplant(z,y);</span><br><span class="line">        (*y).l=(*z).l;</span><br><span class="line">        (*(*y).l).p=y;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BST T;</span><br><span class="line"></span><br><span class="line">void myinsert(int key)</span><br><span class="line">&#123;</span><br><span class="line">    node * p=new node;</span><br><span class="line">    (*p).key=key;</span><br><span class="line">    p-&gt;l=&amp;T.mynil;</span><br><span class="line">    p-&gt;r=&amp;T.mynil;</span><br><span class="line">    T.Insert(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void mydelete(int key)</span><br><span class="line">&#123;</span><br><span class="line">    node * p = T.Search(T.root,key);</span><br><span class="line">    T.Delete(p);</span><br><span class="line">    delete(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是基于C++的RB-Tree类实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">//  main.cpp</span><br><span class="line">//  debugger</span><br><span class="line">//</span><br><span class="line">//  Created by 丁保荣 on 2018/6/6.</span><br><span class="line">//  Copyright © 2018 丁保荣. All rights reserved.</span><br><span class="line">//</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int counter=0;</span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">    bool c; // true is black and false is red.</span><br><span class="line">    int key;</span><br><span class="line">    node * p;</span><br><span class="line">    node * l;</span><br><span class="line">    node * r;</span><br><span class="line">&#125;;</span><br><span class="line">class myRB_Tree</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    node mynil;</span><br><span class="line">    node * root;</span><br><span class="line">    void Initial()</span><br><span class="line">    &#123;</span><br><span class="line">        mynil.c=true;</span><br><span class="line">        mynil.p=mynil.l=mynil.r=NULL;</span><br><span class="line">        mynil.key=-1;</span><br><span class="line">        root=&amp;mynil;</span><br><span class="line">    &#125;</span><br><span class="line">    void Insert(node * z);</span><br><span class="line">    void Delete(node * z);</span><br><span class="line">    node * Search(node * x, int k);</span><br><span class="line">    node * Minimum(node * z);</span><br><span class="line">    void Preorder_tree_walk(node * x);</span><br><span class="line">    </span><br><span class="line">private:</span><br><span class="line">    void Insert_Fixup(node * z);</span><br><span class="line">    void Transplant(node * u, node * v);</span><br><span class="line">    void Left_Rotate(node * x);</span><br><span class="line">    void Right_Rotate(node * x);</span><br><span class="line">    void Delete_Fixup(node * x);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void myRB_Tree::Preorder_tree_walk(node * x)</span><br><span class="line">&#123;</span><br><span class="line">    if(x!=&amp;mynil)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;(*x).key&lt;&lt;&quot;:&quot;&lt;&lt;((*x).c?&quot;black&quot;:&quot;red&quot;)&lt;&lt;endl;</span><br><span class="line">        myRB_Tree::Preorder_tree_walk((*x).l);</span><br><span class="line">        myRB_Tree::Preorder_tree_walk((*x).r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void myRB_Tree::Insert(node * z)</span><br><span class="line">&#123;</span><br><span class="line">    node * y=&amp;mynil;</span><br><span class="line">    node * x=root;</span><br><span class="line">    while(x!=&amp;mynil)</span><br><span class="line">    &#123;</span><br><span class="line">        y=x;</span><br><span class="line">        if((*z).key&lt;(*x).key)</span><br><span class="line">            x=(*x).l;</span><br><span class="line">        else</span><br><span class="line">            x=(*x).r;</span><br><span class="line">    &#125;</span><br><span class="line">    (*z).p=y;</span><br><span class="line">    if(y==&amp;mynil)</span><br><span class="line">        root=z;</span><br><span class="line">    else if((*z).key&lt;(*y).key)</span><br><span class="line">        (*y).l=z;</span><br><span class="line">    else</span><br><span class="line">        (*y).r=z;</span><br><span class="line">    (*z).l=&amp;mynil;</span><br><span class="line">    (*z).r=&amp;mynil;</span><br><span class="line">    (*z).c=0;</span><br><span class="line">    myRB_Tree::Insert_Fixup(z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void myRB_Tree::Insert_Fixup(node * z)</span><br><span class="line">&#123;</span><br><span class="line">    while((*(*z).p).c==false)</span><br><span class="line">    &#123;</span><br><span class="line">        if((*z).p==(*(*(*z).p).p).l)</span><br><span class="line">        &#123;</span><br><span class="line">            node * y=(*(*(*z).p).p).r;</span><br><span class="line">            if((*y).c==false)</span><br><span class="line">            &#123;</span><br><span class="line">                (*(*z).p).c=true;</span><br><span class="line">                (*y).c=true;</span><br><span class="line">                (*(*(*z).p).p).c=false;</span><br><span class="line">                z=(*(*z).p).p;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                if(z==(*(*z).p).r)</span><br><span class="line">                &#123;</span><br><span class="line">                    z=(*z).p;</span><br><span class="line">                    myRB_Tree::Left_Rotate(z);</span><br><span class="line">                &#125;</span><br><span class="line">                (*(*z).p).c=true;</span><br><span class="line">                (*(*(*z).p).p).c=false;</span><br><span class="line">                myRB_Tree::Right_Rotate((*(*z).p).p);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            node * y=(*(*(*z).p).p).l;</span><br><span class="line">            if((*y).c==false)</span><br><span class="line">            &#123;</span><br><span class="line">                (*(*z).p).c=true;</span><br><span class="line">                (*y).c=true;</span><br><span class="line">                (*(*(*z).p).p).c=false;</span><br><span class="line">                z=(*(*z).p).p;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                if(z==(*(*z).p).l)</span><br><span class="line">                &#123;</span><br><span class="line">                    z=(*z).p;</span><br><span class="line">                    myRB_Tree::Right_Rotate(z);</span><br><span class="line">                &#125;</span><br><span class="line">                (*(*z).p).c=true;</span><br><span class="line">                (*(*(*z).p).p).c=false;</span><br><span class="line">                myRB_Tree::Left_Rotate((*(*z).p).p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    (*root).c=true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void myRB_Tree::Left_Rotate(node * x)</span><br><span class="line">&#123;</span><br><span class="line">    node * y= (*x).r;</span><br><span class="line">    (*x).r=(*y).l;</span><br><span class="line">    if((*y).l!=&amp;mynil)</span><br><span class="line">        (*(*y).l).p=x;</span><br><span class="line">    (*y).p=(*x).p;</span><br><span class="line">    if((*x).p==&amp;mynil)</span><br><span class="line">        root=y;</span><br><span class="line">    else if(x==(*(*x).p).l)</span><br><span class="line">        (*(*x).p).l=y;</span><br><span class="line">    else</span><br><span class="line">        (*(*x).p).r=y;</span><br><span class="line">    (*y).l=x;</span><br><span class="line">    (*x).p=y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void myRB_Tree::Right_Rotate(node * x)</span><br><span class="line">&#123;</span><br><span class="line">    node * y= (*x).l;</span><br><span class="line">    (*x).l=(*y).r;</span><br><span class="line">    if((*y).r!=&amp;mynil)</span><br><span class="line">        (*(*y).r).p=x;</span><br><span class="line">    (*y).p=(*x).p;</span><br><span class="line">    if((*x).p==&amp;mynil)</span><br><span class="line">        root=y;</span><br><span class="line">    else if(x==(*(*x).p).r)</span><br><span class="line">        (*(*x).p).r=y;</span><br><span class="line">    else</span><br><span class="line">        (*(*x).p).l=y;</span><br><span class="line">    (*y).r=x;</span><br><span class="line">    (*x).p=y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void myRB_Tree::Transplant(node * u, node * v)</span><br><span class="line">&#123;</span><br><span class="line">    if((*u).p==&amp;mynil)</span><br><span class="line">        root=v;</span><br><span class="line">    else if(u==(*(*u).p).l)</span><br><span class="line">        (*(*u).p).l=v;</span><br><span class="line">    else</span><br><span class="line">        (*(*u).p).r=v;</span><br><span class="line">    (*v).p=(*u).p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void myRB_Tree::Delete(node * z)</span><br><span class="line">&#123;</span><br><span class="line">    node * y=z;</span><br><span class="line">    node * x;</span><br><span class="line">    bool y_original_color=(*y).c;</span><br><span class="line">    if((*z).l==&amp;mynil)</span><br><span class="line">    &#123;</span><br><span class="line">        x=(*z).r;</span><br><span class="line">        myRB_Tree::Transplant(z,(*z).r);</span><br><span class="line">    &#125;</span><br><span class="line">    else if((*z).r==&amp;mynil)</span><br><span class="line">    &#123;</span><br><span class="line">        x=(*z).l;</span><br><span class="line">        myRB_Tree::Transplant(z,(*z).l);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        y=myRB_Tree::Minimum((*z).r);</span><br><span class="line">        y_original_color=(*y).c;</span><br><span class="line">        x=(*y).r;</span><br><span class="line">        if((*y).p==z)</span><br><span class="line">            (*x).p=y;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            myRB_Tree::Transplant(y,(*y).r);</span><br><span class="line">            (*y).r=(*z).r;</span><br><span class="line">            (*(*y).r).p=y;</span><br><span class="line">        &#125;</span><br><span class="line">        myRB_Tree::Transplant(z,y);</span><br><span class="line">        (*y).l=(*z).l;</span><br><span class="line">        (*(*y).l).p=y;</span><br><span class="line">        (*y).c=(*z).c;</span><br><span class="line">    &#125;</span><br><span class="line">    if(y_original_color==true)</span><br><span class="line">        myRB_Tree::Delete_Fixup(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void myRB_Tree::Delete_Fixup(node * x)</span><br><span class="line">&#123;</span><br><span class="line">    node * w;</span><br><span class="line">    while(x!=root and (*x).c==true)</span><br><span class="line">    &#123;</span><br><span class="line">        if(x==(*(*x).p).l)</span><br><span class="line">        &#123;</span><br><span class="line">            w=(*(*x).p).r;</span><br><span class="line">            if((*w).c==false)</span><br><span class="line">            &#123;</span><br><span class="line">                (*w).c=true;</span><br><span class="line">                (*(*x).p).c=false;</span><br><span class="line">                myRB_Tree::Right_Rotate((*x).p);</span><br><span class="line">                w=(*(*x).p).r;</span><br><span class="line">            &#125;</span><br><span class="line">            if((*(*w).l).c==true &amp;&amp; (*(*w).r).c==true)</span><br><span class="line">            &#123;</span><br><span class="line">                (*w).c=false;</span><br><span class="line">                x=(*x).p;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                if((*(*w).r).c==true)</span><br><span class="line">                &#123;</span><br><span class="line">                    (*(*w).l).c=true;</span><br><span class="line">                    (*w).c=false;</span><br><span class="line">                    myRB_Tree::Left_Rotate(w);</span><br><span class="line">                    w=(*(*x).p).r;</span><br><span class="line">                &#125;</span><br><span class="line">                (*w).c=(*(*x).p).c;</span><br><span class="line">                (*(*x).p).c=true;</span><br><span class="line">                (*(*w).r).c=true;</span><br><span class="line">                myRB_Tree::Right_Rotate((*x).p);</span><br><span class="line">                x=root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            w=(*(*x).p).l;</span><br><span class="line">            if((*w).c==false)</span><br><span class="line">            &#123;</span><br><span class="line">                (*w).c=true;</span><br><span class="line">                (*(*x).p).c=false;</span><br><span class="line">                myRB_Tree::Right_Rotate((*x).p);</span><br><span class="line">                w=(*(*x).p).l;</span><br><span class="line">            &#125;</span><br><span class="line">            if((*(*w).r).c==true &amp;&amp; (*(*w).l).c==true)</span><br><span class="line">            &#123;</span><br><span class="line">                (*w).c=false;</span><br><span class="line">                x=(*x).p;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                if((*(*w).l).c==true)</span><br><span class="line">                &#123;</span><br><span class="line">                    (*(*w).r).c=true;</span><br><span class="line">                    (*w).c=false;</span><br><span class="line">                    myRB_Tree::Left_Rotate(w);</span><br><span class="line">                    w=(*(*x).p).l;</span><br><span class="line">                &#125;</span><br><span class="line">                (*w).c=(*(*x).p).c;</span><br><span class="line">                (*(*x).p).c=true;</span><br><span class="line">                (*(*w).l).c=true;</span><br><span class="line">                myRB_Tree::Right_Rotate((*x).p);</span><br><span class="line">                x=root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">node * myRB_Tree::Minimum(node * z)</span><br><span class="line">&#123;</span><br><span class="line">    while((*z).l!=&amp;mynil)</span><br><span class="line">        z=(*z).l;</span><br><span class="line">    return z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">node * myRB_Tree::Search(node * x,int k)</span><br><span class="line">&#123;</span><br><span class="line">    if(x==&amp;mynil || k==(*x).key)</span><br><span class="line">        return x;</span><br><span class="line">    if(k&lt;(*x).key)</span><br><span class="line">    &#123;</span><br><span class="line">        counter++;</span><br><span class="line">        return myRB_Tree::Search((*x).l,k);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        counter++;</span><br><span class="line">        return myRB_Tree::Search((*x).r,k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">myRB_Tree T;</span><br><span class="line">void myinsert(int key)</span><br><span class="line">&#123;</span><br><span class="line">    node * p=new node;</span><br><span class="line">    (*p).key=key;</span><br><span class="line">    p-&gt;l=&amp;T.mynil;</span><br><span class="line">    p-&gt;r=&amp;T.mynil;</span><br><span class="line">    T.Insert(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void mydelete(int key)</span><br><span class="line">&#123;</span><br><span class="line">    node * p = T.Search(T.root,key);</span><br><span class="line">    T.Delete(p);</span><br><span class="line">    delete(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;下面是基于C++的BST类实现&lt;/p&gt;
    
    </summary>
    
    
      <category term="algorithm" scheme="https://ricky-ting.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>微积分五讲</title>
    <link href="https://ricky-ting.github.io/2018/05/14/%E5%BE%AE%E7%A7%AF%E5%88%86%E4%BA%94%E8%AE%B2/"/>
    <id>https://ricky-ting.github.io/2018/05/14/微积分五讲/</id>
    <published>2018-05-14T12:47:58.000Z</published>
    <updated>2018-05-14T12:49:56.146Z</updated>
    
    <content type="html"><![CDATA[<h1 id="微积分五讲-笔记"><a href="#微积分五讲-笔记" class="headerlink" title="微积分五讲 笔记"></a>微积分五讲 笔记</h1><p>希尔伯特的演讲：数学中每一步真正的发展都与更有力的工具和更简单的方法的发现密切联系着，这些工具和方法同时会有助于理解已有的理论并把陈旧的、复杂的东西抛到一边。数学科学发展的这种特点是根深蒂固。</p><a id="more"></a><p>黎曼几何  爱因斯坦的相对论正是以“Riemann几何”作为其数学工具的</p><p>学习数学实际上就是一个以”高级“替代“低级”的过程，否则靠死记硬背，最后将会忘掉一切。</p><p>一元微积分的微积分基本定理的建立标志着微积分的诞生；分析算术化的胜利标志着微积分严格化的完成；外微分形式的产生，建立了多元微积分的微积分基本定理，标志着微积分的完成，并从古典走向近代。</p><p>非标准分析</p><p>分析算术化不是微积分严格化的唯一途径。</p><p>可微一定可积吗？ 不一定 导函数可能无界</p><p>扩展微积分：Lebesgue积分理论，现在称为实变函数或实分析</p><p>形象表述：先按钞票面值的大小分类，然后计算每一类的面额总值，再相加，这就是我的积分思想。如不按面值大小分类，而是按从钱袋中摸出的先后次序来计算总是，那就是Riemann积分的思想</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;微积分五讲-笔记&quot;&gt;&lt;a href=&quot;#微积分五讲-笔记&quot; class=&quot;headerlink&quot; title=&quot;微积分五讲 笔记&quot;&gt;&lt;/a&gt;微积分五讲 笔记&lt;/h1&gt;&lt;p&gt;希尔伯特的演讲：数学中每一步真正的发展都与更有力的工具和更简单的方法的发现密切联系着，这些工具和方法同时会有助于理解已有的理论并把陈旧的、复杂的东西抛到一边。数学科学发展的这种特点是根深蒂固。&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="https://ricky-ting.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>git笔记</title>
    <link href="https://ricky-ting.github.io/2018/04/15/git%E7%AC%94%E8%AE%B0/"/>
    <id>https://ricky-ting.github.io/2018/04/15/git笔记/</id>
    <published>2018-04-15T07:11:08.000Z</published>
    <updated>2018-04-15T07:12:18.627Z</updated>
    
    <content type="html"><![CDATA[<h1 id="git笔记"><a href="#git笔记" class="headerlink" title="git笔记"></a>git笔记</h1><p><code>git init</code> 初始化</p> <a id="more"></a><p>单独执行”git”指令会显示辅助说明;执行”git help -a”则显示完整的指令列表;执行 “git 指令 -help”(例如 “git init -help”) 则会显示该指令的网页说明文件。</p><p><code>git add filename</code></p><p><code>git commit -m &quot;description&quot; --author=&quot;name &lt;email&gt;&quot;</code>        </p><p><code>git commit --amend -m &#39;new description&#39; --author=&quot;name &lt;email&gt;&quot;</code></p><p><code>exit</code></p><p><code>.gitignore</code>忽略特定文件</p><p>Git有三个不同级别的配置文件,它们有不同的优先权.</p><ol><li>文件夹”.git”子文件夹内的config文件(只对它所在的文档库有效)</li><li>登陆账号的home directory中的.gitconfig文件(只对此账号登陆的用户有效)</li><li>Git程序的安装文件夹中的etc\gitconfig文件(对所有登陆账号和所有Git文档库都有效)</li></ol><p><code>git congif -l</code> 显示当前git的设置值。会显示三个配置文件中所有的设置项，顺序是先显示优先权最低的设置</p><p><code>git config --system -l</code><br><code>git config --global -l</code></p><p><code>git config user.name &quot;name&quot;</code><br><code>git config user.email &quot;email&quot;</code></p><p><code>git config --unset user.name</code></p><p><code>git config alias.指令别名 &#39;正式的指令和选项&#39;</code> 别名    </p><p><code>git commit</code> 启动文本编辑器来输入commit</p><p><code>git diff</code>    </p><p>Git 会将文件和文件夹分成以下三类:</p><ol><li>被追踪的(tracked);</li><li>忽略的(ignored);</li><li>不被追踪的(untracked);</li></ol><p><code>touch .gitignore</code></p><p><code>git rm --cached 文件名</code> add之后删除 这个文件将从tracked状态变成untracked状态</p><p><code>git reset HEAD 文件名</code> commit之后</p><p>取出文件:<code>git checkout commit 节点标识符或标签 文件1 文件2 ...</code>文件夹中的文件会被取出的文件覆盖</p><p><code>git grep</code></p><p><code>git blame</code></p><p><code>git mb 原文件名 新文件名</code> </p><p><code>git gc</code> 清理文档库</p><p><code>git log</code></p><p><code>git branch</code></p><p>一般情况下在切换分支之前，会先把最新的文件内容存入文档库</p><p><code>git branch -d 要删除的分支名称</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;git笔记&quot;&gt;&lt;a href=&quot;#git笔记&quot; class=&quot;headerlink&quot; title=&quot;git笔记&quot;&gt;&lt;/a&gt;git笔记&lt;/h1&gt;&lt;p&gt;&lt;code&gt;git init&lt;/code&gt; 初始化&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="https://ricky-ting.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="git" scheme="https://ricky-ting.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>OJ笔记#1</title>
    <link href="https://ricky-ting.github.io/2018/03/26/OJ%E7%AC%94%E8%AE%B0-1/"/>
    <id>https://ricky-ting.github.io/2018/03/26/OJ笔记-1/</id>
    <published>2018-03-26T03:08:21.000Z</published>
    <updated>2018-03-26T03:11:58.432Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OJ笔记-1"><a href="#OJ笔记-1" class="headerlink" title="OJ笔记#1"></a>OJ笔记#1</h1><h2 id="Non-negative-Partial-Sums"><a href="#Non-negative-Partial-Sums" class="headerlink" title="Non-negative Partial Sums"></a>Non-negative Partial Sums</h2><h3 id="My-soultion"><a href="#My-soultion" class="headerlink" title="My soultion"></a>My soultion</h3><p>不断减小序列的长度，最后两个负数间至少有一个整数，最后序列的第一个元素(正常情况下)为正数，最后一个元素可正可负</p> <a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">ios::sync_with_stdio(false);</span><br><span class="line">int n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">while(n!=0)</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;int&gt; a;</span><br><span class="line">bool b[1000000]=&#123;true&#125;;</span><br><span class="line">for(int i=0;i&lt;=n-1;i++)</span><br><span class="line">&#123;</span><br><span class="line">int in;</span><br><span class="line">cin&gt;&gt;in;</span><br><span class="line">a.push_back(in);</span><br><span class="line">if(i&gt;=1)</span><br><span class="line">&#123;</span><br><span class="line">if(a[a.size()-1]&lt;0)</span><br><span class="line">&#123;</span><br><span class="line">while(a.size()&gt;=2 &amp;&amp; a[a.size()-1]+a[a.size()-2]&lt;0)</span><br><span class="line">&#123;</span><br><span class="line">a[a.size()-2]+=a[a.size()-1];</span><br><span class="line">a.pop_back();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">if(a.size()&gt;1 &amp;&amp; a[0]&lt;0)</span><br><span class="line">&#123;</span><br><span class="line">a.push_back(a[0]);</span><br><span class="line">a.erase(a.begin());</span><br><span class="line">&#125;</span><br><span class="line">while(a.size()&gt;=2 &amp;&amp; a[a.size()-1]+a[a.size()-2]&lt;0)</span><br><span class="line">&#123;</span><br><span class="line">a[a.size()-2]+=a[a.size()-1];</span><br><span class="line">a.pop_back();</span><br><span class="line">&#125;</span><br><span class="line">int counter=0;</span><br><span class="line">for(int i=0;i&lt;a.size();i++)</span><br><span class="line">if(a[i]&gt;=0)</span><br><span class="line">counter++;</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;counter&lt;&lt;endl;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提高cin cout效率</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;OJ笔记-1&quot;&gt;&lt;a href=&quot;#OJ笔记-1&quot; class=&quot;headerlink&quot; title=&quot;OJ笔记#1&quot;&gt;&lt;/a&gt;OJ笔记#1&lt;/h1&gt;&lt;h2 id=&quot;Non-negative-Partial-Sums&quot;&gt;&lt;a href=&quot;#Non-negative-Partial-Sums&quot; class=&quot;headerlink&quot; title=&quot;Non-negative Partial Sums&quot;&gt;&lt;/a&gt;Non-negative Partial Sums&lt;/h2&gt;&lt;h3 id=&quot;My-soultion&quot;&gt;&lt;a href=&quot;#My-soultion&quot; class=&quot;headerlink&quot; title=&quot;My soultion&quot;&gt;&lt;/a&gt;My soultion&lt;/h3&gt;&lt;p&gt;不断减小序列的长度，最后两个负数间至少有一个整数，最后序列的第一个元素(正常情况下)为正数，最后一个元素可正可负&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="https://ricky-ting.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="OJ" scheme="https://ricky-ting.github.io/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>无法接触的方程</title>
    <link href="https://ricky-ting.github.io/2018/02/25/%E6%97%A0%E6%B3%95%E8%A7%A3%E5%87%BA%E7%9A%84%E6%96%B9%E7%A8%8B/"/>
    <id>https://ricky-ting.github.io/2018/02/25/无法解出的方程/</id>
    <published>2018-02-25T05:02:36.000Z</published>
    <updated>2018-02-25T05:04:30.483Z</updated>
    
    <content type="html"><![CDATA[<h1 id="无法解出的方程"><a href="#无法解出的方程" class="headerlink" title="无法解出的方程"></a>无法解出的方程</h1><p>平移对称 旋转对称 反射对称 滑移反射对称 置换 </p><a id="more"></a><p>量子力学是以概率的语言表述的</p><p>立体视觉,两只眼睛看到的像是不同的</p><p>这样一个问题:在我们周围的环境中，可以进行什么操作而让描述所有观察到的现象的规律不变？</p><p>棋盘是世界，棋子是宇宙中的诸现象，游戏规则是我们所称的自然规律。当代物理学家希望自然规律不仅代表游戏规则，而且可以解释棋盘和棋子本身的存在与特点！</p><p>有关宇宙唯一可以确定的是各种结果的概率，而非结果本身。上帝确实在掷骰子。</p><p>对称性是破解大自然设计奥秘的一种最重要的工具。</p><p>定义一个群的特点是：</p><ol><li>封闭性</li><li>结合律</li><li>单位元</li><li>逆元素</li></ol><p>由这个简单的定义可以产生一种包含和统一了世界上所有对称性的理论，这个事实一直令数学家吃惊。</p><p>群论被称为“数学抽象地顶尖艺术”</p><p>任何系统的所有对称变换集总是形成一个群。</p><p>爱因斯坦在”科学与幸福”的演讲中谈到:”对于人类自身及其命运的关注组成了所有技术努力的主要目标”</p><p>丢番图方程:如<code>29x+4=8y</code>(整数解).历史上最著名的丢番图方程是被称为费马大定理的那个方程<code>x^n + y^n = z^n</code>对于<code>n&gt;2</code>没有整数解。</p><p>阿贝尔和伽罗瓦</p><p>置换是伽罗瓦证明中的精华</p><p>魔方谜题的解答完全可以用群论的语言来说明</p><p>对置换性质的分析使我们可以自信地预测最终的结果，而不必实际进行试验。这也是伽罗瓦理论背后的基本哲学。</p><p>一个群中元素的数量叫做群的阶。例如，三个对象的置换群$S_3$的阶是6.</p><p>任何对象的对称集合构成一个群。</p><p>每一个群都映射在具有相同的模的置换群上。(同构)</p><p>子群。母群的阶除以子群的阶等于指数，指数总为整数。有限子群的阶总是等分其有限母群的阶。</p><p>正规子群</p><p>伽罗瓦证明，一个方程要有公式解，方程必须具有一种特定类型的伽罗瓦群特别地，如果由后代最大正规子群产生的每一个单独的指数是一个素数，那么伽罗瓦称这个群是可解的。一个方程存在公式解的条件是其伽罗瓦群可解。</p><p>伽罗瓦对五次方程解的寻找产生了“数学抽象地顶尖艺术”——群论。</p><p>一种相同的群结构可以描述似乎全然不同的概念</p><p>公式语言在计算机科学和复杂性理论(涉及计算任务内在的复杂性)方面起着重要作用。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;无法解出的方程&quot;&gt;&lt;a href=&quot;#无法解出的方程&quot; class=&quot;headerlink&quot; title=&quot;无法解出的方程&quot;&gt;&lt;/a&gt;无法解出的方程&lt;/h1&gt;&lt;p&gt;平移对称 旋转对称 反射对称 滑移反射对称 置换 &lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="https://ricky-ting.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="读书" scheme="https://ricky-ting.github.io/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>读的书与想读的书(除计算机)</title>
    <link href="https://ricky-ting.github.io/2018/02/23/%E8%AF%BB%E7%9A%84%E4%B9%A6%E4%B8%8E%E6%83%B3%E8%AF%BB%E7%9A%84%E4%B9%A6-%E9%99%A4%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    <id>https://ricky-ting.github.io/2018/02/23/读的书与想读的书-除计算机/</id>
    <published>2018-02-23T04:14:49.000Z</published>
    <updated>2018-05-20T12:26:26.106Z</updated>
    
    <content type="html"><![CDATA[<h1 id="读的书与想读的书-除计算机"><a href="#读的书与想读的书-除计算机" class="headerlink" title="读的书与想读的书(除计算机)"></a>读的书与想读的书(除计算机)</h1><p>斜体为未读，粗体为在读</p> <a id="more"></a><h2 id="文史哲"><a href="#文史哲" class="headerlink" title="文史哲"></a>文史哲</h2><ul><li><em>中国文学欣赏举隅</em></li><li>吾国吾民</li><li>罗生门</li><li>中国哲学简史</li></ul><h2 id="科普类"><a href="#科普类" class="headerlink" title="科普类"></a>科普类</h2><ul><li>无法解出的方程</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;读的书与想读的书-除计算机&quot;&gt;&lt;a href=&quot;#读的书与想读的书-除计算机&quot; class=&quot;headerlink&quot; title=&quot;读的书与想读的书(除计算机)&quot;&gt;&lt;/a&gt;读的书与想读的书(除计算机)&lt;/h1&gt;&lt;p&gt;斜体为未读，粗体为在读&lt;/p&gt;
    
    </summary>
    
    
      <category term="计划" scheme="https://ricky-ting.github.io/tags/%E8%AE%A1%E5%88%92/"/>
    
      <category term="记录" scheme="https://ricky-ting.github.io/tags/%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>读的书与想读的书(计算机)</title>
    <link href="https://ricky-ting.github.io/2018/02/23/%E8%AF%BB%E7%9A%84%E4%B9%A6%E4%B8%8E%E6%83%B3%E8%AF%BB%E7%9A%84%E4%B9%A6-%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    <id>https://ricky-ting.github.io/2018/02/23/读的书与想读的书-计算机/</id>
    <published>2018-02-23T04:14:26.000Z</published>
    <updated>2018-02-23T04:16:14.977Z</updated>
    
    <content type="html"><![CDATA[<h1 id="读的书与想读的书-计算机方面"><a href="#读的书与想读的书-计算机方面" class="headerlink" title="读的书与想读的书(计算机方面)"></a>读的书与想读的书(计算机方面)</h1><p>斜体为未读，粗体为在读</p> <a id="more"></a><h2 id="程序语言方面"><a href="#程序语言方面" class="headerlink" title="程序语言方面:"></a>程序语言方面:</h2><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><ul><li><em>C++ Primer</em></li></ul><h2 id="算法方面："><a href="#算法方面：" class="headerlink" title="算法方面："></a>算法方面：</h2><ul><li><em>算法导论</em></li></ul><h2 id="数学方面"><a href="#数学方面" class="headerlink" title="数学方面"></a>数学方面</h2><ul><li><strong>离散数学及其应用</strong></li><li><em>具体数学</em></li></ul><h2 id="Linux-Unix-Mac-OS-X-方面"><a href="#Linux-Unix-Mac-OS-X-方面" class="headerlink" title="Linux/Unix/Mac OS X 方面"></a>Linux/Unix/Mac OS X 方面</h2><h2 id="体系结构方面"><a href="#体系结构方面" class="headerlink" title="体系结构方面"></a>体系结构方面</h2><ul><li><em>深入理解计算机系统</em></li></ul><h2 id="科普类"><a href="#科普类" class="headerlink" title="科普类"></a>科普类</h2><ul><li><em>编码：隐匿在计算机软硬件背后的语言</em></li><li><em>黑客与画家</em></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;读的书与想读的书-计算机方面&quot;&gt;&lt;a href=&quot;#读的书与想读的书-计算机方面&quot; class=&quot;headerlink&quot; title=&quot;读的书与想读的书(计算机方面)&quot;&gt;&lt;/a&gt;读的书与想读的书(计算机方面)&lt;/h1&gt;&lt;p&gt;斜体为未读，粗体为在读&lt;/p&gt;
    
    </summary>
    
    
      <category term="计划" scheme="https://ricky-ting.github.io/tags/%E8%AE%A1%E5%88%92/"/>
    
      <category term="记录" scheme="https://ricky-ting.github.io/tags/%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Unix Programming Tools</title>
    <link href="https://ricky-ting.github.io/2018/02/15/Unix-Programming-Tools/"/>
    <id>https://ricky-ting.github.io/2018/02/15/Unix-Programming-Tools/</id>
    <published>2018-02-15T04:43:11.000Z</published>
    <updated>2018-02-16T06:38:57.802Z</updated>
    
    <content type="html"><![CDATA[<p><strong>已弃坑 待更</strong></p><h1 id="gcc"><a href="#gcc" class="headerlink" title="gcc"></a>gcc</h1><p>Gcc can compile C,C++(maybe g++),and objective-C. It is both a compiler and linker.</p><a id="more"></a><p>一步到位：<code>gcc main.c module1.c module2.c -o program</code></p><p>分开：<code>gcc -c main.c</code> <code>gcc -c module1.c</code> <code>gcc -c module2.c</code> <code>gcc main.o module1.o module2.o -o program</code></p><h2 id="command-line-options"><a href="#command-line-options" class="headerlink" title="command-line options"></a>command-line options</h2><p>-c <em>files</em> : Direct gcc to compile the source files into an object files without going through the linking stage. Makefiles (below) use this option to compile files one at a time.</p><p>-o <em>file</em> : Specifies that gcc’s output should be named file. If this option is not specified, then the default name used depends on the context…(a) if compiling a source .c file, the output object file will be named with the same name but with a .o extension. Alternately, (b) if linking to create an executable, the output file will be named a.out. Most often, the -o option is used to specify the output filename when linking an executable, while for compiling, people just let the default .c/.o naming take over.It’s a memorable error if your -o option gets switched around in the command line so it accidentally comes before a source file like “…-o foo.c program” – this can overwrite your source file – bye bye source file!</p><p>-g : Directs the compiler to include extra debugging information in its output. We recommend that you always compile your source with this option set, since we encourage you to gain proficiency using the debugger such as gdb (below).</p><p>-Wall : Give warnings about possible errors in the source code. </p><p>-I<em>dir</em> : Adds the directory dir to the list of directories searched for #include files.</p><p>-l<em>mylib</em> : (lower case ‘L’) Search the library named mylib for unresolved symbols (functions, global variables) when linking. The actual name of the file will be libmylib.a, and must be found in either the default locations for libraries or in a directory added with the -L flag (below).</p><p>-L<em>dir</em> </p><h1 id="make"><a href="#make" class="headerlink" title="make"></a>make</h1><p>The “make” utility automates the process of compiling and linking.</p><p>run make with no arguments in the project directory.and it will search for a file called <code>Makefile</code> or <code>makefile</code> for its build instructions.</p><h2 id="Makefiles"><a href="#Makefiles" class="headerlink" title="Makefiles"></a>Makefiles</h2><p>variable: for example <code>CC=gcc</code></p><p>standard variable names: </p><p>CC: The name of the C compiler, this will default to cc or gcc in most versions of make.</p><p>CFLAGS: A list of options to pass on to the C compiler for all of your source files. This is commonly used to set the include path to include non- standard directories (-I) or build debugging versions (-g).</p><p>LDFLAGS: A list of options to pass on to the linker. This is most commonly used to include application specific library files (-l) and set the library search path (-L).</p><p>To refer to the value of a variable, put a dollar sign ($) followed by the name in parenthesis or curly braces…</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CFLAGS = -g -I/usr/class/cs107/include</span><br><span class="line">$(CC) $(CFLAGS) -c binky.c</span><br></pre></td></tr></table></figure><p>The second major component of a makefile is the dependency/build rule.</p><p>A rule generally consists of two lines: a dependency line followed by a command line.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">binky.o : binky.c binky.h akbar.h </span><br><span class="line">tab$(CC) $(CFLAGS) -c binky.c</span><br></pre></td></tr></table></figure><h1 id="Unix-Shell"><a href="#Unix-Shell" class="headerlink" title="Unix Shell"></a>Unix Shell</h1><h2 id="Directory-Commands"><a href="#Directory-Commands" class="headerlink" title="Directory Commands"></a>Directory Commands</h2><p>cd <em>directory</em>: change directory</p><p>pwd : print working(current) directory</p><p>rm <em>file</em>: delete a file</p><p>mv <em>old</em> <em>new</em> : Rename a file(also works for moving things between directories).If exists, overwritten.</p><p>mkdir <em>name</em> : Create a directory</p><p>rmdir name : Delete a directory(must be empty)</p><h2 id="Shorthand-Notations-amp-Wildcards"><a href="#Shorthand-Notations-amp-Wildcards" class="headerlink" title="Shorthand Notations &amp; Wildcards"></a>Shorthand Notations &amp; Wildcards</h2><p>. : Current Directory</p><p>.. : Parent Directory</p><p>~ : Your home directory</p><p>~/cs107 : The cs107 directory in your home directory</p><p>~<em>user</em> : Home directory of <em>user</em></p><p> 通配符 : Any number of characters(not ‘.’)</p><p>? : Any single character(not ‘.’)</p><h2 id="Miscellaneous-Commands"><a href="#Miscellaneous-Commands" class="headerlink" title="Miscellaneous Commands"></a>Miscellaneous Commands</h2><p>cat <em>file</em> : Print the contents of <em>file</em> to standard output </p><p>more <em>file</em> : Same as <em>cat</em>,but only a page at a time.</p><p>less <em>file</em> : Same as <em>more</em>,but with navigability.</p><p>w : Find out who is on the system and what they are doing.</p><p>ps : List all your processed(use the process id’s in <strong>kill</strong> below)</p><p>jobs : Show jobs that have been suspended(use with fg)</p><p><em>program</em>&amp; : Runs <em>program</em> in the background.</p><p>ctrl-z : Suspend the current program.</p><p>% : Continue last job suspended, or use <strong>fg</strong>(foreground)</p><p>%<em>number</em> : Continue a particular job(the number comes from the <em>jobs</em> list)</p><p>kill <em>process-id</em> : Kill a process</p><p>kill -9 <em>process</em> : Kill a process with extreme prejudice </p><p>grep <em>exp</em> <em>files</em> : Search for an expression in a set of files.</p><p>wc <em>files</em> : Count words,lines and characters in a file</p><p>script : Start saving everything that happens in a file. Type <strong>exit</strong> when done</p><p>lpr <em>file</em> : Print <em>file</em> to the default printer</p><p>lpr -Pinky <em>file</em> : Print <em>file</em> to the printer named <em>inky</em></p><p>diff <em>file1</em> <em>file2</em> Show the differences between two files.</p><p>telnet <em>hostname</em> : Log on to another machine</p><p>source <em>file</em> : Execute the lines in the given file as if they were typed to the shell</p><h2 id="Getting-Help"><a href="#Getting-Help" class="headerlink" title="Getting Help"></a>Getting Help</h2><p>man <em>subject</em> : Read the manual entry on a particular subject</p><p>man -k keyword : Show all the manual pages for a particular keyword</p><h2 id="History"><a href="#History" class="headerlink" title="History"></a>History</h2><p>history : Show the most recent commands executed</p><p>!! : Re-execute the last command (or type up-arrow with modern shells)</p><p>!number : Re-execute a particular command by number</p><p>!<em>string</em> : Re-execute the last command beginning with string </p><p>^wrong^right^ : Re-execute the last command, substituting right for wrong</p><p>ctrl-P : Scroll backwards through previous commands</p><h2 id="Pipes"><a href="#Pipes" class="headerlink" title="Pipes"></a>Pipes</h2><p>a &gt; b : Redirect a’s standard output to overwrite file b</p><p>a &gt;&gt; b : Redirect a’s standard output to append to the file b</p><p>a &gt;&amp; b : Redirect a’s error output to overwrite file b</p><p>a &lt; b : Redirect a’s standard input to read from the file b</p><p>a | b : Redirect a’s standard output to b’s standard input</p><p>参考:<a href="http://cslibrary.stanford.edu/107/UnixProgrammingTools.pdf" target="_blank" rel="noopener">Unix Programming Tools from Standford Univer</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;已弃坑 待更&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;gcc&quot;&gt;&lt;a href=&quot;#gcc&quot; class=&quot;headerlink&quot; title=&quot;gcc&quot;&gt;&lt;/a&gt;gcc&lt;/h1&gt;&lt;p&gt;Gcc can compile C,C++(maybe g++),and objective-C. It is both a compiler and linker.&lt;/p&gt;
    
    </summary>
    
    
      <category term="Unix" scheme="https://ricky-ting.github.io/tags/Unix/"/>
    
      <category term="Tools" scheme="https://ricky-ting.github.io/tags/Tools/"/>
    
      <category term="Programming" scheme="https://ricky-ting.github.io/tags/Programming/"/>
    
  </entry>
  
  <entry>
    <title>2017秋寒假待学习内容(这是一篇flag) 2018.2</title>
    <link href="https://ricky-ting.github.io/2018/02/13/2017%E7%A7%8B%E5%AF%92%E5%81%87%E5%BE%85%E5%AD%A6%E4%B9%A0%E5%86%85%E5%AE%B9-%E8%BF%99%E6%98%AF%E4%B8%80%E7%AF%87flag-2018-2/"/>
    <id>https://ricky-ting.github.io/2018/02/13/2017秋寒假待学习内容-这是一篇flag-2018-2/</id>
    <published>2018-02-13T05:14:08.000Z</published>
    <updated>2018-07-08T01:13:43.931Z</updated>
    
    <content type="html"><![CDATA[<ul><li>机器学习</li><li>编写可读代码的艺术</li><li>离散数学及其应用</li><li>配置软件</li><li>github学习</li><li>git学习</li><li>…</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;机器学习&lt;/li&gt;
&lt;li&gt;编写可读代码的艺术&lt;/li&gt;
&lt;li&gt;离散数学及其应用&lt;/li&gt;
&lt;li&gt;配置软件&lt;/li&gt;
&lt;li&gt;github学习&lt;/li&gt;
&lt;li&gt;git学习&lt;/li&gt;
&lt;li&gt;…&lt;/li&gt;
&lt;/ul&gt;

      
    
    </summary>
    
    
      <category term="flag" scheme="https://ricky-ting.github.io/tags/flag/"/>
    
      <category term="计划" scheme="https://ricky-ting.github.io/tags/%E8%AE%A1%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>机器学习(周志华)笔记</title>
    <link href="https://ricky-ting.github.io/2018/02/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%91%A8%E5%BF%97%E5%8D%8E-%E7%AC%94%E8%AE%B0/"/>
    <id>https://ricky-ting.github.io/2018/02/13/机器学习-周志华-笔记/</id>
    <published>2018-02-13T03:38:41.000Z</published>
    <updated>2018-02-14T04:55:59.093Z</updated>
    
    <content type="html"><![CDATA[<h1 id="机器学习笔记-学习中-进度堪忧"><a href="#机器学习笔记-学习中-进度堪忧" class="headerlink" title="机器学习笔记(学习中 进度堪忧)"></a>机器学习笔记(学习中 进度堪忧)</h1><h2 id="第1章-绪论"><a href="#第1章-绪论" class="headerlink" title="第1章 绪论"></a>第1章 绪论</h2><h3 id="1-1-引言"><a href="#1-1-引言" class="headerlink" title="1.1 引言"></a>1.1 引言</h3><p>通过对经验的利用，就能对新情况做出有效的决策。计算机在这方面可以帮忙。</p><p>机器学习致力于研究如何通过计算的手段，利用经验来改善系统自身的性能。机器学习所研究的主要内容，是关于在计算机上从数据中产生“模型”(model)的算法，即”学习算法”(learning algorithm).</p> <a id="more"></a><h3 id="1-2-基本术语"><a href="#1-2-基本术语" class="headerlink" title="1.2 基本术语"></a>1.2 基本术语</h3><p>一组记录的集合称为一个“数据集”(data set),其中每条记录是关于一个事件或对象的描述，称为一个“示例”(instance)或”样本”(sample)</p><p>反映事件或对象在某方面的表现或性质的事项称为”属性”(attribute)或”特征”(feature).属性上的取值称为”属性值”(attribute value).属性张成的空间称为”属性空间”(attribute space)、”样本空间”(sample space)或”输入空间”.我们也把一个示例称为一个”特征向量”(feature vector).</p><p>每个示例由d个属性描述,d称为样本的”维数”(dimensionality).</p><p>从数据中学得模型的过程称为”学习”(learning)或”训练”(training)</p><p>训练中使用的数据称为”训练数据”(training data),其中每个样本称为一个”训练样本”(training sample),训练样本组成的集合称为”训练集”(training set)</p><p>学得模型对应了关于数据的某种潜在的规律，因此亦称”假设”(hypothesis);这种潜在规律自身，则称为”真相”或”真实”(ground-truth).有时将模型称为”学习器”(learner),可以看作学习算法在给定数据和参数空间上的实例化.</p><p>标记(label);拥有了标记信息的示例,则称为”样例”(example).所有标记的集合称为”标记空间”(label space)或”输出空间”.</p><p>(<strong>x</strong>i,yi)表示第i个样例,<strong>x</strong>i是d维向量.</p><p>若欲预测的是离散值，此类学习任务称为”分类”(classification);若欲预测的是连续值,此类学习任务称为”回归”(regression).</p><p>对于只涉及两个类别的“二分类”(binary classification)任务，通常称其中一个类为”正类”(positive class),另一个类为”反类”(negative class)；涉及多个类别时,则称为“多分类”(multi-class classification)任务。</p><p>学得模型后，使用其进行预测的过程称为“测试”(testing),被预测的样本称为”测试样本”(testing sample) .</p><p>聚类(clustering),即将训练中的示例分成若干组，每组称为一个”簇”(cluster);这些自动形成的簇可能对应一些潜在的概念划分.这样的学习过程有助于我们了解数据内在的规律，能为更深入地分析数据建立基础.</p><p>根据训练数据是否拥有标记信息，学习任务可大致划分为两大类:”监督学习”(supervised learning)和”无监督学习”(unsupervised learning),分类和回归是前者的代表,而聚类则是后者的代表.</p><p>机器学习的目标是使学得的模型能更好地适用于”新样本”，而不是仅仅在训练样本上工作得好.学得模型适用于新样本的能力,称为”泛化”(generalization)能力.</p><p>通常假设样本空间中全体样本服从一个未知”分布”(distribution)<em>D</em>,我们获得的每个样本都是独立地从这个分布上采样获得的,即”独立同分布”(independent and identically distributed,简称<em>i.i.d</em>)</p><h3 id="1-3-假设空间"><a href="#1-3-假设空间" class="headerlink" title="1.3 假设空间"></a>1.3 假设空间</h3><p><em>归纳(induction)和演绎(deduction)科学推理的两大基本手段</em></p><p>归纳学习(inductive learning).狭义的归纳学习要求从训练数据中学得概念(concept),亦称为”概念学习”或”概念形成”.概念学习技术目前研究、应用都比较少，因为要学得泛化性能好且语义明确的概念实在太困难了,现实常用的技术大多是产生”黑箱”模型。</p><p>概念学习中最基本的是布尔概念学习.</p><p>“记住”训练样本，就是所谓的”机械学习”.</p><p>我们可以把学习过程看作一个在所有假设(hypothesis)组成的空间中进行搜索的过程,搜索目标是找到与训练集”匹配”(fit)的假设.现实问题中我们常面临很大的假设空间,但学习过程是基于有限样本训练集进行的,因此，可能有多个假设与训练集一致,即存在着一个与训练集一致的”假设集合”,我们称之为”版本空间”(version space)</p><h3 id="1-4-归纳偏好"><a href="#1-4-归纳偏好" class="headerlink" title="1.4 归纳偏好"></a>1.4 归纳偏好</h3><p>当有多个模型(假设)时，应该采纳哪一个.这时,学习算法本身的”偏好”就会起到关键的作用.</p><p>机器学习算法在学习过程中对某种类型假设的偏好,称为”归纳偏好”(inductive bias),或简称为”偏好”.</p><p>任何一个有效的机器学习算法必有其归纳偏好.</p><p>归纳偏好可看作学习算法自身在一个很庞大的假设空间中对假设进行选择的启发式或”价值观”.“奥卡姆剃刀”(Occam’s razor)是一种常用的、自然科学研究中最基本的原则，即“若有多个假设与观察一致，则选最简单的那个”</p><p>算法的归纳偏好是否与问题本身匹配，大多数时候直接决定了算法能否取得好的性能.</p><p>对于一个学习算法A,若它在某些问题上比学习算法B好,则必然存在另一些问题,在那里B比A好.这个结论对任何算法均成立.<strong>证明待看</strong></p><p>NFL定理(No Free Lunch Theorem)[Wolpert,1996;Wolpert and Macready,1995]</p><p>NFL的最重要寓意，是让我们清楚地认识到,脱离具体问题,空泛地谈论”什么学习算法更好”毫无意义。学习算法自身的归纳偏好与问题是否相配,往往会起到决定性的作用.</p><h3 id="1-5-发展历程"><a href="#1-5-发展历程" class="headerlink" title="1.5 发展历程"></a>1.5 发展历程</h3><p>二十世纪五十年代到七十年代初,人工智能研究处于”推理期”,那时认为人们只要能赋予机器逻辑推理能力，机器就能具有智能.人们逐渐认识到,仅具有逻辑推理能力是远远实现不了人工智能的.后来认为，要使机器具有智能，就必须设法使机器拥有知识.从二十世纪七十年代中期开始,人工智能研究进入了”知识期”。大量专家系统问世。但逐渐的专家系统面临”知识工程瓶颈”，简单地说，就是由人来把知识总结出来再教给计算机是相当困难的.</p><p>二十世纪五十年代初已有机器学习的相关研究,五十年代中后期，基于神经网络的”连接主义”(connectionism)学习开始出现。在六七十年代，基于逻辑表示的“符号主义”(symbolism)学习技术蓬勃发展,以决策理论为基础的学习技术以及强化学习技术等也得到发展。</p><p>总的来看，二十世纪八十年代是机器学习成为一个独立学科领域、各种机器学习技术百花初绽的时期。</p><p>在二十世纪八十年代，“从样例中学习”的一大主流是符号主义学习，其代表包括决策树(decision tree)和基于逻辑的学习.典型的决策树学习以信息论为基础，以信息熵的最小化为目标，直接模拟了人类对概念进行判定的树形流程.决策树学习技术由于简单易用,到今天仍是最常用的机器学习技术之一.</p><p>BP一直是被应用得最广泛的机器学习算法之一.连接主义学习的最大局限是其”试错性”</p><p>二十世纪九十年代中期,”统计学习”(statistical learning)闪亮登场并迅速占据主流舞台,代表性技术是支持向量机(Support Vector Machine,简称SVM)以及更一般的“核方法”(kernel methods).在支持向量机被普遍接受后,核技巧被人们用到了机器学习的几乎每一个角落，核方法(kernel trick)也逐渐成为机器学习的基本内容之一.</p><p>二十一世纪初,连接主义又卷土重来,掀起了以”深度学习”为名的热潮.所谓深度学习，狭义地说就是”很多层”的神经网络.</p><h3 id="1-6-应用现状"><a href="#1-6-应用现状" class="headerlink" title="1.6 应用现状"></a>1.6 应用现状</h3><h2 id="第二章-模型评估与选择"><a href="#第二章-模型评估与选择" class="headerlink" title="第二章 模型评估与选择"></a>第二章 模型评估与选择</h2><h3 id="2-1-经验误差与过拟合"><a href="#2-1-经验误差与过拟合" class="headerlink" title="2.1 经验误差与过拟合"></a>2.1 经验误差与过拟合</h3><p>“错误率”(error rate)：分类错误的样本数占样本总数的比例.</p><p>“精度”(accuracy)：精度 = 1-错误率</p><p>“误差”(error)：学习器的实际预测输出与样本的真实输出之间的差异</p><p>“训练误差”(training error)或”经验误差”(empirical error):学习器在训练集上的误差</p><p>“泛化误差”(generalization error)：学习器在新样本上的误差</p><p>我们希望得到泛化误差小的学习器.然而，我们事先并不知道新样本是什么样的,实际能做的是努力使经验误差最小化.</p><p>“过拟合”(overfitting):当学习器把训练样本学得”太好”了的时候,很可能已经把训练样本本身的一些特点当做了所有潜在样本都会具有的一般性质,这样就会导致泛化性能下降.</p><p>“欠拟合”(underfitting):指对训练样本的一般性质尚未学好。</p><p>欠拟合比较容易克服,例如在决策树学习中扩展分支、在神经网络学习中增加训练轮数等</p><p>过拟合是机器学习面临的关键障碍,过拟合是无法彻底避免的,我们所能做的只是”缓解”.只要相信P $\not=$ NP,过拟合就不可避免.</p><p>机器学习中的”模型选择”(model selection)问题,如何进行模型评估与选择呢？</p><p><strong>疑惑：这里的评估是对学习算法在这特定问题上表现的评估吧？</strong></p><h3 id="2-2-评估方法"><a href="#2-2-评估方法" class="headerlink" title="2.2 评估方法"></a>2.2 评估方法</h3><p>通常，我们可通过实验测试来对学习器的泛化误差进行评估并进而做出选择.为此，需使用一个“测试集”(testing set)来测试学习器对新样本的判别能力,然后以测试集上的“测试误差”(testing error)作为泛化误差的近似.测试集应该尽可能与训练集互斥.</p><p>有限的数据集,如何产生训练集<em>S</em>和测试集<em>T</em>.下面是几种常见的做法</p><h4 id="2-2-1-留出法-hold-out"><a href="#2-2-1-留出法-hold-out" class="headerlink" title="2.2.1 留出法(hold-out)"></a>2.2.1 留出法(hold-out)</h4><p>直接将数据集<em>D</em>划分为两个互斥的集合。</p><p>训练/测试集的划分要尽可能保持数据分布的一致性,避免因数据划分过程中中引入额外的偏差而对最终结果产生影响.”分层采样”(stratified sampling).</p><p>单次使用留出法得到的估计结果往往不够稳定可靠,在使用留出法时,一般要采用若干次随机划分、重复进行试验评估后取平均值作为留出法的评估结果.</p><p>保真性(fidelity),划分比例过大或过小导致的问题没有完美的解决方案,常见做法是将大约2/3~4/5的样本用于训练，剩余样本用于测试.</p><h4 id="2-2-2-交叉验证法-cross-validation"><a href="#2-2-2-交叉验证法-cross-validation" class="headerlink" title="2.2.2 交叉验证法(cross validation)"></a>2.2.2 交叉验证法(cross validation)</h4><p>将数据集<em>D</em>划分为k个子集,保证每个子集数据分布的一致性(可以通过分层采样).每次用k-1个子集训练，剩下的一个做测试集。这样可以得到k组.最后返回k个测试结果的均值.</p><p>这种方法的稳定性和保真性在很大程度上取决于k的取值，通常把这种方法称为”k折交叉验证”(<em>k</em>-fold cross validation).通常k取10</p><p>把数据集D划分为k个子集存在多种方式,所以为了减小划分不同引入的误差,通常要随机使用不同的划分重复p次,最终的评估结果是这p次k折交叉验证结果的均值.</p><p>假定数据集D中包含m个样本,若令k=m，则得到了交叉验证法的一个特例:留一法(Leave-One-Out,简称LOO)。显然，留一法不受随机样本划分方式的影响.留一法的评估结果往往被认为比较准确.留一法也有缺陷:在数据集比较大时，训练m个模型的计算开销可能是难以忍受的.而且这还是在未考虑算法调参的情况下.留一法的估计结果也未必永远比其他评估方法准确.</p><p>“没有免费午餐”定理对实验评估方法同样适用。</p><h4 id="2-2-3-自助法-bootstrapping-可重复采样"><a href="#2-2-3-自助法-bootstrapping-可重复采样" class="headerlink" title="2.2.3 自助法(bootstrapping)=可重复采样"></a>2.2.3 自助法(bootstrapping)=可重复采样</h4><p>有没有什么办法可以减少训练样本规模不同造成的影响,同时还能比较高效地进行实验估计呢？</p><p>”自助法“是一个比较好的解决方案,它直接以自助采样法(bootstrap sampling)为基础.就是相当于摸小球放回知道摸的次数与小球数相等。</p><p>样本在m次采样中始终不被采到的概率是 $(1-\frac{1}{m})^m$，取极限为 $\frac{1}{e} \approx 0.368$ ,将未被抽中的作为测试集。这样的测试结果，亦称”包外估计”(out-of-bag estimate).</p><p>自助法在数据集较小、难以有效划分训练/测试集时很有用；此时，自助法能从初始数据集中产生多个不同训练集,这对集成学习等学习方法有很大的好处。然而，自助法产生的数据集改变了初始数据集的分布，会引入估计偏差.因此在初始数据量足够时，留出法和交叉验证法更常用一些.</p><h4 id="2-2-4-调参-parameter-tuning-与最终模型"><a href="#2-2-4-调参-parameter-tuning-与最终模型" class="headerlink" title="2.2.4 调参(parameter tuning)与最终模型"></a>2.2.4 调参(parameter tuning)与最终模型</h4><p>参数可能在实数范围内取值，有着极大的调参工作量,以至于在不少应用任务中,参数调的好不好往往对最终模型性能有关键性影响。</p><p>模型选择完成后，学习算法和参数配置已选定,此时应该用数据集<em>D</em>重新训练模型.这才是我们最终提交给用户的模型.</p><p>验证集(validation set)存疑</p><h3 id="2-3-性能度量"><a href="#2-3-性能度量" class="headerlink" title="2.3 性能度量"></a>2.3 性能度量</h3><p>需要有衡量模型泛化能力的评价标准,这就是性能度量(performance measure).面对不同的任务需求，选用不同的性能度量。</p><p>回归任务最常用的性能度量是”均方误差”(mean squared error) <strong>公式待补</strong></p><p>下面主要介绍分类任务中常用的性能度量.</p><h4 id="2-3-1-错误率与精度"><a href="#2-3-1-错误率与精度" class="headerlink" title="2.3.1 错误率与精度"></a>2.3.1 错误率与精度</h4><p>这是分类任务中最常用的两种性能度量，既适用于二分类任务，也适用于多分类任务 <strong>公式待补</strong></p><h4 id="2-3-2-查准率-precision-、查全率-recall-与F1"><a href="#2-3-2-查准率-precision-、查全率-recall-与F1" class="headerlink" title="2.3.2 查准率(precision)、查全率(recall)与F1"></a>2.3.2 查准率(precision)、查全率(recall)与F1</h4><p>对于二分类问题,可将样例根据其真实类别与学习器预测类别的组合划分为真正例(true positive,TP)、假正例(false positive,FP)、真反例(true negative,TN)、假反例(false negative,FN)四种情形。<br>分类结果的”混淆矩阵”(confusion matrix)</p><table><thead><tr><th>真实情况</th><th>预测结果</th><th>预测结果 </th></tr></thead><tbody><tr><td>真实情况</td><td>正例</td><td>反例</td></tr><tr><td>正例</td><td>TP(真正例)</td><td>FN(假反例)</td></tr><tr><td>反例</td><td>FP(假正例)</td><td>TN(真反例)</td></tr></tbody></table><p>查准率P与查全率R分别定义为:<br>$$ P=\frac{TP}{TP+FP} $$</p><p>$$R=\frac{TP}{TP+FN}$$</p><p>查准率和查全率是一对矛盾的度量.一般来说，查准率高时，查全率往往偏低;反之类似.</p><p>查准率-查全率曲线,简称”P-R曲线“，显示该曲线的图称为”P-R图“.</p><p>若一个学习器的P-R曲线被另一个学习器的曲线完全”包住”，则可断言后者的性能优于前者.</p><p>若两个学习器的P-R曲线发生了交叉,则一般难以一般性地断言两者孰优孰劣,只能在具体的查准率或查全率条件下进行比较.仍希望比个高低,这时一个比较合理的判据是比较P-R曲线下面积的大小。</p><p>人们设计了一些综合考察查准率、查全率的性能度量.</p><p>”平衡点“(Break-Even Point,简称BEP)就是这样一个度量,它是”查准率=查全率“时的取值</p><p>但BEP还是过于简化了些，更常用的是F1度量:</p><p>$$F1=\frac{2 \times P \times R}{P+R} = \frac{2 \times TP}{样例总数+TP-TN}$$</p><p>F1是基于查准率与查全率的调和平均(harmonic mean)定义的</p><p>F1的一般形式是$F<em>{\beta}$，能让我们表达出对查准率/查全率的不同偏好,$F</em>{\beta}$是加权调和平均.</p><p>$$F_{\beta} = \frac{1+\beta^2 \times P \times R}{(\beta^2 \times P) + R}$$</p><p>其中$\beta &gt;0$度量了查全率对查准率的相对重要性.$\beta = 1$时退化为标准的F1;$\beta &gt;1$时查全率有更大影响；$\beta &lt;1$时查准率有更大影响</p><p>我们希望在n个二分类混淆矩阵上综合考察查准率和查全率.</p><p>一种直接的做法是先在各混淆矩阵上分别计算出查准率和查全率，然后计算平均值,这样就得到”宏查准率”(macro-P)、”宏查全率”(macro-R),以及相应的”宏F1”(macro-F1):</p><p>还有一种:先将各混淆矩阵的对应的元素进行平均,再基于这些平均值计算出”微查准率”(micro-P)、”微查全率”(micro-R)和”微F1”(micro-F1)</p><h4 id="2-3-3-ROC与AUC"><a href="#2-3-3-ROC与AUC" class="headerlink" title="2.3.3 ROC与AUC"></a>2.3.3 ROC与AUC</h4><p>分类阈值(threshold) 截断点(cut point)</p><p>排序本身的质量好坏,体现了综合考虑学习器在不同任务下的”期望泛化性能”的好坏，或者说，”一般情况下“泛化性能的好坏，ROC曲线则是从这个角度出发来研究学习器泛化性能的有力工具.</p><p>ROC全称是”受试者工作特征“(Receiver Operating Characteristic)曲线</p><p>ROC曲线的纵轴是”真正例率“(True Positive Rate,简称”TPR”),横轴是”假正例率”(False Positive Rate,简称FPR)</p><p>$$TPR = \frac{TP}{TP+FN}$$</p><p>$$FPR = \frac{FP}{TN+FP}$$</p><p>两条ROC曲线的比较类似于P-R曲线类似. ROC曲线下的面积,即AUC(Area Under ROC Curve)</p><p><strong>公式待补</strong></p><p>排序”损失”(loss)的定义为: <strong>公式待补</strong></p><p>$l<em>{rank}$对应的是ROC曲线之上的面积,AUC = 1-$l</em>{rank}$</p><h4 id="2-3-4-代价敏感错误率与代价曲线"><a href="#2-3-4-代价敏感错误率与代价曲线" class="headerlink" title="2.3.4 代价敏感错误率与代价曲线"></a>2.3.4 代价敏感错误率与代价曲线</h4><p>为权衡不同类型错误所造成的不同损失，可为错误赋予”非均等代价”(unequal cost).</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;机器学习笔记-学习中-进度堪忧&quot;&gt;&lt;a href=&quot;#机器学习笔记-学习中-进度堪忧&quot; class=&quot;headerlink&quot; title=&quot;机器学习笔记(学习中 进度堪忧)&quot;&gt;&lt;/a&gt;机器学习笔记(学习中 进度堪忧)&lt;/h1&gt;&lt;h2 id=&quot;第1章-绪论&quot;&gt;&lt;a href=&quot;#第1章-绪论&quot; class=&quot;headerlink&quot; title=&quot;第1章 绪论&quot;&gt;&lt;/a&gt;第1章 绪论&lt;/h2&gt;&lt;h3 id=&quot;1-1-引言&quot;&gt;&lt;a href=&quot;#1-1-引言&quot; class=&quot;headerlink&quot; title=&quot;1.1 引言&quot;&gt;&lt;/a&gt;1.1 引言&lt;/h3&gt;&lt;p&gt;通过对经验的利用，就能对新情况做出有效的决策。计算机在这方面可以帮忙。&lt;/p&gt;
&lt;p&gt;机器学习致力于研究如何通过计算的手段，利用经验来改善系统自身的性能。机器学习所研究的主要内容，是关于在计算机上从数据中产生“模型”(model)的算法，即”学习算法”(learning algorithm).&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="https://ricky-ting.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="机器学习" scheme="https://ricky-ting.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>mac已装软件目录</title>
    <link href="https://ricky-ting.github.io/2018/02/10/mac%E5%B7%B2%E8%A3%85%E8%BD%AF%E4%BB%B6%E7%9B%AE%E5%BD%95/"/>
    <id>https://ricky-ting.github.io/2018/02/10/mac已装软件目录/</id>
    <published>2018-02-10T07:34:43.000Z</published>
    <updated>2018-05-14T12:45:47.315Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mac已装软件目录-更新至2018-5-14"><a href="#Mac已装软件目录-更新至2018-5-14" class="headerlink" title="Mac已装软件目录(更新至2018.5.14)"></a>Mac已装软件目录(更新至2018.5.14)</h1><h2 id="Develop"><a href="#Develop" class="headerlink" title="Develop"></a>Develop</h2><ul><li>Xcode</li><li>PyCharm Edu : for python</li><li>MATLAB_R2016b</li><li>Sublime Text</li><li>Mathematic</li><li>iTerm</li><li>Dash</li><li>ScriptFlow</li><li>IconKit<a id="more"></a></li></ul><h2 id="Design"><a href="#Design" class="headerlink" title="Design"></a>Design</h2><ul><li>Adobe Photoshop CC</li><li>Adobe Premiere Pro CC</li><li>Adobe Audition CC</li><li>Total Video Converter Lite</li><li>Sketch</li><li>xScope</li></ul><h2 id="Text"><a href="#Text" class="headerlink" title="Text"></a>Text</h2><ul><li>MacDown</li><li>Evernote</li><li>Texshop</li><li>Pages Keynote Numbers</li><li>VS Code</li></ul><h2 id="Tools"><a href="#Tools" class="headerlink" title="Tools"></a>Tools</h2><ul><li>Chrome</li><li>Firefox</li><li>Parallels Desktop</li><li>EuDic</li><li>iStat Menus</li><li>Baidu Netdisk</li><li>Reeder</li><li>iText</li><li>uTorrent</li><li>WonderPen</li><li>The Unarchiver</li><li>每日英语听力</li><li>XMind</li><li>Reflector 2</li><li>Qlpmsg</li><li>Focusky</li><li>DjView</li><li>CAJCloudViewer</li><li>Blackmagic Disk Speed Test</li><li>1Checker</li><li>1Keyboard</li><li>Disk Graph</li><li>PDF Expert</li><li>WiFi Explorer Pro</li><li>UltraEdit</li><li>WebTorrent</li><li>RescueTime</li><li>OmniGraffle</li><li>Xee</li><li>Workspaces</li></ul><h2 id="Entertainment"><a href="#Entertainment" class="headerlink" title="Entertainment"></a>Entertainment</h2><ul><li>youku</li><li>mpv</li><li>aiqiyi</li><li>QQ Music</li><li>Netease Music</li><li>Steam</li><li>Lep’s World 2</li><li>IINA</li></ul><h2 id="Social-Networking"><a href="#Social-Networking" class="headerlink" title="Social Networking"></a>Social Networking</h2><ul><li>WeChat</li><li>QQ</li></ul><h2 id="Plugins"><a href="#Plugins" class="headerlink" title="Plugins"></a>Plugins</h2><ul><li>Snap</li><li>ShadowsocksX-R</li><li>Irvue</li><li>Alfred 3</li><li>Kap : for screen capturing</li><li>Homebrew</li><li>zsh</li><li>pandoc : File converting</li><li>Bartender 3</li></ul><h2 id="Virtual-Machine"><a href="#Virtual-Machine" class="headerlink" title="Virtual Machine"></a>Virtual Machine</h2><ul><li>Windows 10</li><li>Ubuntu</li><li>Kali Linux </li></ul><h2 id="待装"><a href="#待装" class="headerlink" title="待装"></a>待装</h2><ul><li>SPSS</li><li>Dash</li><li>UltraEdit</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Mac已装软件目录-更新至2018-5-14&quot;&gt;&lt;a href=&quot;#Mac已装软件目录-更新至2018-5-14&quot; class=&quot;headerlink&quot; title=&quot;Mac已装软件目录(更新至2018.5.14)&quot;&gt;&lt;/a&gt;Mac已装软件目录(更新至2018.5.14)&lt;/h1&gt;&lt;h2 id=&quot;Develop&quot;&gt;&lt;a href=&quot;#Develop&quot; class=&quot;headerlink&quot; title=&quot;Develop&quot;&gt;&lt;/a&gt;Develop&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Xcode&lt;/li&gt;
&lt;li&gt;PyCharm Edu : for python&lt;/li&gt;
&lt;li&gt;MATLAB_R2016b&lt;/li&gt;
&lt;li&gt;Sublime Text&lt;/li&gt;
&lt;li&gt;Mathematic&lt;/li&gt;
&lt;li&gt;iTerm&lt;/li&gt;
&lt;li&gt;Dash&lt;/li&gt;
&lt;li&gt;ScriptFlow&lt;/li&gt;
&lt;li&gt;IconKit
    
    </summary>
    
    
      <category term="记录" scheme="https://ricky-ting.github.io/tags/%E8%AE%B0%E5%BD%95/"/>
    
      <category term="Mac" scheme="https://ricky-ting.github.io/tags/Mac/"/>
    
      <category term="软件" scheme="https://ricky-ting.github.io/tags/%E8%BD%AF%E4%BB%B6/"/>
    
  </entry>
  
</feed>
