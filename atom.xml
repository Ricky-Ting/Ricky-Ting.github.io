<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ricky Ting&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/5c8eecd06d08187c73ea49421008f04d</icon>
  <subtitle>当时只道是寻常</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ricky-ting.github.io/"/>
  <updated>2019-01-19T11:11:17.563Z</updated>
  <id>https://ricky-ting.github.io/</id>
  
  <author>
    <name>Ricky-Ting</name>
    <email>1770048119@qq.com dbr1770048119@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MATLAB学习笔记</title>
    <link href="https://ricky-ting.github.io/2019/01/19/MATLAB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://ricky-ting.github.io/2019/01/19/MATLAB学习笔记/</id>
    <published>2019-01-19T07:50:56.000Z</published>
    <updated>2019-01-19T11:11:17.563Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MATLAB学习笔记"><a href="#MATLAB学习笔记" class="headerlink" title="MATLAB学习笔记"></a>MATLAB学习笔记</h1><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ul><li><p>quit: 退出命令</p></li><li><p>clc: 擦除MATLAB工作窗中的所有显示内容，相当于命令行中的clear</p></li><li><p>clf: 擦除MATLAB的当前图形窗中的图形</p></li><li><p>clear: 清除内存中的变量和函数</p></li><li><p>dir: 列出指定目录下的文件和子目录清单</p></li><li><p>cd: 改变当前工作子目录</p></li><li><p>disp: (在运行中)显示变量和文字内容</p></li><li><p>who: 检查内存变量</p></li><li><p>whos: 列出内存变量的详细情况</p></li><li><p>save: 关闭前将变量保存到某一文件中</p></li><li><p>load: 从之前保存的文件中恢复变量</p></li><li><p>help: 非常有用</p></li><li><p>lookfor: 查找相关指令</p></li><li><p>!之后可以加操作系统命令，如 !ls, !vim</p></li></ul><p><img src="/images/MATLAB学习笔记/MATLABop.png" alt=""></p><p>求解方程组时，用除法比用逆矩阵好。</p><h2 id="多项式"><a href="#多项式" class="headerlink" title="多项式"></a>多项式</h2><ul><li><p>用系数行向量表示：p=$[a_0 , a<em>1 , … , a</em>{n-1} , a_n ]$, ($p(x)= a_0 x_n + a<em>1 x</em>{n-1} + … + a<em>{n-1} x + a</em>{n} $).</p></li><li><p>可以用指令产生多项式系数向量: p=poly(AR). 如果AR是方阵，则多项式为特征多项式，如果AR为向量，则AR为多项式的解。</p></li><li><p>poly2str函数</p></li></ul><h3 id="一些常用多项式运算指令"><a href="#一些常用多项式运算指令" class="headerlink" title="一些常用多项式运算指令"></a>一些常用多项式运算指令</h3><ul><li><p>R=roots(p)   求多项式向量p的根</p></li><li><p>PA=polyval(p,S)  按照数组运算规则计算多项式值。 p为多项式，S为矩阵。 相当于求值。</p></li><li><p>PM=polyvalm(p;S) 按照矩阵运算规则计算多项式值。p为多项式，S为矩阵。</p></li><li><p>P=polyfit(x,y,n) 用n阶多项式拟合x,y向量给定的数据</p></li></ul><h2 id="数值积分"><a href="#数值积分" class="headerlink" title="数值积分"></a>数值积分</h2><ul><li><p>S=quad(‘fname’,a,b,tol,trace)  自适用递推Simpson数值积分法</p></li><li><p>S=quad8(‘fname’,a,b,tol,trace) 自适用递推Newton-Cotes数值积分法</p></li><li><p>tol是精度，trace是是否画图</p></li><li><p>quad8比quad有更高的积分精度</p></li></ul><h2 id="非线性方程求解"><a href="#非线性方程求解" class="headerlink" title="非线性方程求解"></a>非线性方程求解</h2><ul><li><p>对于多项式函数求根，r=roots(p)</p></li><li><p>单变量非线性方程求解, z=fzero(‘fname’,x0,tol,trace)</p></li><li><p>一般非线性方程(组)求解， X=fsolve(‘fname’,X0)</p></li></ul><h2 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h2><ul><li><p>fopen(“filename”,’specifier’)</p></li><li><p>fread(fd,..)</p></li><li><p>fwrite()</p></li><li><p>fclose</p></li></ul><h2 id="符号计算"><a href="#符号计算" class="headerlink" title="符号计算"></a>符号计算</h2><ul><li><p>可以用sym定义符号,如 sym(‘x’) 也可以用syms定义多个符号 syms a b c d</p></li><li><p>findsym() 来确认符号表达式中的符号</p></li></ul><h3 id="微积分运算"><a href="#微积分运算" class="headerlink" title="微积分运算"></a>微积分运算</h3><ul><li><p>diff(f) 函数f对符号变量x或字母表上最接近字母x的符号变量求导数</p></li><li><p>diff(f,t) 函数f对符号变量t求导数</p></li><li><p>diff(f,2) 和diff(f,t,2)可以用来求二阶导数</p></li><li><p>int(f)</p></li><li><p>int(f,t)</p></li><li><p>int(f,a,b) 和int(f,t,a,b)</p></li><li><p>limit(f) 当符号变量x(或最接近字母x的符号变量) -&gt;0 时，函数f的极限</p></li><li><p>limit(f,t,a)</p></li><li><p>limit(f,t,a,’left’) 左极限 limit(f,t,a,’right’)右极限</p></li><li><p>symsum(s,t,a,b) 表示s中的符号变量t从a到b的级数和(t缺省时，同上)</p></li><li><p>taylor(f,n,a) 函数f对符号变量x(或…)在a点的n-1阶泰勒多项式(n缺省时值为6，a缺省时值为0)</p></li><li><p>solve(f,t) 对f中的符号变量t解方程f=0(t缺省值为x或…)</p></li><li><p>solve(f,g,..)可以求解方程组</p></li><li><p>dsolve(‘S’,’s1’,’s2’,…,’x’)</p></li><li><p>collect 合并同类项</p></li><li><p>expand 将乘积展开为和式</p></li><li><p>horner 把多项式转换为嵌套表示形式</p></li><li><p>simplify 利用各种恒等式化简代数式，更强有力的函数simple</p></li><li><p>subs(S,old,new) 替换</p></li><li><p>subexpr(S) 将表达式S中的公共部分用sigma表示</p></li></ul><h2 id="MATLAB画图"><a href="#MATLAB画图" class="headerlink" title="MATLAB画图"></a>MATLAB画图</h2><ul><li><p>plot(x,y) 以向量x作为X轴，以向量y作为Y轴，绘制X-Y二维曲线</p></li><li><p>plot(x,y1,’k’,x,y2,’b-‘) 每条曲线的线型和颜色由字符串’cs’指定，其中c表示颜色,s表示线型</p></li></ul><p><img src="/images/MATLAB学习笔记/ColorAndLine.png" alt=""></p><ul><li><p>可以加一些图形标记，如title, xlabel, ylabel, text,legend</p></li><li><p>axis([xmin,xmax,ymin,ymax]) 来设定坐标轴范围</p></li><li><p>hold on: 保持原有图形的基础上绘制新的图形</p></li><li><p>fplot(fname,lims,tol) lims为变量取值范围，tol为相对误差</p></li><li><p>loglog(x,y) 绘制双对数坐标图</p></li><li><p>semilogx(x,y) semilogy(x,y) 绘制单对数坐标图</p></li><li><p>polar(theta,rho) 用来绘制极坐标图</p></li></ul><p><img src="/images/MATLAB学习笔记/2D.png" alt=""></p><ul><li><p>plot3(x1,y1,z1,c1,x2,y2,z2,c2,…)</p></li><li><p>mesh(x,y,z,c)绘制三维网格图</p></li><li><p>surf(x,y,z) 绘制三维曲面图</p></li><li><p>view 指定视点</p></li><li><p>contour3 绘制等高线图</p></li></ul><h2 id="MATLAB程序设计"><a href="#MATLAB程序设计" class="headerlink" title="MATLAB程序设计"></a>MATLAB程序设计</h2><p>MATLAB有两种工作方式：一种是交互式的命令行工作方式，另一种是M文件的程序工作方式</p><h3 id="M文件"><a href="#M文件" class="headerlink" title="M文件"></a>M文件</h3><p>M文件有两类：命令文件和函数文件。区别在于：命令文件没有输入参数，也不返回输出参数；而函数文件可以输入参数，也可以返回输出参数。</p><ul><li><p>input函数， A=input(提示信息，选项);</p></li><li><p>pause(延迟秒数)    pause()直接暂停程序</p></li><li><p>Disp(输出项)</p></li></ul><h3 id="if选择语句"><a href="#if选择语句" class="headerlink" title="if选择语句"></a>if选择语句</h3><ul><li><p>结束时要加end，不需要加begin</p></li><li><p>else +if = elseif</p></li></ul><h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><ul><li><p>结束要加end</p></li><li><p>default改为otherwise</p></li><li><p>case 值 后面没有冒号</p></li></ul><h3 id="for循环结构"><a href="#for循环结构" class="headerlink" title="for循环结构"></a>for循环结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for 循环变量= 表达式1: 表达式2 : 表达式3</span><br><span class="line">    循环体</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">% 表达式1为初值， 表达式2为步长，表达式3为终值</span><br><span class="line"></span><br><span class="line">for 循环变量=矩阵表达式 则遍历矩阵元素</span><br></pre></td></tr></table></figure><h3 id="while循环结构"><a href="#while循环结构" class="headerlink" title="while循环结构"></a>while循环结构</h3><ul><li>结尾加end</li></ul><h3 id="函数文件"><a href="#函数文件" class="headerlink" title="函数文件"></a>函数文件</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> 输出形参表=函数名<span class="params">(输入形参表)</span></span></span><br><span class="line">    注释说明部分</span><br><span class="line">    函数体</span><br></pre></td></tr></table></figure><ul><li><p>当输出形参多余1个时，则应该用方括号括起来</p></li><li><p>参数可调， 用nargin和nargout实现</p></li><li><p>支持嵌套调用和递归</p></li><li><p>加global可以声明全局变量</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MATLAB学习笔记&quot;&gt;&lt;a href=&quot;#MATLAB学习笔记&quot; class=&quot;headerlink&quot; title=&quot;MATLAB学习笔记&quot;&gt;&lt;/a&gt;MATLAB学习笔记&lt;/h1&gt;&lt;h2 id=&quot;常用命令&quot;&gt;&lt;a href=&quot;#常用命令&quot; class=&quot;head
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>文章集锦</title>
    <link href="https://ricky-ting.github.io/2019/01/18/%E6%96%87%E7%AB%A0%E9%9B%86%E9%94%A6/"/>
    <id>https://ricky-ting.github.io/2019/01/18/文章集锦/</id>
    <published>2019-01-18T14:01:01.000Z</published>
    <updated>2019-01-19T04:51:15.466Z</updated>
    
    <content type="html"><![CDATA[<ul><li>什么是真正的程序员 <a href="https://www.cnblogs.com/xueweihan/p/5220513.html" target="_blank" rel="noopener">原文链接</a> （<a href="https://github.com/Ricky-Ting/ArticleCollection/blob/master/2019.1/什么是真正的程序员？%20-%20削微寒%20-%20博客园.pdf" target="_blank" rel="noopener">文章存档</a>）</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;什么是真正的程序员 &lt;a href=&quot;https://www.cnblogs.com/xueweihan/p/5220513.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt; （&lt;a href=&quot;https://gith
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>mac下ssh打开X11转发</title>
    <link href="https://ricky-ting.github.io/2019/01/17/mac%E4%B8%8Bssh%E6%89%93%E5%BC%80X11%E8%BD%AC%E5%8F%91/"/>
    <id>https://ricky-ting.github.io/2019/01/17/mac下ssh打开X11转发/</id>
    <published>2019-01-17T07:13:44.000Z</published>
    <updated>2019-01-17T07:17:15.003Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mac下ssh打开X11转发"><a href="#mac下ssh打开X11转发" class="headerlink" title="mac下ssh打开X11转发"></a>mac下ssh打开X11转发</h1><p>1.首先确认linux下已开启X11转发：</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/ssh/sshd_config</span><br><span class="line"></span><br><span class="line">X11Forwarding yes</span><br><span class="line">X11DisplayOffset 10</span><br><span class="line"></span><br><span class="line">service ssh restart</span><br></pre></td></tr></table></figure></code></pre><p>2.安装XQuartz</p><p>3.在mac端下开启：</p><pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/ssh/ssh_config</span><br><span class="line"></span><br><span class="line">ForwardX11 yes</span><br></pre></td></tr></table></figure></code></pre><p>4.ssh登陆</p><pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -X username@ip</span><br></pre></td></tr></table></figure></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;mac下ssh打开X11转发&quot;&gt;&lt;a href=&quot;#mac下ssh打开X11转发&quot; class=&quot;headerlink&quot; title=&quot;mac下ssh打开X11转发&quot;&gt;&lt;/a&gt;mac下ssh打开X11转发&lt;/h1&gt;&lt;p&gt;1.首先确认linux下已开启X11转发：&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>2019寒假计划(flag)</title>
    <link href="https://ricky-ting.github.io/2019/01/16/2019%E5%AF%92%E5%81%87%E8%AE%A1%E5%88%92-flag/"/>
    <id>https://ricky-ting.github.io/2019/01/16/2019寒假计划-flag/</id>
    <published>2019-01-16T09:32:32.000Z</published>
    <updated>2019-01-16T09:33:26.543Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2019-寒假计划-flag"><a href="#2019-寒假计划-flag" class="headerlink" title="2019 寒假计划(flag)"></a>2019 寒假计划(flag)</h1><h2 id="必做"><a href="#必做" class="headerlink" title="必做"></a>必做</h2><ul><li><p>学习数学建模，参加美赛</p></li><li><p>完成经典阅读论文</p></li><li><p>读Spark源码</p></li><li><p>学习线性代数、代数学引论</p></li><li><p>寒假HK项目准备</p></li><li><p>学习MATLAB</p></li></ul><h2 id="可选"><a href="#可选" class="headerlink" title="可选"></a>可选</h2><ul><li><p>学习IOS开发</p></li><li><p>机器学习导论、人工智能、深度学习</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;2019-寒假计划-flag&quot;&gt;&lt;a href=&quot;#2019-寒假计划-flag&quot; class=&quot;headerlink&quot; title=&quot;2019 寒假计划(flag)&quot;&gt;&lt;/a&gt;2019 寒假计划(flag)&lt;/h1&gt;&lt;h2 id=&quot;必做&quot;&gt;&lt;a href=&quot;#必
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>如何解决项目子模块git冲突</title>
    <link href="https://ricky-ting.github.io/2019/01/03/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E9%A1%B9%E7%9B%AE%E5%AD%90%E6%A8%A1%E5%9D%97git%E5%86%B2%E7%AA%81/"/>
    <id>https://ricky-ting.github.io/2019/01/03/如何解决项目子模块git冲突/</id>
    <published>2019-01-03T15:02:20.000Z</published>
    <updated>2019-01-03T15:03:36.198Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何解决项目子模块git冲突"><a href="#如何解决项目子模块git冲突" class="headerlink" title="如何解决项目子模块git冲突"></a>如何解决项目子模块git冲突</h1><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>在将这学期做的PA提交到github时，因为ics2018中原有git与github上创建的git冲突，因此上传之后ics2018的图标为灰。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ul><li><p>git rm –cache ics2018</p></li><li><p>git add ics2018/</p></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://upupming.site/2018/05/31/git-submodules/#解决方案" target="_blank" rel="noopener">参考链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;如何解决项目子模块git冲突&quot;&gt;&lt;a href=&quot;#如何解决项目子模块git冲突&quot; class=&quot;headerlink&quot; title=&quot;如何解决项目子模块git冲突&quot;&gt;&lt;/a&gt;如何解决项目子模块git冲突&lt;/h1&gt;&lt;h2 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Records for Environment Setup for Spark</title>
    <link href="https://ricky-ting.github.io/2018/11/02/Records-for-Environment-Setup-for-Spark/"/>
    <id>https://ricky-ting.github.io/2018/11/02/Records-for-Environment-Setup-for-Spark/</id>
    <published>2018-11-02T15:29:21.000Z</published>
    <updated>2018-11-02T15:42:07.389Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spark搭建记录-2018-11-2"><a href="#Spark搭建记录-2018-11-2" class="headerlink" title="Spark搭建记录(2018.11.2)"></a>Spark搭建记录(2018.11.2)</h1><p>建立在Hadoop的基础上。</p><p><a href="https://www.cnblogs.com/zyrblog/p/8527048.html" target="_blank" rel="noopener">参考教程</a></p><p>Spark版本：2.1.3.</p><p>在官网上下的直接编译好的文件。</p><p>Spark装之前需要装Scala。我的Scala版本是2.11.6。</p><p>然后解压spark压缩包，修改conf目录下的spark-env.sh(备份到github)。 修改slaves文件。</p><p>注意启动后报错，需要加入JAVA_HOME环境变量，也在spark-env.sh中.</p><h1 id="Spark编译记录"><a href="#Spark编译记录" class="headerlink" title="Spark编译记录"></a>Spark编译记录</h1><p><a href="https://blog.csdn.net/babyhuang/article/details/78656093" target="_blank" rel="noopener">参考教程</a></p><p>在官网下载Spark源码，安装maven(我安装的版本是3.3.9) ，添加maven镜像(已备份)，修改dev目录下的make-distribution.sh文件，将Spark，Hadoop，Scala版本都换为自己的。</p><p>然后用README里的命令编译。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Spark搭建记录-2018-11-2&quot;&gt;&lt;a href=&quot;#Spark搭建记录-2018-11-2&quot; class=&quot;headerlink&quot; title=&quot;Spark搭建记录(2018.11.2)&quot;&gt;&lt;/a&gt;Spark搭建记录(2018.11.2)&lt;/h1&gt;&lt;p&gt;
      
    
    </summary>
    
    
      <category term="记录" scheme="https://ricky-ting.github.io/tags/%E8%AE%B0%E5%BD%95/"/>
    
      <category term="创新项目" scheme="https://ricky-ting.github.io/tags/%E5%88%9B%E6%96%B0%E9%A1%B9%E7%9B%AE/"/>
    
      <category term="大数据" scheme="https://ricky-ting.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>Records for Environment Setup for Hadoop</title>
    <link href="https://ricky-ting.github.io/2018/10/24/Records-for-Environment-Setup-for-Hadoop/"/>
    <id>https://ricky-ting.github.io/2018/10/24/Records-for-Environment-Setup-for-Hadoop/</id>
    <published>2018-10-24T03:20:25.000Z</published>
    <updated>2018-11-02T15:28:24.408Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hadoop环境搭建记录"><a href="#Hadoop环境搭建记录" class="headerlink" title="Hadoop环境搭建记录"></a>Hadoop环境搭建记录</h1><h2 id="安装系统"><a href="#安装系统" class="headerlink" title="安装系统"></a>安装系统</h2><p>安装系统的时候出了很多问题，找不到引导，硬盘被锁啊，感觉不懂的还是很多，最后还是请学长帮忙装好了系统。</p><a id="more"></a><h2 id="Hadoop环境的搭建"><a href="#Hadoop环境的搭建" class="headerlink" title="Hadoop环境的搭建"></a>Hadoop环境的搭建</h2><p>Hadoop版本:2.2.0</p><p><a href="https://blog.csdn.net/fanxin_i/article/details/80425461" target="_blank" rel="noopener">参考教程</a></p><p>教程简版： 1.获取IP，添加解析。2.关闭防火墙 3.安装jdk 4.安装ssh，配置免密通信 5. 安装hadoop，在hdfs目录下创建文件夹(tmp,name,data). 6.修改Hadoop配置文件包括以下几个文件(core-site.xml hadoop-env.sh hdfs-site.xml yarn-env.sh yarn-site.xml slaves).(这些配置文件会备份在github中) 7.用scp将文件夹传到slave上。 然后在master上初始化namenode(hdfs namenode -format)</p><p>我的理解是主要在master里执行namenode初始化就好了，初始化之前最好把master和slave里hdfs目录下删干净(以后可以写个脚本干这个事)。</p><h2 id="写脚本"><a href="#写脚本" class="headerlink" title="写脚本"></a>写脚本</h2><p>写脚本实现只运行MapReduce和在HDFS上运行MapReduce。</p><p>我的理解是只要改改配置文件就好，要运行哪一种方式只要把相应的配置文件拷进去就好。 因为不运行yarn，所以要把yarn的相关配置删除。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env bash</span><br><span class="line"></span><br><span class="line">echo &quot;This is to run mapreduce on hdfs&quot;</span><br><span class="line">rm -rf ~/hadoop-2.2.0/etc/hadoop</span><br><span class="line">echo &quot;Original config files in hadoop-2.2.0/ect/hadoop deleted&quot;</span><br><span class="line">cp -r ~/hadoopconfig/hadoop-distributed ~/hadoop-2.2.0/etc/</span><br><span class="line">echo &quot;Copy config files of hdfs to hadoop-2.2.0/etc/hadoop&quot;</span><br><span class="line">mv ~/hadoop-2.2.0/etc/hadoop-distributed ~/hadoop-2.2.0/etc/hadoop</span><br><span class="line">echo &quot;Rename successfully&quot;</span><br><span class="line">cd ~/hadoop-2.2.0</span><br><span class="line">echo &quot;About to run start-dfs.sh&quot;</span><br><span class="line">start-dfs.sh</span><br><span class="line">echo &quot;About to run an example on hdfs&quot;</span><br><span class="line">hadoop jar /home/hadoop/hadoop-2.2.0/share/hadoop/mapreduce/hadoop-mapreduce-examples-2.2.0.jar pi 10 10</span><br><span class="line">jps</span><br><span class="line">echo &quot;About to run stop-dfs.sh&quot;</span><br><span class="line">stop-dfs.sh</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env bash</span><br><span class="line"></span><br><span class="line">echo &quot;This is to run mapreduce without hdfs&quot;</span><br><span class="line">rm -rf ~/hadoop-2.2.0/etc/hadoop</span><br><span class="line">cp -r ~/hadoopconfig/hadoop-native ~/hadoop-2.2.0/etc/</span><br><span class="line">mv ~/hadoop-2.2.0/etc/hadoop-native ~/hadoop-2.2.0/etc/hadoop</span><br><span class="line">cd ~/hadoop-2.2.0</span><br><span class="line">./bin/hadoop jar ./share/hadoop/mapreduce/hadoop-mapreduce-examples-2.2.0.jar pi 10 10</span><br><span class="line">~</span><br><span class="line">~</span><br><span class="line">~</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Hadoop环境搭建记录&quot;&gt;&lt;a href=&quot;#Hadoop环境搭建记录&quot; class=&quot;headerlink&quot; title=&quot;Hadoop环境搭建记录&quot;&gt;&lt;/a&gt;Hadoop环境搭建记录&lt;/h1&gt;&lt;h2 id=&quot;安装系统&quot;&gt;&lt;a href=&quot;#安装系统&quot; class=&quot;headerlink&quot; title=&quot;安装系统&quot;&gt;&lt;/a&gt;安装系统&lt;/h2&gt;&lt;p&gt;安装系统的时候出了很多问题，找不到引导，硬盘被锁啊，感觉不懂的还是很多，最后还是请学长帮忙装好了系统。&lt;/p&gt;
    
    </summary>
    
    
      <category term="记录" scheme="https://ricky-ting.github.io/tags/%E8%AE%B0%E5%BD%95/"/>
    
      <category term="创新项目" scheme="https://ricky-ting.github.io/tags/%E5%88%9B%E6%96%B0%E9%A1%B9%E7%9B%AE/"/>
    
      <category term="大数据" scheme="https://ricky-ting.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>How to make an installation USB for Linux or other OS in Mac OS X</title>
    <link href="https://ricky-ting.github.io/2018/10/17/How-to-make-an-installation-USB-for-Linux-or-other-OS-in-Mac-OS-X/"/>
    <id>https://ricky-ting.github.io/2018/10/17/How-to-make-an-installation-USB-for-Linux-or-other-OS-in-Mac-OS-X/</id>
    <published>2018-10-17T12:55:11.000Z</published>
    <updated>2018-10-17T12:55:47.121Z</updated>
    
    <content type="html"><![CDATA[<h1 id="How-to-make-an-installation-USB-for-Linux-or-other-OS-in-Mac-OS-X"><a href="#How-to-make-an-installation-USB-for-Linux-or-other-OS-in-Mac-OS-X" class="headerlink" title="How to make an installation USB for Linux or other OS in Mac OS X"></a>How to make an installation USB for Linux or other OS in Mac OS X</h1><p>Step1: Download the image(iso) file from the Internet.</p><p>Step2: Open a Terminal(the following command are all completed in a terminal)</p><a id="more"></a><p>Step3: Trun <code>.iso</code> file into <code>.img</code> file by <code>hdiutil convert -format UDRW -o ~/path/to/target.img ~/path/from/src.iso</code>(The file created may end with <code>.dmg</code>)</p><p>Step4: <code>diskutil list</code> to obtain the devices mounted.</p><p>Step5: Insert your USB.</p><p>Step6: <code>diskutil list</code> to see which is added(/dev/diskN).</p><p>Step7: <code>diskutil unmountDisk /dev/diskN</code> to unmount USB</p><p>Step8: <code>sudo dd if=/path/to/target.img of=/dev/rdiskN bs=1m</code> to write the installation file into the USB</p><p>Step9: <code>diskutil eject /dev/diskN</code> to eject your USB.</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;How-to-make-an-installation-USB-for-Linux-or-other-OS-in-Mac-OS-X&quot;&gt;&lt;a href=&quot;#How-to-make-an-installation-USB-for-Linux-or-other-OS-in-Mac-OS-X&quot; class=&quot;headerlink&quot; title=&quot;How to make an installation USB for Linux or other OS in Mac OS X&quot;&gt;&lt;/a&gt;How to make an installation USB for Linux or other OS in Mac OS X&lt;/h1&gt;&lt;p&gt;Step1: Download the image(iso) file from the Internet.&lt;/p&gt;
&lt;p&gt;Step2: Open a Terminal(the following command are all completed in a terminal)&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Summary of definitions and theorems in graph theory</title>
    <link href="https://ricky-ting.github.io/2018/10/15/Summary-of-definitions-and-theorems-in-graph-theory/"/>
    <id>https://ricky-ting.github.io/2018/10/15/Summary-of-definitions-and-theorems-in-graph-theory/</id>
    <published>2018-10-15T14:06:07.000Z</published>
    <updated>2019-01-08T06:11:07.116Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Summary-of-definitions-and-theorems-in-graph-theory"><a href="#Summary-of-definitions-and-theorems-in-graph-theory" class="headerlink" title="Summary of definitions and theorems in graph theory"></a>Summary of definitions and theorems in graph theory</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><h3 id="1-1-Graphs-and-Graph-Models"><a href="#1-1-Graphs-and-Graph-Models" class="headerlink" title="1.1 Graphs and Graph Models"></a>1.1 Graphs and Graph Models</h3><p>A <strong>Graph</strong> G consists of a finite nonempty set $V$ of objects called <strong>vertices</strong> and a set $E$ of 2-element subsets of $V$ called <strong>edges</strong>. The ses $V$ and $E$ are the <strong>vertex set</strong> and <strong>edge set</strong> of $G$, respectively. Write $G=(V,E)$.</p><p>Two graphs $G$ and $H$ are <strong>equal</strong> if $V(G)=V(H)$ and $E(G)=E(H)$, in which case we write $G=H$.</p><p>If $uv$ is an edge of $G$, then $u$ and $v$ are said to be <strong>adjacent</strong> in $G$.</p><p>The number of vertices in $G$ is often called the <strong>order</strong> of $G$, while the number of edges is its <strong>size</strong>.</p><p>A graph with exactly one vertex is called a <strong>trivial graph</strong>, implying that the order of a <strong>nontrivial graph</strong> is at least 2.</p><p><strong>labeled graph</strong> and <strong>unlabeled graph</strong></p><p>A graph $G$ is called a <strong>word graph</strong> if $G$ is the word graph of some set $S$ of 3-letter words.</p><a id="more"></a><h3 id="1-2-Connected-Graphs"><a href="#1-2-Connected-Graphs" class="headerlink" title="1.2 Connected Graphs"></a>1.2 Connected Graphs</h3><p>The adjacent vertices $u$ and $v$ are said to be <strong>joined</strong> by the edge $e$. The vertices $u$ and $v$ are referred to as <strong>neighbors</strong> of each other. </p><p>Distinct edges incident with a common vertex are <strong>adjacent edges</strong>.</p><p>A graph $H$ is called a <strong>subgraph</strong> of a graph $G$, written $H \subseteq G$, if $V(H) \subseteq V(G)$ and $E(H) \subseteq E(G)$. We also say that $G$ contains $H$ as a subgraph. If $H \subseteq G$ and either $V(H)$ is a proper subset of $V(G)$ or $E(H)$ is a proper subset of $E(G)$, then $H$ is a <strong>proper subgraph</strong> of $G$. If a subgraph of a graph $G$ has the same vertex set as $G$, then it is a <strong>spanning subgraph</strong> of $G$.</p><p>A subgraph $F$ of a graph $G$ is called an <strong>induced subgraph</strong> of $G$ if whenever $u$ and $v$ are vertices of $F$ and $uv$ is an edge of $G$, then $uv$ is an edge of $F$ as well.</p><p>If $S$ is a nonempty set of vertices of a graph $G$, then the <strong>subgraph</strong> of $G$ <strong>induced by</strong> $S$ is the induced subgraph with vertex set $S$. This induced subgraph is denoted by $G[S]$.</p><p>For a nonempty set $X$ of edges, the <strong>subgraph G[X] induced by</strong> $X$ has edge set $X$ and consists of all vertices that are incident with at least one edge in $X$. This subgraph is called an <strong>edge-induced subgraph</strong> of $G$.   </p><p>A $u-v$ <strong>walk</strong> $W$ in $G$ is a sequence of vertices in $G$, beginning with $u$ and ending at $v$ such that consecutives vertices in the sequence are adjacent. If $u=v$, then the walk $W$ is <strong>closed</strong>; while if $u\not=v$, then $W$ is <strong>open</strong>. A walk of length 0 is a <strong>trivial walk</strong>.</p><p>We define a $u-v$ <strong>trial</strong> in a graph $G$ to be a $u-v$ walk in which no edges is traversed more than once.</p><p>A $u-v$ walk in a graph in which no vertices are repeated is a $u-v$ <strong>path</strong>. </p><p>A <strong>circuit</strong> in a graph $G$ is a closed trail of length 3 or more. Hence a circuit begins and ends at the same vertex but repeats no edges.</p><p>A circuit that repeats no vertex, except for the first and last, is a <strong>cycle</strong>.</p><p>If $G$ contains a $u-v$ path, then $u$ and $v$ are said to be <strong>connected</strong> and $u$ is <strong>connected to</strong> $v$.</p><p>A graph $G$ is <strong>connected</strong> if every two vertices of $G$ are connected. A graph that is not connected is called <strong>disconnected</strong>. A connected subgraph of $G$ that is not a proper subgraph of any other connected subgraph of $G$ is a <strong>component</strong> of $G$. The number of components of a graph $G$ is denoted by $k(G)$. Every graph is the union of its components.</p><p>The <strong>distance</strong> between $u$ and $v$ is the smallest length of any $u-v$ path in $G$ and is denoted by $d_{G}(u,v)$ or simply $d(u,v)$. A $u-v$ path of length $d(u,v)$ is called a $u-v$ <strong>geodesic</strong>.</p><p>The greatest distance between any two vertices of a connected graph $G$ is called the <strong>diameter</strong> of $G$ and is denoted by $diam(G)$.</p><p><strong>Theorem 1.10</strong> Let $G$ be a graph of order 3 or more. Then $G$  is connected if and only if $G$ contains two distinct vertices $u$  and $v$  such that $G-u$ and $G-v$ are connected.</p><h3 id="1-3-Common-Classes-of-Graphs"><a href="#1-3-Common-Classes-of-Graphs" class="headerlink" title="1.3 Common Classes of Graphs"></a>1.3 Common Classes of Graphs</h3><p>$G$ is called a <strong>path</strong> if …</p><p>$G$ is called a <strong>cycle</strong> if …</p><p>A graph $G$ is <strong>complete</strong> if every two distinct vertices of $G$ are adjacent. A complete graph of order $n$ is denoted by $K_n$.</p><p>The <strong>complement</strong> $\bar{G}$ of a graph $G$ is that graph whose vertex set is $V(G)$ and such that for each pair $u,v$ of distinct vertices of $G$, $uv$ is an edge of $\bar{G}$ if and only if $uv$ is not an edge of $G$.</p><p>The graph $\bar{K_n}$ has $n$ vertices and no edges, it is called the <strong>empty graph</strong> of order $n$.</p><p><strong>Theorem 1.11</strong> If $G$  is a disconnected graph, then $\bar{G}$ is connected.</p><p><strong>Theorem 1.12</strong> A nontrivial graph $G$ is a bipartite graph if and only if $G$ contains no odd cycles.</p><p>A graph $G$ is a <strong>bipartite graph</strong> if $V(G)$ can be partitioned into two subsets $U$ and $W$, called <strong>partite sets</strong>, such that every edge of $G$ joins a vertex of $U$ and a vertex of $W$.</p><p>If every vertex of $U$  is adjacent to every vertex of $W$ , then we call $G$  a <strong>complete bipartite graph</strong> . A complete graph with $|U|=s$  and $|W|=t$ is denoted by $K<em>{s,t}$ or $K</em>{t,s}$. If either $s=1$ or $t=1$, then $K_{s,t}$ is a <strong>star</strong>.</p><p>A graph $G$  is a $k$<strong>-partite graph</strong> if $V(G)$ can be partitioned into $k$ subsets $V_1$,$V_2$,…,$V_k$,(called <strong>partite sets</strong>) such that if $uv$ is an edge of $G$, then $u$ and $v$ belong to different partite sets. If, in addition, every  two vertices in different partite sets are joined by an edge, then $G$ is a <strong>complete k-partite graph</strong>. If $|V_i|=n<em>i$ for $1 \le i \le k$, then we denote this graph by $K</em>{n1,n2,…,nk}$. </p><p>The <strong>join</strong> $G+H$ consists of $G \cup H$ and all edges joining a vertex of $G$ and a vertex of $H$.</p><p>The <strong>Cartesian product</strong> $G \times H$ has vertex set $V(G \times H) = V(G) \times V(H)$ . Two distinct vertices $(u,v$) and $(x,y)$ are adjacent in $G \times H$ if either (1) $u=x$ and $vy\in E(H)$ or (2) $v=y$ and $ux\in E(G)$.</p><p>We define $Q_1 $ to be $ K<em>2 $ and for $n \ge 2$, define $Q</em>{n}$ to be $Q_{n-1} \times K_2 $. The graphs $Q_n $ are then called $n$<strong>-cubes</strong> or <strong>hypercubes</strong>.</p><h3 id="1-4-Multigraphs-and-Digraphs"><a href="#1-4-Multigraphs-and-Digraphs" class="headerlink" title="1.4 Multigraphs and Digraphs"></a>1.4 Multigraphs and Digraphs</h3><p>A <strong>multigraph</strong> $M$ consists of a finite nonempty set $V$ of vertices and a set $E$ of edges, where every two vertices of M are joined by a finite number of edges(possibly zero). If two or more edges join the same pair of (distinct) vertices, then these edges are called <strong>parallel</strong> edges.</p><p>In a <strong>pseudograph</strong>, not only are parallel edges permitted but an edge is also permitted to join a vertex to itself. Such an edge is called a <strong>loop</strong>.</p><p>A <strong>digraph</strong>(or <strong>directed graph</strong>) $D$ is a finite nonempty set $V$ of objects called <strong>vertices</strong> together with a set $E$ of ordered pairs of distinct vertices. The elements of $E$ are called <strong>directed edges</strong> or <strong>arcs</strong>. If $(u,v)$ is a directed edge, then we indicate this in a diagram representing $D$ by drawing a directed line segment or curve from $u$ to $v$. Then u is said to be <strong>adjacent to</strong> v and v is <strong>adjacent from</strong> u.</p><p>If, in the definition of digraph, for each pair $u,v$ of distinct vertices, at most one of $(u,v)$ and $(v,u)$ is a directed edge, then the resulting digraph is an <strong>oriented graph</strong>  </p><h2 id="Degrees"><a href="#Degrees" class="headerlink" title="Degrees"></a>Degrees</h2><h3 id="2-1-The-Degree-of-a-Vertex"><a href="#2-1-The-Degree-of-a-Vertex" class="headerlink" title="2.1 The Degree of a Vertex"></a>2.1 The Degree of a Vertex</h3><p>The <strong>degree of a vertex</strong> $v$ in a graph $G$ is the number of edges incident with $v$ and is denoted by $deg_G \ v$ or simply by $deg \ v$ if the graph $G$ is clear from the context.  The set $N(v)$ of neighbors of a vertex $v$  is called the <strong>neighborhood</strong> of $v$. Thus $deg \ v = |N(v)|$.</p><p>A vertex of degree 0 is referred to as an <strong>isolated vertex</strong> and a vertex of degree 1 is an <strong>end-vertex</strong>(or a <strong>leaf</strong>). </p><p>The <strong>minimum degree</strong> of $G$  is the minimum degree among the vertices of $G$ and is denoted by $\delta(G)$, the <strong>maximum degree</strong> of $G$ is denoted by $\Delta(G)$.</p><p>For $G$ of order $n$, we have $0 \le \delta(G) \le deg \ v \le \Delta(G) \le n-1$.</p><p><strong>Theorem 2.1(The First Theorem of Graph Theory)</strong>  If $G$  is a graph of size $m$, then $\sum \limits_{v\in V(G)} deg \ v =2m$.</p><p>A vertex of even degree is called an <strong>even vertex</strong>, while a vertex of odd degree is an <strong>odd vertex</strong>.</p><p><strong>Corollary 2.3</strong> Every graph has an even number of odd vertices.</p><p>If a graph $G$ order $n$ contains a vertex of degree $n-1$, then $G$ is connected. However, this is not a necessary condition.</p><p><strong>Theorem 2.4</strong> Let $G$ be a graph of order $n$. If $deg \ u + deg \ v \ge n-1$, for every two nonadjacent vertices $u$ and $v$ of $G$ , then $G$ is connected and $diam(G) \le 2$.</p><ul><li><p>The bound of <strong>Theorem 2.4</strong> is sharp.</p></li><li><p><strong>What if there is only one pair?</strong></p></li></ul><p><strong>Corollary 2.5</strong> If $G$  is a graph of order $n$ with $\delta(G) \ge (n-1)/2$, then $G$ is connected.</p><p><strong>outdegree</strong> and <strong>indegree</strong>.</p><h3 id="2-2-Regular-Graphs"><a href="#2-2-Regular-Graphs" class="headerlink" title="2.2 Regular Graphs"></a>2.2 Regular Graphs</h3><p>If $\delta(G)=\Delta(G)$, then the vertices of $G$  have the same degree and $G$  is called <strong>regular</strong>. If $deg \ r=r$ for every vertex $v$  of $G$, where $0 \le r \le n-1$, then $G$  is $r$ <strong>-regular</strong> or <strong>regular of degree r</strong>.</p><p>A 3-regular graph is also referred to as a <strong>cubic graph</strong>. The best known cubic graph may very well be the <strong>Petersen graph</strong>.</p><p><strong>Theorem 2.6</strong> Let $r$ and $n$  be integers with $0 \le r \le n-1$. There exists an r-regular graph of order $n$  if and only if at least one of $r$ and $n$  is even.</p><ul><li><p>How to construct this graph?  </p></li><li><p>The graphs $H_{r,n}$ are called <strong>Harary graph</strong></p></li></ul><p><strong>Theorem 2.7</strong> For every graph $G$ and every integer $r \ge \Delta(G)$, there exists an r-regular graph $H$ containing $G$ as an induced subgraph.</p><h3 id="2-3-Degree-Sequences"><a href="#2-3-Degree-Sequences" class="headerlink" title="2.3 Degree Sequences"></a>2.3 Degree Sequences</h3><p>If the degrees of the vertices of a graph $G$ are listed in a sequence $s$, then $s$  is called a <strong>degree sequence</strong> of $G$.</p><p>A finite sequence of nonnegative integers is called <strong>graphical</strong> if it is a degree sequence of some graph.</p><p><strong>Theorem 2.10</strong> A non-increasing sequence $s$: $d_1 ,d_2 ,…,d_n (n\ge 2)$ of non-negative integers, where $d_1 \ge 1$, is graphical if and only if the sequence $s_1：d<em>2 -1,d</em> 3-1,…,d<em>{d</em> 1 + 1}-1,d<em>{d</em> 1+1}-1,d<em>{d</em> 1+2},…d_ n $ is graphical.</p><h2 id="Isomorphic-Graphs"><a href="#Isomorphic-Graphs" class="headerlink" title="Isomorphic Graphs"></a>Isomorphic Graphs</h2><h3 id="3-1-The-Definition-of-Isomorphism"><a href="#3-1-The-Definition-of-Isomorphism" class="headerlink" title="3.1 The Definition of Isomorphism"></a>3.1 The Definition of Isomorphism</h3><p>We call two graphs $G$ and $H$ “isomorphic” if they have the same structure and write $G \cong H$ to indicate this. </p><p>Formally, two (labeled) graphs $G$ and $H$  are <strong>isomorphic</strong> (have the same structure) if there exists a one-to-one correspondence $\phi$ from $V(G)$ to $V(H)$ such that $uv \in E(G)$ if and only if $\phi(u)\phi(v) \in E(H)$. In this case, $\phi$  is called an <strong>isomorphism</strong> from $G$ to $H$.</p><p><strong>Theorem 3.1</strong> Two graphs $G$ and $H$ are isomorphic if and only if their complements $\bar{G}$ and $\bar{H}$ are isomorphic.</p><p>A graph $G$ is <strong>self-complementary</strong> if $G\cong \bar{G}$ . </p><p><strong>Theorem 3.2</strong> If $G$ and $H$ are isomorphic graphs, then the degrees of the vertices of $G$ are the same as the degrees of the vertices of $H$.</p><p><strong>Note</strong>: Having the same degree sequences don’t necessarily mean two graph are isomorphic.</p><h2 id="Trees"><a href="#Trees" class="headerlink" title="Trees"></a>Trees</h2><h3 id="4-1-Bridges"><a href="#4-1-Bridges" class="headerlink" title="4.1 Bridges"></a>4.1 Bridges</h3><p>An edge $e=uv$ of a connected graph $G$ is called a <strong>bridge</strong> of $G$ if $G-e$ is disconnected.</p><p>An edge $e$ is a <strong>bridge</strong> of a disconnected graph if $e$ is a bridge of some component of $G$.</p><p>An edge $e$ is a bridge of a graph $G$ if and only if $k(G-e)=k(G)+1$</p><p>End-vertice: vertice with degree $1$.</p><p><strong>Theorem 4.1</strong>: <em>An edge $e$ of a graph $G$ is a bridge if and only if $e$ lies on no cycle of $G$</em> </p><h3 id="4-2-Trees"><a href="#4-2-Trees" class="headerlink" title="4.2 Trees"></a>4.2 Trees</h3><p>A graph G is called <strong>acyclic</strong> if it has no cycles.</p><p>A <strong>tree</strong> is an acyclic connected graph.</p><p>Every edge in a tree is a bridge.</p><p>A tree containing exactly two vertices that are not end-vertices(which are necessarily adjacent) is called a <strong>double star</strong>.</p><p>A <strong>caterpillar</strong> is a tree of order 3 or more, the removal of whose end-vertices produces a path called <strong>spine</strong> of the caterpillar.</p><p>Choose a vertex of a tree $T$, and designate this vertex as the <strong>root</strong> of $T$. The tree $T$ then becomes a <strong>rooted tree</strong>. </p><p>Acyclic graphs are also referred to as <strong>forests</strong>. Therefore each component of a forest is a tree.</p><p>The one fact that distinguishes trees from forests is that a tree is required to be connected, while a forest is not required to be connected.</p><p><strong>Theorem 4.2</strong> <em>A graph $G$ is a tree if and only if every two vertices of G are connected by a unique path</em>.</p><p><strong>Theorem 4.3</strong> <em>Every nontrivial tree has at least two end-vertices</em>.</p><p><strong>Theorem 4.4</strong> <em>Every tree of order n has size $n-1$</em></p><p><strong>Corollary 4.6</strong> <em>Every forest of order n with k components has size $n-k$</em></p><p><strong>Theorem 4.7</strong> <em>The size of every connected graph of order $n$ is at least $n-1$</em>.</p><p><strong>Theorem 4.8</strong> <em>Let $G$ be a graph of order $n$ and size $m$. If $G$ satisfies any two of the properties: (1) $G$ is connected, (2)$G$ is acyclic, (3)$m=n-1$, then $G$ is a tree.</em></p><p><strong>Theorem 4.9</strong> <em>Let $T$ be a tree of order $k$. If $G$ is a graph with $\delta(G) \ge k-1$, then $T$ is isomorphic to some subgraph of $G$</em></p><h3 id="4-3-The-Minimum-Spanning-Tree-Problem"><a href="#4-3-The-Minimum-Spanning-Tree-Problem" class="headerlink" title="4.3 The Minimum Spanning Tree Problem"></a>4.3 The Minimum Spanning Tree Problem</h3><p>A spanning subgraph $H$ of a connected graph $G$ such that $H$ is a tree is called a <strong>spanning tree</strong> of $G$.</p><p><strong>Theorem 4.10</strong> <em>Every connected graph contains a spanning tree</em>.</p><p>The <strong>weight</strong> $w(H)$ of $H$ is defined as the sum of the weights of its edges.</p><p>A spanning tree with the minimum weight is called a <strong>minimum spanning tree</strong>.</p><p>The problem of finding a minimum spanning tree in a connected weighted graph is called the <strong>Minimum Spanning Tree Problem</strong>. </p><p><strong>Kruskal’s Algorithm</strong>: For a connected weighted graph $G$, a spanning tree $T$ of $G$ is constructed as follows: For the first edge $e_1$ of $T$, we select any edge of $G$ of minimum weight and for the second edge $e_2$ of $T$, we select any remaining edge of $G$ of minimum weight. For the thrid edge $e_3$ of T, we choose any remaining edge of $G$ of minimum weight that does not produce a cycle with the previously selected edges. We continue in the manner until a spanning tree is produced.</p><p><strong>Theorem 4.11</strong> <em>Kruskal’s Algorithm produces a minimum spanning tree in a connected weighted graph</em>.</p><ul><li>证明思路：取与T共同边数最多的最小生成树为H，取其中第一条不在T的边，构造新的生成树，构造关系，证明相等，矛盾</li></ul><p><strong>Prim’s Algorithm</strong>: For a connected weighted graph $G$, a spanning tree $T$ of $G$ is constructed as follows: For an arbitrary vertex $u$ for $G$, an edge of minimum weight incident with $u$ is selected as the first edge $e_1$ of $T$. For subsequent edges $e_2$, $e<em>3$, ..,$e</em>{n-1}$, we select an edge of minimum weight among those edges having exactly one of its vertices incident with an edge already selected.</p><p><strong>Theorem 4.12</strong> <em>Prim’s Algorithm produces a minimum spanning tree in a connected weighted graph.</em></p><h3 id="4-4-Excursion-The-Number-of-Spanning-Trees"><a href="#4-4-Excursion-The-Number-of-Spanning-Trees" class="headerlink" title="4.4 Excursion: The Number of Spanning Trees"></a>4.4 Excursion: The Number of Spanning Trees</h3><p><strong>THeorem 4.15</strong> <em>The number of distinct trees of order n with a specified vertex set is $n^{n-2}$</em>.</p><p><strong>Matrix Tree Theorem</strong> (to be continued).</p><h2 id="Connectivity"><a href="#Connectivity" class="headerlink" title="Connectivity"></a>Connectivity</h2><h3 id="5-1-Cut-Vertices"><a href="#5-1-Cut-Vertices" class="headerlink" title="5.1 Cut-Vertices"></a>5.1 Cut-Vertices</h3><p>A vertex $v$ in a connected graph $G$ is a <strong>cut-vertex</strong> of $G$ if $G-v$  is disconnected. More generally, a vertex $v$ is a cut-vertex in a graph $G$  if $v$  is a cut-vertex of a component of $G$.</p><p><strong>Theorem 5.1</strong> Let $v$ be a vertex incident with a bridge in a connected graph $G$. Then $v$ is a cut-vertex of $G$ if and only if $deg \ v \ge 2$. </p><p><strong>Corollary 5.2</strong> Let $G$ be a connected graph of order 3 or more. If $G$ contains a bridge, then $G$  contains a cut-vertex.</p><p><strong>Theorem 5.3</strong> Let $v$ be a cut-vertex in a connected graph $G$ and let $u$ and $w$ be vertices in distinct components of $G-v$ . Then $v$ lies on every $u-w$ path in $G$.</p><p><strong>Corollary 5.4</strong> A vertex $v$ of a connected graph $G$  is a cut-vertex of $G$ if and only if there exist vertices $u$ and $w$ distinct from $v$ such that $v$ lies on every $u-w$ path of $G$.</p><p><strong>Theorem 5.5</strong> Let $G$ be a nontrivial connected graph and let $u\in V(G)$ . If $v$ is a vertex that is farthest from $u$ in $G$, then $v$ is not a cut-vertex of $G$.</p><p><strong>Corollary 5.6</strong> Every nontrivial connected graph contains at least two vertices that are not cut-vertices.</p><h3 id="5-2-Blocks"><a href="#5-2-Blocks" class="headerlink" title="5.2 Blocks"></a>5.2 Blocks</h3><p>A nontrivial connected graph with no cut-vertices is called a <strong>nonseparable graph</strong>.</p><p><strong>Theorem 5.7</strong> A graph of order at least 3 is nonseparable if and only if every two vertices lie on a common cycle.</p><p><strong>Theorem 5.8</strong> Let $R$ be the relation defined on the edge set of a nontrivial connected graph $G$ by $e \ R \ f$, where $e,f \in E(G)$, if $e=f$ or $e$ and $f$ lie on a common cycle of $G$. Then $R$ is an equivalence relation.</p><p><strong>Corollary 5.9</strong> Every two distinct blocks $B_1$ and $B_2$ in a nontrivial connected graph $G$ have the following properties: </p><ul><li><p>(a) The blocks $B_1$ and $B_2$ are edge-disjoint.</p></li><li><p>(b) The blocks $B_1$ and $B_2$ have at most one vertex in common.</p></li><li><p>(c) If $B_1$ and $B_2$ have a vertex $v$ in common, then $v$ is a cut-vertex of $G$.</p></li></ul><h3 id="5-3-Connectivity"><a href="#5-3-Connectivity" class="headerlink" title="5.3 Connectivity"></a>5.3 Connectivity</h3><p>By a <strong>vertex-cut</strong> in a graph $G$, we mean a set $U$ of vertices of $G$ such that $G-U$ is disconnected. A vertex-cut of minimum cardinality in $G$ is called a <strong>minimum vertex-cut</strong>.</p><p><strong>Note</strong>: A connected graph contains a vertex-cut if and only if $G$ is not complete.</p><p>For a graph $G$ that is not complete, the <strong>vertex-connectivity</strong>(or simply the <strong>connectivity</strong>) $\kappa(G)$ of $G$ is defined as the cardinality of a minimum vertex-cut of $G$; if $G=K_n$ for some positive integer $n$, then $\kappa(G)$ is defined to be $n-1$. $$0 \le \kappa(G) \le n-1$$.</p><p>For a nonnegative integer $k$, a graph $G$ is said to be $k$<strong>-connected</strong> if $\kappa(G) \ge k$.</p><p>An <strong>edge-cut</strong> in a nontrivial graph $G$  is a set $X$ of edges of $G$ such that $G-X$ is disconnected.</p><p>An edge-cut $X$  of a connected graph $G$  is <strong>minimal</strong> if no proper subset of $X$ is an edge-cut of $G$. If $X$ is a minimal edge-cut of a connected graph $G$, then $G-X$ contains exactly two components $G_1$ and $G_2$. Necessarily  then , $X$ consists of all those edges of $G$  joining $G_1$ and $G_2$.  </p><p>An edge-cut of minimum cardinality is called a <strong>minimum edge-cut</strong>.</p><p>The <strong>edge-connectivity</strong> …….</p><p>For a nonnegative integer $k$, …</p><p><strong>Theorem 5.11</strong> For every graph $G$, $$ \kappa(G) \le \lambda(G) \le \delta(G) $$</p><p><strong>Theorem 5.12</strong> If $G$ is a cubic graph, then $\kappa(G) = \lambda(G)$.</p><p><strong>Theorem 5.13</strong> If $G$ is a graph of order $n$ and size $m \le n-1$, then $\kappa(G) \le \lfloor \frac{2m}{n} \rfloor$ .</p><p>$\kappa(T)=1$</p><p>Let $G$ be a connected graph of diameter $d$. For an integer $k$ with $1 \le k \le d$, the $k$<strong>th power</strong> $G^k $ of $G$  is the graph with $V(G^k ) = V(G)$ such that $uv$ is an edge of $G^k$ if $1 \le d_{G} (u,v) \le k$.</p><p><strong>Theorem 5.14</strong> If $G$ is a connected graph of order at least 3, then its square $G^2$  is 2-connected.</p><p><strong>Theorem 5.15</strong> For every two integers $r$ and $n$ with $2 \le r \le n$, $$\kappa(H_{r,n})=r$$.</p><h3 id="5-4-Menger’s-Theorem"><a href="#5-4-Menger’s-Theorem" class="headerlink" title="5.4 Menger’s Theorem"></a>5.4 Menger’s Theorem</h3><p>TBC.</p><h2 id="Traversability"><a href="#Traversability" class="headerlink" title="Traversability"></a>Traversability</h2><h3 id="6-1-Eulerian-Graphs"><a href="#6-1-Eulerian-Graphs" class="headerlink" title="6.1 Eulerian Graphs"></a>6.1 Eulerian Graphs</h3><p>A circuit $C$ in a graph $G$ is called an <strong>Eulerian circuit</strong> if $C$ contains every edge of $G$. Since no edges is repeated in a circuit, every edge appears exactly once in an Eulerian circuit. A connected graph that contains an Eulerian circuit is called an <strong>Eulerian graph</strong>.</p><p>For a connected graph $G$, we refer to an open trial that contains every edge of $G$ as an <strong>Eulerian trial</strong>.</p><p><strong>Theorem 6.1</strong> A nontrivial connected graph $G$ is Eulerian if and only if every vertex of $G$ has even degree.</p><p><strong>Theorem 6.2</strong> A connected graph $G$ contains an Eulerian trial if and only if exactly two vertices of $G$ have odd degree. Furthermore, each Eulerian trial of $G$ begins at one of these odd vertices and ends at the other.</p><p>We have a conclusion: Let $G$ and $H$ be nontrivial connected graphs. Then $G \times H$ is Eulerian if and only if both $G$ and $H$ are Eulerian or every vertex of $G$ and $H$  is odd.</p><h3 id="6-2-Hamiltonian-Graphs"><a href="#6-2-Hamiltonian-Graphs" class="headerlink" title="6.2 Hamiltonian Graphs"></a>6.2 Hamiltonian Graphs</h3><p>A cycle in a graph $G$ that contains every vertex of $G$ is called a <strong>Hamiltonian cycle</strong> of $G$. A <strong>Hamiltonian graph</strong> is a graph that contains a Hamiltonian cycle.</p><p>A path in a graph $G$ that contains every vertex of $G$ is called a <strong>Hamiltonian path</strong> in $G$.</p><p><strong>Theorem 6.4</strong> The Petersen graph is non-Hamiltonian.</p><p><strong>Theorem 6.5</strong> If $G$ is a Hamiltonian graph, then for every nonempty proper set $S$ of vertices of $G$, $$\kappa(G-S) \le |S|$$</p><p><strong>Theorem 6.6</strong> Let $G$ be a graph of order $n \ge 3$. If $deg \ u + deg \ v \ge n$ for each pair $u$, $v$ of nonadjacent vertices of $G$, then $G$ is Hamiltonian.</p><p><strong>Corollary 6.7</strong> Let $G$ be graph of order $n \ge 3$. If $deg \ v \ge n/2$  for each vertex $v$ of $G$, then $G$ is Hamiltonian.</p><p><strong>Theorem 6.8</strong> Let $u$ and $v$ be nonadjacent vertices in a graph $G$ of order $n$ such that $deg \ u + deg \ v \ge n$ . Then $G+uv$ is Hamiltonian if and only if $G$ is Hamiltonian.</p><p>The <strong>closure</strong> $C(G)$ of a graph $G$ of order $n$ is the graph obtained from $G$ by recursively joining pairs of nonadjacent vertices whose degree sum is at least $n$ (in the resulting graph at each stage) until no such pair remains.</p><p><strong>Theorem 6.9</strong> A graph is Hamiltonian if and only if its closure is Hamiltonian.</p><p><strong>Corollary 6.10</strong> If $G$ is a graph of order at least 3 such that $C(G)$ is complete, the n $G$ is Hamiltonian.</p><p><strong>Theorem 6.11</strong> Let $G$ be a graph of order $n \ge 3$. If for every integer $j$ with $ 1 \le j &lt; \frac{n}{2}$, the number of vertices of $G$ with degree at most $j$ is less than $j$, then $G$ is Hamiltonian.</p><h3 id="6-3-Hamiltonian-Walks"><a href="#6-3-Hamiltonian-Walks" class="headerlink" title="6.3 Hamiltonian Walks"></a>6.3 Hamiltonian Walks</h3><h2 id="Matchings-and-Factorization"><a href="#Matchings-and-Factorization" class="headerlink" title="Matchings and Factorization"></a>Matchings and Factorization</h2><h3 id="8-1-Matchings"><a href="#8-1-Matchings" class="headerlink" title="8.1 Matchings"></a>8.1 Matchings</h3><p>A set of edges in a graph is <strong>independent</strong> if no two edges in the set are adjacent.</p><p>By a <strong>macthing</strong> in a graph $G$ , we mean an independent set of edges in $G$.</p><p>The graph $G$ is said to satisfy <strong>Hall’s condition</strong> if $|N(X)| \ge|X|$ for every nonempty subset $X$ of $U$.</p><p><strong>Theorem 8.3</strong> Let $G$ be a bipartite graph with partite sets $U$ and $W$ such that $r= |U| \le |W|$. Then $G$ contains a matching of cardinality $r$ if and only if $G$ satisfies Hall’s condition.</p><p><strong>Theorem 8.4</strong> A collection ${ S_1 , S_2 , … , S_n}$ of nonempty finite sets has a system of distinct representatives if and only if for each integer $k$ with $1 \le k \le n$, the union of any $k$ of these sets contains at elast $k$ elements.</p><p><strong>Theorem 8.5(The Marriage Theorem)</strong> In a collection of $r$ women and $r$ men, a total of $r$ marriages between acquainted couples is possible if and only if for each integer $k$ with $1 \le k \le r$, every subset of $k$ women is collectively acquainted with at least $k$ men.</p><p>A matching of maximum cardinality is called a <strong>maximum matching</strong>.  </p><p>If a graph $G$ of order $2k$ has a matching $M$ of cardinality $k$, then this (necessarily maximum)  matching $M$ is called a <strong>perfect matching</strong> as $M$ matches every vertex of $G$ to some vertex of $G$ .</p><p><strong>Theorem 8.6</strong> Every r-regular bipartite graph($r \ge 1$)  has a perfect matching.</p><p>The <strong>edge independence number</strong> $\alpha’(G)$ of a graph $G$  is the maximum cardinality of an independent set of edges.</p><p>Furthermore, a graph $G$ of order $n$ has a perfect matching if and only if $n$ is even and $\alpha ‘(G) = n/2$.</p><p>A vertex and an incident edge are said to <strong>cover</strong> each other.</p><p>An <strong>edge cover</strong> of a graph $G$ without isolated vertices is a set of edges of $G$ that covers all vertices of $G$.</p><p>The <strong>edge covering number</strong> $\beta’(G)$ of a graph $G$ is the minimum cardlinality of an edge cover of $G$.  An edge cover of $G$ of cardinality $\beta’(G)$ is a <strong>minimum edge cover</strong> of $G$.</p><p><strong>Theorem 8.7</strong> For every graph $G$ of order $n$ containing no isolated vertices, $$\alpha(G’)+ \beta(G’)=n$$.</p><p>A set of vertices in a graph is <strong>independent</strong> if  no two vertices in the set are adjacent. The <strong>vertex independence number</strong> (or the <strong>independence number</strong>) $\alpha(G)$ of a graph $G$ is the maximum cardinality of an independent set of vertices in $G$. An independent set in $G$ of cardinality $\alpha(G)$ is called a <strong>maximum independent set</strong>. </p><p>A <strong>vertex cover</strong> in a graph $G$ is a set of vertices that covers all edges of $G$. The minimum number of vertices in a vertex cover of $G$  is the <strong>vertex covering number</strong> $\beta(G)$  of $G$. A vertex cover of cardinality $\beta(G)$ is a <strong>minimum vertex cover</strong> in $G$.</p><p><strong>Theorem 8.8</strong> For every graph $G$ of order $n$ containing no isolated vertices, $$\alpha(G) + \beta(G) =n$$. </p><h3 id="8-2-Factorization"><a href="#8-2-Factorization" class="headerlink" title="8.2 Factorization"></a>8.2 Factorization</h3><p>A 1-regular spanning subgraph of a graph $G$ is also called a <strong>1-factor</strong> of $G$. </p><p>A graph $G$ has a 1-factor if and only if $G$ has a perfect matching.</p><p>A component of a graph is <strong>odd</strong> or <strong>even</strong> according to whether its order is odd or even. We write $k_O (G)$ for the number of odd components of a graph $G$.</p><p><strong>Theorem 8.10</strong> A graph $G$ contains a 1-factor if and only if $k_O (G-S) \le |S|$ for every proper subset $S$ of $V(G)$.</p><p><strong>Theorem 8.11(Petersen’s Theorem)</strong> Every 3-regular bridgeless graph contains a 1-factor.</p><p><strong>Theorem 8.12</strong> Every 3-regular graph with at most two bridges contains a 1-factor.</p><p>A graph $G$ is said to be <strong>1-factorable</strong> if there exists 1-factors $F_1,F_2,…,F_r$ of $G$ such that ${E(F_1),E(F_2),..,E(F_r)}$ is a partition of $E(G)$.  We then say that $G$ is <strong>factored</strong> into the 1-factors $F_1.F_2,…,F_r$ , which form a <strong>1-factorization</strong> of $G$.</p><p>Every 1-factorable graph is regular.</p><p><strong>Theorem 8.13</strong> The Petersen graph is not 1-factorable.</p><p><strong>Theorem 8.14</strong> For each positive integer $k$, the complete graph $K_{2k}$ is 1-factorable.</p><p><strong>Theorem 8.15</strong> Every r-regular bipartite graph , $r\ge 1$, is factorable.</p><p>A <strong>2-factor</strong> in a graph $G$ is a spanning 2-regular subgraph of $G$. Every component of a 2-factor is therefore a cycle. A graph $G$ is said to be <strong>2-factorable</strong> if there exist 2-factors $F_1,F_2,..,F_k$ such that ${E(F_1),E(F_2),…,E(F_k)}$ is a partition of $E(G)$.</p><p><strong>Theorem 8.16</strong> A graph $G$ is 2-factorable if and only if $G$ is r-regular for some positive even integer $r$.</p><p>A spanning subgraph $F$ of a graph $G$ is called a <strong>factor</strong> of $G$. The graph $G$ is said to be <strong>factorable</strong> into the factors $F_1,F_2,…,F_k$ if ${E(F_1),E(F_2),…,E(F_k)}$ is a partition of $E(G)$. If each factor $F_i$ is isomorphic to some graph $G$, then $G$ is <strong>F-factorable</strong>.</p><p>TBC.</p><h3 id="8-3-Decompositions-and-Graceful-Labelings"><a href="#8-3-Decompositions-and-Graceful-Labelings" class="headerlink" title="8.3 Decompositions and Graceful Labelings"></a>8.3 Decompositions and Graceful Labelings</h3><p>A graph $G$ is said to be <strong>decomposable</strong> into the subgraphs $H_1,H_2,…,H_k$ if ${E(H_1),E(H_2),…,E(H_k)}$ is a partition of $E(G)$. Such a partition produces a <strong>decomposition</strong> of $G$.  If each $H_i$ is isomorphic to some graph $H$, then the graph $G$ is $H-$ <strong>decomposable</strong>  and the decomposition is an $H-$ <strong>decomposition</strong>. </p><p>A <strong>Steiner triple system</strong> of order $n$ is a set $S$ of cardinality $n$ and a collection $T$ of 3-element subsets, called <strong>triples</strong>, such that every two distinct elements of $S$ belong to a unique triple in $T$.</p><p>TBC</p><h2 id="Planarity"><a href="#Planarity" class="headerlink" title="Planarity"></a>Planarity</h2><h3 id="9-1-Planar-Graphs"><a href="#9-1-Planar-Graphs" class="headerlink" title="9.1 Planar Graphs"></a>9.1 Planar Graphs</h3><p>A graph $G$  is called a <strong>planar graph</strong> if $G$  can be drawn in the plane so that no two of its edges cross each other. A graph that is not planar is called <strong>nonplanar</strong>. A graph $G$ is called a <strong>plane graph</strong>  if it is drawn in the plane so that no two edges of $G$ cross. </p><p>A plane graph divides the plane into connected pieces called <strong>regions</strong>. In every plane graph, there is always one region that is unbounded. This is the <strong>exterior region</strong>.  The subgraph of a plane graph whose vertices and edges are incident with a given region $R$  is the <strong>boundary</strong> of $R$. </p><p><strong>Theorem 9.1(The Euler Identity)</strong> If $G$ is a connected plane graph of order $n$, size $m$ and having $r$ regions, then $n-m+r=2$.</p><p><strong>Theorem 9.2</strong> If $G$ is a planar graph of order $n \ge 3$ and size $m$, then $$m \le 3n-6$$.</p><p><strong>Corollary 9.3</strong> Every planar graph contains a vertex of degree 5 or less.</p><p><strong>Corollary 9.4</strong> The complete graph $K_5$ is nonplanar.</p><p><strong>Theorem 9.5</strong> The graph $K_{3,3}$ is nonplanar.</p><p>A graph $G$ is <strong>maximal planar</strong> if $G$ is planar but the addition of an edge between any two nonadjacent vertices of $G$  results in a nonplanar graph.</p><p>More formally, a graph is called a <strong>subdivision</strong> of a graph $G$ if $G’=G$ or one or more vertices of degree 2 are inserted into one or more edges of $G$.</p><p><strong>Theorem 9.7(Kuratowski’s Theorem)</strong> A graph $G$ is planar if and only if $G$ does not contain a subdivision of $K<em>5$ or $K</em>{3,3}$ as a subgraph. </p><h2 id="Coloring-Graphs"><a href="#Coloring-Graphs" class="headerlink" title="Coloring Graphs"></a>Coloring Graphs</h2><h3 id="10-2-Vertex-Coloring"><a href="#10-2-Vertex-Coloring" class="headerlink" title="10.2 Vertex Coloring"></a>10.2 Vertex Coloring</h3><p>With each map, there is associated a graph $G$  called the  <strong>dual</strong> of the map, whose vertices are the regions of the map and such that two vertices of $G$  are adjacent if the corresponding regions are neighboring regions.</p><p>By a <strong>proper coloring</strong> (or, more simply, a <strong>coloring</strong>)  of a graph $G$  ,  we mean an assignment of colors (elements of some set) to the vertices of $G$ , one color to each vertex, such that adjacent vertices are colored differently.  </p><p>The smallest number of colors in any coloring of a graph $G$  is called the <strong>chromatic number</strong>  of $G$  and is denoted by $\chi(G)$.  If it is possible to color $G$ from a set of $k$  colors, then $G$  is said to be <strong>k-colorable</strong>. A coloring that uses $k$ colors is called a <strong>k-coloring</strong>. If $\chi(G)=k$, then $G$ is said to be <strong>k-chromatic</strong> and every $k-coloring$ of $G$ is a <strong>minimum coloring</strong> of $G$. </p><p><strong>Theorem 10.1(The Four Color Theorem)</strong> The chromatic number of every planargraph is at most 4.</p><p>If $G$ is a k-chromatic graph, then it is possible to partition $V(G)$ into  $k-1$ independent sets $V_1 , V_2 , …., V_k $, called <strong>color classes</strong>, but it is not possible to partition $V(G)$ into $k-1$ independent sets.</p><p><strong>Theorem 10.2</strong> A graph $G$ has chromantic number 2 if and only if $G$ is a nonempty bipartite graph.</p><p>A graph $G$ of order $n$ has chromatic number $n$ if and only if $G =K_n$.</p><p>If $H$ is a subgraph of $G$, then $\chi(H) \le \chi(G)$.</p><p>A <strong>clique</strong> in a graph $G$ is a complete subgraph of $G$. The order of the largest clique ina graph $G$ is its <strong>clique number</strong>, which is denoted by $\omega(G)$.</p><p>In fact,  $\alpha(G)=k$ if and only if $\omega(\bar{G})=k$.</p><p><strong>Theorem 10.5</strong> For every graph $G$ of order $n$, $\chi(G \ge \omega(G))$ and $\chi(G) \ge \frac{n}{\alpha(G)}$.</p><p><strong>Theorem 10.7</strong> For every graph $G$, $$\chi(G) \le 1 + \Delta(G)$$ </p><p><strong>Theorem 10.8(Brooks’ Theorem)</strong> For every connected graph $G$ that is not an odd cycle or a complete graph, $\chi(G) \le \Delta(G)$.</p><p><strong>Theorem 10.9</strong> For every graph $G$, $\chi(G) \le 1+ max{\delta(H)}$, where the maximum is taken over all induced subgraphs $H$ of $G$.</p><p>The <strong>shadow graph</strong> $S(G)$ of a graph $G$ is obtained from $G$ by adding, for each vertex $v$ of $G$, a new vertex $v’$, called the <strong>shadow vertex</strong> of $v$ , and joining $v’$ to the neighbors of $v$ in $G$. Observe that (1) a vertex of $G$ and its shadow vertex are not adjacent in $S(G)$ and (2) no two shadow vertices are adjacent in $S(G)$.</p><p><strong>Theorem 10.10</strong> For every integer $k \ge 3$, there exists a triangle-free graph with chromatic number $k$.</p><p>A graph $G$ is called <strong>perfect</strong> if $\chi(H)=\omega(H)$ for every induced subgraph $H$ of $G$.</p><p><strong>The Perfect Graph Theorem</strong> A graph is perfect if and only if its complement is perfect.</p><p><strong>The Strong Perfect Graph T</strong> A graph $G$ is perfect if and only if neither $G$ nor $\bar{G}$ contains an induced odd cycle of length 5 or more.</p><p>Reference:</p><p>[1] G.Chartrand and P.Zhang, First Course in Graph Theory, New York: Dover Publications, 2012.</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Summary-of-definitions-and-theorems-in-graph-theory&quot;&gt;&lt;a href=&quot;#Summary-of-definitions-and-theorems-in-graph-theory&quot; class=&quot;headerlink&quot; title=&quot;Summary of definitions and theorems in graph theory&quot;&gt;&lt;/a&gt;Summary of definitions and theorems in graph theory&lt;/h1&gt;&lt;h2 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h2&gt;&lt;h3 id=&quot;1-1-Graphs-and-Graph-Models&quot;&gt;&lt;a href=&quot;#1-1-Graphs-and-Graph-Models&quot; class=&quot;headerlink&quot; title=&quot;1.1 Graphs and Graph Models&quot;&gt;&lt;/a&gt;1.1 Graphs and Graph Models&lt;/h3&gt;&lt;p&gt;A &lt;strong&gt;Graph&lt;/strong&gt; G consists of a finite nonempty set $V$ of objects called &lt;strong&gt;vertices&lt;/strong&gt; and a set $E$ of 2-element subsets of $V$ called &lt;strong&gt;edges&lt;/strong&gt;. The ses $V$ and $E$ are the &lt;strong&gt;vertex set&lt;/strong&gt; and &lt;strong&gt;edge set&lt;/strong&gt; of $G$, respectively. Write $G=(V,E)$.&lt;/p&gt;
&lt;p&gt;Two graphs $G$ and $H$ are &lt;strong&gt;equal&lt;/strong&gt; if $V(G)=V(H)$ and $E(G)=E(H)$, in which case we write $G=H$.&lt;/p&gt;
&lt;p&gt;If $uv$ is an edge of $G$, then $u$ and $v$ are said to be &lt;strong&gt;adjacent&lt;/strong&gt; in $G$.&lt;/p&gt;
&lt;p&gt;The number of vertices in $G$ is often called the &lt;strong&gt;order&lt;/strong&gt; of $G$, while the number of edges is its &lt;strong&gt;size&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;A graph with exactly one vertex is called a &lt;strong&gt;trivial graph&lt;/strong&gt;, implying that the order of a &lt;strong&gt;nontrivial graph&lt;/strong&gt; is at least 2.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;labeled graph&lt;/strong&gt; and &lt;strong&gt;unlabeled graph&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A graph $G$ is called a &lt;strong&gt;word graph&lt;/strong&gt; if $G$ is the word graph of some set $S$ of 3-letter words.&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Daily Records for 2018 Oct</title>
    <link href="https://ricky-ting.github.io/2018/10/01/Daily-Records-for-2018-Oct/"/>
    <id>https://ricky-ting.github.io/2018/10/01/Daily-Records-for-2018-Oct/</id>
    <published>2018-10-01T11:48:48.000Z</published>
    <updated>2018-10-07T15:11:45.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Oct-1-7"><a href="#Oct-1-7" class="headerlink" title="Oct 1-7"></a>Oct 1-7</h1><ul><li>Did some Lab1</li><li>Completed PA2.1</li><li>Completed ProblemSolving3-4</li><li>Completed Expr03 and Expr04 of Digital Logical Circuits</li><li>Did some further reading</li></ul><h1 id="Oct-8"><a href="#Oct-8" class="headerlink" title="Oct 8"></a>Oct 8</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Oct-1-7&quot;&gt;&lt;a href=&quot;#Oct-1-7&quot; class=&quot;headerlink&quot; title=&quot;Oct 1-7&quot;&gt;&lt;/a&gt;Oct 1-7&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Did some Lab1&lt;/li&gt;
&lt;li&gt;Completed PA2.1&lt;/li&gt;

      
    
    </summary>
    
    
      <category term="记录" scheme="https://ricky-ting.github.io/tags/%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>PA拾慧</title>
    <link href="https://ricky-ting.github.io/2018/09/16/PA%E6%8B%BE%E6%85%A7/"/>
    <id>https://ricky-ting.github.io/2018/09/16/PA拾慧/</id>
    <published>2018-09-16T15:03:19.000Z</published>
    <updated>2018-10-07T15:30:53.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>天将降PA于斯人也，必先使其STFW,RTFM,RTFSC, 所以动心忍性，曾益其所不能</strong></p><h1 id="tmux-分屏工具"><a href="#tmux-分屏工具" class="headerlink" title="tmux(分屏工具)"></a>tmux(分屏工具)</h1><p>Prefix: <code>Ctrl+B</code></p><p>左右分屏:<code>Prefix + %</code> 上下分屏: <code>Prefix + &quot;</code></p><p>切换: <code>Prefix + 方向键</code></p><h1 id="Vim配置"><a href="#Vim配置" class="headerlink" title="Vim配置"></a>Vim配置</h1><h2 id="vim分屏："><a href="#vim分屏：" class="headerlink" title="vim分屏："></a>vim分屏：</h2><p><code>Ctrl+W s</code>:上下分割当前打开的文件</p><p><code>:sp filename</code>:上下分割，并打开一个新的文件</p><p><code>Ctrl+W v</code>: 左右分割当前打开的文件</p><p><code>:vsp filename</code>: 左右分割，并打开一个新的文件</p><p><code>Ctrl+W l,h,k,j</code>: 在窗格见切换</p><h2 id="vim函数跳转"><a href="#vim函数跳转" class="headerlink" title="vim函数跳转:"></a>vim函数跳转:</h2><ol><li>安装ctags: ‘sudo apt-get install ctags’</li><li>测试ctags是否安装成功: <code>whereis ctags</code></li><li>为源代码生成tags文件，建议在项目根目录下生成: <code>ctags -R</code>,更多高级选项请自行查询或man</li><li>配置vimrc: <code>sudo vim ~/.vimrc</code></li><li>修改vimrc: 加入下面两行 </li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set tags=[path]/tags</span><br><span class="line">set tags=./tags,tags;$HOME</span><br></pre></td></tr></table></figure><h2 id="vim配置选项"><a href="#vim配置选项" class="headerlink" title="vim配置选项"></a>vim配置选项</h2><p><code>set laststatus=2</code></p><p>跳转快捷键: <code>Ctrl+]</code>跳转,  <code>Ctrl+t</code> or <code>Ctrl+o</code>返回.</p><p>在终端里输入<code>vim -t functionname</code> 可以直接跳转至你想跳转的函数.(来自StardustDL的补充)</p><p>vim函数跳转部分参考<a href="https://mengzelev.github.io/2018/09/12/pa-inspirations/" target="_blank" rel="noopener">Mengzelve’s Blog</a> </p><h1 id="C语言相关"><a href="#C语言相关" class="headerlink" title="C语言相关"></a>C语言相关</h1><p>顺时针法则</p><p>strcmp返回值为0是两个字符串相等</p><p>结构体里利用位域实现位级访问</p><h1 id="Linux相关"><a href="#Linux相关" class="headerlink" title="Linux相关"></a>Linux相关</h1><p>linux里的管道(pipeline)将不同程序的输入输出连起来。</p><p><code>time ./a.out</code> 可以测程序运行的时间。</p><p>在shell中使用终端设置别名:<code>alias cdblog=&#39;cd ~/Desktop/Github/Blog&#39;</code></p><p>统计代码行数: <code>find . | grep -E &#39;\.c$|\.h$&#39; | xargs cat | wc -l</code></p><p>统计代码行数(不含空格): <code>find . | grep -E &#39;\.c$|\.h$&#39; | xargs cat | grep -v ‘^$’ | wc -l</code></p><h1 id="一些好的文章："><a href="#一些好的文章：" class="headerlink" title="一些好的文章："></a>一些好的文章：</h1><p><a href="https://i.linuxtoy.org/docs/guide/index.html" target="_blank" rel="noopener">开源世界旅行手册</a></p><p><a href="http://songshuhui.net/archives/70194" target="_blank" rel="noopener">计算的极限</a></p><p><a href="https://eli.thegreenplace.net/2011/01/23/how-debuggers-work-part-1/#id7" target="_blank" rel="noopener">How debuggers work</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;天将降PA于斯人也，必先使其STFW,RTFM,RTFSC, 所以动心忍性，曾益其所不能&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;tmux-分屏工具&quot;&gt;&lt;a href=&quot;#tmux-分屏工具&quot; class=&quot;headerlink&quot; title=&quot;tmux(
      
    
    </summary>
    
    
      <category term="记录" scheme="https://ricky-ting.github.io/tags/%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Debian install sudo</title>
    <link href="https://ricky-ting.github.io/2018/09/06/Debian-install-sudo/"/>
    <id>https://ricky-ting.github.io/2018/09/06/Debian-install-sudo/</id>
    <published>2018-09-06T01:08:13.000Z</published>
    <updated>2018-09-06T07:39:19.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Debian-install-sudo"><a href="#Debian-install-sudo" class="headerlink" title="Debian install sudo"></a>Debian install sudo</h1><ol><li><code>su</code>切换至root</li><li><code>apt-get install sudo</code></li><li><code>visudo</code> 在<code>root ALL(ALL:ALL) ALL</code>后面加入一行<code>&lt;user&gt; ALL=(ALL:ALL) ALL</code></li><li>然后Ctrl-O 保存文件，要把文件名里的<code>.tmp</code>删除，两次yes， Ctrl-X退出编辑</li></ol><p><code>sudoers</code>文件目录为<code>/etc/sudoers</code></p><p><code>su</code>进入root, <code>exit</code>退出root</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Debian-install-sudo&quot;&gt;&lt;a href=&quot;#Debian-install-sudo&quot; class=&quot;headerlink&quot; title=&quot;Debian install sudo&quot;&gt;&lt;/a&gt;Debian install sudo&lt;/h1&gt;&lt;ol&gt;

      
    
    </summary>
    
    
      <category term="bug" scheme="https://ricky-ting.github.io/tags/bug/"/>
    
      <category term="solution" scheme="https://ricky-ting.github.io/tags/solution/"/>
    
  </entry>
  
  <entry>
    <title>Daily-Records for 2018-Sept</title>
    <link href="https://ricky-ting.github.io/2018/09/01/Daily-Records-for-2018-Sept/"/>
    <id>https://ricky-ting.github.io/2018/09/01/Daily-Records-for-2018-Sept/</id>
    <published>2018-09-01T14:42:22.000Z</published>
    <updated>2018-10-07T15:10:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Sept-1"><a href="#Sept-1" class="headerlink" title="Sept 1"></a>Sept 1</h1><ul><li>复习汇编</li><li>汇编考试(2:00 pm - 4:00 pm)</li><li>重新搭建Hadoop环境(进度50%),修复了好多bug</li><li><p>装Windows XP 虚拟机(玩了三维弹球)</p><a id="more"></a></li></ul><h1 id="Sept-2"><a href="#Sept-2" class="headerlink" title="Sept 2"></a>Sept 2</h1><ul><li>搭建Hadoop环境完成</li><li>学习java(进度55/689)</li><li>吃火锅</li><li>看big bang(S1E1-S1E3)</li></ul><h1 id="Sept-3-开学第一天"><a href="#Sept-3-开学第一天" class="headerlink" title="Sept 3(开学第一天)"></a>Sept 3(开学第一天)</h1><ul><li>装windows7虚拟机，并安装Quartus，重新做了实验0(数字逻辑电路真好玩 雾)</li><li>学习Verilog(1/13)</li></ul><p><img src="/images/dailyrecordfor2018sept/sept3_1.JPG" alt=""></p><h1 id="Sept-4"><a href="#Sept-4" class="headerlink" title="Sept 4"></a>Sept 4</h1><ul><li>问题求解3-1(7/11)</li></ul><h1 id="Sept-5"><a href="#Sept-5" class="headerlink" title="Sept 5"></a>Sept 5</h1><ul><li>问题求解3-1(11/11)</li><li>PA0(1/5)</li></ul><h1 id="Sept-6"><a href="#Sept-6" class="headerlink" title="Sept 6"></a>Sept 6</h1><ul><li>配置PA环境</li><li>学习使用vim</li></ul><h1 id="Sept-7"><a href="#Sept-7" class="headerlink" title="Sept 7"></a>Sept 7</h1><ul><li>completed Java OJ</li><li>Went to Shanghai </li></ul><h1 id="Sept-8"><a href="#Sept-8" class="headerlink" title="Sept 8"></a>Sept 8</h1><ul><li>Went to Shanghai Natrual History Museum with girlfriend</li><li>Walk along the river with girlfriend</li><li>Went to BBQ with girlfriend</li></ul><h1 id="Sept-9"><a href="#Sept-9" class="headerlink" title="Sept 9"></a>Sept 9</h1><ul><li>Went to Jiangwan Stadium with girlfriend</li><li>Had some dessert.</li><li>Went back to Nanjing</li><li>Completed PA0</li></ul><h1 id="Sept-10"><a href="#Sept-10" class="headerlink" title="Sept 10"></a>Sept 10</h1><ul><li>Completed Linear Algebra Exercise 1</li><li>Completed the cpu_state part of PA1</li><li>Completed exp02 in Digital Logical Circuits</li></ul><h1 id="Sept-11"><a href="#Sept-11" class="headerlink" title="Sept 11"></a>Sept 11</h1><ul><li>Completed PA1 stage1</li><li>Completed University Physics Homework</li></ul><h1 id="Sept-12"><a href="#Sept-12" class="headerlink" title="Sept 12"></a>Sept 12</h1><ul><li>Completed OJ(1/4)</li><li>Learned Java</li></ul><h1 id="Sept-13"><a href="#Sept-13" class="headerlink" title="Sept 13"></a>Sept 13</h1><ul><li>Completed OJ(4/4)</li><li>Completed Linear Algebra (4/4)</li><li>Completed ICS homework</li></ul><h1 id="Sept-14"><a href="#Sept-14" class="headerlink" title="Sept 14"></a>Sept 14</h1><ul><li>Completed Linear Algebra (3/3)</li></ul><h1 id="Sept-15"><a href="#Sept-15" class="headerlink" title="Sept 15"></a>Sept 15</h1><ul><li>Met the research supervisor</li><li>Did some problem solving</li><li>Played with my Hadoop</li></ul><h1 id="Sept-16"><a href="#Sept-16" class="headerlink" title="Sept 16"></a>Sept 16</h1><ul><li>Completed Problem Solving 3-2</li></ul><h1 id="Sept-17"><a href="#Sept-17" class="headerlink" title="Sept 17"></a>Sept 17</h1><h1 id="Sept-18"><a href="#Sept-18" class="headerlink" title="Sept 18"></a>Sept 18</h1><ul><li>Finished 形势与政策 homework</li><li>Did Expr04 of Digital Logical Circuits</li></ul><h1 id="Sept-19"><a href="#Sept-19" class="headerlink" title="Sept 19"></a>Sept 19</h1><ul><li>Completed PA1.2</li><li>Completed Linear Algebra(6/6)</li><li>Completed OJ(3/3)</li></ul><h1 id="Sept-20"><a href="#Sept-20" class="headerlink" title="Sept 20"></a>Sept 20</h1><ul><li>Completed OJ(1/1)</li><li>Completed Problem-Solving 3-3</li><li>Bug-fixing for PA1.2</li></ul><h1 id="Sept-21"><a href="#Sept-21" class="headerlink" title="Sept 21"></a>Sept 21</h1><ul><li>Completed Linear Algebra (3/3)</li></ul><h1 id="Sept-22"><a href="#Sept-22" class="headerlink" title="Sept 22"></a>Sept 22</h1><ul><li>Went downtown with girlfriend</li><li>Had a meal in Nanjing Univer(Xianling Campus) with girlfriend</li><li>Had a tour around the campus with girlfirend</li><li>Had some fruit mixed with yoghurt with girlfriend</li><li>Watched the Europe.Raiders with girlfriend</li></ul><h1 id="Sept-23"><a href="#Sept-23" class="headerlink" title="Sept 23"></a>Sept 23</h1><ul><li>Studied with girlfriend</li><li>Watched The.Little.Prince with girlfriend</li><li>Went to Nanjing University(Gulou Campus) for dinner with girlfriend</li><li>Went to Librairie Avant-Garde (Mount Wutai Branch) with girlfriend and bought a lucky package</li></ul><h1 id="Sept-24"><a href="#Sept-24" class="headerlink" title="Sept 24"></a>Sept 24</h1><ul><li>Went to a cat-featured coffee shop with girlfriend </li><li>Said farewell with girlfriend </li><li>Completed the OO-2 homework(Java)</li></ul><h1 id="Sept-25"><a href="#Sept-25" class="headerlink" title="Sept 25"></a>Sept 25</h1><ul><li>Finished Watchpoint of PA1.3</li></ul><h1 id="Sept-26"><a href="#Sept-26" class="headerlink" title="Sept 26"></a>Sept 26</h1><ul><li>Finished the report of PA1</li><li>Watched several episodes of Big Bang</li><li>Did some reading and learned something about philosophy</li></ul><h1 id="Sept-27"><a href="#Sept-27" class="headerlink" title="Sept 27"></a>Sept 27</h1><ul><li>Did some coding</li></ul><h1 id="Sept-28"><a href="#Sept-28" class="headerlink" title="Sept 28"></a>Sept 28</h1><ul><li>Did some coding</li></ul><h1 id="Sept-29"><a href="#Sept-29" class="headerlink" title="Sept 29"></a>Sept 29</h1><ul><li>Did some coding</li><li>Did some Lab1</li></ul><h1 id="Sept-30"><a href="#Sept-30" class="headerlink" title="Sept 30"></a>Sept 30</h1><ul><li>Completed Linear Algebra(1/1)</li><li>Went home</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Sept-1&quot;&gt;&lt;a href=&quot;#Sept-1&quot; class=&quot;headerlink&quot; title=&quot;Sept 1&quot;&gt;&lt;/a&gt;Sept 1&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;复习汇编&lt;/li&gt;
&lt;li&gt;汇编考试(2:00 pm - 4:00 pm)&lt;/li&gt;
&lt;li&gt;重新搭建Hadoop环境(进度50%),修复了好多bug&lt;/li&gt;
&lt;li&gt;&lt;p&gt;装Windows XP 虚拟机(玩了三维弹球)&lt;/p&gt;
    
    </summary>
    
    
      <category term="记录" scheme="https://ricky-ting.github.io/tags/%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Bug-Fix for hadoop installing</title>
    <link href="https://ricky-ting.github.io/2018/09/01/Bug-Fix-for-hadoop-installing/"/>
    <id>https://ricky-ting.github.io/2018/09/01/Bug-Fix-for-hadoop-installing/</id>
    <published>2018-09-01T14:26:44.000Z</published>
    <updated>2018-09-01T14:39:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>启动守护进程的时候(<code>start-dfs.sh</code>)报错：<code>master: ssh: Could not resolve hostname master: Name or Service not knwon</code>。</p><p>解决方法: 在host文件中添加master解析。</p><p><code>sudo vim /etc/hosts</code></p><p><code>127.0.0.1  master</code></p><p><a href="http://www.powerxing.com/install-hadoop/comment-page-1/" target="_blank" rel="noopener">贴一篇超详细的教程</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;启动守护进程的时候(&lt;code&gt;start-dfs.sh&lt;/code&gt;)报错：&lt;code&gt;master: ssh: Could not resolve hostname master: Name or Service not knwon&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;解决方
      
    
    </summary>
    
    
      <category term="bug" scheme="https://ricky-ting.github.io/tags/bug/"/>
    
  </entry>
  
  <entry>
    <title>shared folder in virtual machine</title>
    <link href="https://ricky-ting.github.io/2018/09/01/shared-folder-in-virtual-machine/"/>
    <id>https://ricky-ting.github.io/2018/09/01/shared-folder-in-virtual-machine/</id>
    <published>2018-09-01T11:35:31.000Z</published>
    <updated>2018-09-11T13:12:20.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="shared-folder-in-virtual-machine"><a href="#shared-folder-in-virtual-machine" class="headerlink" title="shared folder in virtual machine"></a>shared folder in virtual machine</h1><ol><li>首先在virtual box点击 <code>Insert Guest Additions CD Image</code></li><li>在虚拟机中运行弹出来的窗口</li><li>在Terminal中输入<code>sudo adduser $YourUserName vboxsf</code></li><li>Restart</li></ol><p><a href="https://stackoverflow.com/questions/26740113/virtualbox-shared-folder-permissions" target="_blank" rel="noopener">Stack Overflow相关链接</a></p><p>But when you cannot mount the disk automatically, you have to do it manually. Steps are as follows:</p><ol><li><p>Devices -&gt; Install Guest Additions..</p></li><li><p>Type the following in the guest terminal</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir --p /media/cdrom</span><br><span class="line">sudo mount -t auto /dev/cdrom /media/cdrom/</span><br><span class="line">cd /media/cdrom/</span><br><span class="line">sudo sh VBoxLinuxAdditions.run</span><br></pre></td></tr></table></figure><ol><li>Then<code>sudo adduser $YourUserName vboxsf</code></li><li>Restart.</li></ol><p><a href="https://askubuntu.com/questions/80341/unable-to-mount-virtualbox-guest-additions-as-a-guest-win7-host" target="_blank" rel="noopener">相关链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;shared-folder-in-virtual-machine&quot;&gt;&lt;a href=&quot;#shared-folder-in-virtual-machine&quot; class=&quot;headerlink&quot; title=&quot;shared folder in virtual mac
      
    
    </summary>
    
    
      <category term="bug" scheme="https://ricky-ting.github.io/tags/bug/"/>
    
  </entry>
  
  <entry>
    <title>回顾与展望(2018.8.25)</title>
    <link href="https://ricky-ting.github.io/2018/08/25/%E5%9B%9E%E9%A1%BE%E4%B8%8E%E5%B1%95%E6%9C%9B-2018-8-25/"/>
    <id>https://ricky-ting.github.io/2018/08/25/回顾与展望-2018-8-25/</id>
    <published>2018-08-25T02:05:06.000Z</published>
    <updated>2018-08-25T02:21:35.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="暑假里干的事"><a href="#暑假里干的事" class="headerlink" title="暑假里干的事"></a>暑假里干的事</h2><a id="more"></a><ol><li>看了《数学之美》</li><li>看了《黑客与画家》</li><li>看了《1Q84》</li><li>看完CSAPP前三章，并完成汇编实验和作业，拆炸弹</li><li>进行《挑战程序设计竞赛》里的编程训练</li><li>看完《计算机系统基础》前三章，并看完ICS网课相应部分</li><li>完成《Hadoop技术内幕》的源代码分析环境搭建，并阅读前两章(意识到要先学习java)</li><li>看了n(&gt;20)部电影</li><li>湖北五日游</li><li>练车，过了科三</li><li>社会实践(扬州二日游)</li></ol><p>总结：感觉效率还是不高，在家易涣散。技术学习和课外拓展较少。<del>导师的邮件让我意识到暑假里一事无成,趁着还有几天亡羊补牢吧</del></p><p>思考：</p><ul><li>计算机专业涵盖面太广，想学很多东西，但往往局限于了解。</li><li>其次需要学的多了的时候，易浮躁。</li><li>学会在信息的洪流中认准自己需要的，贪多不易得。</li><li>学习方法需要改进，经常在网上学习新知识的时候，易陷入递归状态，不断地点击超链接和查询新名词，导致经常开了十几个页面，最后只了解了皮毛，自暴自弃把所有页面关了。</li><li>要养成随时学习的习惯，保持对技术和知识的热情。</li><li>在做中学。 </li><li>ddl是第一生产力，没有ddl，就只能靠自己自觉了。</li><li><del>大神们的博客太有趣了，看着看着就荒废了一天。</del></li></ul><h2 id="新学期展望"><a href="#新学期展望" class="headerlink" title="新学期展望"></a>新学期展望</h2><h3 id="需要养成的习惯或改掉的坏习惯"><a href="#需要养成的习惯或改掉的坏习惯" class="headerlink" title="需要养成的习惯或改掉的坏习惯"></a>需要养成的习惯或改掉的坏习惯</h3><ul><li>养成daily record的习惯，追踪自己的进展，不要到最后才发现一事无成。</li><li>并且对短期设立计划。</li><li>进行学习思考。</li><li>不浮躁，用心学习</li></ul><h3 id="新学期要做的事"><a href="#新学期要做的事" class="headerlink" title="新学期要做的事"></a>新学期要做的事</h3><ol><li>多看书 (阅读经典，技术书籍等)</li><li>专业课好好上，实验好好做</li><li>大数据学习和实践(java Hadoop spark)</li><li>广泛涉猎技术</li><li>练科二，争取寒假考过</li></ol><h3 id="大数据、云计算学习方面"><a href="#大数据、云计算学习方面" class="headerlink" title="大数据、云计算学习方面"></a>大数据、云计算学习方面</h3><ol><li>多动手，多找一些示例跑一跑。</li><li>养成借助google、Stack Overflow解决配置、运行时出现的问题</li><li>对源代码进行分析</li><li>学习java</li><li>多读经典paper，广泛涉猎</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;暑假里干的事&quot;&gt;&lt;a href=&quot;#暑假里干的事&quot; class=&quot;headerlink&quot; title=&quot;暑假里干的事&quot;&gt;&lt;/a&gt;暑假里干的事&lt;/h2&gt;
    
    </summary>
    
    
      <category term="计划" scheme="https://ricky-ting.github.io/tags/%E8%AE%A1%E5%88%92/"/>
    
      <category term="记录" scheme="https://ricky-ting.github.io/tags/%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>挑战程序设计竞赛笔记</title>
    <link href="https://ricky-ting.github.io/2018/08/24/%E6%8C%91%E6%88%98%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%E7%AC%94%E8%AE%B0/"/>
    <id>https://ricky-ting.github.io/2018/08/24/挑战程序设计竞赛笔记/</id>
    <published>2018-08-24T11:24:53.000Z</published>
    <updated>2018-08-24T11:26:19.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="三角形"><a href="#三角形" class="headerlink" title="三角形"></a>三角形</h2><h3 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h3><p>从一堆绳子中找出三根绳子使得围成的三角形的周长最大。</p><a id="more"></a><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><ol><li>穷举，O($n^3$)</li><li>先排序，看最大的三根可不可以，不可以，将最大的一根剔除，然后递归。O($n \log_{}n$)</li></ol><h2 id="Ants-POJ-1852"><a href="#Ants-POJ-1852" class="headerlink" title="Ants(POJ 1852)"></a>Ants(POJ 1852)</h2><h3 id="描述：-1"><a href="#描述：-1" class="headerlink" title="描述："></a>描述：</h3><p>一堆蚂蚁在一根绳子上，不知道初始朝向，两个蚂蚁相遇会各自掉头，给出每个蚂蚁距离左端的距离和绳子，求出所有蚂蚁掉下绳子的最长时间和最短时间。</p><h3 id="题解：-1"><a href="#题解：-1" class="headerlink" title="题解："></a>题解：</h3><p>两个蚂蚁相遇掉头就相当于两个蚂蚁穿过对方继续前进。O(n)</p><h2 id="Lake-Counting-POJ-2386"><a href="#Lake-Counting-POJ-2386" class="headerlink" title="Lake Counting(POJ 2386)"></a>Lake Counting(POJ 2386)</h2><h3 id="描述：-2"><a href="#描述：-2" class="headerlink" title="描述："></a>描述：</h3><p>和W相邻的八个square可以认为是连在一起的，构成水洼，计算有多少块水洼。</p><h3 id="题解：-2"><a href="#题解：-2" class="headerlink" title="题解："></a>题解：</h3><p>用DFS，把和W相邻的变为<code>.</code>,一次DFS解决一块水洼，多少次DFS就有多少块水洼。复杂度：O(8 $\times$ N $\times$ M)</p><h2 id="迷宫的最短路径"><a href="#迷宫的最短路径" class="headerlink" title="迷宫的最短路径"></a>迷宫的最短路径</h2><h3 id="描述：-3"><a href="#描述：-3" class="headerlink" title="描述："></a>描述：</h3><p>寻找迷宫的最短路径</p><h3 id="题解：-3"><a href="#题解：-3" class="headerlink" title="题解："></a>题解：</h3><p>BFS，用数组记录每一点的距离，不断更新，用队列实现BFS。</p><h2 id="硬币问题"><a href="#硬币问题" class="headerlink" title="硬币问题"></a>硬币问题</h2><h3 id="描述：-4"><a href="#描述：-4" class="headerlink" title="描述："></a>描述：</h3><p>1元、5元、十元、50元、100元的硬币，如何找钱是个数最少。</p><h3 id="题解：-4"><a href="#题解：-4" class="headerlink" title="题解："></a>题解：</h3><p>贪心算法，但有条件，所有大的硬币的面额都得是小的硬币的倍数。如果上面加入20元的硬币，贪心算法就无法使用</p><h2 id="区间调度问题"><a href="#区间调度问题" class="headerlink" title="区间调度问题"></a>区间调度问题</h2><h3 id="描述：-5"><a href="#描述：-5" class="headerlink" title="描述："></a>描述：</h3><p>有很多工作区间，同时只能干一件事，要求在一段时间内完成最多的工作(个数)</p><h3 id="题解：-5"><a href="#题解：-5" class="headerlink" title="题解："></a>题解：</h3><p>总是在可选的工作中选取结束时间最早的工作</p><h2 id="Best-Cow-Line-POJ-3617"><a href="#Best-Cow-Line-POJ-3617" class="headerlink" title="Best Cow Line(POJ 3617)"></a>Best Cow Line(POJ 3617)</h2><h3 id="描述：-6"><a href="#描述：-6" class="headerlink" title="描述："></a>描述：</h3><p>每次可以从S的头部或尾部取一个字符加入到T的尾部，使得最终T的字典序最小</p><h3 id="题解：-6"><a href="#题解：-6" class="headerlink" title="题解："></a>题解：</h3><p>比较S和反转后S的字典序，取字典序小的那边，贪心。</p><h2 id="Saruman’s-Army-POJ-3069"><a href="#Saruman’s-Army-POJ-3069" class="headerlink" title="Saruman’s Army (POJ 3069)"></a>Saruman’s Army (POJ 3069)</h2><h3 id="描述：-7"><a href="#描述：-7" class="headerlink" title="描述："></a>描述：</h3><p>点覆盖问题，半径R</p><h3 id="题解：-7"><a href="#题解：-7" class="headerlink" title="题解："></a>题解：</h3><p>贪心</p><h2 id="Fence-Repair-POJ-3253"><a href="#Fence-Repair-POJ-3253" class="headerlink" title="Fence Repair (POJ 3253)"></a>Fence Repair (POJ 3253)</h2><h3 id="描述：-8"><a href="#描述：-8" class="headerlink" title="描述："></a>描述：</h3><p>切木板开销问题</p><h3 id="题解：-8"><a href="#题解：-8" class="headerlink" title="题解："></a>题解：</h3><p>两个最小板应该是一起切得，贪心。</p><h2 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h2><h3 id="描述：-9"><a href="#描述：-9" class="headerlink" title="描述："></a>描述：</h3><p>背包容量有限，拿或不拿。</p><h3 id="题解：-9"><a href="#题解：-9" class="headerlink" title="题解："></a>题解：</h3><p>动态规划</p><h2 id="最长公共子序列问题"><a href="#最长公共子序列问题" class="headerlink" title="最长公共子序列问题"></a>最长公共子序列问题</h2><h3 id="描述：-10"><a href="#描述：-10" class="headerlink" title="描述："></a>描述：</h3><p>求两个字符串的最大公共子序列长度，子序列可不连续</p><h3 id="题解：-10"><a href="#题解：-10" class="headerlink" title="题解："></a>题解：</h3><p>DP</p><h2 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h2><h3 id="描述：-11"><a href="#描述：-11" class="headerlink" title="描述："></a>描述：</h3><p>每种物品可选任意多件</p><h3 id="题解：-11"><a href="#题解：-11" class="headerlink" title="题解："></a>题解：</h3><p>改改递推关系式</p><h2 id="多重部分和关系"><a href="#多重部分和关系" class="headerlink" title="多重部分和关系"></a>多重部分和关系</h2><h3 id="描述：-12"><a href="#描述：-12" class="headerlink" title="描述："></a>描述：</h3><p>有n种不同大小的数字$a_i$,每种各$m_i$个。判断是否可以从这些数字之中选出若干使它们的和恰好为K.</p><h3 id="题解：-12"><a href="#题解：-12" class="headerlink" title="题解："></a>题解：</h3><p>需要记录剩余的数字个数，DP</p><h2 id="最长上升子序列问题"><a href="#最长上升子序列问题" class="headerlink" title="最长上升子序列问题"></a>最长上升子序列问题</h2><h3 id="描述：-13"><a href="#描述：-13" class="headerlink" title="描述："></a>描述：</h3><p>求一个序列的最长上升子序列</p><h3 id="题解：-13"><a href="#题解：-13" class="headerlink" title="题解："></a>题解：</h3><p>DP，记录以$a_i$结尾的最长上升子序列长度</p><h2 id="划分数"><a href="#划分数" class="headerlink" title="划分数"></a>划分数</h2><h3 id="描述：-14"><a href="#描述：-14" class="headerlink" title="描述："></a>描述：</h3><p>有n个无区别的物品，将它们划分成不超过m组，求出划分方法数模M的余数</p><h3 id="题解：-14"><a href="#题解：-14" class="headerlink" title="题解："></a>题解：</h3><p>DP，找出状态转移，设dp[i][j]是j的i划分数，有关系dp[i][j]=dp[i][j-i]+dp[i-1][j]</p><h2 id="多重集组合数"><a href="#多重集组合数" class="headerlink" title="多重集组合数"></a>多重集组合数</h2><h3 id="描述：-15"><a href="#描述：-15" class="headerlink" title="描述："></a>描述：</h3><p>n种物品，第i种有$a_i$个，然后一共取m个，有多少种取法</p><h3 id="题解：-15"><a href="#题解：-15" class="headerlink" title="题解："></a>题解：</h3><p>DP，$dp[i+1][j]=\sum_{k=0}^{min(j,a[i])} dp[i][j-k]$, 可以进一步化简得到: $dp[i+1][j]=dp[i+1][j-1]+dp[i][j]-dp[i][j-1-a_i]$</p><h2 id="Expedition-POJ-2431"><a href="#Expedition-POJ-2431" class="headerlink" title="Expedition (POJ 2431)"></a>Expedition (POJ 2431)</h2><h3 id="描述：-16"><a href="#描述：-16" class="headerlink" title="描述："></a>描述：</h3><p>加油问题，要求次数最少</p><h3 id="题解：-16"><a href="#题解：-16" class="headerlink" title="题解："></a>题解：</h3><p>贪心+优先队列。 不断行驶，当油量为0时，选择经过的最大加油量的加油站。</p><h2 id="食物链-POJ-1182"><a href="#食物链-POJ-1182" class="headerlink" title="食物链 (POJ 1182)"></a>食物链 (POJ 1182)</h2><h3 id="描述：-17"><a href="#描述：-17" class="headerlink" title="描述："></a>描述：</h3><p>有N只动物，分三类，形成循环状的捕食关系，循环给出两种信息：x和y属于同一类和x吃y，一共K条。其中可能出错，求出出错的消息数。</p><h3 id="题解：-17"><a href="#题解：-17" class="headerlink" title="题解："></a>题解：</h3><p>用并查集，维护3*N种状态，看是否有矛盾，进行合并操作和查询操作。</p><h2 id="二分图判定"><a href="#二分图判定" class="headerlink" title="二分图判定"></a>二分图判定</h2><h3 id="描述：-18"><a href="#描述：-18" class="headerlink" title="描述："></a>描述：</h3><p>给定一个n个顶点的图，能否最多用两个颜色染色，相邻顶点颜色不同</p><h3 id="题解：-18"><a href="#题解：-18" class="headerlink" title="题解："></a>题解：</h3><p>用dfs，把相邻的染上不同色，看是否有矛盾</p><h2 id="Minimum-Scalar-Product-GCJ-2008-Round1A-A"><a href="#Minimum-Scalar-Product-GCJ-2008-Round1A-A" class="headerlink" title="Minimum Scalar Product (GCJ 2008 Round1A A)"></a>Minimum Scalar Product (GCJ 2008 Round1A A)</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述:"></a>描述:</h3><p>两个向量，内部换序，使得最后的向量积最小。</p><h3 id="题解：-19"><a href="#题解：-19" class="headerlink" title="题解："></a>题解：</h3><p>设a&lt;b,c&lt;d, 可以证明ad+bc最小。所以只要将两个向量分别排序，最大的和最小的乘就可以。 对于large数据，要用long long</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">long long a[802],b[802];</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">int t,n;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line">long long ans;</span><br><span class="line">for(int i=0;i&lt;t;i++)</span><br><span class="line">&#123;</span><br><span class="line">ans=0;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">for(int j=0;j&lt;n;j++)</span><br><span class="line">cin&gt;&gt;a[j];</span><br><span class="line">for(int j=0;j&lt;n;j++)</span><br><span class="line">cin&gt;&gt;b[j];</span><br><span class="line">sort(a,a+n);</span><br><span class="line">sort(b,b+n);</span><br><span class="line">for(int j=0;j&lt;n;j++)</span><br><span class="line">ans+=(a[j]*b[n-j-1]);</span><br><span class="line">cout&lt;&lt;&quot;Case #&quot;&lt;&lt;i+1&lt;&lt;&quot;: &quot;&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Crazy-Rows-GCJ-2009-Round2-A"><a href="#Crazy-Rows-GCJ-2009-Round2-A" class="headerlink" title="Crazy Rows (GCJ 2009 Round2 A)"></a>Crazy Rows (GCJ 2009 Round2 A)</h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述:"></a>描述:</h3><p>只交换相邻行，使得主对角线上方的元素都是0，求最小交换次数。</p><h3 id="题解：-20"><a href="#题解：-20" class="headerlink" title="题解："></a>题解：</h3><p>对于每一行循环，寻找最近的符合条件的，然后交换</p><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code:"></a>Code:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int a[41];</span><br><span class="line">int t,n;</span><br><span class="line">int counter;</span><br><span class="line">void solve(void);</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line">for(int i=0;i&lt;t;i++)</span><br><span class="line">&#123;</span><br><span class="line">solve();</span><br><span class="line">cout&lt;&lt;&quot;Case #&quot;&lt;&lt;i+1&lt;&lt;&quot;: &quot;&lt;&lt;counter&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void solve(void)</span><br><span class="line">&#123;</span><br><span class="line">counter=0;</span><br><span class="line">string s;</span><br><span class="line">int tmp;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">a[i]=-1;</span><br><span class="line">cin&gt;&gt;s;</span><br><span class="line">for(int j=0;j&lt;n;j++)</span><br><span class="line">if(s[j]==&apos;1&apos;)</span><br><span class="line">a[i]=j;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">int pos=-1;</span><br><span class="line">for(int j=i;j&lt;n;j++)</span><br><span class="line">if(a[j]&lt;=i)</span><br><span class="line">&#123;</span><br><span class="line">pos=j;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">for(int j=pos;j&gt;i;j--)</span><br><span class="line">&#123;</span><br><span class="line">tmp=a[j];</span><br><span class="line">a[j]=a[j-1];</span><br><span class="line">a[j-1]=tmp;</span><br><span class="line">counter++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;三角形&quot;&gt;&lt;a href=&quot;#三角形&quot; class=&quot;headerlink&quot; title=&quot;三角形&quot;&gt;&lt;/a&gt;三角形&lt;/h2&gt;&lt;h3 id=&quot;描述：&quot;&gt;&lt;a href=&quot;#描述：&quot; class=&quot;headerlink&quot; title=&quot;描述：&quot;&gt;&lt;/a&gt;描述：&lt;/h3&gt;&lt;p&gt;从一堆绳子中找出三根绳子使得围成的三角形的周长最大。&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="https://ricky-ting.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>数学之美笔记</title>
    <link href="https://ricky-ting.github.io/2018/08/24/%E6%95%B0%E5%AD%A6%E4%B9%8B%E7%BE%8E%E7%AC%94%E8%AE%B0/"/>
    <id>https://ricky-ting.github.io/2018/08/24/数学之美笔记/</id>
    <published>2018-08-24T11:18:55.000Z</published>
    <updated>2018-08-24T11:23:01.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数学之美笔记"><a href="#数学之美笔记" class="headerlink" title="数学之美笔记"></a>数学之美笔记</h1><h2 id="一、统计语言模型"><a href="#一、统计语言模型" class="headerlink" title="一、统计语言模型"></a>一、统计语言模型</h2><p>利用数学犯法来解决自然语言处理问题，而非传统的语法分析。基于概率的模型</p><p>P(S)=P(w1)P(w2|w1)P(w3|w1&amp;w2)…P(wn|w1&amp;w2…&amp;wn-1)</p><p>利用马尔可夫假设，可以简化为：</p><p>P(S)=P(w1)P(w2|w1)P(w3|w2)…P(wi|wi-1)</p><a id="more"></a><h2 id="二、谈谈中文分词"><a href="#二、谈谈中文分词" class="headerlink" title="二、谈谈中文分词"></a>二、谈谈中文分词</h2><p>1.查字典法,最大匹配-&gt;最小分割法。但对于二义性无能为力</p><p>2.最大概率分词法。用统计语言模型计算出每种分词后句子出现的概率，并找出其中概率最大的。</p><p>找到复合词的嵌套结构</p><h2 id="三、隐含马尔科夫模型在语言处理中的应用"><a href="#三、隐含马尔科夫模型在语言处理中的应用" class="headerlink" title="三、隐含马尔科夫模型在语言处理中的应用"></a>三、隐含马尔科夫模型在语言处理中的应用</h2><p>(s1 s2 s3)-&gt;(o1 o2 o3)</p><p>求P(s1,s2,s3|o1,o2,o3)最大，利用贝叶斯公式：</p><p>P(o1,o2,o3,…|s1,s3,s3)*P(s1,s2,s3)</p><p>做两个假设：</p><ol><li>s1,s2,s3,..是一个马尔科夫链,即，si只由si-1决定</li><li>第i时刻的接受信号oi只由发送信号si决定,又称独立输出假设,即P(o1,o2,o3..|s1,s2,s3,..)=P(o1|s1)<em> P(o2|s2) </em> P(o3|s3)…</li></ol><h2 id="四、怎么度量信息？"><a href="#四、怎么度量信息？" class="headerlink" title="四、怎么度量信息？"></a>四、怎么度量信息？</h2><p>香农：信息熵。</p><p>一条信息的信息量大小和它的不确定性有直接关系。它越不确定，信息量越大。</p><p>用bit的概念来度量信息量</p><p>$$ H(X)=- \sum_{x}P(x)\log_2[P(x)] $$</p><p>实际信息的表示和信息熵的差距称作”冗余度”(redundancy)</p><h2 id="五、简单之美：布尔代数和搜索引擎的索引"><a href="#五、简单之美：布尔代数和搜索引擎的索引" class="headerlink" title="五、简单之美：布尔代数和搜索引擎的索引"></a>五、简单之美：布尔代数和搜索引擎的索引</h2><p>最简单的索引是用一个很长的二进制数，每一位代表一个关键词，如果有，则为1，否则为0</p><h2 id="六、图论和网络爬虫"><a href="#六、图论和网络爬虫" class="headerlink" title="六、图论和网络爬虫"></a>六、图论和网络爬虫</h2><p>BFS和DFS</p><p>网络爬虫，通过hash来判断是否爬过</p><h2 id="七、信息论在信息处理中的应用"><a href="#七、信息论在信息处理中的应用" class="headerlink" title="七、信息论在信息处理中的应用"></a>七、信息论在信息处理中的应用</h2><p>不确定性越小，模型越好。信息熵可以直接用于衡量统计语言模型的好坏。</p><p>两个概念：“互信息”(Mutual Information)和”相对熵”(Kullback-Leibler Divergence)</p><ul><li>互信息:是对两个随机事件相关性的度量。可以很好地解决二义性</li><li>相对熵：衡量两个正函数是否相似。对于两个完全相同的函数，它们的相对熵等于零。</li></ul><h2 id="八、贾里尼克的故事和现代语言处理"><a href="#八、贾里尼克的故事和现代语言处理" class="headerlink" title="八、贾里尼克的故事和现代语言处理"></a>八、贾里尼克的故事和现代语言处理</h2><h2 id="九、如何确定网页和查询的相关性"><a href="#九、如何确定网页和查询的相关性" class="headerlink" title="九、如何确定网页和查询的相关性"></a>九、如何确定网页和查询的相关性</h2><p>对关键词次数进行归一化(否则长文章占优),即求频次：称为”关键词频率“或“单文本词汇频率”(Term Frequency)</p><p>还有要去除介词等”应删除词”(Stopwords)，</p><p>对不同的关键词给予不同的权重，如专业词比通用词权重高。有下面两个条件：</p><ol><li><p>一个词预测主题能力越强，权重越大，反之越小</p></li><li><p>应删除词权重为零</p></li></ol><p>使用最多的权重是”逆文本频率指数(Inverse document frequency)“: log(D/Dw),D为全部网页数</p><p>所以计算公式为：TF1 <em> IDF1 + TF2 </em> IDF2+.. + TFN * IDFN</p><p>给定查询，网页的综合排名由相关性和网页排名乘积决定</p><p>IDFN的计算公式为什么取log有待学习</p><h2 id="十、有限状态机和地址识别"><a href="#十、有限状态机和地址识别" class="headerlink" title="十、有限状态机和地址识别"></a>十、有限状态机和地址识别</h2><p>类似于时序逻辑里的状态转移</p><p>为了能进行模糊匹配，提出基于概率的有限状态机，和离散的马尔科夫链基本等效</p><h2 id="十二、余弦定理和新闻的分类"><a href="#十二、余弦定理和新闻的分类" class="headerlink" title="十二、余弦定理和新闻的分类"></a>十二、余弦定理和新闻的分类</h2><p>基于TF/IDF，生成新闻的特征向量，用余弦定理计算它们的夹角，计算它们的相似度。</p><p>疑问：关于同义词、近义词是否有很好的映射工具</p><h2 id="十三、信息指纹及其应用"><a href="#十三、信息指纹及其应用" class="headerlink" title="十三、信息指纹及其应用"></a>十三、信息指纹及其应用</h2><p>其实就是hash函数，如MD5,SHA1等</p><h2 id="十四、浅谈数学模型的重要性"><a href="#十四、浅谈数学模型的重要性" class="headerlink" title="十四、浅谈数学模型的重要性"></a>十四、浅谈数学模型的重要性</h2><ol><li>一个正确的数学模型应当在形式上是简单的。</li><li>一个正确的模型在它开始的时候可能还不如一个精雕细琢的错误的模型来的准确，但是，如果我们认定大方向是对的，就应该坚持下去。</li><li>大量准确的数据对研发很重要。</li><li>正确的模型也可能受噪音干扰，而显得不准确：这时我们不应该用一种凑合的修正方法来弥补它，而是要找到噪音的根源，这也许能通往重大发现。</li></ol><h2 id="十六-上-、不要把所有的鸡蛋放在一个篮子里–谈谈最大熵模型"><a href="#十六-上-、不要把所有的鸡蛋放在一个篮子里–谈谈最大熵模型" class="headerlink" title="十六(上)、不要把所有的鸡蛋放在一个篮子里–谈谈最大熵模型"></a>十六(上)、不要把所有的鸡蛋放在一个篮子里–谈谈最大熵模型</h2><p>最大熵原理：要保留全部的不确定性，将风险降到最小。</p><p>最大熵原理指出，当我们需要对一个随机事件的概率分布进行预测时，我们的预测应当满足全部已知的条件，而对未知的情况不要做任何主观假设。</p><p>希萨证明，对任何一组不自相矛盾的信息，这个最大熵模型不仅存在，而且是唯一的，都有同一个非常简单的形式–指数函数。</p><p>$$ P(w3|w1,w2,subject)=\frac{e^{\lambda_1(w1,w2,w3)+\lambda_2(subject,w3)}}{Z(w1,w2,subject)}$$</p><p>$\lambda$ 和 Z需要通过观测数据训练出来。</p><h2 id="十六-下-、不要把所有的鸡蛋放在一个篮子里–最大熵模型"><a href="#十六-下-、不要把所有的鸡蛋放在一个篮子里–最大熵模型" class="headerlink" title="十六(下)、不要把所有的鸡蛋放在一个篮子里–最大熵模型"></a>十六(下)、不要把所有的鸡蛋放在一个篮子里–最大熵模型</h2><p>最原始的最大熵模型的训练方法是一种称为通用迭代算法GIS(Generalized iterative scaling)的迭代算法。分为以下几个步骤</p><ol><li>假定第零次迭代的初始模型为等概率的均匀分布。</li><li>用第N次迭代的模型来估算每种信息特征在训练数据中的分布，如果超过了实际的，就把相应的模型参数变小；否则，将它们变大。</li><li>重复步骤2直到收敛</li></ol><p>实际应用中很少用，只是通过它了解最大熵模型的算法，迭代时间长，次数多，不太稳定，容易溢出</p><p>后来有很多改进工作</p><h2 id="十七、闪光的不一定是金子，谈谈搜索引擎作弊问题-Search-Engine-Anti-SPAM"><a href="#十七、闪光的不一定是金子，谈谈搜索引擎作弊问题-Search-Engine-Anti-SPAM" class="headerlink" title="十七、闪光的不一定是金子，谈谈搜索引擎作弊问题(Search Engine Anti_SPAM)"></a>十七、闪光的不一定是金子，谈谈搜索引擎作弊问题(Search Engine Anti_SPAM)</h2><p>常见作弊方法：增加关键词，创建专门放链接的网站</p><p>相当于声音中加入了噪音，而混入噪音，在数学上相当于两个信号做卷积。噪音消除的过程就是解卷积的过程。</p><h2 id="十八、矩阵运算和文本处理中的分类问题"><a href="#十八、矩阵运算和文本处理中的分类问题" class="headerlink" title="十八、矩阵运算和文本处理中的分类问题"></a>十八、矩阵运算和文本处理中的分类问题</h2><p>分类需要计算相关性，而用内积方法的话，两两配对，计算量很大</p><p>另一种方法是利用矩阵运算中的奇异值分解(Single Value Decomposition 简称SVD)：大矩阵拆分成小矩阵</p><h2 id="十九、马尔科夫链的扩展–贝叶斯网络-Bayesian-Networks"><a href="#十九、马尔科夫链的扩展–贝叶斯网络-Bayesian-Networks" class="headerlink" title="十九、马尔科夫链的扩展–贝叶斯网络(Bayesian Networks)"></a>十九、马尔科夫链的扩展–贝叶斯网络(Bayesian Networks)</h2><p>把有向图看成一个网络，就是贝叶斯网络，每个圆圈代表状态，状态之间的连线表示它们的因果关系。这些关系都有一个可以量化的可信度(belief)</p><p>贝叶斯网络的训练是NP-complete问题。</p><h2 id="二十一、布隆过滤器-Bloom-Filter"><a href="#二十一、布隆过滤器-Bloom-Filter" class="headerlink" title="二十一、布隆过滤器(Bloom Filter)"></a>二十一、布隆过滤器(Bloom Filter)</h2><p>实际上是一个很长的二进制向量和一系列随机映射函数。</p><p>n个随机函数选择位，然后设为1。</p><p>有误判概率</p><h2 id="二十二、由电视剧《暗算》所想到的-谈谈密码学的数学原理"><a href="#二十二、由电视剧《暗算》所想到的-谈谈密码学的数学原理" class="headerlink" title="二十二、由电视剧《暗算》所想到的-谈谈密码学的数学原理"></a>二十二、由电视剧《暗算》所想到的-谈谈密码学的数学原理</h2><p>RSA加密</p><h2 id="二十三、输入一个汉字需要敲多少个键——谈谈香农第一定律"><a href="#二十三、输入一个汉字需要敲多少个键——谈谈香农第一定律" class="headerlink" title="二十三、输入一个汉字需要敲多少个键——谈谈香农第一定律"></a>二十三、输入一个汉字需要敲多少个键——谈谈香农第一定律</h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数学之美笔记&quot;&gt;&lt;a href=&quot;#数学之美笔记&quot; class=&quot;headerlink&quot; title=&quot;数学之美笔记&quot;&gt;&lt;/a&gt;数学之美笔记&lt;/h1&gt;&lt;h2 id=&quot;一、统计语言模型&quot;&gt;&lt;a href=&quot;#一、统计语言模型&quot; class=&quot;headerlink&quot; title=&quot;一、统计语言模型&quot;&gt;&lt;/a&gt;一、统计语言模型&lt;/h2&gt;&lt;p&gt;利用数学犯法来解决自然语言处理问题，而非传统的语法分析。基于概率的模型&lt;/p&gt;
&lt;p&gt;P(S)=P(w1)P(w2|w1)P(w3|w1&amp;amp;w2)…P(wn|w1&amp;amp;w2…&amp;amp;wn-1)&lt;/p&gt;
&lt;p&gt;利用马尔可夫假设，可以简化为：&lt;/p&gt;
&lt;p&gt;P(S)=P(w1)P(w2|w1)P(w3|w2)…P(wi|wi-1)&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="https://ricky-ting.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>插入代码注意事项</title>
    <link href="https://ricky-ting.github.io/2018/08/03/%E6%8F%92%E5%85%A5%E4%BB%A3%E7%A0%81%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <id>https://ricky-ting.github.io/2018/08/03/插入代码注意事项/</id>
    <published>2018-08-03T08:26:43.000Z</published>
    <updated>2018-08-03T08:28:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>开启mathjax后排版混乱，本来以为是mathjax的锅，后发现```之后多加了一个空格。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;开启mathjax后排版混乱，本来以为是mathjax的锅，后发现```之后多加了一个空格。&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="bug" scheme="https://ricky-ting.github.io/tags/bug/"/>
    
  </entry>
  
  <entry>
    <title>2018 Spring Problem Solving 2</title>
    <link href="https://ricky-ting.github.io/2018/07/08/2018-Spring-Problem-Solving-2/"/>
    <id>https://ricky-ting.github.io/2018/07/08/2018-Spring-Problem-Solving-2/</id>
    <published>2018-07-08T01:12:08.000Z</published>
    <updated>2018-08-03T08:25:50.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2018春问题求解笔记"><a href="#2018春问题求解笔记" class="headerlink" title="2018春问题求解笔记"></a>2018春问题求解笔记</h1><h2 id="2-1-算法正确性-2018-3-7"><a href="#2-1-算法正确性-2018-3-7" class="headerlink" title="2-1 算法正确性(2018.3.7)"></a>2-1 算法正确性(2018.3.7)</h2><p>程序和算法不等同</p><p>算法正确性是基础</p> <a id="more"></a><p>“Program testing can be used to show the presence of bugs, but never to show their absence!”</p><p>封闭环境内同一个输入会产生同样的错误，但网络环境以及并行下不一定。错误的难重现</p><p>部分正确性(if terminates)和完全正确性(indeed terminates)</p><p>循环不变式</p><p>show converge</p><p>assertion和checkpoint：我们可以在算法的任意位置，设置assertion，这个“位置”就是check point</p><p>证明就是断言的序列</p><p>一条链</p><p>递归：数学归纳法</p><p>证明多个变量的数学归纳法：$\forall$ m, 对n做归纳</p><h3 id="习题讲解-2018-3-12"><a href="#习题讲解-2018-3-12" class="headerlink" title="习题讲解(2018.3.12)"></a>习题讲解(2018.3.12)</h3><p>totalwork = workdone + worktodo</p><p>(1)-&gt;(2)-&gt;(2’)-&gt;(3)-&gt;(4)</p><h3 id="open-topic"><a href="#open-topic" class="headerlink" title="open topic"></a>open topic</h3><h4 id="1-证明插入排序的完全正确性"><a href="#1-证明插入排序的完全正确性" class="headerlink" title="1.证明插入排序的完全正确性"></a>1.证明插入排序的完全正确性</h4><p>两层循环 内层 外层</p><h4 id="2-证明旋转汉诺塔的完全正确性"><a href="#2-证明旋转汉诺塔的完全正确性" class="headerlink" title="2.证明旋转汉诺塔的完全正确性"></a>2.证明旋转汉诺塔的完全正确性</h4><p>状态数 操作数：操作数&gt;状态数，则非最优解</p><h2 id="2-2-算法的效率"><a href="#2-2-算法的效率" class="headerlink" title="2-2 算法的效率"></a>2-2 算法的效率</h2><h3 id="open-topic-1"><a href="#open-topic-1" class="headerlink" title="open topic"></a>open topic</h3><h4 id="Algorithmic-Gap"><a href="#Algorithmic-Gap" class="headerlink" title="Algorithmic Gap"></a>Algorithmic Gap</h4><p>Decision Tree</p><p>Adversary Argument</p><h2 id="2-3-组合与计数"><a href="#2-3-组合与计数" class="headerlink" title="2-3 组合与计数"></a>2-3 组合与计数</h2><p>计数在算法分析中很重要</p><p>抽象</p><p>加法原理 乘法原理</p><p>kth falling factorial power of n</p><p>Pascal’s triangle</p><p>Pascal relationship</p><p>multiset：放入k个后取</p><p>等价关系用于计数 等价类 商集</p><h2 id="2-4-分治法与递归"><a href="#2-4-分治法与递归" class="headerlink" title="2-4 分治法与递归"></a>2-4 分治法与递归</h2><p>Divide-and-Conquer: 3steps(Divid -&gt; Conquer -&gt; Combine)</p><p>递归中subproblem出现的两种case:recursive case, base case</p><h3 id="three-methods-for-solving-recurrences"><a href="#three-methods-for-solving-recurrences" class="headerlink" title="three methods for solving recurrences:"></a>three methods for solving recurrences:</h3><ul><li>substitution method</li><li>recursion-tree method</li><li>master method</li></ul><h3 id="maximum-subarray-problem"><a href="#maximum-subarray-problem" class="headerlink" title="maximum-subarray problem"></a>maximum-subarray problem</h3><p>consider the daily change in price</p><p>divide-and-conquer解法: 把序列一分为二，然后最长的有三种情况，全在左边一半，全在右边一半，横跨中点。然后重点如何处理第三种情况，在中点向两边分别找，然后合并。复杂度为O(nlogn).</p><p>有O(n)算法 类似于DP</p><h3 id="Strassen’s-algorithm-for-matrix-multiplication"><a href="#Strassen’s-algorithm-for-matrix-multiplication" class="headerlink" title="Strassen’s algorithm for matrix multiplication"></a>Strassen’s algorithm for matrix multiplication</h3><p>$O(n^3) -&gt; O(n^{2.81})[O(n^{lg7})]$</p><h3 id="substituition-method"><a href="#substituition-method" class="headerlink" title="substituition method"></a>substituition method</h3><p>Guess and then prove. Mathematical Induction.</p><ol><li>Guess the form of the solution.</li><li>Use mathemarical induction to find the constants and show that the solution works.</li></ol><p>一些证明中的小技巧:改变起始项，更换变量</p><h3 id="Recursion-tree-method"><a href="#Recursion-tree-method" class="headerlink" title="Recursion-tree method"></a>Recursion-tree method</h3><p>A recursion-tree is best used to generate a good guess.</p><p>Analyse and then sum.</p><h3 id="master-method"><a href="#master-method" class="headerlink" title="master method"></a>master method</h3><p>prove</p><p>为什么分治法能降低时间复杂度？</p><h2 id="2-5-递归及其数学基础"><a href="#2-5-递归及其数学基础" class="headerlink" title="2-5 递归及其数学基础"></a>2-5 递归及其数学基础</h2><p>求解精确解</p><h3 id="Mathematical-Induction"><a href="#Mathematical-Induction" class="headerlink" title="Mathematical Induction"></a>Mathematical Induction</h3><ul><li>base case  </li><li>inductive hypothesis</li><li>inductive step</li><li>inductive conclusion</li></ul><p>The terms weak and strong arise from what is assumed in the inductive hypothesis. Adding more restrictions strengthens an assertion, while removing restrictions weakens the assertion</p><p>recursion和mathematical induction有密切联系<br>一个自上而下(分解问题) 一个自下而上(组合问题)</p><p>structural induction</p><p>triangulated polygon<br>Ear Lemma</p><p>等比数列</p><p>ﬁrst-order linear recurrence ：T(n) = f (n)T(n − 1) + g(n)</p><p>巧用微积分知识</p><p>解一阶线性：直接展开</p><p>解线性齐次：解特征方程</p><h2 id="2-6-算法方法"><a href="#2-6-算法方法" class="headerlink" title="2-6 算法方法"></a>2-6 算法方法</h2><p>问题求解：压缩解空间</p><p>Maximal Polygon Distance问题</p><p>Minimal Spanning Tree</p><p>Greedy DP(本质上还是穷竭搜索 但空间换时间)</p><p>DFS BFS</p><p>Bin packing NPC问题</p><h2 id="2-7-离散概率"><a href="#2-7-离散概率" class="headerlink" title="2-7 离散概率"></a>2-7 离散概率</h2><p>Complementary Probabilities</p><p>The Uniform Probability Distribution</p><p>(Principle of Inclusion and Exclusion for Probability)<br>Proof1: 算P(x)的系数 用二项式定理 Proof2:待理解</p><p>Conditional probability: P(E|F)=P(E \cap F) / P(F) [P(E|F)=P(E) when P(F)=0]</p><p>We say E is independent of F if P(E|F) = P(E). 我认为P(E|F)不是由公式导出的。存疑</p><p><strong>Bayes’ Theorem</strong>：P(E|F)P(F) = P(F|E)P(E).</p><p>product principle for independent probabilities: P(E \cap F) = P(E)P(F)</p><p>independent trials process</p><p>our model of hashing is an independent trials process.</p><p>probability tree</p><p>A random variable for an experiment with a sample space S is a function that assigns a number to each element of S.</p><p>Bernoulli trials process</p><p>expected value</p><p>indicator random variable</p><p>The Number of Trials until the First Success</p><p>指示器随机变量提供了一个便利的工具实现事件A发生的概率和期望之间的转换：求某个随机变量的期望往往可以简化为若干个和该随机变量相关的事件的概率之和</p><h2 id="2-8-概率分析与随机化算法"><a href="#2-8-概率分析与随机化算法" class="headerlink" title="2-8 概率分析与随机化算法"></a>2-8 概率分析与随机化算法</h2><p>conditional expected value</p><p>Randomized Algorithms</p><p>Quicksort分析</p><p>normal curve</p><p>variance</p><p>Central limit theorem.</p><p>normal distribution</p><h2 id="2-9-排序与选择"><a href="#2-9-排序与选择" class="headerlink" title="2-9 排序与选择"></a>2-9 排序与选择</h2><p>The Coupon Collector’s Problem</p><p>$n log n + (m-1)nloglogn + nC_m + o(n), n \rightarrow \infty, m fixed$</p><p>Tony Hoare: Quicksort, Hoare Logic: {P}S{Q}, null pointer “I call it my billion-dollar mistake”.</p><p>证明下界：1. decision tree 2. adversary strategy</p><p>Adversary Argument：证下界</p><p>检测01、同时找最大最小、找第二小，k=3 is still open， 找中间值</p><h2 id="2-10-基本数据结构"><a href="#2-10-基本数据结构" class="headerlink" title="2-10 基本数据结构"></a>2-10 基本数据结构</h2><p>tail指向最后一个元素的后一个 为什么</p><p>Why Numbering Should Start at Zero(EWD831)</p><h2 id="2-11-堆与堆排序"><a href="#2-11-堆与堆排序" class="headerlink" title="2-11 堆与堆排序"></a>2-11 堆与堆排序</h2><h2 id="2-12-Hashing方法"><a href="#2-12-Hashing方法" class="headerlink" title="2-12 Hashing方法"></a>2-12 Hashing方法</h2><h2 id="2-13-搜索树"><a href="#2-13-搜索树" class="headerlink" title="2-13 搜索树"></a>2-13 搜索树</h2><p>A tree is a recursive abstract data type</p><h3 id="Binary-Search-Tree"><a href="#Binary-Search-Tree" class="headerlink" title="Binary Search Tree"></a>Binary Search Tree</h3><p>Operations: Search(用while), Minimum(当子节点不为nil一直下去), Maximum, Predecessor(分两种情况:有右子树 无右子树), Successor, Insert and Delete(分三种情况).  Transplant(不管子节点)</p><p>The expected height of a randomly built binary search tree is $O(\lg{n})$.</p><p>B-trees are particularly good for maintaining databases on secondary(disk) storage</p><h4 id="Binary-search-tree-property"><a href="#Binary-search-tree-property" class="headerlink" title="Binary-search-tree property"></a>Binary-search-tree property</h4><p> If y is a node of left subtree of x, then $y.key \le x.key$.</p><p> If x is a node of right subtree of x, then $y.key \ge x.key$</p><h4 id="tree-walk"><a href="#tree-walk" class="headerlink" title="tree walk"></a>tree walk</h4><p>inorder tree walk   Inorder-tree-walk(T.root)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">INORDER-TREE-WALK(x)</span><br><span class="line">if x!=NIL</span><br><span class="line">INORDER-TREE-WALK(x.left)</span><br><span class="line">print x.key</span><br><span class="line">INORDER-TREE-WALK(x.right)</span><br></pre></td></tr></table></figure><p>如何证明其正确性<br>效率$\Theta(n) 用master直观 用替代法证明$</p><p>preorder tree walk</p><p>postorder tree walk.</p><h4 id="Tree-Search-and-Tree-Insert"><a href="#Tree-Search-and-Tree-Insert" class="headerlink" title="Tree-Search and Tree-Insert"></a>Tree-Search and Tree-Insert</h4><h4 id="Minimum-and-maximum"><a href="#Minimum-and-maximum" class="headerlink" title="Minimum and maximum"></a>Minimum and maximum</h4><h4 id="Successor-and-Predecessor"><a href="#Successor-and-Predecessor" class="headerlink" title="Successor and Predecessor"></a>Successor and Predecessor</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Tree-Successor(x)</span><br><span class="line">if x.right!=NIL</span><br><span class="line">return Tree-Minimum(x.right)</span><br><span class="line">y=x.p</span><br><span class="line">while y!=NIL &amp;&amp; x=y.right</span><br><span class="line">x=y</span><br><span class="line">y=x.p</span><br><span class="line">return y</span><br></pre></td></tr></table></figure><h4 id="Insertion-and-Deletion"><a href="#Insertion-and-Deletion" class="headerlink" title="Insertion and Deletion"></a>Insertion and Deletion</h4><p>插入找空位就可</p><p>删除分三种情况：没有孩子(直接删除)、有一个孩子(直接登基)、有两个孩子(找后继)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Transplant(T,u,v)</span><br><span class="line">if u.p==NIL</span><br><span class="line">T.root=v</span><br><span class="line">elseif u==u.p.left</span><br><span class="line">u.p.left=v</span><br><span class="line">else</span><br><span class="line">u.p.right=v</span><br><span class="line">if v!=NIL</span><br><span class="line">v.p=u.p</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Tree-Delete(T,z)</span><br><span class="line">if z.left==NIL</span><br><span class="line">Transplant(T,z,z.right)</span><br><span class="line">elseif z.right==NIL</span><br><span class="line">Transplant(T,z,z.left)</span><br><span class="line">else</span><br><span class="line">y=Tree-Minimum(z.right)</span><br><span class="line">if y.p!=z</span><br><span class="line">Transplant(T,y,y.right)</span><br><span class="line">y.right=z.right</span><br><span class="line">y.right.p=y</span><br><span class="line">Transplant(T,z,y)</span><br><span class="line">y.left=z.left</span><br><span class="line">y.left.p=y</span><br></pre></td></tr></table></figure><h3 id="Red-Black-Tree"><a href="#Red-Black-Tree" class="headerlink" title="Red Black Tree"></a>Red Black Tree</h3><h4 id="red-black-properties"><a href="#red-black-properties" class="headerlink" title="red-black properties"></a>red-black properties</h4><ol><li>Every node is either red or black</li><li>The root is black</li><li>Every leaf(NIL) is black</li><li>If a node is red, then both its children are black.</li><li>For each node, all simple paths from the node to descendant leaves contain the same number of black nodes.</li></ol><p>A red-black tree with n internal nodes has height at most $2\lg{n+1}$</p><h4 id="Rotations"><a href="#Rotations" class="headerlink" title="Rotations"></a>Rotations</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Left-Rotate(T,x)</span><br><span class="line">y=x.right</span><br><span class="line">x.right=y.left</span><br><span class="line">if y.left!=T.nil</span><br><span class="line">y.left.p=x</span><br><span class="line">y.p=x.p</span><br><span class="line">if x.p==T.nil</span><br><span class="line">T.root=y</span><br><span class="line">elseif x==x.p.left</span><br><span class="line">x.p.left=y</span><br><span class="line">else</span><br><span class="line">x.p.right=y</span><br><span class="line">y.left=x</span><br><span class="line">x.p=y</span><br></pre></td></tr></table></figure><p>In every n-node binary search tree, there are exactly n-1 possible rotations.</p><h4 id="Insertion"><a href="#Insertion" class="headerlink" title="Insertion"></a>Insertion</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">RB-INSERT(T,z)</span><br><span class="line">y=T.nil</span><br><span class="line">x=T.root</span><br><span class="line">while x!=T.nil</span><br><span class="line">y=x</span><br><span class="line">if z.key&lt;x.key</span><br><span class="line">x=x.left</span><br><span class="line">else x=x.right</span><br><span class="line">z.p=y</span><br><span class="line">if y==T.nil</span><br><span class="line">T.root=z</span><br><span class="line">elseif z.key&lt;y.key</span><br><span class="line">y.left=z</span><br><span class="line">else y.right=z</span><br><span class="line">z.left=T.nil</span><br><span class="line">z.right=T.nil</span><br><span class="line">z.color = RED</span><br><span class="line">RB-INSERT-FIXUP(T,z)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">RB-INSERT-FIXUP(T,z)</span><br><span class="line">while z.p.color==RED</span><br><span class="line">if z.p==z.p.p.left</span><br><span class="line">y=z.p.p.right</span><br><span class="line">if y.color==RED</span><br><span class="line">z.p.color=BLACK//case1</span><br><span class="line">y.color=BLACK//case1</span><br><span class="line">z.p.p.color=RED//case1</span><br><span class="line">z=z.p.p//case1</span><br><span class="line">else if z==z.p.right</span><br><span class="line">z=z.p//case2</span><br><span class="line">LEFT-ROTATE(T,z)//case2</span><br><span class="line">z.p.color=BLACK//case3</span><br><span class="line">z.p.p.color=RED//case3</span><br><span class="line">RIGHT-ROTATE(T,z.p.p)//case3</span><br><span class="line">else (same as then clause with &quot;right&quot; and &quot;left&quot; exchanged) </span><br><span class="line">T.root.color=BLACK</span><br></pre></td></tr></table></figure><h2 id="2-14-B树"><a href="#2-14-B树" class="headerlink" title="2-14 B树"></a>2-14 B树</h2><h2 id="Appendix-C"><a href="#Appendix-C" class="headerlink" title="Appendix C"></a>Appendix C</h2><p>Binomial bounds: C_n^k &gt;= (n/k)^k</p><p>对于自然数集N: <code>E[X]=\sum_{i=0}^{\infty} i*Pr{X=i} =\sum_{i=0}^{\infty} i*(Pr{X&gt;=i}-Pr{X&gt;=i+1}) = \sum_{i=1}^{\infty} Pr{X&gt;=i}</code></p><p>Var[X]=E[X^2]-E^2[X]</p><p>Var[aX]=a^2Var[X]</p><p>Var[X+Y]=Var[X]+Var[Y]</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;2018春问题求解笔记&quot;&gt;&lt;a href=&quot;#2018春问题求解笔记&quot; class=&quot;headerlink&quot; title=&quot;2018春问题求解笔记&quot;&gt;&lt;/a&gt;2018春问题求解笔记&lt;/h1&gt;&lt;h2 id=&quot;2-1-算法正确性-2018-3-7&quot;&gt;&lt;a href=&quot;#2-1-算法正确性-2018-3-7&quot; class=&quot;headerlink&quot; title=&quot;2-1 算法正确性(2018.3.7)&quot;&gt;&lt;/a&gt;2-1 算法正确性(2018.3.7)&lt;/h2&gt;&lt;p&gt;程序和算法不等同&lt;/p&gt;
&lt;p&gt;算法正确性是基础&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="https://ricky-ting.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
