<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ricky Ting&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/4492b8f6628f8336b7f13bd4cb84b846</icon>
  <subtitle>当时只道是寻常</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ricky-ting.github.io/"/>
  <updated>2019-06-20T05:58:12.308Z</updated>
  <id>https://ricky-ting.github.io/</id>
  
  <author>
    <name>Ricky-Ting</name>
    <email>Ricky.Ting@outlook.com Ricky.B.Ting@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>template</title>
    <link href="https://ricky-ting.github.io/2019/06/20/template/"/>
    <id>https://ricky-ting.github.io/2019/06/20/template/</id>
    <published>2019-06-20T05:57:14.000Z</published>
    <updated>2019-06-20T05:58:12.308Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;ctime&gt;</span><br><span class="line">#include &lt;ctype.h&gt;</span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef long long ll;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const int maxn = 1E9 + 9;</span><br><span class="line">bool notPrime[maxn];</span><br><span class="line">int cPrime, primes[maxn];</span><br><span class="line"></span><br><span class="line">void init_prime_table()&#123;</span><br><span class="line">  notPrime[0] = true;</span><br><span class="line">  notPrime[1] = true;</span><br><span class="line"></span><br><span class="line">  for(int i = 2;i &lt; maxn;++i)&#123;</span><br><span class="line">    if(!notPrime[i]) primes[cPrime++] = i;</span><br><span class="line">    for(int j=0;j &lt; cPrime;++j)&#123;</span><br><span class="line">      if(primes[j] * (ll)i &gt;= maxn) break;</span><br><span class="line">      notPrime[primes[j] * i] = true;</span><br><span class="line">      if((i % primes[j]) == 0) break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bool isprime(ll n, ll s);</span><br><span class="line"></span><br><span class="line">void test()&#123;</span><br><span class="line">  init_prime_table();</span><br><span class="line">  for(int i=2;i&lt;maxn;++i)&#123;</span><br><span class="line">    if(notPrime[i]) &#123;</span><br><span class="line">    //if(isprime(i,5))</span><br><span class="line">    //printf(&quot;%d\n&quot;,i);</span><br><span class="line">    assert(!isprime(i,5));</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">    //if(!isprime(i,5))</span><br><span class="line">    //printf(&quot;%d\n&quot;,i);</span><br><span class="line">    assert(isprime(i,5));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">  srand(time(0));</span><br><span class="line">  test();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ll exponent(ll a, ll s, ll n) &#123;</span><br><span class="line">ll ret = 1;</span><br><span class="line">ll x = a;</span><br><span class="line">while(s) &#123;</span><br><span class="line">if(s&amp;0x1) &#123;</span><br><span class="line">ret = (ret*x) %n;</span><br><span class="line">&#125;</span><br><span class="line">s&gt;&gt;=1;</span><br><span class="line">x = (x*x)%n;</span><br><span class="line">&#125;</span><br><span class="line">return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool witness(ll n, ll a) &#123;</span><br><span class="line">ll s = n-1;</span><br><span class="line">int t = 0;</span><br><span class="line"></span><br><span class="line">while((s&amp;0x1) == 0) &#123;</span><br><span class="line">t++;</span><br><span class="line">s&gt;&gt;=1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll x = exponent(a,s,n);</span><br><span class="line">ll nx;</span><br><span class="line">for(int i=0;i&lt;t;i++) &#123;</span><br><span class="line">nx = (x*x)%n;</span><br><span class="line">if(nx==1 &amp;&amp; x!=1 &amp;&amp; x!=n-1)</span><br><span class="line">return true;</span><br><span class="line">x = nx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(x!=1)</span><br><span class="line">return true;</span><br><span class="line">return false;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bool isprime(ll n, ll s) &#123;</span><br><span class="line"></span><br><span class="line">if(n==2)</span><br><span class="line">return true;</span><br><span class="line">if( (n&amp;0x1) == 0)</span><br><span class="line">return false;</span><br><span class="line">while(s--) &#123;</span><br><span class="line">ll a = (rand()%(n-1)) + 1;</span><br><span class="line">if(witness(n,a))</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void compute_p(string P) &#123;</span><br><span class="line">int m = P.length();</span><br><span class="line">p[1] = 0;</span><br><span class="line">int k = 0;</span><br><span class="line">for(int q=2;q&lt;=m;q++) &#123;</span><br><span class="line">while(k&gt;0 &amp;&amp; P[k]!=P[q-1])</span><br><span class="line">k = p[k];</span><br><span class="line">if(P[k] == P[q-1])</span><br><span class="line">k++;</span><br><span class="line">p[q] = k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void kmp(string P, string T) &#123;</span><br><span class="line">int n = T.length();</span><br><span class="line">int m = P.length();</span><br><span class="line"></span><br><span class="line">int k = 0;</span><br><span class="line">for(int q=1;q&lt;=n;q++) &#123;</span><br><span class="line">while(k&gt;0 &amp;&amp; P[k]!=T[q-1])</span><br><span class="line">k = p[k];</span><br><span class="line">if(P[k] == T[q-1])</span><br><span class="line">k++;</span><br><span class="line">if(k==m) &#123;</span><br><span class="line">k=p[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数据通信期中复习</title>
    <link href="https://ricky-ting.github.io/2019/04/29/%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0/"/>
    <id>https://ricky-ting.github.io/2019/04/29/数据通信期中复习/</id>
    <published>2019-04-29T14:24:02.000Z</published>
    <updated>2019-04-29T16:21:51.354Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据通信期中复习"><a href="#数据通信期中复习" class="headerlink" title="数据通信期中复习"></a>数据通信期中复习</h1><p>通信模型： 源点-&gt;发送器-&gt;传输系统-&gt;接收器-&gt;终点</p><p>单工、半双工、双工。</p><p>数字通信系统:利用数字信号来传递信息的通信系统</p><p>模拟通信系统: 利用模拟信号来传递信息的通信系统</p><p>混成系统</p><p>TCP/IP 5层模型</p><ul><li><p>应用层：用于支持各种不同应用程序的逻辑 (SMTP,FTP,SSH,HTTP)</p></li><li><p>运输层：提供端到端的传输服务 (TCP,UDP)</p></li><li><p>网际层：提供多个网络的路由选择功能，能够让数据跨越多个互联的网路 (IPv4,Ipv6))</p></li><li><p>数据链路层：为与同一个网络相连的两个系统提供网络接入 (以太网,WiFi,ATM,帧中继)</p></li><li><p>物理层：负责数据传输设备与传输媒体的物理接口 (双绞线,光纤,卫星,地面微波)</p></li></ul><p>网络体系结构分层的好处：</p><ul><li><p>为应用提供一个抽象，对应用设计者<strong>隐藏网络的复杂性</strong></p></li><li><p>促进<strong>标准化</strong></p></li><li><p>各层互相独立，技术升级和扩展<strong>灵活性好</strong></p></li><li><p>便于方案设计和<strong>维护</strong></p></li></ul><p>信源编码与译码的目的：</p><ul><li><p>提高信息传输的有效性</p></li><li><p>完成模/数转换</p></li></ul><p>信道编码与译码的目的：</p><ul><li>增强抗干扰能力</li></ul><p>加密与解密的目的：</p><ul><li>保证所传信息的安全</li></ul><p>数字调制与解调的目的：</p><ul><li>形成适合在信道中传输的带通信号</li></ul><p>数字通信的特点</p><ul><li><p>优点：</p><ul><li><p>抗干扰能力强，且噪声不积累</p></li><li><p>传输差错可控</p></li><li><p>便于处理、变换、存储</p></li><li><p>便于将来自不同信源的信号综合到一起传输</p></li><li><p>易于集成，使通信设备微型化，重量轻</p></li><li><p>易于加密处理，且保密性好</p></li></ul></li><li><p>缺点：</p><ul><li><p>需要较大的传输带宽</p></li><li><p>对同步要求高</p></li></ul></li></ul><p>套接字：</p><ul><li><p>流套接字(TCP)： 面向连接的可靠数据传输，并保证按发送时的顺序到达</p></li><li><p>数据报套接字(UDP): 快速，交付没有保证，也不一定会保留初始顺序</p></li><li><p>原始套接字：直接访问底层协议。</p></li></ul><h2 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h2><p>成功的数据传输依赖于两个因素：</p><ul><li><p>传输信号的质量</p></li><li><p>传输媒体的特性</p></li></ul><p>传输媒体：</p><ul><li><p>导向媒体：电磁波在导线引导下 沿某一物理路径前进， 双绞线，光纤，同轴电缆</p></li><li><p>非导向媒体：无线传输，提供传输电磁波方式，但不引导传输方向，空气，真空，海水</p></li></ul><p>傅里叶变换</p><p>方波信号：$s(t) = A \times \frac{4}{\pi} \sum_{k=1,k \ is \ odd}^{\infty} \frac{sin(2\pi kft)}{k}$</p><p>频谱：信号所包含的频率范围</p><p>绝对带宽：信号的频谱宽度</p><p>有效带宽：包含信号绝大多数能量的窄带</p><p>直流分量：信号中频率为零的成份</p><p>$R_b = 2f$</p><p>信号的能量与功率：</p><p>能量：$E<em>x = \int</em>{-\infty} ^{\infty} |x(t)|^2 dt$</p><p>功率：$P_x = \frac{1}{t_2-t<em>1} \int</em>{t_1}^{t_2} |x(t)|^2 dt$.</p><p>一个周期的平均功率为$P= \frac{1}{T} \int_{0}^{T} |x(t)|^2 dt$</p><p>模拟信号：用连续变化电磁波来表示数据</p><p>数字信号：用电压脉冲序列来表示数据</p><p>3dB带宽：即$P<em>{\text{半功}} = 0.5 P</em>{\text{峰值}}$， 也就是说该区间边界的功率值比峰值功率值低3dB.</p><p>数字信号传输：</p><ul><li><p>比传输模拟信号便宜</p></li><li><p>不易受噪声干扰</p></li><li><p>比传输模拟信号更容易受衰减影响</p></li></ul><p>目前普遍采用数字技术的原因：</p><ul><li><p>大规模集成电路在体积和价格上都不断降低</p></li><li><p>数据完整性：不使用放大器而使用转发器，噪声和其他损伤的影响不会被累积</p></li><li><p>容量利用率：实现复用，数字技术(时分)比模拟技术(频分)更容易也更便宜</p></li><li><p>安全与保密：数字数据可以直接加密，而模拟数据还得数字化之后才能加密</p></li><li><p>综合性：所有信号具有相同的格式并且处理方法也相同。经济方便</p></li></ul><p>主要考虑的损伤：</p><ul><li><p>衰减：解决方法：放大器和转发器</p></li><li><p>失真： 时延失真，码间串扰</p></li><li><p>噪声：包括热噪声、互调噪声、串扰、冲激噪声</p></li></ul><p>信噪比：$SNR_{dB} = 10 lg \frac{S}{N}$.</p><p>热噪声：由电子的热运动造成的。 热噪声均匀地分布在通信系统常用的频率范围内，因此通常称为白噪声。$N_0 = kT(W/Hz)$</p><p>互调噪声：当不同频率的信号共享同一传输媒体时，可能会产生互调噪声。互调噪声的产生是由于在发送器、接收器中存在非线性因素，或者是传输系统受到干扰。 额外的信号，频率是两个原频率之和或差。</p><p>串扰：载有多路信号的相邻双绞线之间发生电耦合，有时在同轴电缆之间也会发生。 双绞线的扭绞结构是为了减少相邻导线 间的串扰和消除外界干扰。</p><p>以上噪声都是可预测的，并有着比较固定的强度。</p><p>冲激噪声：是非连续的，由不规则的脉冲或持续时间短而振幅大的噪声尖峰组成。它的产生有多种原因，包括外部电磁波干扰以及通信通信系统本身的故障和缺陷。</p><p>信道容量：给定条件下，某一通信信道上所能达到的最大数据传输速率。</p><p>奈奎斯特带宽： $C = 2B log_2M$</p><p>波特率$R_B$与比特率$R_b$</p><p>$R_b = R_B log_2 M$ </p><p>香农公式: $C = B log_2 (1+SNR)$</p><p>$E_b$为每比特信号的能量, $N_0$ 为每赫兹噪声功率密度</p><p>$\frac{E_b}{N_0} = \frac{S/R}{N_0} = \frac{S}{kTR}$</p><h2 id="传输媒体"><a href="#传输媒体" class="headerlink" title="传输媒体"></a>传输媒体</h2><p>双绞线：</p><ul><li><p>廉价</p></li><li><p>方便</p></li><li><p>数据率低</p></li><li><p>传输距离短</p></li></ul><p>插入损耗，近端串扰</p><p>同轴电缆可以被用于长距离传输和更多的复用</p><p>光纤的特点：</p><ul><li><p>容量更大</p></li><li><p>体积更小、质量更轻</p></li><li><p>衰减更小</p></li><li><p>隔绝电磁场 (可以提高安全性)</p></li><li><p>转发器的间隔更远</p></li></ul><p>分类：</p><ul><li><p>多模突变传播：有多个角度可以发生反射。存在多条传播路径</p></li><li><p>单模传播：</p></li><li><p>多模渐变</p></li></ul><p>天线增益：$G_{dB} = 10 lg(P_2/p_1)$ </p><p>天线增益和有效面积的关系：$G = \frac{4 \pi A_e}{\lambda^2} = \frac{4 \pi f^2 A_e}{c^2}$  $A_e = 0.56 A$</p><p>无线传播:</p><ul><li><p>地波： f&lt;2MHz, AM</p></li><li><p>天波： BBC</p></li><li><p>视距： f&gt;30MHz.  $d = 3.57 (\sqrt{Kh_1} + \sqrt{Kh_2})$ </p></li></ul><p>自由空间损耗：$\frac{P_t}{P_r} = \frac{(4 \pi d)^2}{\lambda^2} = \frac{(4\pi f d)^2}{c^2}$  </p><h2 id="信号编码技术"><a href="#信号编码技术" class="headerlink" title="信号编码技术"></a>信号编码技术</h2><p>极性</p><ul><li><p>单极性：正电平和零电平对应二进制码1和0。 有直流分量，不适用有交流耦合的远距离传输。</p></li><li><p>双极性：正电平和负电平对应1和0. 1和0等概率出现时无直流分量</p></li></ul><p>归零:</p><ul><li><p>归零：电脉冲宽度小于码元宽度，即信号电压在一个码元终止时刻前总要回到零电平 (易于提取同步信息)</p></li><li><p>不归零：占空比100%</p></li></ul><p>占空比：电脉冲宽度/码元宽度</p><p>双相位：’0’用’01’两个相位表示, ‘1’用’10’两个相位表示</p><p>差分波形：利用相邻码元的电平跳变和不变来表示消息代码</p><p>数字信号编码：</p><ul><li><p>不归零电平(NRZ-L)</p><ul><li><p>0=高电平</p></li><li><p>1=低电平</p></li></ul></li><li><p>不归零1制(NRZI)</p><ul><li><p>0=在间隔的起始位置没有跳变</p></li><li><p>1=在间隔的起始位置跳变</p></li></ul></li><li><p>双极性AMI</p><ul><li><p>0=没有线路信号</p></li><li><p>1=正电平或负电平，如果是连续的比特1，则在正负电平之间不断交替</p></li></ul></li><li><p>伪三进制码</p><ul><li><p>0= 正电平或负电平，如果是连续的比特0，则在正负电平之间不断交替</p></li><li><p>1=没有线路信号</p></li></ul></li><li><p>曼彻斯特编码</p><ul><li><p>0=在间隔的中间位置从高向低跳变</p></li><li><p>1=在间隔的中间位置从低向高跳变</p></li></ul></li><li><p>差分曼彻斯特编码：在间隔的中间位置总是有一个跳变</p><ul><li><p>0 = 在间隔的起始位置跳变</p></li><li><p>1 = 在间隔的起始位置没有跳变</p></li></ul></li><li><p>8零替换(B8ZS)</p><ul><li>与双极性AMI类似，除了连续的8个零的比特串被另一个比特串所取代，这个比特串中有两个码是违反编码规则的</li></ul></li><li><p>高密度双极性3零码(HDB3)</p><ul><li>与双极性AMI类似，除了连续的4个零的比特串被另一个比特串所取代，这个比特串中有一个码是违反编码规则的</li></ul></li></ul><p>NRZ特点：</p><ul><li><p>简单</p></li><li><p>有效利用带宽</p></li><li><p>具有直流成份</p></li><li><p>缺乏同步能力</p></li></ul><p>扰码技术：使用扰码替代产生恒定电压的序列</p><p>填充序列</p><ul><li><p>必须产生足够的跳变以利于同步</p></li><li><p>必须被接收器识别并以原始序列替换回来</p></li><li><p>和原始序列长度相同</p></li></ul><p>设计目标：</p><ul><li><p>不含直流</p></li><li><p>含有丰富的定时信息</p></li><li><p>不会降低数据率</p></li><li><p>可提供差错检测</p></li><li><p>易于检测，不会被接收端误判</p></li></ul><p>三角公式</p><p>正交调幅： QAM : $s(t) = d_1(t)cos 2\pi f_c t + d_2(t) sin 2\pi f_c t$.</p><p>在同样的载波频率上发送两个不同的信号：</p><ul><li><p>使用两个载波，具备90偏移</p></li><li><p>每个载波通过ASK调制</p></li><li><p>在同样的传输媒体发送两个独立的信号</p></li></ul><p>脉码调制</p><p>压扩函数</p><p>AM: $S_{AM}(t) = (A_0+m(t)) cos \omega_c t$</p><p>PM: $S(t) = Acos[w_ct + n_p m(t)]$</p><p>FM: $S(t) = Acos[w_c t + n_f \int m(\tau) d \tau]$ </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据通信期中复习&quot;&gt;&lt;a href=&quot;#数据通信期中复习&quot; class=&quot;headerlink&quot; title=&quot;数据通信期中复习&quot;&gt;&lt;/a&gt;数据通信期中复习&lt;/h1&gt;&lt;p&gt;通信模型： 源点-&amp;gt;发送器-&amp;gt;传输系统-&amp;gt;接收器-&amp;gt;终点&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android Studio Installation</title>
    <link href="https://ricky-ting.github.io/2019/04/03/Android-Studio-Installation/"/>
    <id>https://ricky-ting.github.io/2019/04/03/Android-Studio-Installation/</id>
    <published>2019-04-03T03:07:18.000Z</published>
    <updated>2019-04-03T03:11:38.845Z</updated>
    
    <content type="html"><![CDATA[<p>出现错误的话，把<code>~/.gradle</code>删除, 并把代理全部关掉，重新打开build。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;出现错误的话，把&lt;code&gt;~/.gradle&lt;/code&gt;删除, 并把代理全部关掉，重新打开build。&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>proxy for bash</title>
    <link href="https://ricky-ting.github.io/2019/04/01/proxy-for-bash/"/>
    <id>https://ricky-ting.github.io/2019/04/01/proxy-for-bash/</id>
    <published>2019-04-01T03:04:55.000Z</published>
    <updated>2019-04-01T03:06:15.893Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export ALL_PROXY=socks5://127.0.0.1:1086</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数据通信笔记</title>
    <link href="https://ricky-ting.github.io/2019/03/12/%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%E7%AC%94%E8%AE%B0/"/>
    <id>https://ricky-ting.github.io/2019/03/12/数据通信笔记/</id>
    <published>2019-03-12T06:02:49.000Z</published>
    <updated>2019-03-12T07:51:10.247Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据通信笔记"><a href="#数据通信笔记" class="headerlink" title="数据通信笔记"></a>数据通信笔记</h1><h2 id="课程介绍"><a href="#课程介绍" class="headerlink" title="课程介绍"></a>课程介绍</h2><p>课程主页：<a href="http://cs.nju.edu.cn/yafeng/" target="_blank" rel="noopener">http://cs.nju.edu.cn/yafeng/</a> </p><p>考核形式：</p><ul><li><p>课程习题：考试重点(6-8次)</p></li><li><p>课外作业：文档阅读，完成报告(&gt;=6页)</p></li><li><p>期中小测验+期末考试</p></li><li><p>成绩：期末(70%)+期中(10%)+课程习题(10%)+课外作业(10%)</p></li></ul><a id="more"></a><h2 id="数据通信综述"><a href="#数据通信综述" class="headerlink" title="数据通信综述"></a>数据通信综述</h2><p><strong>数字通信系统：</strong>利用数字信号来传递信息的通信系统</p><p><strong>模拟通信系统:</strong>   利用模拟信号来传递信息的通信系统</p><p><strong>混成系统：</strong> 同一系统中包含模拟通信和数字通信</p><p>网络术语：</p><ul><li><p>节点(node): 网络中通信线路连接的计算机和交换机</p></li><li><p>线路(line): 节点间通信的物理连接</p></li><li><p>链路(link): 建立在相邻节点物理连接上的逻辑信道</p></li><li><p>电路(circuit): 源站点与目的站点之间建立的传输通路</p></li><li><p>交换(switching): 交换节点建立、保持和改变数据传输通路的过程</p></li><li><p>路由选择(routing): 交换技术中选择传输路径的功能</p></li><li><p>传输中继/传输网</p></li><li><p>接入线/接入网</p></li></ul><p>网络拓扑：</p><ul><li><p>星型</p></li><li><p>树型</p></li><li><p>环型</p></li><li><p>总线型</p></li></ul><h2 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h2><p>成功的数据传输依赖于两个因素：</p><ul><li><p>传输信号的质量 Quality of the Signal</p></li><li><p>传输媒体的特性</p></li></ul><p>导向媒体(点对点、多点)， 非导向媒体</p><p>噪声:通信通路上的平均噪声电平</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数据通信笔记&quot;&gt;&lt;a href=&quot;#数据通信笔记&quot; class=&quot;headerlink&quot; title=&quot;数据通信笔记&quot;&gt;&lt;/a&gt;数据通信笔记&lt;/h1&gt;&lt;h2 id=&quot;课程介绍&quot;&gt;&lt;a href=&quot;#课程介绍&quot; class=&quot;headerlink&quot; title=&quot;课程介绍&quot;&gt;&lt;/a&gt;课程介绍&lt;/h2&gt;&lt;p&gt;课程主页：&lt;a href=&quot;http://cs.nju.edu.cn/yafeng/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://cs.nju.edu.cn/yafeng/&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;考核形式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;课程习题：考试重点(6-8次)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;课外作业：文档阅读，完成报告(&amp;gt;=6页)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;期中小测验+期末考试&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;成绩：期末(70%)+期中(10%)+课程习题(10%)+课外作业(10%)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>问题求解2019Spring</title>
    <link href="https://ricky-ting.github.io/2019/03/06/%E9%97%AE%E9%A2%98%E6%B1%82%E8%A7%A32019Spring/"/>
    <id>https://ricky-ting.github.io/2019/03/06/问题求解2019Spring/</id>
    <published>2019-03-06T02:26:24.000Z</published>
    <updated>2019-03-24T14:39:59.744Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题求解-2019Spring"><a href="#问题求解-2019Spring" class="headerlink" title="问题求解 2019Spring"></a>问题求解 2019Spring</h1><h2 id="4-1线性规划"><a href="#4-1线性规划" class="headerlink" title="4.1线性规划"></a>4.1线性规划</h2><p>In linear programming, we do not allow strict inequalities.</p><p><strong>minimization linear program</strong> and <strong>maximization program</strong></p><p>The simplex algorithm does not run in polynomial time in the worst case, but it is fairly efficient and widely used in practice.</p><p>We use two forms, <strong>standard</strong> and <strong>slack</strong>.</p><p>Informally, a linear program in standard form is the maximization of a linear function subject to linear inequalities, whereas a linear program in slack form is the maximization of a linear function subject to linear equalities.</p><a id="more"></a><p>We call the feasible region formed by the intersection of these half-spaces a <strong>simplex</strong>.</p><p>The <strong>simplex</strong> algorithm starts at some vertex of the simplex and performs a sequence of iterations. In each iteration, it moves along an edge of the simplex from a current vertex to a neighboring vertex whose objective value is no smaller than that of the current vertex(and usually is larger.) The simplex algorithm terminates when it reaches a local maximum, which is a vertex from which all neighboring vertices have a smaller objective value.</p><p>If we add to a linear program the additional requirement that all variables take on integer values, we have an <strong>integer linear program</strong>.</p><p>An arbitrary linear program need not have nonnegativity constraints, but standard form requires them.</p><p>We say that two maximization linear programs $L$ and $L’$ are <strong>equivalent</strong> if for each feasible solution $\bar{x}$ to $L$ with objective value $z$, there is a corresponding feasible solution $\bar{x}’$ to $L’$  with objective value $z$ and for each feasible solution $\bar{x}’’$ to $L’$ with objective value $z$, there is a corresponding feasible solution $\bar{x}$ to $L$ with objective value $z$.(This definition does not imply a one-to-one correspondence between feasible solutions.)</p><p>How to convert linear programs into standard form?</p><p>如何添加非负限制的设计很精巧</p><p>How to convert linear programs into slack form?</p><p>We call $s$ a <strong>slack variable</strong> because it measures the <strong>slack</strong>, or the difference, between the left-hand and right-hand sides of equation.</p><p>We call the variables on the left-hand side of the equalities <strong>basic variables</strong> and those on the right-hand side <strong>nonbasic variables</strong>.</p><h2 id="4-2-群论初步"><a href="#4-2-群论初步" class="headerlink" title="4.2 群论初步"></a>4.2 群论初步</h2><h3 id="Some-definations"><a href="#Some-definations" class="headerlink" title="Some definations"></a>Some definations</h3><p>A <strong>symmetry</strong> of a geometric figure is a rearrangement of the figure preserving the arrangement of its sides and vertices as well as its distances and angles. </p><p>A map from the plane to itself preserving the symmetry of an object is called a <strong>rigid motion</strong>.</p><p>A <strong>binary operation</strong> or <strong>law of composition</strong> on a set $G$ is a function $G \times G \rightarrow G$ that assigns to each pair $(a,b) \in G \times G$  a unique element  $a \circ b$, or $ab$ in $G$, called the composition of $a$ and $b$. A <strong>group</strong> $(G,\circ)$ is a set $G$ together with a law of composition $(a,b) \mapsto a \circ b$ that satisfies the following axioms.</p><ul><li><p><strong>associative</strong>:     $(a \circ b) \circ c = a \circ (b \circ c)$ </p></li><li><p><strong>identity element</strong>:  $e \circ a = a \circ e =a$</p></li><li><p><strong>inverse element</strong> : $a \circ a^{-1} = a^{-1} \circ a =e$ </p></li></ul><p>A group $G$ with the property that $a \circ b = b \circ a$ for all $a,b \in G$  is called <strong>abelian</strong> or <strong>commutative</strong>. Groups not satisfying this property are said to be <strong>nonabelian</strong> or <strong>noncommutative</strong>.</p><p><img src="/images/" alt=""></p><p>A <strong>Cayley table</strong> .</p><p>Every nonzero $k$ does have an inverse in $Z<em>{n}$ if $k$ is relatively prime to $n$. Denote the set of all such nonzero elements in $Z</em>{n}$ by $U(n)$. Then $U(n)$  is  a group called the <strong>group of units</strong> of $Z_{n}$ .</p><p>The set of invertible matrices forms a group  called the <strong>general linear group</strong>. </p><p>A group is <strong>finite</strong>, or has <strong>finite order</strong>, if it contains a finite number of elements; otherwise, the group is said to be <strong>infinite</strong> or to have <strong>infinite</strong> order. The <strong>order</strong> of a finite group is the number of elements that it contains.</p><h3 id="Basic-Properties-of-Groups"><a href="#Basic-Properties-of-Groups" class="headerlink" title="Basic Properties of Groups"></a>Basic Properties of Groups</h3><p><strong>Proposition 3.17.</strong> The identity element in a group $G$ is unique; that is, there exists only one element $e \in G$</p><p> such that $eg=ge=g$ for all $g \in G$.</p><p><strong>Proposition 3.18.</strong> If $g$ is any element in a group $G$, then the inverse of $g$ , denoted by $g^{-1}$ , is unique.</p><p><strong>Proposition 3.19</strong> Let $G$  be a group. If $a,b \in G$, then $(ab)^{-1} = b^{-1}a^{-1}$.</p><p><strong>Proposition 3.20.</strong> Let $G$ be a group. For any $a \in G$, $(a^{-1})^{-1}=a$.</p><p><strong>Proposition 3.21</strong> Let $G$ be a group and $a$ and $b$ be any two elements in $G$. Then the equations $ax=b$ and $xa=b$ have unique solutions in $G$.</p><p><strong>Proposition 3.22. (right and left cancellation laws)</strong>  If $G$ is a group and $a,b,c\in G$, then $ba=ca$ implies $b=c$ and $ab=ac$ implies $b=c$.</p><p><strong>Theorem 3.23.</strong> In a group, the usual laws of exponents hold; that is, for all $g,h \in G$,</p><ol><li><p>$g^m G^n = g^{m+n}$ for all $m,n \in Z$</p></li><li><p>$(g^m)^n = g^{mn}$ for all $m,n \in Z$ </p></li><li><p>$(gh)^n = (h^{-1} g^{-1})^{-n}$ for all $n\in Z$. Furthermore, if $G$ is abelian, then $(gh)^n = g^n h^n$.</p></li></ol><h3 id="Subgroups"><a href="#Subgroups" class="headerlink" title="Subgroups"></a>Subgroups</h3><p>We define a <strong>subgroup</strong> $H$ of a group $G$ to be a subset $H$ of $G$ such that when the group operation of $G$ is restricted to $H$, $H$ is a group in its own right.</p><p>Every group has at least two subgroups. The subgroup $H={e}$ of a group $G$ is called the <strong>trivial subgroup</strong>. A subgroup that is a proper subset of $G$ is called a <strong>proper subgroup</strong>.</p><h3 id="Some-Subgroup-Theorems"><a href="#Some-Subgroup-Theorems" class="headerlink" title="Some Subgroup Theorems"></a>Some Subgroup Theorems</h3><p><strong>Proposition 3.30</strong> A subset $H$ of $G$ is a subgroup if and only if it satisfies the following conditions.</p><ol><li><p>The identity of $e$ of $G$ is in $H$.</p></li><li><p>If $h_1,h_2 \in H$, thne $h_1h_2 \in H$.</p></li><li><p>If $h \in H$, then $h^{-1} \in H$.</p></li></ol><p><strong>Proposition 3.31</strong> Let $H$ be a subset of a group $G$. Then $H$ is a subgroup of $G$ if and only if $H \not= \emptyset$, and whenever $g,h \in H$ then $gh^{-1}$ is in $H$.</p><h3 id="Cyclic-Subgroups"><a href="#Cyclic-Subgroups" class="headerlink" title="Cyclic Subgroups"></a>Cyclic Subgroups</h3><p><strong>Theorem 4.3</strong> Let $G$ be a group and $a$ be any element in $G$. Then the set $<a> = { a^k : k \in Z }$ is a subgroup of $G$. Furthermore, $<a>$ is the smallest subgroup of $G$ that contains $a$.</a></a></p><p>For  $a\in G$, we call $<a>$ the <strong>cyclic subgroup</strong> generated by $a$. If $G$ contains some element $a$ such that $G=<a>$, then $G$ is a <strong>cyclic group</strong>. In this case $a$ is a <strong>generator</strong> of $G$. If $a$ is an element of a group $G$, we define the <strong>order</strong> of $a$ to be the smallest positive integer $n$ such that $a^n =e$, and we write $|a|=n$. If there is no such integer $n$, we say that the order of $a$ is inifinte and write $|a|= \infty$ to denote the order of $a$.</a></a></p><p><strong>Theorem 4.9.</strong> Every cyclic group is abelian.</p><p><strong>Theorem 4.10</strong> Every subgroup of a cyclic group is cyclic.</p><p><strong>Corollary 4.11</strong> The subgroups of $Z$ are exactly $nZ$ for $n=0,1,2,….$</p><p><strong>Proposition 4.12</strong> Let $G$ be a cyclic group of order $n$ and suppose that $a$ is a generator for $G$. Then $a^k=e$ if and only if $n$ divides $k$.</p><p><strong>Theorem 4.13</strong> Let $G$ be a cyclic group of order $n$ and suppose that $a \in G$ is a generator of the group. If $b= a^k$, then the order of $b$ is $n/d$, where $d=gcd(k,n)$.</p><p><strong>Corollary 4.14</strong> The generators of $Z_n$ are the integers $r$ such that $1 \le r &lt; n$ and $gcd(r,n)=1$.</p><h3 id="置换群与拉格朗日定理"><a href="#置换群与拉格朗日定理" class="headerlink" title="置换群与拉格朗日定理"></a>置换群与拉格朗日定理</h3><p>In general, the permutations of a set $X$ form a group $S_X$. If $X$ is a finite set, we can assume $X={1,2,…,n}$. In this case we write $S_n$ instead of $S_X$.  We call this group the <strong>symmetric group</strong> on $n$ letters.</p><p><strong>Theorem 5.1</strong> The symmetric group on $n$ letters, $S_n$ is a group with $n!$ elements, where the binary operation is the composition of maps.</p><p>A subgroup of $S_n$ is called a <strong>permutation group</strong>.</p><p>Permutation multiplication is not usually commutative.</p><p>A permutation $\sigma \in S_X$ is a <strong>cycle of length</strong> $k$ if there exist elements $a_1, a_2, …, a_k \in X$ such that $ \sigma(a_1)=a_2,\sigma(a_2)=a_3,…,\sigma(a_k)=a_1  $ and $\sigma(x)=x$ for all other elements $x \in X$. We will write $(a_1,a_2,..,a_k)$ to denote the cycle $\sigma$. </p><p>Cycles are the building blocks of all permutations.</p><p>Two cycles in $S_X$ , $\sigma = (a_1, a_2,…,a_k)$ and $\tau = (b_1,b_2,…,b_l)$, are <strong>disjoint</strong> of $a_i \not= b_i$ for all $i$ and $j$.</p><p><strong>Proposition 5.8.</strong> Let $\sigma$ and $\tau$ be two disjoint cycles in $S_X$. Then $\sigma \tau = \tau \sigma$.</p><p><strong>Theorem 5.9</strong> Every permutation in $S_n$ can be written as the product of disjoint cycles.</p><h4 id="Transpositions"><a href="#Transpositions" class="headerlink" title="Transpositions"></a>Transpositions</h4><p>The simplest permutation is a cycle of length $2$. Such cycles are called <strong>transpositions</strong>. Since $(a_1,a_2,…,a_n)=(a_1a_n)(a<em>1 a</em>{n-1})…(a_1a_3)(a_1a_2)$</p><p><strong>Proposition 5.12.</strong> Any permutation of a finite set containing at least two elements can be written as the product of transpositions.</p><p>No permutation can be written as the product of both an even number of transpositions and an odd number of transpositions.</p><p><strong>Lemma 5.14</strong> If the identity is written as the product of $r$ transpositions, $id = \tau_1 \tau_2 \cdot \cdot \cdot \tau_r , $  then $r$ is an even number.   (Proof need to be understood)</p><p><strong>Theorem 5.15</strong> If a permutation $\sigma$ can be expressed as the product of an even number of transpositions, then any other product of transpositions equaling $\sigma$ must also contain an even number of transpositions. Similarly, if $\sigma$ can be expressed as the product of an odd number of transpositions, then any other product of transpositions equaling $\sigma$ must also contain an odd number of transpositions.</p><p><strong>My comment on the proof of 5.14:</strong>  The fact that the inverse of $\sigma$ is $\sigma_m \cdot \cdot \cdot  \sigma_1$ confuses me some time. By introducing the fact that two identity transpositions equals to the identity, it is much clear.  Also note that the inverse of any transposition is itself.</p><p>We define a permutation to be <strong>even</strong> if it can be expressed as an even number of transpostions and <strong>odd</strong> if it can be expressed as an odd number of transpositions.</p><h4 id="The-Alternating-Groups"><a href="#The-Alternating-Groups" class="headerlink" title="The Alternating Groups"></a>The Alternating Groups</h4><p>One of the most important subgroups of $S_n$ is the set of all even permutations, $A_n$. The group $A_n$ is called the <strong>alternating group on $n$ letters</strong>.</p><p><strong>Theorem 5.16</strong> The set $A_n$ is a subgroup of $S_n$.</p><p><strong>Proposition 5.17</strong> The number of even permutations in $S_n, n&gt;2$, is equal to the number of odd permutations; hence, the order of $A_n$ is $n!/2$ .</p><h4 id="Dihedral-Groups"><a href="#Dihedral-Groups" class="headerlink" title="Dihedral Groups"></a>Dihedral Groups</h4><p>For $n=3,4,…,$, we define the $n$<strong>th dihedral group</strong> to be the group of rigid motions of a regular $n$-gon.</p><p><strong>Theorem 5.20.</strong> The dihedral group, $D_n$, is a subgroup of $S_n$ of order $2n$.</p><p><strong>Theorem 5.23.</strong> The group $D_n$ , $n \ge 3$, consists of all products of two elements $r$ and $s$, satisfying the relations $r^n=1, s^2=1, srs=r^{-1}$.</p><p><strong>Proposition 5.27.</strong> The group of rigid motions of a cube contains $24$ elements.</p><p><strong>Theorem 5.28.</strong> The group of rigid motions of a cube is $S_4$.</p><h4 id="Cosets"><a href="#Cosets" class="headerlink" title="Cosets"></a>Cosets</h4><p>Let $G$ be a group and $H$ a subgroup of $G$. Define a <strong>left coset</strong> of $H$ with <strong>representative</strong> $g \in G$ to be the set $gH = { gh : h \in H }$. <strong>Right cosets</strong> can be defined similarly by $Hg = { hg:h \in H }$. </p><p><strong>Lemma 6.3.</strong> Let $H$ be a subgroup of a group $G$ and suppose that $g_1,g_2 \in G$. The following conditions are equivalent.</p><ol><li><p>$g_1 H = g_2 H$</p></li><li><p>$H g_1^{-1} = H g_2^{-1}$</p></li><li><p>$g_1 H \subset g_2 H $</p></li><li><p>$g_2 \in g_1 H$</p></li><li><p>$ g_1^{-1} g_2 \in H$.</p></li></ol><p><strong>Theorem 6.4</strong> Let $H$ be a subgroup of a group $G$. Then the left cosets of $H$ in $G$ partition $G$. That is, the group $G$ is the disjoint union of the left cosets of $H$ in $G$.</p><p>Let $G$ be a group and $H$ be a subgroup of $G$. Define the <strong>index</strong> of $H$ in $G$ to be the number of left cosets of $H$ in $G$. We will denote the index by $[G:H]$.</p><p><strong>Theorem 6.8.</strong>  Let $H$ be a subgroup of a group $G$. The number of left cosets of $H$ in $G$ is the same as the number of right cosets of $H$ in $G$.</p><p><strong>Proposition 6.9.</strong> Let $H$ be a subgroup of $G$ with $g \in G$ and define a map $\phi : H \rightarrow gH$ by $\phi(h) = gh$. The map $\phi$ is bijective; hence, the number of elements in $H$ is the same as the number of elements in $gH$.</p><p><strong>Theorem 6.10 Lagrange.</strong> Let $G$ be a finite group and let $H$ be a subgroup of $G$. Then $|G|/|H|=[G:H]$ is the number of distinct left cosets in $G$. In particular, the number of elements in $H$ must divide the number of elements in $G$.</p><p><strong>Corollary 6.11.</strong> Suppose that $G$ is a finite group and $g \in G$. Then the order of $g$ must divide the number of elements in $G$.</p><p><strong>Corollary 6.12</strong> Let $|G|=p$ with $p$ a prime number. Then $G$ is cyclic and any $g \in G$ such that $g\not= e$ is a generator.</p><p><strong>Corollary 6.13.</strong> Let $H$ and $K$ be subgroups of a finite group $G$ such that $G \supset H \supset K.$ Then $[G:K]=[G:H][H:K].$</p><p><strong>Proposition 6.15</strong> The group $A_4$ has no subgroup of order $6$.</p><p><strong>Theorem 6.16.</strong> Two cycles $\tau$ and $\mu$ in $S_n$ have the same length if and only if there exists $a \sigma \in S_n$ such that $\mu = \sigma \tau \sigma^{-1}$.</p><h4 id="Fermat’s-and-Euler’s-Theorems"><a href="#Fermat’s-and-Euler’s-Theorems" class="headerlink" title="Fermat’s and Euler’s Theorems"></a>Fermat’s and Euler’s Theorems</h4><p>The <strong>Euler</strong> $\phi$ <strong>-function</strong> is the map $\phi:N \rightarrow N$ defined by $\phi(n)=1$ for $n=1$, and, for $n&gt;1$, $\phi(n)$ is the number of positive integers $m$ with $1 \le m &lt; n$ and $gcd(m,n)=1$.</p><p><strong>Theorem 6.17.</strong> Let $U(n)$ be the group of units in $Z_n$. Then $|U(n)| = \phi(n)$.</p><p><strong>Theorem 6.18 Euler’s Theorem.</strong> Let $a$ and $n$ be integers such that $n&gt;0$ and $gcd(a,n)=1$. Then $a^{\phi(n)} \equiv 1$(mod $n$).</p><p><strong>Theorem 6.19. Fermat’s Little Theorem.</strong> Let $p$ be any prime number and suppose that $ p \nmid a$ ($p$ does not divide $a$). Then $a^{p-1} \equiv 1$ (mod $p$). Furthermore, for any integer $b$, $b^p \equiv b$ (mod $p$). </p><h3 id="群同态基本定理与正规子群"><a href="#群同态基本定理与正规子群" class="headerlink" title="群同态基本定理与正规子群"></a>群同态基本定理与正规子群</h3><h4 id="Isomorphisms"><a href="#Isomorphisms" class="headerlink" title="Isomorphisms"></a>Isomorphisms</h4><p>Two groups $(G, \cdot )$ and $(H, \circ)$ are <strong>isomorphic</strong> if there exists a one-to-one and onto map $\phi : G \rightarrow H$ such that the group operation is preserved; that is, $\phi (a \cdot b) = \phi(a) \circ \phi (b)$ for all $a$ and $b$ in $G$. If $G$ is isomorphic to $H$, we write $G \cong H$. The map $\phi$ is called an <strong>isomorphism</strong>.</p><p><strong>Theorem 9.6.</strong> Let $\phi : G \rightarrow H$ be an isomorphism of two subgroups. Then the following statements are true.</p><ol><li><p>$\phi^{-1}: H \rightarrow G$ is an isomorphism.</p></li><li><p>$|G| = |H|.$</p></li><li><p>If $G$ is abelian, then $H$ is abelian.</p></li><li><p>If $G$ is cyclic, then $H$ is cyclic.</p></li><li><p>If $G$ has a subgroup of order $n$, then $H$ has a subgroup of order $n$.</p></li></ol><p><strong>Theorem 9.7.</strong> All cyclic groups of infinite order are isomorphic to $Z$.</p><p><strong>Theorem 9.8.</strong> If $G$ is a cyclic group of order $n$, then $G$ is isomorphic to $Z_n$.</p><p><strong>Corollary 9.9.</strong> If $G$ is a group of order $p$, where $p$ is a prime number, then $G$ is isomorphic to $Z_p$.</p><p><strong>Theorem 9.10.</strong> The isomorphism of groups determines an equivalence relation on the class of all groups.</p><p><strong>Theorem 9.12 Cayley.</strong> Every group is isomorphic to a group of permutations.</p><p>The isomorphism $g \mapsto \lambda_g$ is known as the <strong>left regular representation</strong> of $G$.</p><h4 id="External-Direct-Products"><a href="#External-Direct-Products" class="headerlink" title="External Direct Products"></a>External Direct Products</h4><p>If $(G, \cdot)$ and $(H,\circ)$ are groups, then we can make the Cartesian product of $G$ and $H$ into a new group. As a set, our group is just the ordered pairs $(g,h) \in G \times H$ where $g \in G$ and $h \in H$. We can define a binary operation on $G \times H$ by $(g_1,h_1)(g_2,h_2) = (g_1 \cdot g_2, h_1 \cdot h_2)$.</p><p><strong>Proposition 9.13.</strong> Let $G$ and $H$ be groups. The set $G \times H$ is a group under the operation $(g_1,h_2)(g_2,h_2) = (g_1g_2, h_1h_2)$ where $g_1,g_2 \in G$ and $h_1,h_2 \in H$.</p><p>The group $G \times H$ is called the <strong>external direct product</strong> of $G$ and $H$. </p><p><strong>Theorem 9.17.</strong> Let $(g,h) \in G \times H$. If $g$ and $h$ have finite orders $r$ and $s$ respectively, then the order of $(g,h)$ in $G \times H$ is the least common multiple of $r$ and $s$.</p><p><strong>Corollary 9.18.</strong> Let $(g_1, …, g_n) \in \prod G_i$. If $g_i$ has finite order $r_i$ in $G_i$, then the order of $(g_1,…,g_n) \in \prod G_i$ is the least common multiple of $r_1,…,r_n$.</p><p><strong>Theorem 9.21.</strong> The group $Z_m \times Z<em>n$ is isomorphic to $Z</em>{mn}$ if and only if $gcd(m,n)=1$.</p><p><strong>Corollary 9.22.</strong> Let $n_1,…,n<em>k$ be positive integers. Then $\prod\limits</em>{i=1}^{k}Z_{n<em>i} \cong Z</em>{n_1…n_k}$  if and only if $gcd(n_i,n_j)=1$ for $i \not= j$.</p><p><strong>Corollary 9.23.</strong> If $m = p_1^{e_1} \cdot \cdot \cdot p_k^{e_k}$, where the $p_is$ are distinct primes, then $Z<em>m \cong Z</em>{p_1 ^{e<em>1}} \times \cdot \cdot \cdot \times Z</em>{p_k^{e_k}}$.</p><h4 id="Internal-Direct-Products"><a href="#Internal-Direct-Products" class="headerlink" title="Internal Direct Products"></a>Internal Direct Products</h4><p>Let $G$ be a group with subgroups $H$ and $K$ satisfying the following conditions.</p><ul><li><p>$G = H K = {hk: h\in H , k \in K}$;</p></li><li><p>$H \cap K = {e}$;</p></li><li><p>$hk=kh$ for all $k \in K$ and $h \in H$.</p></li></ul><p>Then $G$ is the <strong>internal direct product</strong> of $H$ and $K$.</p><p><strong>Theorem 9.27.</strong> Let $G$ be the internal direct product of subgroups $H$ and $K$. Then $G$ is isomorphic to $H \times K$. Then $G$ is isomorphic to $H \times K$.</p><p><strong>Theorem 9.29.</strong> Let $G$ be the internal direct product of subgroups $H_i$, where $i = 1,2,…,n$. Then $G$ is isomorphic to $\prod_i H_i$.</p><h4 id="Normal-Subgroups"><a href="#Normal-Subgroups" class="headerlink" title="Normal Subgroups"></a>Normal Subgroups</h4><p>A subgroup $H$ of a group $G$ is <strong>normal</strong> in $G$ if $gH = Hg$ for all $g \in G$. </p><p><strong>Theorem 10.3.</strong> Let $G$ be a group and $N$ be a subgroup of $G$. Then the following statements are equivalent.</p><ol><li><p>The subgroup $N$ is normal in $G$.</p></li><li><p>For all $g \in G$, $g N g^{-1} \subset N$.</p></li><li><p>For all $g \in G$, $gNg^{-1} = N$.</p></li></ol><h4 id="Factor-Groups"><a href="#Factor-Groups" class="headerlink" title="Factor Groups"></a>Factor Groups</h4><p>If $N$ is a normal subgroup of a group $G$, then the cosets of $N$ in $G$ form a group $G/N$ under the operation $(aN)(bN)=abN$. This group is called the <strong>factor</strong> or <strong>quotient group</strong> of $G$ and $N$.</p><p><strong>Theorem 10.4.</strong> Let $N$ be a normal subgroup of a group $G$. The cosets of $N$ in $G$ form a group $G/N$ of order $[G:N]$.</p><h4 id="The-Simplicity-of-the-Alternating-Group"><a href="#The-Simplicity-of-the-Alternating-Group" class="headerlink" title="The Simplicity of the Alternating Group"></a>The Simplicity of the Alternating Group</h4><p>Of special interest are groups with no nontrivial normal subgroups. Such groups are called <strong>simple groups</strong>.</p><p><strong>Lemma 10.8.</strong> The alternating group $A_n$ is generated by $3-$cycles for $n \ge 3$.</p><p><strong>Lemma 10.9.</strong> Let $N$ be a normal subgroup of $A_n$, where $n \ge 3$. If $N$ contains a $3-$cycle, then $N=A_n$.</p><p><strong>Lemma 10.10.</strong> For $n \ge 5$, every nontrivial normal subgroup $N$ of $A_n$ contains a $3-$ cycle.</p><p><strong>Theorem 10.11.</strong> The alternating group, $A_n$, is simple for $n \ge 5$.</p><h4 id="Group-Homomorphisms"><a href="#Group-Homomorphisms" class="headerlink" title="Group Homomorphisms"></a>Group Homomorphisms</h4><p>A <strong>homomorphism</strong> between groups $(G, \cdot)$ and $(H, \circ)$ is a map $\phi: G \rightarrow H$ such that $\phi(g_1 \cdot g_2) = \phi(g_1) \circ \phi(g_2)$ for $g_1, g_2 \in G$. The range of $\phi$ in $H$ is called the <strong>homomorphic image</strong> of $\phi$. </p><p><strong>Proposition 11.4.</strong>  Let $\phi : G_1 \rightarrow G_2$ be a homomorphism of groups. Then </p><ol><li><p>If $e$ is the identity of $G_1$, then $\phi(e)$ is the identity of $G_2$;</p></li><li><p>For any element $g \in G_1$, $\phi(g^{-1}) = [\phi(g)]^{-1}$;</p></li><li><p>If $H_1$ is a subrgoup of $G_1$, then $\phi(H_1)$ is a subrgoup of $G_2$;</p></li><li><p>If $H_2$ is a subgroup of $G_2$, then $\phi^{-1}(H_2) = {g \in G_1 : \phi(g) \in H_2}$ is a subgroup of $G_1$. Furthermore, if $H_2$ is normal in $G_2$, then $\phi^{-1}(H_2)$ is normal in $G_1$.</p></li></ol><p>Let $\phi: G \rightarrow H$ be a group homomorphism and suppose that $e$ is the identity of $H$.  By Proposition 11.4, $\phi^{-1}({e})$ is a subrgoup of $G$. This subgroup is called the <strong>kernel</strong> of $\phi$ and will be denoted by ker $\phi$.</p><p><strong>Theorem 11.5.</strong> Let $\phi : G \rightarrow H$ be a group homomorphism. Then the kernel of $\phi$ is a normal subgroup of $G$.</p><h4 id="The-Isomorphism-Theorems"><a href="#The-Isomorphism-Theorems" class="headerlink" title="The Isomorphism Theorems"></a>The Isomorphism Theorems</h4><p>Let $H$ be a normal subgroup of $G$. Define the <strong>natural</strong> or <strong>canonical homomorphism</strong> $\phi : G \rightarrow G/H$ by $\phi(g) = g H$.</p><p><strong>Theorem 11.10 First Isomorphism Theorem.</strong> If $\psi : G \rightarrow H$ is a group homomorphism with $K = ker \psi$, then $K$ is normal in $G$. Let $\phi: G \rightarrow G/K$ be the canonical homomorphism. Then there exists a unique isomorphism $\eta : G/K \rightarrow \psi(G)$ such that $\psi = \eta \phi$</p><p><strong>Theorem 11.12 Second Isomorphism Theorem.</strong>  Let $H$ be a subgroup of a group $G$ (not necessarily normal in $G$) and $N$ a normal subgroup of $G$. Then $HN$ is a subgroup of $G$, $H \cap N$ is a normal subgroup of $H$, and $H/ H \cap N \cong HN/N$.</p><p><strong>Theorem 11.13 Correspondence Theorem.</strong> Let $N$ be a normal subgroup of a group $G$. Then $H \mapsto H/N$ is a one-to-one correspondence between the set of subgroups $H$ containing $N$ and the set of subgroups of $G/N$. Furthermore, the normal subgroups of $G$ containing $N$ correspond to normal subgroups of $G/N$.</p><p><strong>Theorem 11.14 Third Isomorphism Theorem.</strong> Let $G$ be a group and $N$ and $H$ be normal subgroups of $G$ with $N \subset H.$ Then $G/H \cong \frac{G/N}{H/N}$.</p><h3 id="串匹配"><a href="#串匹配" class="headerlink" title="串匹配"></a>串匹配</h3><h4 id="The-naive-string-matching-algorithm"><a href="#The-naive-string-matching-algorithm" class="headerlink" title="The naive string-matching algorithm"></a>The naive string-matching algorithm</h4>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;问题求解-2019Spring&quot;&gt;&lt;a href=&quot;#问题求解-2019Spring&quot; class=&quot;headerlink&quot; title=&quot;问题求解 2019Spring&quot;&gt;&lt;/a&gt;问题求解 2019Spring&lt;/h1&gt;&lt;h2 id=&quot;4-1线性规划&quot;&gt;&lt;a href=&quot;#4-1线性规划&quot; class=&quot;headerlink&quot; title=&quot;4.1线性规划&quot;&gt;&lt;/a&gt;4.1线性规划&lt;/h2&gt;&lt;p&gt;In linear programming, we do not allow strict inequalities.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;minimization linear program&lt;/strong&gt; and &lt;strong&gt;maximization program&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The simplex algorithm does not run in polynomial time in the worst case, but it is fairly efficient and widely used in practice.&lt;/p&gt;
&lt;p&gt;We use two forms, &lt;strong&gt;standard&lt;/strong&gt; and &lt;strong&gt;slack&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Informally, a linear program in standard form is the maximization of a linear function subject to linear inequalities, whereas a linear program in slack form is the maximization of a linear function subject to linear equalities.&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MATLAB学习笔记</title>
    <link href="https://ricky-ting.github.io/2019/01/19/MATLAB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://ricky-ting.github.io/2019/01/19/MATLAB学习笔记/</id>
    <published>2019-01-19T07:50:56.000Z</published>
    <updated>2019-01-19T11:14:53.890Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MATLAB学习笔记"><a href="#MATLAB学习笔记" class="headerlink" title="MATLAB学习笔记"></a>MATLAB学习笔记</h1> <a id="more"></a><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ul><li><p>quit: 退出命令</p></li><li><p>clc: 擦除MATLAB工作窗中的所有显示内容，相当于命令行中的clear</p></li><li><p>clf: 擦除MATLAB的当前图形窗中的图形</p></li><li><p>clear: 清除内存中的变量和函数</p></li><li><p>dir: 列出指定目录下的文件和子目录清单</p></li><li><p>cd: 改变当前工作子目录</p></li><li><p>disp: (在运行中)显示变量和文字内容</p></li><li><p>who: 检查内存变量</p></li><li><p>whos: 列出内存变量的详细情况</p></li><li><p>save: 关闭前将变量保存到某一文件中</p></li><li><p>load: 从之前保存的文件中恢复变量</p></li><li><p>help: 非常有用</p></li><li><p>lookfor: 查找相关指令</p></li><li><p>!之后可以加操作系统命令，如 !ls, !vim</p></li></ul><p><img src="/images/MATLAB学习笔记/MATLABop.png" alt=""></p><p>求解方程组时，用除法比用逆矩阵好。</p><h2 id="多项式"><a href="#多项式" class="headerlink" title="多项式"></a>多项式</h2><ul><li><p>用系数行向量表示：p=$[a_0 , a<em>1 , … , a</em>{n-1} , a_n ]$, ($p(x)= a_0 x_n + a<em>1 x</em>{n-1} + … + a<em>{n-1} x + a</em>{n} $).</p></li><li><p>可以用指令产生多项式系数向量: p=poly(AR). 如果AR是方阵，则多项式为特征多项式，如果AR为向量，则AR为多项式的解。</p></li><li><p>poly2str函数</p></li></ul><h3 id="一些常用多项式运算指令"><a href="#一些常用多项式运算指令" class="headerlink" title="一些常用多项式运算指令"></a>一些常用多项式运算指令</h3><ul><li><p>R=roots(p)   求多项式向量p的根</p></li><li><p>PA=polyval(p,S)  按照数组运算规则计算多项式值。 p为多项式，S为矩阵。 相当于求值。</p></li><li><p>PM=polyvalm(p;S) 按照矩阵运算规则计算多项式值。p为多项式，S为矩阵。</p></li><li><p>P=polyfit(x,y,n) 用n阶多项式拟合x,y向量给定的数据</p></li></ul><h2 id="数值积分"><a href="#数值积分" class="headerlink" title="数值积分"></a>数值积分</h2><ul><li><p>S=quad(‘fname’,a,b,tol,trace)  自适用递推Simpson数值积分法</p></li><li><p>S=quad8(‘fname’,a,b,tol,trace) 自适用递推Newton-Cotes数值积分法</p></li><li><p>tol是精度，trace是是否画图</p></li><li><p>quad8比quad有更高的积分精度</p></li></ul><h2 id="非线性方程求解"><a href="#非线性方程求解" class="headerlink" title="非线性方程求解"></a>非线性方程求解</h2><ul><li><p>对于多项式函数求根，r=roots(p)</p></li><li><p>单变量非线性方程求解, z=fzero(‘fname’,x0,tol,trace)</p></li><li><p>一般非线性方程(组)求解， X=fsolve(‘fname’,X0)</p></li></ul><h2 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h2><ul><li><p>fopen(“filename”,’specifier’)</p></li><li><p>fread(fd,..)</p></li><li><p>fwrite()</p></li><li><p>fclose</p></li></ul><h2 id="符号计算"><a href="#符号计算" class="headerlink" title="符号计算"></a>符号计算</h2><ul><li><p>可以用sym定义符号,如 sym(‘x’) 也可以用syms定义多个符号 syms a b c d</p></li><li><p>findsym() 来确认符号表达式中的符号</p></li></ul><h3 id="微积分运算"><a href="#微积分运算" class="headerlink" title="微积分运算"></a>微积分运算</h3><ul><li><p>diff(f) 函数f对符号变量x或字母表上最接近字母x的符号变量求导数</p></li><li><p>diff(f,t) 函数f对符号变量t求导数</p></li><li><p>diff(f,2) 和diff(f,t,2)可以用来求二阶导数</p></li><li><p>int(f)</p></li><li><p>int(f,t)</p></li><li><p>int(f,a,b) 和int(f,t,a,b)</p></li><li><p>limit(f) 当符号变量x(或最接近字母x的符号变量) -&gt;0 时，函数f的极限</p></li><li><p>limit(f,t,a)</p></li><li><p>limit(f,t,a,’left’) 左极限 limit(f,t,a,’right’)右极限</p></li><li><p>symsum(s,t,a,b) 表示s中的符号变量t从a到b的级数和(t缺省时，同上)</p></li><li><p>taylor(f,n,a) 函数f对符号变量x(或…)在a点的n-1阶泰勒多项式(n缺省时值为6，a缺省时值为0)</p></li><li><p>solve(f,t) 对f中的符号变量t解方程f=0(t缺省值为x或…)</p></li><li><p>solve(f,g,..)可以求解方程组</p></li><li><p>dsolve(‘S’,’s1’,’s2’,…,’x’)</p></li><li><p>collect 合并同类项</p></li><li><p>expand 将乘积展开为和式</p></li><li><p>horner 把多项式转换为嵌套表示形式</p></li><li><p>simplify 利用各种恒等式化简代数式，更强有力的函数simple</p></li><li><p>subs(S,old,new) 替换</p></li><li><p>subexpr(S) 将表达式S中的公共部分用sigma表示</p></li></ul><h2 id="MATLAB画图"><a href="#MATLAB画图" class="headerlink" title="MATLAB画图"></a>MATLAB画图</h2><ul><li><p>plot(x,y) 以向量x作为X轴，以向量y作为Y轴，绘制X-Y二维曲线</p></li><li><p>plot(x,y1,’k’,x,y2,’b-‘) 每条曲线的线型和颜色由字符串’cs’指定，其中c表示颜色,s表示线型</p></li></ul><p><img src="/images/MATLAB学习笔记/ColorAndLine.png" alt=""></p><ul><li><p>可以加一些图形标记，如title, xlabel, ylabel, text,legend</p></li><li><p>axis([xmin,xmax,ymin,ymax]) 来设定坐标轴范围</p></li><li><p>hold on: 保持原有图形的基础上绘制新的图形</p></li><li><p>fplot(fname,lims,tol) lims为变量取值范围，tol为相对误差</p></li><li><p>loglog(x,y) 绘制双对数坐标图</p></li><li><p>semilogx(x,y) semilogy(x,y) 绘制单对数坐标图</p></li><li><p>polar(theta,rho) 用来绘制极坐标图</p></li></ul><p><img src="/images/MATLAB学习笔记/2D.png" alt=""></p><ul><li><p>plot3(x1,y1,z1,c1,x2,y2,z2,c2,…)</p></li><li><p>mesh(x,y,z,c)绘制三维网格图</p></li><li><p>surf(x,y,z) 绘制三维曲面图</p></li><li><p>view 指定视点</p></li><li><p>contour3 绘制等高线图</p></li></ul><h2 id="MATLAB程序设计"><a href="#MATLAB程序设计" class="headerlink" title="MATLAB程序设计"></a>MATLAB程序设计</h2><p>MATLAB有两种工作方式：一种是交互式的命令行工作方式，另一种是M文件的程序工作方式</p><h3 id="M文件"><a href="#M文件" class="headerlink" title="M文件"></a>M文件</h3><p>M文件有两类：命令文件和函数文件。区别在于：命令文件没有输入参数，也不返回输出参数；而函数文件可以输入参数，也可以返回输出参数。</p><ul><li><p>input函数， A=input(提示信息，选项);</p></li><li><p>pause(延迟秒数)    pause()直接暂停程序</p></li><li><p>Disp(输出项)</p></li></ul><h3 id="if选择语句"><a href="#if选择语句" class="headerlink" title="if选择语句"></a>if选择语句</h3><ul><li><p>结束时要加end，不需要加begin</p></li><li><p>else +if = elseif</p></li></ul><h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><ul><li><p>结束要加end</p></li><li><p>default改为otherwise</p></li><li><p>case 值 后面没有冒号</p></li></ul><h3 id="for循环结构"><a href="#for循环结构" class="headerlink" title="for循环结构"></a>for循环结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for 循环变量= 表达式1: 表达式2 : 表达式3</span><br><span class="line">    循环体</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">% 表达式1为初值， 表达式2为步长，表达式3为终值</span><br><span class="line"></span><br><span class="line">for 循环变量=矩阵表达式 则遍历矩阵元素</span><br></pre></td></tr></table></figure><h3 id="while循环结构"><a href="#while循环结构" class="headerlink" title="while循环结构"></a>while循环结构</h3><ul><li>结尾加end</li></ul><h3 id="函数文件"><a href="#函数文件" class="headerlink" title="函数文件"></a>函数文件</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> 输出形参表=函数名<span class="params">(输入形参表)</span></span></span><br><span class="line">    注释说明部分</span><br><span class="line">    函数体</span><br></pre></td></tr></table></figure><ul><li><p>当输出形参多余1个时，则应该用方括号括起来</p></li><li><p>参数可调， 用nargin和nargout实现</p></li><li><p>支持嵌套调用和递归</p></li><li><p>加global可以声明全局变量</p></li></ul><p>参考资料：MATLAB 数学工具软件实例简明教程</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;MATLAB学习笔记&quot;&gt;&lt;a href=&quot;#MATLAB学习笔记&quot; class=&quot;headerlink&quot; title=&quot;MATLAB学习笔记&quot;&gt;&lt;/a&gt;MATLAB学习笔记&lt;/h1&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>文章集锦</title>
    <link href="https://ricky-ting.github.io/2019/01/18/%E6%96%87%E7%AB%A0%E9%9B%86%E9%94%A6/"/>
    <id>https://ricky-ting.github.io/2019/01/18/文章集锦/</id>
    <published>2019-01-18T14:01:01.000Z</published>
    <updated>2019-02-12T13:54:36.358Z</updated>
    
    <content type="html"><![CDATA[<ul><li>什么是真正的程序员 <a href="https://www.cnblogs.com/xueweihan/p/5220513.html" target="_blank" rel="noopener">原文链接</a> （<a href="https://github.com/Ricky-Ting/ArticleCollection/blob/master/2019.1/什么是真正的程序员？%20-%20削微寒%20-%20博客园.pdf" target="_blank" rel="noopener">文章存档</a>）</li><li>信息消费：从入门到放弃 | 2018 年度征文 <a href="https://sspai.com/post/52832" target="_blank" rel="noopener">原文链接</a> (<a href="https://github.com/Ricky-Ting/ArticleCollection/blob/master/2019.2/信息消费：从入门到放弃%20%7C%202018%20年度征文%20-%20少数派.pdf" target="_blank" rel="noopener">文章存档</a>)</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;什么是真正的程序员 &lt;a href=&quot;https://www.cnblogs.com/xueweihan/p/5220513.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt; （&lt;a href=&quot;https://gith
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>mac下ssh打开X11转发</title>
    <link href="https://ricky-ting.github.io/2019/01/17/mac%E4%B8%8Bssh%E6%89%93%E5%BC%80X11%E8%BD%AC%E5%8F%91/"/>
    <id>https://ricky-ting.github.io/2019/01/17/mac下ssh打开X11转发/</id>
    <published>2019-01-17T07:13:44.000Z</published>
    <updated>2019-01-17T07:17:15.003Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mac下ssh打开X11转发"><a href="#mac下ssh打开X11转发" class="headerlink" title="mac下ssh打开X11转发"></a>mac下ssh打开X11转发</h1><p>1.首先确认linux下已开启X11转发：</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/ssh/sshd_config</span><br><span class="line"></span><br><span class="line">X11Forwarding yes</span><br><span class="line">X11DisplayOffset 10</span><br><span class="line"></span><br><span class="line">service ssh restart</span><br></pre></td></tr></table></figure></code></pre><p>2.安装XQuartz</p><p>3.在mac端下开启：</p><pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/ssh/ssh_config</span><br><span class="line"></span><br><span class="line">ForwardX11 yes</span><br></pre></td></tr></table></figure></code></pre><p>4.ssh登陆</p><pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -X username@ip</span><br></pre></td></tr></table></figure></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;mac下ssh打开X11转发&quot;&gt;&lt;a href=&quot;#mac下ssh打开X11转发&quot; class=&quot;headerlink&quot; title=&quot;mac下ssh打开X11转发&quot;&gt;&lt;/a&gt;mac下ssh打开X11转发&lt;/h1&gt;&lt;p&gt;1.首先确认linux下已开启X11转发：&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>2019寒假计划(flag)</title>
    <link href="https://ricky-ting.github.io/2019/01/16/2019%E5%AF%92%E5%81%87%E8%AE%A1%E5%88%92-flag/"/>
    <id>https://ricky-ting.github.io/2019/01/16/2019寒假计划-flag/</id>
    <published>2019-01-16T09:32:32.000Z</published>
    <updated>2019-01-16T09:33:26.543Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2019-寒假计划-flag"><a href="#2019-寒假计划-flag" class="headerlink" title="2019 寒假计划(flag)"></a>2019 寒假计划(flag)</h1><h2 id="必做"><a href="#必做" class="headerlink" title="必做"></a>必做</h2><ul><li><p>学习数学建模，参加美赛</p></li><li><p>完成经典阅读论文</p></li><li><p>读Spark源码</p></li><li><p>学习线性代数、代数学引论</p></li><li><p>寒假HK项目准备</p></li><li><p>学习MATLAB</p></li></ul><h2 id="可选"><a href="#可选" class="headerlink" title="可选"></a>可选</h2><ul><li><p>学习IOS开发</p></li><li><p>机器学习导论、人工智能、深度学习</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;2019-寒假计划-flag&quot;&gt;&lt;a href=&quot;#2019-寒假计划-flag&quot; class=&quot;headerlink&quot; title=&quot;2019 寒假计划(flag)&quot;&gt;&lt;/a&gt;2019 寒假计划(flag)&lt;/h1&gt;&lt;h2 id=&quot;必做&quot;&gt;&lt;a href=&quot;#必
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>如何解决项目子模块git冲突</title>
    <link href="https://ricky-ting.github.io/2019/01/03/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E9%A1%B9%E7%9B%AE%E5%AD%90%E6%A8%A1%E5%9D%97git%E5%86%B2%E7%AA%81/"/>
    <id>https://ricky-ting.github.io/2019/01/03/如何解决项目子模块git冲突/</id>
    <published>2019-01-03T15:02:20.000Z</published>
    <updated>2019-01-03T15:03:36.198Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何解决项目子模块git冲突"><a href="#如何解决项目子模块git冲突" class="headerlink" title="如何解决项目子模块git冲突"></a>如何解决项目子模块git冲突</h1><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>在将这学期做的PA提交到github时，因为ics2018中原有git与github上创建的git冲突，因此上传之后ics2018的图标为灰。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ul><li><p>git rm –cache ics2018</p></li><li><p>git add ics2018/</p></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://upupming.site/2018/05/31/git-submodules/#解决方案" target="_blank" rel="noopener">参考链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;如何解决项目子模块git冲突&quot;&gt;&lt;a href=&quot;#如何解决项目子模块git冲突&quot; class=&quot;headerlink&quot; title=&quot;如何解决项目子模块git冲突&quot;&gt;&lt;/a&gt;如何解决项目子模块git冲突&lt;/h1&gt;&lt;h2 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Records for Environment Setup for Spark</title>
    <link href="https://ricky-ting.github.io/2018/11/02/Records-for-Environment-Setup-for-Spark/"/>
    <id>https://ricky-ting.github.io/2018/11/02/Records-for-Environment-Setup-for-Spark/</id>
    <published>2018-11-02T15:29:21.000Z</published>
    <updated>2018-11-02T15:42:07.389Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spark搭建记录-2018-11-2"><a href="#Spark搭建记录-2018-11-2" class="headerlink" title="Spark搭建记录(2018.11.2)"></a>Spark搭建记录(2018.11.2)</h1><p>建立在Hadoop的基础上。</p><p><a href="https://www.cnblogs.com/zyrblog/p/8527048.html" target="_blank" rel="noopener">参考教程</a></p><p>Spark版本：2.1.3.</p><p>在官网上下的直接编译好的文件。</p><p>Spark装之前需要装Scala。我的Scala版本是2.11.6。</p><p>然后解压spark压缩包，修改conf目录下的spark-env.sh(备份到github)。 修改slaves文件。</p><p>注意启动后报错，需要加入JAVA_HOME环境变量，也在spark-env.sh中.</p><h1 id="Spark编译记录"><a href="#Spark编译记录" class="headerlink" title="Spark编译记录"></a>Spark编译记录</h1><p><a href="https://blog.csdn.net/babyhuang/article/details/78656093" target="_blank" rel="noopener">参考教程</a></p><p>在官网下载Spark源码，安装maven(我安装的版本是3.3.9) ，添加maven镜像(已备份)，修改dev目录下的make-distribution.sh文件，将Spark，Hadoop，Scala版本都换为自己的。</p><p>然后用README里的命令编译。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Spark搭建记录-2018-11-2&quot;&gt;&lt;a href=&quot;#Spark搭建记录-2018-11-2&quot; class=&quot;headerlink&quot; title=&quot;Spark搭建记录(2018.11.2)&quot;&gt;&lt;/a&gt;Spark搭建记录(2018.11.2)&lt;/h1&gt;&lt;p&gt;
      
    
    </summary>
    
    
      <category term="记录" scheme="https://ricky-ting.github.io/tags/%E8%AE%B0%E5%BD%95/"/>
    
      <category term="创新项目" scheme="https://ricky-ting.github.io/tags/%E5%88%9B%E6%96%B0%E9%A1%B9%E7%9B%AE/"/>
    
      <category term="大数据" scheme="https://ricky-ting.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>Records for Environment Setup for Hadoop</title>
    <link href="https://ricky-ting.github.io/2018/10/24/Records-for-Environment-Setup-for-Hadoop/"/>
    <id>https://ricky-ting.github.io/2018/10/24/Records-for-Environment-Setup-for-Hadoop/</id>
    <published>2018-10-24T03:20:25.000Z</published>
    <updated>2018-11-02T15:28:24.408Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hadoop环境搭建记录"><a href="#Hadoop环境搭建记录" class="headerlink" title="Hadoop环境搭建记录"></a>Hadoop环境搭建记录</h1><h2 id="安装系统"><a href="#安装系统" class="headerlink" title="安装系统"></a>安装系统</h2><p>安装系统的时候出了很多问题，找不到引导，硬盘被锁啊，感觉不懂的还是很多，最后还是请学长帮忙装好了系统。</p><a id="more"></a><h2 id="Hadoop环境的搭建"><a href="#Hadoop环境的搭建" class="headerlink" title="Hadoop环境的搭建"></a>Hadoop环境的搭建</h2><p>Hadoop版本:2.2.0</p><p><a href="https://blog.csdn.net/fanxin_i/article/details/80425461" target="_blank" rel="noopener">参考教程</a></p><p>教程简版： 1.获取IP，添加解析。2.关闭防火墙 3.安装jdk 4.安装ssh，配置免密通信 5. 安装hadoop，在hdfs目录下创建文件夹(tmp,name,data). 6.修改Hadoop配置文件包括以下几个文件(core-site.xml hadoop-env.sh hdfs-site.xml yarn-env.sh yarn-site.xml slaves).(这些配置文件会备份在github中) 7.用scp将文件夹传到slave上。 然后在master上初始化namenode(hdfs namenode -format)</p><p>我的理解是主要在master里执行namenode初始化就好了，初始化之前最好把master和slave里hdfs目录下删干净(以后可以写个脚本干这个事)。</p><h2 id="写脚本"><a href="#写脚本" class="headerlink" title="写脚本"></a>写脚本</h2><p>写脚本实现只运行MapReduce和在HDFS上运行MapReduce。</p><p>我的理解是只要改改配置文件就好，要运行哪一种方式只要把相应的配置文件拷进去就好。 因为不运行yarn，所以要把yarn的相关配置删除。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env bash</span><br><span class="line"></span><br><span class="line">echo &quot;This is to run mapreduce on hdfs&quot;</span><br><span class="line">rm -rf ~/hadoop-2.2.0/etc/hadoop</span><br><span class="line">echo &quot;Original config files in hadoop-2.2.0/ect/hadoop deleted&quot;</span><br><span class="line">cp -r ~/hadoopconfig/hadoop-distributed ~/hadoop-2.2.0/etc/</span><br><span class="line">echo &quot;Copy config files of hdfs to hadoop-2.2.0/etc/hadoop&quot;</span><br><span class="line">mv ~/hadoop-2.2.0/etc/hadoop-distributed ~/hadoop-2.2.0/etc/hadoop</span><br><span class="line">echo &quot;Rename successfully&quot;</span><br><span class="line">cd ~/hadoop-2.2.0</span><br><span class="line">echo &quot;About to run start-dfs.sh&quot;</span><br><span class="line">start-dfs.sh</span><br><span class="line">echo &quot;About to run an example on hdfs&quot;</span><br><span class="line">hadoop jar /home/hadoop/hadoop-2.2.0/share/hadoop/mapreduce/hadoop-mapreduce-examples-2.2.0.jar pi 10 10</span><br><span class="line">jps</span><br><span class="line">echo &quot;About to run stop-dfs.sh&quot;</span><br><span class="line">stop-dfs.sh</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env bash</span><br><span class="line"></span><br><span class="line">echo &quot;This is to run mapreduce without hdfs&quot;</span><br><span class="line">rm -rf ~/hadoop-2.2.0/etc/hadoop</span><br><span class="line">cp -r ~/hadoopconfig/hadoop-native ~/hadoop-2.2.0/etc/</span><br><span class="line">mv ~/hadoop-2.2.0/etc/hadoop-native ~/hadoop-2.2.0/etc/hadoop</span><br><span class="line">cd ~/hadoop-2.2.0</span><br><span class="line">./bin/hadoop jar ./share/hadoop/mapreduce/hadoop-mapreduce-examples-2.2.0.jar pi 10 10</span><br><span class="line">~</span><br><span class="line">~</span><br><span class="line">~</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Hadoop环境搭建记录&quot;&gt;&lt;a href=&quot;#Hadoop环境搭建记录&quot; class=&quot;headerlink&quot; title=&quot;Hadoop环境搭建记录&quot;&gt;&lt;/a&gt;Hadoop环境搭建记录&lt;/h1&gt;&lt;h2 id=&quot;安装系统&quot;&gt;&lt;a href=&quot;#安装系统&quot; class=&quot;headerlink&quot; title=&quot;安装系统&quot;&gt;&lt;/a&gt;安装系统&lt;/h2&gt;&lt;p&gt;安装系统的时候出了很多问题，找不到引导，硬盘被锁啊，感觉不懂的还是很多，最后还是请学长帮忙装好了系统。&lt;/p&gt;
    
    </summary>
    
    
      <category term="记录" scheme="https://ricky-ting.github.io/tags/%E8%AE%B0%E5%BD%95/"/>
    
      <category term="创新项目" scheme="https://ricky-ting.github.io/tags/%E5%88%9B%E6%96%B0%E9%A1%B9%E7%9B%AE/"/>
    
      <category term="大数据" scheme="https://ricky-ting.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>How to make an installation USB for Linux or other OS in Mac OS X</title>
    <link href="https://ricky-ting.github.io/2018/10/17/How-to-make-an-installation-USB-for-Linux-or-other-OS-in-Mac-OS-X/"/>
    <id>https://ricky-ting.github.io/2018/10/17/How-to-make-an-installation-USB-for-Linux-or-other-OS-in-Mac-OS-X/</id>
    <published>2018-10-17T12:55:11.000Z</published>
    <updated>2018-10-17T12:55:47.121Z</updated>
    
    <content type="html"><![CDATA[<h1 id="How-to-make-an-installation-USB-for-Linux-or-other-OS-in-Mac-OS-X"><a href="#How-to-make-an-installation-USB-for-Linux-or-other-OS-in-Mac-OS-X" class="headerlink" title="How to make an installation USB for Linux or other OS in Mac OS X"></a>How to make an installation USB for Linux or other OS in Mac OS X</h1><p>Step1: Download the image(iso) file from the Internet.</p><p>Step2: Open a Terminal(the following command are all completed in a terminal)</p><a id="more"></a><p>Step3: Trun <code>.iso</code> file into <code>.img</code> file by <code>hdiutil convert -format UDRW -o ~/path/to/target.img ~/path/from/src.iso</code>(The file created may end with <code>.dmg</code>)</p><p>Step4: <code>diskutil list</code> to obtain the devices mounted.</p><p>Step5: Insert your USB.</p><p>Step6: <code>diskutil list</code> to see which is added(/dev/diskN).</p><p>Step7: <code>diskutil unmountDisk /dev/diskN</code> to unmount USB</p><p>Step8: <code>sudo dd if=/path/to/target.img of=/dev/rdiskN bs=1m</code> to write the installation file into the USB</p><p>Step9: <code>diskutil eject /dev/diskN</code> to eject your USB.</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;How-to-make-an-installation-USB-for-Linux-or-other-OS-in-Mac-OS-X&quot;&gt;&lt;a href=&quot;#How-to-make-an-installation-USB-for-Linux-or-other-OS-in-Mac-OS-X&quot; class=&quot;headerlink&quot; title=&quot;How to make an installation USB for Linux or other OS in Mac OS X&quot;&gt;&lt;/a&gt;How to make an installation USB for Linux or other OS in Mac OS X&lt;/h1&gt;&lt;p&gt;Step1: Download the image(iso) file from the Internet.&lt;/p&gt;
&lt;p&gt;Step2: Open a Terminal(the following command are all completed in a terminal)&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Summary of definitions and theorems in graph theory</title>
    <link href="https://ricky-ting.github.io/2018/10/15/Summary-of-definitions-and-theorems-in-graph-theory/"/>
    <id>https://ricky-ting.github.io/2018/10/15/Summary-of-definitions-and-theorems-in-graph-theory/</id>
    <published>2018-10-15T14:06:07.000Z</published>
    <updated>2019-01-08T06:11:07.116Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Summary-of-definitions-and-theorems-in-graph-theory"><a href="#Summary-of-definitions-and-theorems-in-graph-theory" class="headerlink" title="Summary of definitions and theorems in graph theory"></a>Summary of definitions and theorems in graph theory</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><h3 id="1-1-Graphs-and-Graph-Models"><a href="#1-1-Graphs-and-Graph-Models" class="headerlink" title="1.1 Graphs and Graph Models"></a>1.1 Graphs and Graph Models</h3><p>A <strong>Graph</strong> G consists of a finite nonempty set $V$ of objects called <strong>vertices</strong> and a set $E$ of 2-element subsets of $V$ called <strong>edges</strong>. The ses $V$ and $E$ are the <strong>vertex set</strong> and <strong>edge set</strong> of $G$, respectively. Write $G=(V,E)$.</p><p>Two graphs $G$ and $H$ are <strong>equal</strong> if $V(G)=V(H)$ and $E(G)=E(H)$, in which case we write $G=H$.</p><p>If $uv$ is an edge of $G$, then $u$ and $v$ are said to be <strong>adjacent</strong> in $G$.</p><p>The number of vertices in $G$ is often called the <strong>order</strong> of $G$, while the number of edges is its <strong>size</strong>.</p><p>A graph with exactly one vertex is called a <strong>trivial graph</strong>, implying that the order of a <strong>nontrivial graph</strong> is at least 2.</p><p><strong>labeled graph</strong> and <strong>unlabeled graph</strong></p><p>A graph $G$ is called a <strong>word graph</strong> if $G$ is the word graph of some set $S$ of 3-letter words.</p><a id="more"></a><h3 id="1-2-Connected-Graphs"><a href="#1-2-Connected-Graphs" class="headerlink" title="1.2 Connected Graphs"></a>1.2 Connected Graphs</h3><p>The adjacent vertices $u$ and $v$ are said to be <strong>joined</strong> by the edge $e$. The vertices $u$ and $v$ are referred to as <strong>neighbors</strong> of each other. </p><p>Distinct edges incident with a common vertex are <strong>adjacent edges</strong>.</p><p>A graph $H$ is called a <strong>subgraph</strong> of a graph $G$, written $H \subseteq G$, if $V(H) \subseteq V(G)$ and $E(H) \subseteq E(G)$. We also say that $G$ contains $H$ as a subgraph. If $H \subseteq G$ and either $V(H)$ is a proper subset of $V(G)$ or $E(H)$ is a proper subset of $E(G)$, then $H$ is a <strong>proper subgraph</strong> of $G$. If a subgraph of a graph $G$ has the same vertex set as $G$, then it is a <strong>spanning subgraph</strong> of $G$.</p><p>A subgraph $F$ of a graph $G$ is called an <strong>induced subgraph</strong> of $G$ if whenever $u$ and $v$ are vertices of $F$ and $uv$ is an edge of $G$, then $uv$ is an edge of $F$ as well.</p><p>If $S$ is a nonempty set of vertices of a graph $G$, then the <strong>subgraph</strong> of $G$ <strong>induced by</strong> $S$ is the induced subgraph with vertex set $S$. This induced subgraph is denoted by $G[S]$.</p><p>For a nonempty set $X$ of edges, the <strong>subgraph G[X] induced by</strong> $X$ has edge set $X$ and consists of all vertices that are incident with at least one edge in $X$. This subgraph is called an <strong>edge-induced subgraph</strong> of $G$.   </p><p>A $u-v$ <strong>walk</strong> $W$ in $G$ is a sequence of vertices in $G$, beginning with $u$ and ending at $v$ such that consecutives vertices in the sequence are adjacent. If $u=v$, then the walk $W$ is <strong>closed</strong>; while if $u\not=v$, then $W$ is <strong>open</strong>. A walk of length 0 is a <strong>trivial walk</strong>.</p><p>We define a $u-v$ <strong>trial</strong> in a graph $G$ to be a $u-v$ walk in which no edges is traversed more than once.</p><p>A $u-v$ walk in a graph in which no vertices are repeated is a $u-v$ <strong>path</strong>. </p><p>A <strong>circuit</strong> in a graph $G$ is a closed trail of length 3 or more. Hence a circuit begins and ends at the same vertex but repeats no edges.</p><p>A circuit that repeats no vertex, except for the first and last, is a <strong>cycle</strong>.</p><p>If $G$ contains a $u-v$ path, then $u$ and $v$ are said to be <strong>connected</strong> and $u$ is <strong>connected to</strong> $v$.</p><p>A graph $G$ is <strong>connected</strong> if every two vertices of $G$ are connected. A graph that is not connected is called <strong>disconnected</strong>. A connected subgraph of $G$ that is not a proper subgraph of any other connected subgraph of $G$ is a <strong>component</strong> of $G$. The number of components of a graph $G$ is denoted by $k(G)$. Every graph is the union of its components.</p><p>The <strong>distance</strong> between $u$ and $v$ is the smallest length of any $u-v$ path in $G$ and is denoted by $d_{G}(u,v)$ or simply $d(u,v)$. A $u-v$ path of length $d(u,v)$ is called a $u-v$ <strong>geodesic</strong>.</p><p>The greatest distance between any two vertices of a connected graph $G$ is called the <strong>diameter</strong> of $G$ and is denoted by $diam(G)$.</p><p><strong>Theorem 1.10</strong> Let $G$ be a graph of order 3 or more. Then $G$  is connected if and only if $G$ contains two distinct vertices $u$  and $v$  such that $G-u$ and $G-v$ are connected.</p><h3 id="1-3-Common-Classes-of-Graphs"><a href="#1-3-Common-Classes-of-Graphs" class="headerlink" title="1.3 Common Classes of Graphs"></a>1.3 Common Classes of Graphs</h3><p>$G$ is called a <strong>path</strong> if …</p><p>$G$ is called a <strong>cycle</strong> if …</p><p>A graph $G$ is <strong>complete</strong> if every two distinct vertices of $G$ are adjacent. A complete graph of order $n$ is denoted by $K_n$.</p><p>The <strong>complement</strong> $\bar{G}$ of a graph $G$ is that graph whose vertex set is $V(G)$ and such that for each pair $u,v$ of distinct vertices of $G$, $uv$ is an edge of $\bar{G}$ if and only if $uv$ is not an edge of $G$.</p><p>The graph $\bar{K_n}$ has $n$ vertices and no edges, it is called the <strong>empty graph</strong> of order $n$.</p><p><strong>Theorem 1.11</strong> If $G$  is a disconnected graph, then $\bar{G}$ is connected.</p><p><strong>Theorem 1.12</strong> A nontrivial graph $G$ is a bipartite graph if and only if $G$ contains no odd cycles.</p><p>A graph $G$ is a <strong>bipartite graph</strong> if $V(G)$ can be partitioned into two subsets $U$ and $W$, called <strong>partite sets</strong>, such that every edge of $G$ joins a vertex of $U$ and a vertex of $W$.</p><p>If every vertex of $U$  is adjacent to every vertex of $W$ , then we call $G$  a <strong>complete bipartite graph</strong> . A complete graph with $|U|=s$  and $|W|=t$ is denoted by $K<em>{s,t}$ or $K</em>{t,s}$. If either $s=1$ or $t=1$, then $K_{s,t}$ is a <strong>star</strong>.</p><p>A graph $G$  is a $k$<strong>-partite graph</strong> if $V(G)$ can be partitioned into $k$ subsets $V_1$,$V_2$,…,$V_k$,(called <strong>partite sets</strong>) such that if $uv$ is an edge of $G$, then $u$ and $v$ belong to different partite sets. If, in addition, every  two vertices in different partite sets are joined by an edge, then $G$ is a <strong>complete k-partite graph</strong>. If $|V_i|=n<em>i$ for $1 \le i \le k$, then we denote this graph by $K</em>{n1,n2,…,nk}$. </p><p>The <strong>join</strong> $G+H$ consists of $G \cup H$ and all edges joining a vertex of $G$ and a vertex of $H$.</p><p>The <strong>Cartesian product</strong> $G \times H$ has vertex set $V(G \times H) = V(G) \times V(H)$ . Two distinct vertices $(u,v$) and $(x,y)$ are adjacent in $G \times H$ if either (1) $u=x$ and $vy\in E(H)$ or (2) $v=y$ and $ux\in E(G)$.</p><p>We define $Q_1 $ to be $ K<em>2 $ and for $n \ge 2$, define $Q</em>{n}$ to be $Q_{n-1} \times K_2 $. The graphs $Q_n $ are then called $n$<strong>-cubes</strong> or <strong>hypercubes</strong>.</p><h3 id="1-4-Multigraphs-and-Digraphs"><a href="#1-4-Multigraphs-and-Digraphs" class="headerlink" title="1.4 Multigraphs and Digraphs"></a>1.4 Multigraphs and Digraphs</h3><p>A <strong>multigraph</strong> $M$ consists of a finite nonempty set $V$ of vertices and a set $E$ of edges, where every two vertices of M are joined by a finite number of edges(possibly zero). If two or more edges join the same pair of (distinct) vertices, then these edges are called <strong>parallel</strong> edges.</p><p>In a <strong>pseudograph</strong>, not only are parallel edges permitted but an edge is also permitted to join a vertex to itself. Such an edge is called a <strong>loop</strong>.</p><p>A <strong>digraph</strong>(or <strong>directed graph</strong>) $D$ is a finite nonempty set $V$ of objects called <strong>vertices</strong> together with a set $E$ of ordered pairs of distinct vertices. The elements of $E$ are called <strong>directed edges</strong> or <strong>arcs</strong>. If $(u,v)$ is a directed edge, then we indicate this in a diagram representing $D$ by drawing a directed line segment or curve from $u$ to $v$. Then u is said to be <strong>adjacent to</strong> v and v is <strong>adjacent from</strong> u.</p><p>If, in the definition of digraph, for each pair $u,v$ of distinct vertices, at most one of $(u,v)$ and $(v,u)$ is a directed edge, then the resulting digraph is an <strong>oriented graph</strong>  </p><h2 id="Degrees"><a href="#Degrees" class="headerlink" title="Degrees"></a>Degrees</h2><h3 id="2-1-The-Degree-of-a-Vertex"><a href="#2-1-The-Degree-of-a-Vertex" class="headerlink" title="2.1 The Degree of a Vertex"></a>2.1 The Degree of a Vertex</h3><p>The <strong>degree of a vertex</strong> $v$ in a graph $G$ is the number of edges incident with $v$ and is denoted by $deg_G \ v$ or simply by $deg \ v$ if the graph $G$ is clear from the context.  The set $N(v)$ of neighbors of a vertex $v$  is called the <strong>neighborhood</strong> of $v$. Thus $deg \ v = |N(v)|$.</p><p>A vertex of degree 0 is referred to as an <strong>isolated vertex</strong> and a vertex of degree 1 is an <strong>end-vertex</strong>(or a <strong>leaf</strong>). </p><p>The <strong>minimum degree</strong> of $G$  is the minimum degree among the vertices of $G$ and is denoted by $\delta(G)$, the <strong>maximum degree</strong> of $G$ is denoted by $\Delta(G)$.</p><p>For $G$ of order $n$, we have $0 \le \delta(G) \le deg \ v \le \Delta(G) \le n-1$.</p><p><strong>Theorem 2.1(The First Theorem of Graph Theory)</strong>  If $G$  is a graph of size $m$, then $\sum \limits_{v\in V(G)} deg \ v =2m$.</p><p>A vertex of even degree is called an <strong>even vertex</strong>, while a vertex of odd degree is an <strong>odd vertex</strong>.</p><p><strong>Corollary 2.3</strong> Every graph has an even number of odd vertices.</p><p>If a graph $G$ order $n$ contains a vertex of degree $n-1$, then $G$ is connected. However, this is not a necessary condition.</p><p><strong>Theorem 2.4</strong> Let $G$ be a graph of order $n$. If $deg \ u + deg \ v \ge n-1$, for every two nonadjacent vertices $u$ and $v$ of $G$ , then $G$ is connected and $diam(G) \le 2$.</p><ul><li><p>The bound of <strong>Theorem 2.4</strong> is sharp.</p></li><li><p><strong>What if there is only one pair?</strong></p></li></ul><p><strong>Corollary 2.5</strong> If $G$  is a graph of order $n$ with $\delta(G) \ge (n-1)/2$, then $G$ is connected.</p><p><strong>outdegree</strong> and <strong>indegree</strong>.</p><h3 id="2-2-Regular-Graphs"><a href="#2-2-Regular-Graphs" class="headerlink" title="2.2 Regular Graphs"></a>2.2 Regular Graphs</h3><p>If $\delta(G)=\Delta(G)$, then the vertices of $G$  have the same degree and $G$  is called <strong>regular</strong>. If $deg \ r=r$ for every vertex $v$  of $G$, where $0 \le r \le n-1$, then $G$  is $r$ <strong>-regular</strong> or <strong>regular of degree r</strong>.</p><p>A 3-regular graph is also referred to as a <strong>cubic graph</strong>. The best known cubic graph may very well be the <strong>Petersen graph</strong>.</p><p><strong>Theorem 2.6</strong> Let $r$ and $n$  be integers with $0 \le r \le n-1$. There exists an r-regular graph of order $n$  if and only if at least one of $r$ and $n$  is even.</p><ul><li><p>How to construct this graph?  </p></li><li><p>The graphs $H_{r,n}$ are called <strong>Harary graph</strong></p></li></ul><p><strong>Theorem 2.7</strong> For every graph $G$ and every integer $r \ge \Delta(G)$, there exists an r-regular graph $H$ containing $G$ as an induced subgraph.</p><h3 id="2-3-Degree-Sequences"><a href="#2-3-Degree-Sequences" class="headerlink" title="2.3 Degree Sequences"></a>2.3 Degree Sequences</h3><p>If the degrees of the vertices of a graph $G$ are listed in a sequence $s$, then $s$  is called a <strong>degree sequence</strong> of $G$.</p><p>A finite sequence of nonnegative integers is called <strong>graphical</strong> if it is a degree sequence of some graph.</p><p><strong>Theorem 2.10</strong> A non-increasing sequence $s$: $d_1 ,d_2 ,…,d_n (n\ge 2)$ of non-negative integers, where $d_1 \ge 1$, is graphical if and only if the sequence $s_1：d<em>2 -1,d</em> 3-1,…,d<em>{d</em> 1 + 1}-1,d<em>{d</em> 1+1}-1,d<em>{d</em> 1+2},…d_ n $ is graphical.</p><h2 id="Isomorphic-Graphs"><a href="#Isomorphic-Graphs" class="headerlink" title="Isomorphic Graphs"></a>Isomorphic Graphs</h2><h3 id="3-1-The-Definition-of-Isomorphism"><a href="#3-1-The-Definition-of-Isomorphism" class="headerlink" title="3.1 The Definition of Isomorphism"></a>3.1 The Definition of Isomorphism</h3><p>We call two graphs $G$ and $H$ “isomorphic” if they have the same structure and write $G \cong H$ to indicate this. </p><p>Formally, two (labeled) graphs $G$ and $H$  are <strong>isomorphic</strong> (have the same structure) if there exists a one-to-one correspondence $\phi$ from $V(G)$ to $V(H)$ such that $uv \in E(G)$ if and only if $\phi(u)\phi(v) \in E(H)$. In this case, $\phi$  is called an <strong>isomorphism</strong> from $G$ to $H$.</p><p><strong>Theorem 3.1</strong> Two graphs $G$ and $H$ are isomorphic if and only if their complements $\bar{G}$ and $\bar{H}$ are isomorphic.</p><p>A graph $G$ is <strong>self-complementary</strong> if $G\cong \bar{G}$ . </p><p><strong>Theorem 3.2</strong> If $G$ and $H$ are isomorphic graphs, then the degrees of the vertices of $G$ are the same as the degrees of the vertices of $H$.</p><p><strong>Note</strong>: Having the same degree sequences don’t necessarily mean two graph are isomorphic.</p><h2 id="Trees"><a href="#Trees" class="headerlink" title="Trees"></a>Trees</h2><h3 id="4-1-Bridges"><a href="#4-1-Bridges" class="headerlink" title="4.1 Bridges"></a>4.1 Bridges</h3><p>An edge $e=uv$ of a connected graph $G$ is called a <strong>bridge</strong> of $G$ if $G-e$ is disconnected.</p><p>An edge $e$ is a <strong>bridge</strong> of a disconnected graph if $e$ is a bridge of some component of $G$.</p><p>An edge $e$ is a bridge of a graph $G$ if and only if $k(G-e)=k(G)+1$</p><p>End-vertice: vertice with degree $1$.</p><p><strong>Theorem 4.1</strong>: <em>An edge $e$ of a graph $G$ is a bridge if and only if $e$ lies on no cycle of $G$</em> </p><h3 id="4-2-Trees"><a href="#4-2-Trees" class="headerlink" title="4.2 Trees"></a>4.2 Trees</h3><p>A graph G is called <strong>acyclic</strong> if it has no cycles.</p><p>A <strong>tree</strong> is an acyclic connected graph.</p><p>Every edge in a tree is a bridge.</p><p>A tree containing exactly two vertices that are not end-vertices(which are necessarily adjacent) is called a <strong>double star</strong>.</p><p>A <strong>caterpillar</strong> is a tree of order 3 or more, the removal of whose end-vertices produces a path called <strong>spine</strong> of the caterpillar.</p><p>Choose a vertex of a tree $T$, and designate this vertex as the <strong>root</strong> of $T$. The tree $T$ then becomes a <strong>rooted tree</strong>. </p><p>Acyclic graphs are also referred to as <strong>forests</strong>. Therefore each component of a forest is a tree.</p><p>The one fact that distinguishes trees from forests is that a tree is required to be connected, while a forest is not required to be connected.</p><p><strong>Theorem 4.2</strong> <em>A graph $G$ is a tree if and only if every two vertices of G are connected by a unique path</em>.</p><p><strong>Theorem 4.3</strong> <em>Every nontrivial tree has at least two end-vertices</em>.</p><p><strong>Theorem 4.4</strong> <em>Every tree of order n has size $n-1$</em></p><p><strong>Corollary 4.6</strong> <em>Every forest of order n with k components has size $n-k$</em></p><p><strong>Theorem 4.7</strong> <em>The size of every connected graph of order $n$ is at least $n-1$</em>.</p><p><strong>Theorem 4.8</strong> <em>Let $G$ be a graph of order $n$ and size $m$. If $G$ satisfies any two of the properties: (1) $G$ is connected, (2)$G$ is acyclic, (3)$m=n-1$, then $G$ is a tree.</em></p><p><strong>Theorem 4.9</strong> <em>Let $T$ be a tree of order $k$. If $G$ is a graph with $\delta(G) \ge k-1$, then $T$ is isomorphic to some subgraph of $G$</em></p><h3 id="4-3-The-Minimum-Spanning-Tree-Problem"><a href="#4-3-The-Minimum-Spanning-Tree-Problem" class="headerlink" title="4.3 The Minimum Spanning Tree Problem"></a>4.3 The Minimum Spanning Tree Problem</h3><p>A spanning subgraph $H$ of a connected graph $G$ such that $H$ is a tree is called a <strong>spanning tree</strong> of $G$.</p><p><strong>Theorem 4.10</strong> <em>Every connected graph contains a spanning tree</em>.</p><p>The <strong>weight</strong> $w(H)$ of $H$ is defined as the sum of the weights of its edges.</p><p>A spanning tree with the minimum weight is called a <strong>minimum spanning tree</strong>.</p><p>The problem of finding a minimum spanning tree in a connected weighted graph is called the <strong>Minimum Spanning Tree Problem</strong>. </p><p><strong>Kruskal’s Algorithm</strong>: For a connected weighted graph $G$, a spanning tree $T$ of $G$ is constructed as follows: For the first edge $e_1$ of $T$, we select any edge of $G$ of minimum weight and for the second edge $e_2$ of $T$, we select any remaining edge of $G$ of minimum weight. For the thrid edge $e_3$ of T, we choose any remaining edge of $G$ of minimum weight that does not produce a cycle with the previously selected edges. We continue in the manner until a spanning tree is produced.</p><p><strong>Theorem 4.11</strong> <em>Kruskal’s Algorithm produces a minimum spanning tree in a connected weighted graph</em>.</p><ul><li>证明思路：取与T共同边数最多的最小生成树为H，取其中第一条不在T的边，构造新的生成树，构造关系，证明相等，矛盾</li></ul><p><strong>Prim’s Algorithm</strong>: For a connected weighted graph $G$, a spanning tree $T$ of $G$ is constructed as follows: For an arbitrary vertex $u$ for $G$, an edge of minimum weight incident with $u$ is selected as the first edge $e_1$ of $T$. For subsequent edges $e_2$, $e<em>3$, ..,$e</em>{n-1}$, we select an edge of minimum weight among those edges having exactly one of its vertices incident with an edge already selected.</p><p><strong>Theorem 4.12</strong> <em>Prim’s Algorithm produces a minimum spanning tree in a connected weighted graph.</em></p><h3 id="4-4-Excursion-The-Number-of-Spanning-Trees"><a href="#4-4-Excursion-The-Number-of-Spanning-Trees" class="headerlink" title="4.4 Excursion: The Number of Spanning Trees"></a>4.4 Excursion: The Number of Spanning Trees</h3><p><strong>THeorem 4.15</strong> <em>The number of distinct trees of order n with a specified vertex set is $n^{n-2}$</em>.</p><p><strong>Matrix Tree Theorem</strong> (to be continued).</p><h2 id="Connectivity"><a href="#Connectivity" class="headerlink" title="Connectivity"></a>Connectivity</h2><h3 id="5-1-Cut-Vertices"><a href="#5-1-Cut-Vertices" class="headerlink" title="5.1 Cut-Vertices"></a>5.1 Cut-Vertices</h3><p>A vertex $v$ in a connected graph $G$ is a <strong>cut-vertex</strong> of $G$ if $G-v$  is disconnected. More generally, a vertex $v$ is a cut-vertex in a graph $G$  if $v$  is a cut-vertex of a component of $G$.</p><p><strong>Theorem 5.1</strong> Let $v$ be a vertex incident with a bridge in a connected graph $G$. Then $v$ is a cut-vertex of $G$ if and only if $deg \ v \ge 2$. </p><p><strong>Corollary 5.2</strong> Let $G$ be a connected graph of order 3 or more. If $G$ contains a bridge, then $G$  contains a cut-vertex.</p><p><strong>Theorem 5.3</strong> Let $v$ be a cut-vertex in a connected graph $G$ and let $u$ and $w$ be vertices in distinct components of $G-v$ . Then $v$ lies on every $u-w$ path in $G$.</p><p><strong>Corollary 5.4</strong> A vertex $v$ of a connected graph $G$  is a cut-vertex of $G$ if and only if there exist vertices $u$ and $w$ distinct from $v$ such that $v$ lies on every $u-w$ path of $G$.</p><p><strong>Theorem 5.5</strong> Let $G$ be a nontrivial connected graph and let $u\in V(G)$ . If $v$ is a vertex that is farthest from $u$ in $G$, then $v$ is not a cut-vertex of $G$.</p><p><strong>Corollary 5.6</strong> Every nontrivial connected graph contains at least two vertices that are not cut-vertices.</p><h3 id="5-2-Blocks"><a href="#5-2-Blocks" class="headerlink" title="5.2 Blocks"></a>5.2 Blocks</h3><p>A nontrivial connected graph with no cut-vertices is called a <strong>nonseparable graph</strong>.</p><p><strong>Theorem 5.7</strong> A graph of order at least 3 is nonseparable if and only if every two vertices lie on a common cycle.</p><p><strong>Theorem 5.8</strong> Let $R$ be the relation defined on the edge set of a nontrivial connected graph $G$ by $e \ R \ f$, where $e,f \in E(G)$, if $e=f$ or $e$ and $f$ lie on a common cycle of $G$. Then $R$ is an equivalence relation.</p><p><strong>Corollary 5.9</strong> Every two distinct blocks $B_1$ and $B_2$ in a nontrivial connected graph $G$ have the following properties: </p><ul><li><p>(a) The blocks $B_1$ and $B_2$ are edge-disjoint.</p></li><li><p>(b) The blocks $B_1$ and $B_2$ have at most one vertex in common.</p></li><li><p>(c) If $B_1$ and $B_2$ have a vertex $v$ in common, then $v$ is a cut-vertex of $G$.</p></li></ul><h3 id="5-3-Connectivity"><a href="#5-3-Connectivity" class="headerlink" title="5.3 Connectivity"></a>5.3 Connectivity</h3><p>By a <strong>vertex-cut</strong> in a graph $G$, we mean a set $U$ of vertices of $G$ such that $G-U$ is disconnected. A vertex-cut of minimum cardinality in $G$ is called a <strong>minimum vertex-cut</strong>.</p><p><strong>Note</strong>: A connected graph contains a vertex-cut if and only if $G$ is not complete.</p><p>For a graph $G$ that is not complete, the <strong>vertex-connectivity</strong>(or simply the <strong>connectivity</strong>) $\kappa(G)$ of $G$ is defined as the cardinality of a minimum vertex-cut of $G$; if $G=K_n$ for some positive integer $n$, then $\kappa(G)$ is defined to be $n-1$. $$0 \le \kappa(G) \le n-1$$.</p><p>For a nonnegative integer $k$, a graph $G$ is said to be $k$<strong>-connected</strong> if $\kappa(G) \ge k$.</p><p>An <strong>edge-cut</strong> in a nontrivial graph $G$  is a set $X$ of edges of $G$ such that $G-X$ is disconnected.</p><p>An edge-cut $X$  of a connected graph $G$  is <strong>minimal</strong> if no proper subset of $X$ is an edge-cut of $G$. If $X$ is a minimal edge-cut of a connected graph $G$, then $G-X$ contains exactly two components $G_1$ and $G_2$. Necessarily  then , $X$ consists of all those edges of $G$  joining $G_1$ and $G_2$.  </p><p>An edge-cut of minimum cardinality is called a <strong>minimum edge-cut</strong>.</p><p>The <strong>edge-connectivity</strong> …….</p><p>For a nonnegative integer $k$, …</p><p><strong>Theorem 5.11</strong> For every graph $G$, $$ \kappa(G) \le \lambda(G) \le \delta(G) $$</p><p><strong>Theorem 5.12</strong> If $G$ is a cubic graph, then $\kappa(G) = \lambda(G)$.</p><p><strong>Theorem 5.13</strong> If $G$ is a graph of order $n$ and size $m \le n-1$, then $\kappa(G) \le \lfloor \frac{2m}{n} \rfloor$ .</p><p>$\kappa(T)=1$</p><p>Let $G$ be a connected graph of diameter $d$. For an integer $k$ with $1 \le k \le d$, the $k$<strong>th power</strong> $G^k $ of $G$  is the graph with $V(G^k ) = V(G)$ such that $uv$ is an edge of $G^k$ if $1 \le d_{G} (u,v) \le k$.</p><p><strong>Theorem 5.14</strong> If $G$ is a connected graph of order at least 3, then its square $G^2$  is 2-connected.</p><p><strong>Theorem 5.15</strong> For every two integers $r$ and $n$ with $2 \le r \le n$, $$\kappa(H_{r,n})=r$$.</p><h3 id="5-4-Menger’s-Theorem"><a href="#5-4-Menger’s-Theorem" class="headerlink" title="5.4 Menger’s Theorem"></a>5.4 Menger’s Theorem</h3><p>TBC.</p><h2 id="Traversability"><a href="#Traversability" class="headerlink" title="Traversability"></a>Traversability</h2><h3 id="6-1-Eulerian-Graphs"><a href="#6-1-Eulerian-Graphs" class="headerlink" title="6.1 Eulerian Graphs"></a>6.1 Eulerian Graphs</h3><p>A circuit $C$ in a graph $G$ is called an <strong>Eulerian circuit</strong> if $C$ contains every edge of $G$. Since no edges is repeated in a circuit, every edge appears exactly once in an Eulerian circuit. A connected graph that contains an Eulerian circuit is called an <strong>Eulerian graph</strong>.</p><p>For a connected graph $G$, we refer to an open trial that contains every edge of $G$ as an <strong>Eulerian trial</strong>.</p><p><strong>Theorem 6.1</strong> A nontrivial connected graph $G$ is Eulerian if and only if every vertex of $G$ has even degree.</p><p><strong>Theorem 6.2</strong> A connected graph $G$ contains an Eulerian trial if and only if exactly two vertices of $G$ have odd degree. Furthermore, each Eulerian trial of $G$ begins at one of these odd vertices and ends at the other.</p><p>We have a conclusion: Let $G$ and $H$ be nontrivial connected graphs. Then $G \times H$ is Eulerian if and only if both $G$ and $H$ are Eulerian or every vertex of $G$ and $H$  is odd.</p><h3 id="6-2-Hamiltonian-Graphs"><a href="#6-2-Hamiltonian-Graphs" class="headerlink" title="6.2 Hamiltonian Graphs"></a>6.2 Hamiltonian Graphs</h3><p>A cycle in a graph $G$ that contains every vertex of $G$ is called a <strong>Hamiltonian cycle</strong> of $G$. A <strong>Hamiltonian graph</strong> is a graph that contains a Hamiltonian cycle.</p><p>A path in a graph $G$ that contains every vertex of $G$ is called a <strong>Hamiltonian path</strong> in $G$.</p><p><strong>Theorem 6.4</strong> The Petersen graph is non-Hamiltonian.</p><p><strong>Theorem 6.5</strong> If $G$ is a Hamiltonian graph, then for every nonempty proper set $S$ of vertices of $G$, $$\kappa(G-S) \le |S|$$</p><p><strong>Theorem 6.6</strong> Let $G$ be a graph of order $n \ge 3$. If $deg \ u + deg \ v \ge n$ for each pair $u$, $v$ of nonadjacent vertices of $G$, then $G$ is Hamiltonian.</p><p><strong>Corollary 6.7</strong> Let $G$ be graph of order $n \ge 3$. If $deg \ v \ge n/2$  for each vertex $v$ of $G$, then $G$ is Hamiltonian.</p><p><strong>Theorem 6.8</strong> Let $u$ and $v$ be nonadjacent vertices in a graph $G$ of order $n$ such that $deg \ u + deg \ v \ge n$ . Then $G+uv$ is Hamiltonian if and only if $G$ is Hamiltonian.</p><p>The <strong>closure</strong> $C(G)$ of a graph $G$ of order $n$ is the graph obtained from $G$ by recursively joining pairs of nonadjacent vertices whose degree sum is at least $n$ (in the resulting graph at each stage) until no such pair remains.</p><p><strong>Theorem 6.9</strong> A graph is Hamiltonian if and only if its closure is Hamiltonian.</p><p><strong>Corollary 6.10</strong> If $G$ is a graph of order at least 3 such that $C(G)$ is complete, the n $G$ is Hamiltonian.</p><p><strong>Theorem 6.11</strong> Let $G$ be a graph of order $n \ge 3$. If for every integer $j$ with $ 1 \le j &lt; \frac{n}{2}$, the number of vertices of $G$ with degree at most $j$ is less than $j$, then $G$ is Hamiltonian.</p><h3 id="6-3-Hamiltonian-Walks"><a href="#6-3-Hamiltonian-Walks" class="headerlink" title="6.3 Hamiltonian Walks"></a>6.3 Hamiltonian Walks</h3><h2 id="Matchings-and-Factorization"><a href="#Matchings-and-Factorization" class="headerlink" title="Matchings and Factorization"></a>Matchings and Factorization</h2><h3 id="8-1-Matchings"><a href="#8-1-Matchings" class="headerlink" title="8.1 Matchings"></a>8.1 Matchings</h3><p>A set of edges in a graph is <strong>independent</strong> if no two edges in the set are adjacent.</p><p>By a <strong>macthing</strong> in a graph $G$ , we mean an independent set of edges in $G$.</p><p>The graph $G$ is said to satisfy <strong>Hall’s condition</strong> if $|N(X)| \ge|X|$ for every nonempty subset $X$ of $U$.</p><p><strong>Theorem 8.3</strong> Let $G$ be a bipartite graph with partite sets $U$ and $W$ such that $r= |U| \le |W|$. Then $G$ contains a matching of cardinality $r$ if and only if $G$ satisfies Hall’s condition.</p><p><strong>Theorem 8.4</strong> A collection ${ S_1 , S_2 , … , S_n}$ of nonempty finite sets has a system of distinct representatives if and only if for each integer $k$ with $1 \le k \le n$, the union of any $k$ of these sets contains at elast $k$ elements.</p><p><strong>Theorem 8.5(The Marriage Theorem)</strong> In a collection of $r$ women and $r$ men, a total of $r$ marriages between acquainted couples is possible if and only if for each integer $k$ with $1 \le k \le r$, every subset of $k$ women is collectively acquainted with at least $k$ men.</p><p>A matching of maximum cardinality is called a <strong>maximum matching</strong>.  </p><p>If a graph $G$ of order $2k$ has a matching $M$ of cardinality $k$, then this (necessarily maximum)  matching $M$ is called a <strong>perfect matching</strong> as $M$ matches every vertex of $G$ to some vertex of $G$ .</p><p><strong>Theorem 8.6</strong> Every r-regular bipartite graph($r \ge 1$)  has a perfect matching.</p><p>The <strong>edge independence number</strong> $\alpha’(G)$ of a graph $G$  is the maximum cardinality of an independent set of edges.</p><p>Furthermore, a graph $G$ of order $n$ has a perfect matching if and only if $n$ is even and $\alpha ‘(G) = n/2$.</p><p>A vertex and an incident edge are said to <strong>cover</strong> each other.</p><p>An <strong>edge cover</strong> of a graph $G$ without isolated vertices is a set of edges of $G$ that covers all vertices of $G$.</p><p>The <strong>edge covering number</strong> $\beta’(G)$ of a graph $G$ is the minimum cardlinality of an edge cover of $G$.  An edge cover of $G$ of cardinality $\beta’(G)$ is a <strong>minimum edge cover</strong> of $G$.</p><p><strong>Theorem 8.7</strong> For every graph $G$ of order $n$ containing no isolated vertices, $$\alpha(G’)+ \beta(G’)=n$$.</p><p>A set of vertices in a graph is <strong>independent</strong> if  no two vertices in the set are adjacent. The <strong>vertex independence number</strong> (or the <strong>independence number</strong>) $\alpha(G)$ of a graph $G$ is the maximum cardinality of an independent set of vertices in $G$. An independent set in $G$ of cardinality $\alpha(G)$ is called a <strong>maximum independent set</strong>. </p><p>A <strong>vertex cover</strong> in a graph $G$ is a set of vertices that covers all edges of $G$. The minimum number of vertices in a vertex cover of $G$  is the <strong>vertex covering number</strong> $\beta(G)$  of $G$. A vertex cover of cardinality $\beta(G)$ is a <strong>minimum vertex cover</strong> in $G$.</p><p><strong>Theorem 8.8</strong> For every graph $G$ of order $n$ containing no isolated vertices, $$\alpha(G) + \beta(G) =n$$. </p><h3 id="8-2-Factorization"><a href="#8-2-Factorization" class="headerlink" title="8.2 Factorization"></a>8.2 Factorization</h3><p>A 1-regular spanning subgraph of a graph $G$ is also called a <strong>1-factor</strong> of $G$. </p><p>A graph $G$ has a 1-factor if and only if $G$ has a perfect matching.</p><p>A component of a graph is <strong>odd</strong> or <strong>even</strong> according to whether its order is odd or even. We write $k_O (G)$ for the number of odd components of a graph $G$.</p><p><strong>Theorem 8.10</strong> A graph $G$ contains a 1-factor if and only if $k_O (G-S) \le |S|$ for every proper subset $S$ of $V(G)$.</p><p><strong>Theorem 8.11(Petersen’s Theorem)</strong> Every 3-regular bridgeless graph contains a 1-factor.</p><p><strong>Theorem 8.12</strong> Every 3-regular graph with at most two bridges contains a 1-factor.</p><p>A graph $G$ is said to be <strong>1-factorable</strong> if there exists 1-factors $F_1,F_2,…,F_r$ of $G$ such that ${E(F_1),E(F_2),..,E(F_r)}$ is a partition of $E(G)$.  We then say that $G$ is <strong>factored</strong> into the 1-factors $F_1.F_2,…,F_r$ , which form a <strong>1-factorization</strong> of $G$.</p><p>Every 1-factorable graph is regular.</p><p><strong>Theorem 8.13</strong> The Petersen graph is not 1-factorable.</p><p><strong>Theorem 8.14</strong> For each positive integer $k$, the complete graph $K_{2k}$ is 1-factorable.</p><p><strong>Theorem 8.15</strong> Every r-regular bipartite graph , $r\ge 1$, is factorable.</p><p>A <strong>2-factor</strong> in a graph $G$ is a spanning 2-regular subgraph of $G$. Every component of a 2-factor is therefore a cycle. A graph $G$ is said to be <strong>2-factorable</strong> if there exist 2-factors $F_1,F_2,..,F_k$ such that ${E(F_1),E(F_2),…,E(F_k)}$ is a partition of $E(G)$.</p><p><strong>Theorem 8.16</strong> A graph $G$ is 2-factorable if and only if $G$ is r-regular for some positive even integer $r$.</p><p>A spanning subgraph $F$ of a graph $G$ is called a <strong>factor</strong> of $G$. The graph $G$ is said to be <strong>factorable</strong> into the factors $F_1,F_2,…,F_k$ if ${E(F_1),E(F_2),…,E(F_k)}$ is a partition of $E(G)$. If each factor $F_i$ is isomorphic to some graph $G$, then $G$ is <strong>F-factorable</strong>.</p><p>TBC.</p><h3 id="8-3-Decompositions-and-Graceful-Labelings"><a href="#8-3-Decompositions-and-Graceful-Labelings" class="headerlink" title="8.3 Decompositions and Graceful Labelings"></a>8.3 Decompositions and Graceful Labelings</h3><p>A graph $G$ is said to be <strong>decomposable</strong> into the subgraphs $H_1,H_2,…,H_k$ if ${E(H_1),E(H_2),…,E(H_k)}$ is a partition of $E(G)$. Such a partition produces a <strong>decomposition</strong> of $G$.  If each $H_i$ is isomorphic to some graph $H$, then the graph $G$ is $H-$ <strong>decomposable</strong>  and the decomposition is an $H-$ <strong>decomposition</strong>. </p><p>A <strong>Steiner triple system</strong> of order $n$ is a set $S$ of cardinality $n$ and a collection $T$ of 3-element subsets, called <strong>triples</strong>, such that every two distinct elements of $S$ belong to a unique triple in $T$.</p><p>TBC</p><h2 id="Planarity"><a href="#Planarity" class="headerlink" title="Planarity"></a>Planarity</h2><h3 id="9-1-Planar-Graphs"><a href="#9-1-Planar-Graphs" class="headerlink" title="9.1 Planar Graphs"></a>9.1 Planar Graphs</h3><p>A graph $G$  is called a <strong>planar graph</strong> if $G$  can be drawn in the plane so that no two of its edges cross each other. A graph that is not planar is called <strong>nonplanar</strong>. A graph $G$ is called a <strong>plane graph</strong>  if it is drawn in the plane so that no two edges of $G$ cross. </p><p>A plane graph divides the plane into connected pieces called <strong>regions</strong>. In every plane graph, there is always one region that is unbounded. This is the <strong>exterior region</strong>.  The subgraph of a plane graph whose vertices and edges are incident with a given region $R$  is the <strong>boundary</strong> of $R$. </p><p><strong>Theorem 9.1(The Euler Identity)</strong> If $G$ is a connected plane graph of order $n$, size $m$ and having $r$ regions, then $n-m+r=2$.</p><p><strong>Theorem 9.2</strong> If $G$ is a planar graph of order $n \ge 3$ and size $m$, then $$m \le 3n-6$$.</p><p><strong>Corollary 9.3</strong> Every planar graph contains a vertex of degree 5 or less.</p><p><strong>Corollary 9.4</strong> The complete graph $K_5$ is nonplanar.</p><p><strong>Theorem 9.5</strong> The graph $K_{3,3}$ is nonplanar.</p><p>A graph $G$ is <strong>maximal planar</strong> if $G$ is planar but the addition of an edge between any two nonadjacent vertices of $G$  results in a nonplanar graph.</p><p>More formally, a graph is called a <strong>subdivision</strong> of a graph $G$ if $G’=G$ or one or more vertices of degree 2 are inserted into one or more edges of $G$.</p><p><strong>Theorem 9.7(Kuratowski’s Theorem)</strong> A graph $G$ is planar if and only if $G$ does not contain a subdivision of $K<em>5$ or $K</em>{3,3}$ as a subgraph. </p><h2 id="Coloring-Graphs"><a href="#Coloring-Graphs" class="headerlink" title="Coloring Graphs"></a>Coloring Graphs</h2><h3 id="10-2-Vertex-Coloring"><a href="#10-2-Vertex-Coloring" class="headerlink" title="10.2 Vertex Coloring"></a>10.2 Vertex Coloring</h3><p>With each map, there is associated a graph $G$  called the  <strong>dual</strong> of the map, whose vertices are the regions of the map and such that two vertices of $G$  are adjacent if the corresponding regions are neighboring regions.</p><p>By a <strong>proper coloring</strong> (or, more simply, a <strong>coloring</strong>)  of a graph $G$  ,  we mean an assignment of colors (elements of some set) to the vertices of $G$ , one color to each vertex, such that adjacent vertices are colored differently.  </p><p>The smallest number of colors in any coloring of a graph $G$  is called the <strong>chromatic number</strong>  of $G$  and is denoted by $\chi(G)$.  If it is possible to color $G$ from a set of $k$  colors, then $G$  is said to be <strong>k-colorable</strong>. A coloring that uses $k$ colors is called a <strong>k-coloring</strong>. If $\chi(G)=k$, then $G$ is said to be <strong>k-chromatic</strong> and every $k-coloring$ of $G$ is a <strong>minimum coloring</strong> of $G$. </p><p><strong>Theorem 10.1(The Four Color Theorem)</strong> The chromatic number of every planargraph is at most 4.</p><p>If $G$ is a k-chromatic graph, then it is possible to partition $V(G)$ into  $k-1$ independent sets $V_1 , V_2 , …., V_k $, called <strong>color classes</strong>, but it is not possible to partition $V(G)$ into $k-1$ independent sets.</p><p><strong>Theorem 10.2</strong> A graph $G$ has chromantic number 2 if and only if $G$ is a nonempty bipartite graph.</p><p>A graph $G$ of order $n$ has chromatic number $n$ if and only if $G =K_n$.</p><p>If $H$ is a subgraph of $G$, then $\chi(H) \le \chi(G)$.</p><p>A <strong>clique</strong> in a graph $G$ is a complete subgraph of $G$. The order of the largest clique ina graph $G$ is its <strong>clique number</strong>, which is denoted by $\omega(G)$.</p><p>In fact,  $\alpha(G)=k$ if and only if $\omega(\bar{G})=k$.</p><p><strong>Theorem 10.5</strong> For every graph $G$ of order $n$, $\chi(G \ge \omega(G))$ and $\chi(G) \ge \frac{n}{\alpha(G)}$.</p><p><strong>Theorem 10.7</strong> For every graph $G$, $$\chi(G) \le 1 + \Delta(G)$$ </p><p><strong>Theorem 10.8(Brooks’ Theorem)</strong> For every connected graph $G$ that is not an odd cycle or a complete graph, $\chi(G) \le \Delta(G)$.</p><p><strong>Theorem 10.9</strong> For every graph $G$, $\chi(G) \le 1+ max{\delta(H)}$, where the maximum is taken over all induced subgraphs $H$ of $G$.</p><p>The <strong>shadow graph</strong> $S(G)$ of a graph $G$ is obtained from $G$ by adding, for each vertex $v$ of $G$, a new vertex $v’$, called the <strong>shadow vertex</strong> of $v$ , and joining $v’$ to the neighbors of $v$ in $G$. Observe that (1) a vertex of $G$ and its shadow vertex are not adjacent in $S(G)$ and (2) no two shadow vertices are adjacent in $S(G)$.</p><p><strong>Theorem 10.10</strong> For every integer $k \ge 3$, there exists a triangle-free graph with chromatic number $k$.</p><p>A graph $G$ is called <strong>perfect</strong> if $\chi(H)=\omega(H)$ for every induced subgraph $H$ of $G$.</p><p><strong>The Perfect Graph Theorem</strong> A graph is perfect if and only if its complement is perfect.</p><p><strong>The Strong Perfect Graph T</strong> A graph $G$ is perfect if and only if neither $G$ nor $\bar{G}$ contains an induced odd cycle of length 5 or more.</p><p>Reference:</p><p>[1] G.Chartrand and P.Zhang, First Course in Graph Theory, New York: Dover Publications, 2012.</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Summary-of-definitions-and-theorems-in-graph-theory&quot;&gt;&lt;a href=&quot;#Summary-of-definitions-and-theorems-in-graph-theory&quot; class=&quot;headerlink&quot; title=&quot;Summary of definitions and theorems in graph theory&quot;&gt;&lt;/a&gt;Summary of definitions and theorems in graph theory&lt;/h1&gt;&lt;h2 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h2&gt;&lt;h3 id=&quot;1-1-Graphs-and-Graph-Models&quot;&gt;&lt;a href=&quot;#1-1-Graphs-and-Graph-Models&quot; class=&quot;headerlink&quot; title=&quot;1.1 Graphs and Graph Models&quot;&gt;&lt;/a&gt;1.1 Graphs and Graph Models&lt;/h3&gt;&lt;p&gt;A &lt;strong&gt;Graph&lt;/strong&gt; G consists of a finite nonempty set $V$ of objects called &lt;strong&gt;vertices&lt;/strong&gt; and a set $E$ of 2-element subsets of $V$ called &lt;strong&gt;edges&lt;/strong&gt;. The ses $V$ and $E$ are the &lt;strong&gt;vertex set&lt;/strong&gt; and &lt;strong&gt;edge set&lt;/strong&gt; of $G$, respectively. Write $G=(V,E)$.&lt;/p&gt;
&lt;p&gt;Two graphs $G$ and $H$ are &lt;strong&gt;equal&lt;/strong&gt; if $V(G)=V(H)$ and $E(G)=E(H)$, in which case we write $G=H$.&lt;/p&gt;
&lt;p&gt;If $uv$ is an edge of $G$, then $u$ and $v$ are said to be &lt;strong&gt;adjacent&lt;/strong&gt; in $G$.&lt;/p&gt;
&lt;p&gt;The number of vertices in $G$ is often called the &lt;strong&gt;order&lt;/strong&gt; of $G$, while the number of edges is its &lt;strong&gt;size&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;A graph with exactly one vertex is called a &lt;strong&gt;trivial graph&lt;/strong&gt;, implying that the order of a &lt;strong&gt;nontrivial graph&lt;/strong&gt; is at least 2.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;labeled graph&lt;/strong&gt; and &lt;strong&gt;unlabeled graph&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A graph $G$ is called a &lt;strong&gt;word graph&lt;/strong&gt; if $G$ is the word graph of some set $S$ of 3-letter words.&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Daily Records for 2018 Oct</title>
    <link href="https://ricky-ting.github.io/2018/10/01/Daily-Records-for-2018-Oct/"/>
    <id>https://ricky-ting.github.io/2018/10/01/Daily-Records-for-2018-Oct/</id>
    <published>2018-10-01T11:48:48.000Z</published>
    <updated>2018-10-07T15:11:45.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Oct-1-7"><a href="#Oct-1-7" class="headerlink" title="Oct 1-7"></a>Oct 1-7</h1><ul><li>Did some Lab1</li><li>Completed PA2.1</li><li>Completed ProblemSolving3-4</li><li>Completed Expr03 and Expr04 of Digital Logical Circuits</li><li>Did some further reading</li></ul><h1 id="Oct-8"><a href="#Oct-8" class="headerlink" title="Oct 8"></a>Oct 8</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Oct-1-7&quot;&gt;&lt;a href=&quot;#Oct-1-7&quot; class=&quot;headerlink&quot; title=&quot;Oct 1-7&quot;&gt;&lt;/a&gt;Oct 1-7&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Did some Lab1&lt;/li&gt;
&lt;li&gt;Completed PA2.1&lt;/li&gt;

      
    
    </summary>
    
    
      <category term="记录" scheme="https://ricky-ting.github.io/tags/%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>PA拾慧</title>
    <link href="https://ricky-ting.github.io/2018/09/16/PA%E6%8B%BE%E6%85%A7/"/>
    <id>https://ricky-ting.github.io/2018/09/16/PA拾慧/</id>
    <published>2018-09-16T15:03:19.000Z</published>
    <updated>2018-10-07T15:30:53.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>天将降PA于斯人也，必先使其STFW,RTFM,RTFSC, 所以动心忍性，曾益其所不能</strong></p><h1 id="tmux-分屏工具"><a href="#tmux-分屏工具" class="headerlink" title="tmux(分屏工具)"></a>tmux(分屏工具)</h1><p>Prefix: <code>Ctrl+B</code></p><p>左右分屏:<code>Prefix + %</code> 上下分屏: <code>Prefix + &quot;</code></p><p>切换: <code>Prefix + 方向键</code></p><h1 id="Vim配置"><a href="#Vim配置" class="headerlink" title="Vim配置"></a>Vim配置</h1><h2 id="vim分屏："><a href="#vim分屏：" class="headerlink" title="vim分屏："></a>vim分屏：</h2><p><code>Ctrl+W s</code>:上下分割当前打开的文件</p><p><code>:sp filename</code>:上下分割，并打开一个新的文件</p><p><code>Ctrl+W v</code>: 左右分割当前打开的文件</p><p><code>:vsp filename</code>: 左右分割，并打开一个新的文件</p><p><code>Ctrl+W l,h,k,j</code>: 在窗格见切换</p><h2 id="vim函数跳转"><a href="#vim函数跳转" class="headerlink" title="vim函数跳转:"></a>vim函数跳转:</h2><ol><li>安装ctags: ‘sudo apt-get install ctags’</li><li>测试ctags是否安装成功: <code>whereis ctags</code></li><li>为源代码生成tags文件，建议在项目根目录下生成: <code>ctags -R</code>,更多高级选项请自行查询或man</li><li>配置vimrc: <code>sudo vim ~/.vimrc</code></li><li>修改vimrc: 加入下面两行 </li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set tags=[path]/tags</span><br><span class="line">set tags=./tags,tags;$HOME</span><br></pre></td></tr></table></figure><h2 id="vim配置选项"><a href="#vim配置选项" class="headerlink" title="vim配置选项"></a>vim配置选项</h2><p><code>set laststatus=2</code></p><p>跳转快捷键: <code>Ctrl+]</code>跳转,  <code>Ctrl+t</code> or <code>Ctrl+o</code>返回.</p><p>在终端里输入<code>vim -t functionname</code> 可以直接跳转至你想跳转的函数.(来自StardustDL的补充)</p><p>vim函数跳转部分参考<a href="https://mengzelev.github.io/2018/09/12/pa-inspirations/" target="_blank" rel="noopener">Mengzelve’s Blog</a> </p><h1 id="C语言相关"><a href="#C语言相关" class="headerlink" title="C语言相关"></a>C语言相关</h1><p>顺时针法则</p><p>strcmp返回值为0是两个字符串相等</p><p>结构体里利用位域实现位级访问</p><h1 id="Linux相关"><a href="#Linux相关" class="headerlink" title="Linux相关"></a>Linux相关</h1><p>linux里的管道(pipeline)将不同程序的输入输出连起来。</p><p><code>time ./a.out</code> 可以测程序运行的时间。</p><p>在shell中使用终端设置别名:<code>alias cdblog=&#39;cd ~/Desktop/Github/Blog&#39;</code></p><p>统计代码行数: <code>find . | grep -E &#39;\.c$|\.h$&#39; | xargs cat | wc -l</code></p><p>统计代码行数(不含空格): <code>find . | grep -E &#39;\.c$|\.h$&#39; | xargs cat | grep -v ‘^$’ | wc -l</code></p><h1 id="一些好的文章："><a href="#一些好的文章：" class="headerlink" title="一些好的文章："></a>一些好的文章：</h1><p><a href="https://i.linuxtoy.org/docs/guide/index.html" target="_blank" rel="noopener">开源世界旅行手册</a></p><p><a href="http://songshuhui.net/archives/70194" target="_blank" rel="noopener">计算的极限</a></p><p><a href="https://eli.thegreenplace.net/2011/01/23/how-debuggers-work-part-1/#id7" target="_blank" rel="noopener">How debuggers work</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;天将降PA于斯人也，必先使其STFW,RTFM,RTFSC, 所以动心忍性，曾益其所不能&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;tmux-分屏工具&quot;&gt;&lt;a href=&quot;#tmux-分屏工具&quot; class=&quot;headerlink&quot; title=&quot;tmux(
      
    
    </summary>
    
    
      <category term="记录" scheme="https://ricky-ting.github.io/tags/%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Debian install sudo</title>
    <link href="https://ricky-ting.github.io/2018/09/06/Debian-install-sudo/"/>
    <id>https://ricky-ting.github.io/2018/09/06/Debian-install-sudo/</id>
    <published>2018-09-06T01:08:13.000Z</published>
    <updated>2018-09-06T07:39:19.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Debian-install-sudo"><a href="#Debian-install-sudo" class="headerlink" title="Debian install sudo"></a>Debian install sudo</h1><ol><li><code>su</code>切换至root</li><li><code>apt-get install sudo</code></li><li><code>visudo</code> 在<code>root ALL(ALL:ALL) ALL</code>后面加入一行<code>&lt;user&gt; ALL=(ALL:ALL) ALL</code></li><li>然后Ctrl-O 保存文件，要把文件名里的<code>.tmp</code>删除，两次yes， Ctrl-X退出编辑</li></ol><p><code>sudoers</code>文件目录为<code>/etc/sudoers</code></p><p><code>su</code>进入root, <code>exit</code>退出root</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Debian-install-sudo&quot;&gt;&lt;a href=&quot;#Debian-install-sudo&quot; class=&quot;headerlink&quot; title=&quot;Debian install sudo&quot;&gt;&lt;/a&gt;Debian install sudo&lt;/h1&gt;&lt;ol&gt;

      
    
    </summary>
    
    
      <category term="bug" scheme="https://ricky-ting.github.io/tags/bug/"/>
    
      <category term="solution" scheme="https://ricky-ting.github.io/tags/solution/"/>
    
  </entry>
  
  <entry>
    <title>Daily-Records for 2018-Sept</title>
    <link href="https://ricky-ting.github.io/2018/09/01/Daily-Records-for-2018-Sept/"/>
    <id>https://ricky-ting.github.io/2018/09/01/Daily-Records-for-2018-Sept/</id>
    <published>2018-09-01T14:42:22.000Z</published>
    <updated>2018-10-07T15:10:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Sept-1"><a href="#Sept-1" class="headerlink" title="Sept 1"></a>Sept 1</h1><ul><li>复习汇编</li><li>汇编考试(2:00 pm - 4:00 pm)</li><li>重新搭建Hadoop环境(进度50%),修复了好多bug</li><li><p>装Windows XP 虚拟机(玩了三维弹球)</p><a id="more"></a></li></ul><h1 id="Sept-2"><a href="#Sept-2" class="headerlink" title="Sept 2"></a>Sept 2</h1><ul><li>搭建Hadoop环境完成</li><li>学习java(进度55/689)</li><li>吃火锅</li><li>看big bang(S1E1-S1E3)</li></ul><h1 id="Sept-3-开学第一天"><a href="#Sept-3-开学第一天" class="headerlink" title="Sept 3(开学第一天)"></a>Sept 3(开学第一天)</h1><ul><li>装windows7虚拟机，并安装Quartus，重新做了实验0(数字逻辑电路真好玩 雾)</li><li>学习Verilog(1/13)</li></ul><p><img src="/images/dailyrecordfor2018sept/sept3_1.JPG" alt=""></p><h1 id="Sept-4"><a href="#Sept-4" class="headerlink" title="Sept 4"></a>Sept 4</h1><ul><li>问题求解3-1(7/11)</li></ul><h1 id="Sept-5"><a href="#Sept-5" class="headerlink" title="Sept 5"></a>Sept 5</h1><ul><li>问题求解3-1(11/11)</li><li>PA0(1/5)</li></ul><h1 id="Sept-6"><a href="#Sept-6" class="headerlink" title="Sept 6"></a>Sept 6</h1><ul><li>配置PA环境</li><li>学习使用vim</li></ul><h1 id="Sept-7"><a href="#Sept-7" class="headerlink" title="Sept 7"></a>Sept 7</h1><ul><li>completed Java OJ</li><li>Went to Shanghai </li></ul><h1 id="Sept-8"><a href="#Sept-8" class="headerlink" title="Sept 8"></a>Sept 8</h1><ul><li>Went to Shanghai Natrual History Museum with girlfriend</li><li>Walk along the river with girlfriend</li><li>Went to BBQ with girlfriend</li></ul><h1 id="Sept-9"><a href="#Sept-9" class="headerlink" title="Sept 9"></a>Sept 9</h1><ul><li>Went to Jiangwan Stadium with girlfriend</li><li>Had some dessert.</li><li>Went back to Nanjing</li><li>Completed PA0</li></ul><h1 id="Sept-10"><a href="#Sept-10" class="headerlink" title="Sept 10"></a>Sept 10</h1><ul><li>Completed Linear Algebra Exercise 1</li><li>Completed the cpu_state part of PA1</li><li>Completed exp02 in Digital Logical Circuits</li></ul><h1 id="Sept-11"><a href="#Sept-11" class="headerlink" title="Sept 11"></a>Sept 11</h1><ul><li>Completed PA1 stage1</li><li>Completed University Physics Homework</li></ul><h1 id="Sept-12"><a href="#Sept-12" class="headerlink" title="Sept 12"></a>Sept 12</h1><ul><li>Completed OJ(1/4)</li><li>Learned Java</li></ul><h1 id="Sept-13"><a href="#Sept-13" class="headerlink" title="Sept 13"></a>Sept 13</h1><ul><li>Completed OJ(4/4)</li><li>Completed Linear Algebra (4/4)</li><li>Completed ICS homework</li></ul><h1 id="Sept-14"><a href="#Sept-14" class="headerlink" title="Sept 14"></a>Sept 14</h1><ul><li>Completed Linear Algebra (3/3)</li></ul><h1 id="Sept-15"><a href="#Sept-15" class="headerlink" title="Sept 15"></a>Sept 15</h1><ul><li>Met the research supervisor</li><li>Did some problem solving</li><li>Played with my Hadoop</li></ul><h1 id="Sept-16"><a href="#Sept-16" class="headerlink" title="Sept 16"></a>Sept 16</h1><ul><li>Completed Problem Solving 3-2</li></ul><h1 id="Sept-17"><a href="#Sept-17" class="headerlink" title="Sept 17"></a>Sept 17</h1><h1 id="Sept-18"><a href="#Sept-18" class="headerlink" title="Sept 18"></a>Sept 18</h1><ul><li>Finished 形势与政策 homework</li><li>Did Expr04 of Digital Logical Circuits</li></ul><h1 id="Sept-19"><a href="#Sept-19" class="headerlink" title="Sept 19"></a>Sept 19</h1><ul><li>Completed PA1.2</li><li>Completed Linear Algebra(6/6)</li><li>Completed OJ(3/3)</li></ul><h1 id="Sept-20"><a href="#Sept-20" class="headerlink" title="Sept 20"></a>Sept 20</h1><ul><li>Completed OJ(1/1)</li><li>Completed Problem-Solving 3-3</li><li>Bug-fixing for PA1.2</li></ul><h1 id="Sept-21"><a href="#Sept-21" class="headerlink" title="Sept 21"></a>Sept 21</h1><ul><li>Completed Linear Algebra (3/3)</li></ul><h1 id="Sept-22"><a href="#Sept-22" class="headerlink" title="Sept 22"></a>Sept 22</h1><ul><li>Went downtown with girlfriend</li><li>Had a meal in Nanjing Univer(Xianling Campus) with girlfriend</li><li>Had a tour around the campus with girlfirend</li><li>Had some fruit mixed with yoghurt with girlfriend</li><li>Watched the Europe.Raiders with girlfriend</li></ul><h1 id="Sept-23"><a href="#Sept-23" class="headerlink" title="Sept 23"></a>Sept 23</h1><ul><li>Studied with girlfriend</li><li>Watched The.Little.Prince with girlfriend</li><li>Went to Nanjing University(Gulou Campus) for dinner with girlfriend</li><li>Went to Librairie Avant-Garde (Mount Wutai Branch) with girlfriend and bought a lucky package</li></ul><h1 id="Sept-24"><a href="#Sept-24" class="headerlink" title="Sept 24"></a>Sept 24</h1><ul><li>Went to a cat-featured coffee shop with girlfriend </li><li>Said farewell with girlfriend </li><li>Completed the OO-2 homework(Java)</li></ul><h1 id="Sept-25"><a href="#Sept-25" class="headerlink" title="Sept 25"></a>Sept 25</h1><ul><li>Finished Watchpoint of PA1.3</li></ul><h1 id="Sept-26"><a href="#Sept-26" class="headerlink" title="Sept 26"></a>Sept 26</h1><ul><li>Finished the report of PA1</li><li>Watched several episodes of Big Bang</li><li>Did some reading and learned something about philosophy</li></ul><h1 id="Sept-27"><a href="#Sept-27" class="headerlink" title="Sept 27"></a>Sept 27</h1><ul><li>Did some coding</li></ul><h1 id="Sept-28"><a href="#Sept-28" class="headerlink" title="Sept 28"></a>Sept 28</h1><ul><li>Did some coding</li></ul><h1 id="Sept-29"><a href="#Sept-29" class="headerlink" title="Sept 29"></a>Sept 29</h1><ul><li>Did some coding</li><li>Did some Lab1</li></ul><h1 id="Sept-30"><a href="#Sept-30" class="headerlink" title="Sept 30"></a>Sept 30</h1><ul><li>Completed Linear Algebra(1/1)</li><li>Went home</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Sept-1&quot;&gt;&lt;a href=&quot;#Sept-1&quot; class=&quot;headerlink&quot; title=&quot;Sept 1&quot;&gt;&lt;/a&gt;Sept 1&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;复习汇编&lt;/li&gt;
&lt;li&gt;汇编考试(2:00 pm - 4:00 pm)&lt;/li&gt;
&lt;li&gt;重新搭建Hadoop环境(进度50%),修复了好多bug&lt;/li&gt;
&lt;li&gt;&lt;p&gt;装Windows XP 虚拟机(玩了三维弹球)&lt;/p&gt;
    
    </summary>
    
    
      <category term="记录" scheme="https://ricky-ting.github.io/tags/%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Bug-Fix for hadoop installing</title>
    <link href="https://ricky-ting.github.io/2018/09/01/Bug-Fix-for-hadoop-installing/"/>
    <id>https://ricky-ting.github.io/2018/09/01/Bug-Fix-for-hadoop-installing/</id>
    <published>2018-09-01T14:26:44.000Z</published>
    <updated>2018-09-01T14:39:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>启动守护进程的时候(<code>start-dfs.sh</code>)报错：<code>master: ssh: Could not resolve hostname master: Name or Service not knwon</code>。</p><p>解决方法: 在host文件中添加master解析。</p><p><code>sudo vim /etc/hosts</code></p><p><code>127.0.0.1  master</code></p><p><a href="http://www.powerxing.com/install-hadoop/comment-page-1/" target="_blank" rel="noopener">贴一篇超详细的教程</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;启动守护进程的时候(&lt;code&gt;start-dfs.sh&lt;/code&gt;)报错：&lt;code&gt;master: ssh: Could not resolve hostname master: Name or Service not knwon&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;解决方
      
    
    </summary>
    
    
      <category term="bug" scheme="https://ricky-ting.github.io/tags/bug/"/>
    
  </entry>
  
</feed>
