<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ricky Ting&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/5c8eecd06d08187c73ea49421008f04d</icon>
  <subtitle>当时只道是寻常</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ricky-ting.github.io/"/>
  <updated>2019-01-03T15:03:36.198Z</updated>
  <id>https://ricky-ting.github.io/</id>
  
  <author>
    <name>Ricky-Ting</name>
    <email>1770048119@qq.com dbr1770048119@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何解决项目子模块git冲突</title>
    <link href="https://ricky-ting.github.io/2019/01/03/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E9%A1%B9%E7%9B%AE%E5%AD%90%E6%A8%A1%E5%9D%97git%E5%86%B2%E7%AA%81/"/>
    <id>https://ricky-ting.github.io/2019/01/03/如何解决项目子模块git冲突/</id>
    <published>2019-01-03T15:02:20.000Z</published>
    <updated>2019-01-03T15:03:36.198Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何解决项目子模块git冲突"><a href="#如何解决项目子模块git冲突" class="headerlink" title="如何解决项目子模块git冲突"></a>如何解决项目子模块git冲突</h1><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>在将这学期做的PA提交到github时，因为ics2018中原有git与github上创建的git冲突，因此上传之后ics2018的图标为灰。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ul><li><p>git rm –cache ics2018</p></li><li><p>git add ics2018/</p></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://upupming.site/2018/05/31/git-submodules/#解决方案" target="_blank" rel="noopener">参考链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;如何解决项目子模块git冲突&quot;&gt;&lt;a href=&quot;#如何解决项目子模块git冲突&quot; class=&quot;headerlink&quot; title=&quot;如何解决项目子模块git冲突&quot;&gt;&lt;/a&gt;如何解决项目子模块git冲突&lt;/h1&gt;&lt;h2 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Records for Environment Setup for Spark</title>
    <link href="https://ricky-ting.github.io/2018/11/02/Records-for-Environment-Setup-for-Spark/"/>
    <id>https://ricky-ting.github.io/2018/11/02/Records-for-Environment-Setup-for-Spark/</id>
    <published>2018-11-02T15:29:21.000Z</published>
    <updated>2018-11-02T15:42:07.389Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spark搭建记录-2018-11-2"><a href="#Spark搭建记录-2018-11-2" class="headerlink" title="Spark搭建记录(2018.11.2)"></a>Spark搭建记录(2018.11.2)</h1><p>建立在Hadoop的基础上。</p><p><a href="https://www.cnblogs.com/zyrblog/p/8527048.html" target="_blank" rel="noopener">参考教程</a></p><p>Spark版本：2.1.3.</p><p>在官网上下的直接编译好的文件。</p><p>Spark装之前需要装Scala。我的Scala版本是2.11.6。</p><p>然后解压spark压缩包，修改conf目录下的spark-env.sh(备份到github)。 修改slaves文件。</p><p>注意启动后报错，需要加入JAVA_HOME环境变量，也在spark-env.sh中.</p><h1 id="Spark编译记录"><a href="#Spark编译记录" class="headerlink" title="Spark编译记录"></a>Spark编译记录</h1><p><a href="https://blog.csdn.net/babyhuang/article/details/78656093" target="_blank" rel="noopener">参考教程</a></p><p>在官网下载Spark源码，安装maven(我安装的版本是3.3.9) ，添加maven镜像(已备份)，修改dev目录下的make-distribution.sh文件，将Spark，Hadoop，Scala版本都换为自己的。</p><p>然后用README里的命令编译。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Spark搭建记录-2018-11-2&quot;&gt;&lt;a href=&quot;#Spark搭建记录-2018-11-2&quot; class=&quot;headerlink&quot; title=&quot;Spark搭建记录(2018.11.2)&quot;&gt;&lt;/a&gt;Spark搭建记录(2018.11.2)&lt;/h1&gt;&lt;p&gt;
      
    
    </summary>
    
    
      <category term="记录" scheme="https://ricky-ting.github.io/tags/%E8%AE%B0%E5%BD%95/"/>
    
      <category term="创新项目" scheme="https://ricky-ting.github.io/tags/%E5%88%9B%E6%96%B0%E9%A1%B9%E7%9B%AE/"/>
    
      <category term="大数据" scheme="https://ricky-ting.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>Records for Environment Setup for Hadoop</title>
    <link href="https://ricky-ting.github.io/2018/10/24/Records-for-Environment-Setup-for-Hadoop/"/>
    <id>https://ricky-ting.github.io/2018/10/24/Records-for-Environment-Setup-for-Hadoop/</id>
    <published>2018-10-24T03:20:25.000Z</published>
    <updated>2018-11-02T15:28:24.408Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hadoop环境搭建记录"><a href="#Hadoop环境搭建记录" class="headerlink" title="Hadoop环境搭建记录"></a>Hadoop环境搭建记录</h1><h2 id="安装系统"><a href="#安装系统" class="headerlink" title="安装系统"></a>安装系统</h2><p>安装系统的时候出了很多问题，找不到引导，硬盘被锁啊，感觉不懂的还是很多，最后还是请学长帮忙装好了系统。</p><a id="more"></a><h2 id="Hadoop环境的搭建"><a href="#Hadoop环境的搭建" class="headerlink" title="Hadoop环境的搭建"></a>Hadoop环境的搭建</h2><p>Hadoop版本:2.2.0</p><p><a href="https://blog.csdn.net/fanxin_i/article/details/80425461" target="_blank" rel="noopener">参考教程</a></p><p>教程简版： 1.获取IP，添加解析。2.关闭防火墙 3.安装jdk 4.安装ssh，配置免密通信 5. 安装hadoop，在hdfs目录下创建文件夹(tmp,name,data). 6.修改Hadoop配置文件包括以下几个文件(core-site.xml hadoop-env.sh hdfs-site.xml yarn-env.sh yarn-site.xml slaves).(这些配置文件会备份在github中) 7.用scp将文件夹传到slave上。 然后在master上初始化namenode(hdfs namenode -format)</p><p>我的理解是主要在master里执行namenode初始化就好了，初始化之前最好把master和slave里hdfs目录下删干净(以后可以写个脚本干这个事)。</p><h2 id="写脚本"><a href="#写脚本" class="headerlink" title="写脚本"></a>写脚本</h2><p>写脚本实现只运行MapReduce和在HDFS上运行MapReduce。</p><p>我的理解是只要改改配置文件就好，要运行哪一种方式只要把相应的配置文件拷进去就好。 因为不运行yarn，所以要把yarn的相关配置删除。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env bash</span><br><span class="line"></span><br><span class="line">echo &quot;This is to run mapreduce on hdfs&quot;</span><br><span class="line">rm -rf ~/hadoop-2.2.0/etc/hadoop</span><br><span class="line">echo &quot;Original config files in hadoop-2.2.0/ect/hadoop deleted&quot;</span><br><span class="line">cp -r ~/hadoopconfig/hadoop-distributed ~/hadoop-2.2.0/etc/</span><br><span class="line">echo &quot;Copy config files of hdfs to hadoop-2.2.0/etc/hadoop&quot;</span><br><span class="line">mv ~/hadoop-2.2.0/etc/hadoop-distributed ~/hadoop-2.2.0/etc/hadoop</span><br><span class="line">echo &quot;Rename successfully&quot;</span><br><span class="line">cd ~/hadoop-2.2.0</span><br><span class="line">echo &quot;About to run start-dfs.sh&quot;</span><br><span class="line">start-dfs.sh</span><br><span class="line">echo &quot;About to run an example on hdfs&quot;</span><br><span class="line">hadoop jar /home/hadoop/hadoop-2.2.0/share/hadoop/mapreduce/hadoop-mapreduce-examples-2.2.0.jar pi 10 10</span><br><span class="line">jps</span><br><span class="line">echo &quot;About to run stop-dfs.sh&quot;</span><br><span class="line">stop-dfs.sh</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env bash</span><br><span class="line"></span><br><span class="line">echo &quot;This is to run mapreduce without hdfs&quot;</span><br><span class="line">rm -rf ~/hadoop-2.2.0/etc/hadoop</span><br><span class="line">cp -r ~/hadoopconfig/hadoop-native ~/hadoop-2.2.0/etc/</span><br><span class="line">mv ~/hadoop-2.2.0/etc/hadoop-native ~/hadoop-2.2.0/etc/hadoop</span><br><span class="line">cd ~/hadoop-2.2.0</span><br><span class="line">./bin/hadoop jar ./share/hadoop/mapreduce/hadoop-mapreduce-examples-2.2.0.jar pi 10 10</span><br><span class="line">~</span><br><span class="line">~</span><br><span class="line">~</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Hadoop环境搭建记录&quot;&gt;&lt;a href=&quot;#Hadoop环境搭建记录&quot; class=&quot;headerlink&quot; title=&quot;Hadoop环境搭建记录&quot;&gt;&lt;/a&gt;Hadoop环境搭建记录&lt;/h1&gt;&lt;h2 id=&quot;安装系统&quot;&gt;&lt;a href=&quot;#安装系统&quot; class=&quot;headerlink&quot; title=&quot;安装系统&quot;&gt;&lt;/a&gt;安装系统&lt;/h2&gt;&lt;p&gt;安装系统的时候出了很多问题，找不到引导，硬盘被锁啊，感觉不懂的还是很多，最后还是请学长帮忙装好了系统。&lt;/p&gt;
    
    </summary>
    
    
      <category term="记录" scheme="https://ricky-ting.github.io/tags/%E8%AE%B0%E5%BD%95/"/>
    
      <category term="创新项目" scheme="https://ricky-ting.github.io/tags/%E5%88%9B%E6%96%B0%E9%A1%B9%E7%9B%AE/"/>
    
      <category term="大数据" scheme="https://ricky-ting.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>How to make an installation USB for Linux or other OS in Mac OS X</title>
    <link href="https://ricky-ting.github.io/2018/10/17/How-to-make-an-installation-USB-for-Linux-or-other-OS-in-Mac-OS-X/"/>
    <id>https://ricky-ting.github.io/2018/10/17/How-to-make-an-installation-USB-for-Linux-or-other-OS-in-Mac-OS-X/</id>
    <published>2018-10-17T12:55:11.000Z</published>
    <updated>2018-10-17T12:55:47.121Z</updated>
    
    <content type="html"><![CDATA[<h1 id="How-to-make-an-installation-USB-for-Linux-or-other-OS-in-Mac-OS-X"><a href="#How-to-make-an-installation-USB-for-Linux-or-other-OS-in-Mac-OS-X" class="headerlink" title="How to make an installation USB for Linux or other OS in Mac OS X"></a>How to make an installation USB for Linux or other OS in Mac OS X</h1><p>Step1: Download the image(iso) file from the Internet.</p><p>Step2: Open a Terminal(the following command are all completed in a terminal)</p><a id="more"></a><p>Step3: Trun <code>.iso</code> file into <code>.img</code> file by <code>hdiutil convert -format UDRW -o ~/path/to/target.img ~/path/from/src.iso</code>(The file created may end with <code>.dmg</code>)</p><p>Step4: <code>diskutil list</code> to obtain the devices mounted.</p><p>Step5: Insert your USB.</p><p>Step6: <code>diskutil list</code> to see which is added(/dev/diskN).</p><p>Step7: <code>diskutil unmountDisk /dev/diskN</code> to unmount USB</p><p>Step8: <code>sudo dd if=/path/to/target.img of=/dev/rdiskN bs=1m</code> to write the installation file into the USB</p><p>Step9: <code>diskutil eject /dev/diskN</code> to eject your USB.</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;How-to-make-an-installation-USB-for-Linux-or-other-OS-in-Mac-OS-X&quot;&gt;&lt;a href=&quot;#How-to-make-an-installation-USB-for-Linux-or-other-OS-in-Mac-OS-X&quot; class=&quot;headerlink&quot; title=&quot;How to make an installation USB for Linux or other OS in Mac OS X&quot;&gt;&lt;/a&gt;How to make an installation USB for Linux or other OS in Mac OS X&lt;/h1&gt;&lt;p&gt;Step1: Download the image(iso) file from the Internet.&lt;/p&gt;
&lt;p&gt;Step2: Open a Terminal(the following command are all completed in a terminal)&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Summary of definitions and theorems in graph theory</title>
    <link href="https://ricky-ting.github.io/2018/10/15/Summary-of-definitions-and-theorems-in-graph-theory/"/>
    <id>https://ricky-ting.github.io/2018/10/15/Summary-of-definitions-and-theorems-in-graph-theory/</id>
    <published>2018-10-15T14:06:07.000Z</published>
    <updated>2019-01-06T06:18:52.845Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Summary-of-definitions-and-theorems-in-graph-theory"><a href="#Summary-of-definitions-and-theorems-in-graph-theory" class="headerlink" title="Summary of definitions and theorems in graph theory"></a>Summary of definitions and theorems in graph theory</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><h3 id="1-1-Graphs-and-Graph-Models"><a href="#1-1-Graphs-and-Graph-Models" class="headerlink" title="1.1 Graphs and Graph Models"></a>1.1 Graphs and Graph Models</h3><p>A <strong>Graph</strong> G consists of a finite nonempty set $V$ of objects called <strong>vertices</strong> and a set $E$ of 2-element subsets of $V$ called <strong>edges</strong>. The ses $V$ and $E$ are the <strong>vertex set</strong> and <strong>edge set</strong> of $G$, respectively. Write $G=(V,E)$.</p><p>Two graphs $G$ and $H$ are <strong>equal</strong> if $V(G)=V(H)$ and $E(G)=E(H)$, in which case we write $G=H$.</p><p>If $uv$ is an edge of $G$, then $u$ and $v$ are said to be <strong>adjacent</strong> in $G$.</p><p>The number of vertices in $G$ is often called the <strong>order</strong> of $G$, while the number of edges is its <strong>size</strong>.</p><p>A graph with exactly one vertex is called a <strong>trivial graph</strong>, implying that the order of a <strong>nontrivial graph</strong> is at least 2.</p><p><strong>labeled graph</strong> and <strong>unlabeled graph</strong></p><p>A graph $G$ is called a <strong>word graph</strong> if $G$ is the word graph of some set $S$ of 3-letter words.</p><h3 id="1-2-Connected-Graphs"><a href="#1-2-Connected-Graphs" class="headerlink" title="1.2 Connected Graphs"></a>1.2 Connected Graphs</h3><p>The adjacent vertices $u$ and $v$ are said to be <strong>joined</strong> by the edge $e$. The vertices $u$ and $v$ are referred to as <strong>neighbors</strong> of each other. </p><p>Distinct edges incident with a common vertex are <strong>adjacent edges</strong>.</p><p>A graph $H$ is called a <strong>subgraph</strong> of a graph $G$, written $H \subseteq G$, if $V(H) \subseteq V(G)$ and $E(H) \subseteq E(G)$. We also say that $G$ contains $H$ as a subgraph. If $H \subseteq G$ and either $V(H)$ is a proper subset of $V(G)$ or $E(H)$ is a proper subset of $E(G)$, then $H$ is a <strong>proper subgraph</strong> of $G$. If a subgraph of a graph $G$ has the same vertex set as $G$, then it is a <strong>spanning subgraph</strong> of $G$.</p><p>A subgraph $F$ of a graph $G$ is called an <strong>induced subgraph</strong> of $G$ if whenever $u$ and $v$ are vertices of $F$ and $uv$ is an edge of $G$, then $uv$ is an edge of $F$ as well.</p><p>If $S$ is a nonempty set of vertices of a graph $G$, then the <strong>subgraph</strong> of $G$ <strong>induced by</strong> $S$ is the induced subgraph with vertex set $S$. This induced subgraph is denoted by $G[S]$.</p><p>For a nonempty set $X$ of edges, the <strong>subgraph G[X] induced by</strong> $X$ has edge set $X$ and consists of all vertices that are incident with at least one edge in $X$. This subgraph is called an <strong>edge-induced subgraph</strong> of $G$.   </p><p>A $u-v$ <strong>walk</strong> $W$ in $G$ is a sequence of vertices in $G$, beginning with $u$ and ending at $v$ such that consecutives vertices in the sequence are adjacent. If $u=v$, then the walk $W$ is <strong>closed</strong>; while if $u\not=v$, then $W$ is <strong>open</strong>. A walk of length 0 is a <strong>trivial walk</strong>.</p><p>We define a $u-v$ <strong>trial</strong> in a graph $G$ to be a $u-v$ walk in which no edges is traversed more than once.</p><p>A $u-v$ walk in a graph in which no vertices are repeated is a $u-v$ <strong>path</strong>. </p><p>A <strong>circuit</strong> in a graph $G$ is a closed trail of length 3 or more. Hence a circuit begins and ends at the same vertex but repeats no edges.</p><p>A circuit that repeats no vertex, except for the first and last, is a <strong>cycle</strong>.</p><p>If $G$ contains a $u-v$ path, then $u$ and $v$ are said to be <strong>connected</strong> and $u$ is <strong>connected to</strong> $v$.</p><p>A graph $G$ is <strong>connected</strong> if every two vertices of $G$ are connected. A graph that is not connected is called <strong>disconnected</strong>. A connected subgraph of $G$ that is not a proper subgraph of any other connected subgraph of $G$ is a <strong>component</strong> of $G$. The number of components of a graph $G$ is denoted by $k(G)$. Every graph is the union of its components.</p><p>The <strong>distance</strong> between $u$ and $v$ is the smallest length of any $u-v$ path in $G$ and is denoted by $d_{G}(u,v)$ or simply $d(u,v)$. A $u-v$ path of length $d(u,v)$ is called a $u-v$ <strong>geodesic</strong>.</p><p>The greatest distance between any two vertices of a connected graph $G$ is called the <strong>diameter</strong> of $G$ and is denoted by $diam(G)$.</p><p><strong>Theorem 1.10</strong> Let $G$ be a graph of order 3 or more. Then $G$  is connected if and only if $G$ contains two distinct vertices $u$  and $v$  such that $G-u$ and $G-v$ are connected.</p><h3 id="1-3-Common-Classes-of-Graphs"><a href="#1-3-Common-Classes-of-Graphs" class="headerlink" title="1.3 Common Classes of Graphs"></a>1.3 Common Classes of Graphs</h3><p>$G$ is called a <strong>path</strong> if …</p><p>$G$ is called a <strong>cycle</strong> if …</p><p>A graph $G$ is <strong>complete</strong> if every two distinct vertices of $G$ are adjacent. A complete graph of order $n$ is denoted by $K_n$.</p><p>The <strong>complement</strong> $\bar{G}$ of a graph $G$ is that graph whose vertex set is $V(G)$ and such that for each pair $u,v$ of distinct vertices of $G$, $uv$ is an edge of $\bar{G}$ if and only if $uv$ is not an edge of $G$.</p><p>The graph $\bar{K_n}$ has $n$ vertices and no edges, it is called the <strong>empty graph</strong> of order $n$.</p><p><strong>Theorem 1.11</strong> If $G$  is a disconnected graph, then $\bar{G}$ is connected.</p><p><strong>Theorem 1.12</strong> A nontrivial graph $G$ is a bipartite graph if and only if $G$ contains no odd cycles.</p><p>A graph $G$ is a <strong>bipartite graph</strong> if $V(G)$ can be partitioned into two subsets $U$ and $W$, called <strong>partite sets</strong>, such that every edge of $G$ joins a vertex of $U$ and a vertex of $W$.</p><p>If every vertex of $U$  is adjacent to every vertex of $W$ , then we call $G$  a <strong>complete bipartite graph</strong> . A complete graph with $|U|=s$  and $|W|=t$ is denoted by $K<em>{s,t}$ or $K</em>{t,s}$. If either $s=1$ or $t=1$, then $K_{s,t}$ is a <strong>star</strong>.</p><p>A graph $G$  is a $k$<strong>-partite graph</strong> if $V(G)$ can be partitioned into $k$ subsets $V_1$,$V_2$,…,$V_k$,(called <strong>partite sets</strong>) such that if $uv$ is an edge of $G$, then $u$ and $v$ belong to different partite sets. If, in addition, every  two vertices in different partite sets are joined by an edge, then $G$ is a <strong>complete k-partite graph</strong>. If $|V_i|=n<em>i$ for $1 \le i \le k$, then we denote this graph by $K</em>{n1,n2,…,nk}$. </p><p>The <strong>join</strong> $G+H$ consists of $G \cup H$ and all edges joining a vertex of $G$ and a vertex of $H$.</p><p>The <strong>Cartesian product</strong> $G \times H$ has vertex set $V(G \times H) = V(G) \times V(H)$ . Two distinct vertices $(u,v$) and $(x,y)$ are adjacent in $G \times H$ if either (1) $u=x$ and $vy\in E(H)$ or (2) $v=y$ and $ux\in E(G)$.</p><p>We define $Q_1$ to be $K_2$ and for $n \ge 2$, define $Q<em>n$ to be $Q</em>{n-1} \times K_2$. The graphs $Q_n$ are then called $n$<strong>-cubes</strong> or <strong>hypercubes</strong>.</p><h3 id="1-4-Multigraphs-and-Digraphs"><a href="#1-4-Multigraphs-and-Digraphs" class="headerlink" title="1.4 Multigraphs and Digraphs"></a>1.4 Multigraphs and Digraphs</h3><p>A <strong>multigraph</strong> $M$ consists of a finite nonempty set $V$ of vertices and a set $E$ of edges, where every two vertices of M are joined by a finite number of edges(possibly zero). If two or more edges join the same pair of (distinct) vertices, then these edges are called <strong>parallel</strong> edges.</p><p>In a <strong>pseudograph</strong>, not only are parallel edges permitted but an edge is also permitted to join a vertex to itself. Such an edge is called a <strong>loop</strong>.</p><p>A <strong>digraph</strong>(or <strong>directed graph</strong>) $D$ is a finite nonempty set $V$ of objects called <strong>vertices</strong> together with a set $E$ of ordered pairs of distinct vertices. The elements of $E$ are called <strong>directed edges</strong> or <strong>arcs</strong>. If $(u,v)$ is a directed edge, then we indicate this in a diagram representing $D$ by drawing a directed line segment or curve from $u$ to $v$. Then u is said to be <strong>adjacent to</strong> v and v is <strong>adjacent from</strong> u.</p><p>If, in the definition of digraph, for each pair $u,v$ of distinct vertices, at most one of $(u,v)$ and $(v,u)$ is a directed edge, then the resulting digraph is an <strong>oriented graph</strong>  </p><h2 id="Degrees"><a href="#Degrees" class="headerlink" title="Degrees"></a>Degrees</h2><h3 id="2-1-The-Degree-of-a-Vertex"><a href="#2-1-The-Degree-of-a-Vertex" class="headerlink" title="2.1 The Degree of a Vertex"></a>2.1 The Degree of a Vertex</h3><p>The <strong>degree of a vertex</strong> $v$ in a graph $G$ is the number of edges incident with $v$ and is denoted by $deg_G \ v$ or simply by $deg \ v$ if the graph $G$ is clear from the context.  The set $N(v)$ of neighbors of a vertex $v$  is called the <strong>neighborhood</strong> of $v$. Thus $deg \ v = |N(v)|$.</p><p>A vertex of degree 0 is referred to as an <strong>isolated vertex</strong> and a vertex of degree 1 is an <strong>end-vertex</strong>(or a <strong>leaf</strong>). </p><p>The <strong>minimum degree</strong> of $G$  is the minimum degree among the vertices of $G$ and is denoted by $\delta(G)$, the <strong>maximum degree</strong> of $G$ is denoted by $\Delta(G)$.</p><p>For $G$ of order $n$, we have $0 \le \delta(G) \le deg \ v \le \Delta(G) \le n-1$.</p><p><strong>Theorem 2.1(The First Theorem of Graph Theory)</strong>  If $G$  is a graph of size $m$, then $\sum \limits_{v\in V(G)} deg \ v =2m$.</p><p>A vertex of even degree is called an <strong>even vertex</strong>, while a vertex of odd degree is an <strong>odd vertex</strong>.</p><p><strong>Corollary 2.3</strong> Every graph has an even number of odd vertices.</p><p>If a graph $G$ order $n$ contains a vertex of degree $n-1$, then $G$ is connected. However, this is not a necessary condition.</p><p><strong>Theorem 2.4</strong> Let $G$ be a graph of order $n$. If $deg \ u + deg \ v \ge n-1$, for every two nonadjacent vertices $u$ and $v$ of $G$ , then $G$ is connected and $diam(G) \le 2$.</p><ul><li>The bound of <strong>Theorem 2.4</strong> is sharp.</li></ul><p><strong>What if there is only one pair?</strong></p><p><strong>Corollary 2.5</strong> If $G$  is a graph of order $n$ with $\delta(G) \ge (n-1)/2$, then $G$ is connected.</p><p><strong>outdegree</strong> and <strong>indegree</strong>.</p><h3 id="2-2-Regular-Graphs"><a href="#2-2-Regular-Graphs" class="headerlink" title="2.2 Regular Graphs"></a>2.2 Regular Graphs</h3><p>If $\delta(G)=\Delta(G)$, then the vertices of $G$  have the same degree and $G$  is called <strong>regular</strong>. If $deg \ r=r$ for every vertex $v$  of $G$, where $0 \le r \le n-1$, then $G$  is $r$ <strong>-regular</strong> or <strong>regular of degree r</strong>.</p><p>A 3-regular graph is also referred to as a <strong>cubic graph</strong>. The best known cubic graph may very well be the <strong>Petersen graph</strong>.</p><p>There are no r-regular graphs of order $n$ if $r$ and $n$  are both odd.</p><h2 id="Trees"><a href="#Trees" class="headerlink" title="Trees"></a>Trees</h2><h3 id="4-1-Bridges"><a href="#4-1-Bridges" class="headerlink" title="4.1 Bridges"></a>4.1 Bridges</h3><p>An edge $e=uv$ of a connected graph $G$ is called a <strong>bridge</strong> of $G$ if $G-e$ is disconnected.</p><a id="more"></a><p>An edge $e$ is a <strong>bridge</strong> of a disconnected graph if $e$ is a bridge of some component of $G$.</p><p>An edge $e$ is a bridge of a graph $G$ if and only if $k(G-e)=k(G)+1$</p><p>End-vertice: vertice with degree $1$.</p><p><strong>Theorem 4.1</strong>: <em>An edge $e$ of a graph $G$ is a bridge if and only if $e$ lies on no cycle of $G$</em> </p><h3 id="4-2-Trees"><a href="#4-2-Trees" class="headerlink" title="4.2 Trees"></a>4.2 Trees</h3><p>A graph G is called <strong>acyclic</strong> if it has no cycles.</p><p>A <strong>tree</strong> is an acyclic connected graph.</p><p>Every edge in a tree is a bridge.</p><p>A tree containing exactly two vertices that are not end-vertices(which are necessarily adjacent) is called a <strong>double star</strong>.</p><p>A <strong>caterpillar</strong> is a tree of order 3 or more, the removal of whose end-vertices produces a path called <strong>spine</strong> of the caterpillar.</p><p>Choose a vertex of a tree $T$, and designate this vertex as the <strong>root</strong> of $T$. The tree $T$ then becomes a <strong>rooted tree</strong>. </p><p>Acyclic graphs are also referred to as <em>forests*</em>. Therefore each component of a forest is a tree.</p><p>The one fact that distinguishes trees from forests is that a tree is required to be connected, while a forest is not required to be connected.</p><p><strong>Theorem 4.2</strong> <em>A graph $G$ is a tree if and only if every two vertices of G are connected by a unique path</em>.</p><p><strong>Theorem 4.3</strong> <em>Every nontrivial tree has at least two end-vertices</em>.</p><p><strong>Theorem 4.4</strong> <em>Every tree of order n has size $n-1$</em></p><p><strong>Corollary 4.6</strong> <em>Every forest of order n with k components has size $n-k$</em></p><p><strong>Theorem 4.7</strong> <em>The size of every connected graph of order $n$ is at least $n-1$</em>.</p><p><strong>Theorem 4.8</strong> <em>Let $G$ be a graph of order $n$ and size $m$. If $G$ satisfies any two of the properties: (1) $G$ is connected, (2)$G$ is acyclic, (3)$m=n-1$, then $G$ is a tree.</em></p><p><strong>Theorem 4.9</strong> <em>Let $T$ be a tree of order $k$. If $G$ is a graph with $\delta(G) \ge k-1$, then $T$ is isomorphic to some subgraph of $G$</em></p><h3 id="4-3-The-Minimum-Spanning-Tree-Problem"><a href="#4-3-The-Minimum-Spanning-Tree-Problem" class="headerlink" title="4.3 The Minimum Spanning Tree Problem"></a>4.3 The Minimum Spanning Tree Problem</h3><p>A spanning subgraph $H$ of a connected graph $G$ such that $H$ is a tree is called a <strong>spanning tree</strong> of $G$.</p><p><strong>Theorem 4.10</strong> <em>Every connected graph contains a spanning tree</em>.</p><p>The <strong>weight</strong> $w(H)$ of $H$ is defined as the sum of the weights of its edges.</p><p>A spanning tree with the minimum weight is called a <strong>minimum spanning tree</strong>.</p><p>The problem of finding a minimum spanning tree in a connected weighted graph is called the <strong>Minimum Spanning Tree Problem</strong>. </p><p><strong>Kruskal’s Algorithm</strong>: For a connected weighted graph $G$, a spanning tree $T$ of $G$ is constructed as follows: For the first edge $e_1$ of $T$, we select any edge of $G$ of minimum weight and for the second edge $e_2$ of $T$, we select any remaining edge of $G$ of minimum weight. For the thrid edge $e_3$ of T, we choose any remaining edge of $G$ of minimum weight that does not produce a cycle with the previously selected edges. We continue in the manner until a spanning tree is produced.</p><p><strong>Theorem 4.11</strong> <em>Kruskal’s Algorithm produces a minimum spanning tree in a connected weighted graph</em>.</p><p><strong>Prim’s Algorithm</strong>: For a connected weighted graph $G$, a spanning tree $T$ of $G$ is constructed as follows: For an arbitrary vertex $u$ for $G$, an edge of minimum weight incident with $u$ is selected as the first edge $e_1$ of $T$. For subsequent edges $e_2$, $e<em>3$, ..,$e</em>{n-1}$, we select an edge of minimum weight among those edges having exactly one of its vertices incident with an edge already selected.</p><p><strong>Theorem 4.12</strong> <em>Prim’s Algorithm produces a minimum spanning tree in a connected weighted graph.</em></p><h3 id="4-4-Excursion-The-Number-of-Spanning-Trees"><a href="#4-4-Excursion-The-Number-of-Spanning-Trees" class="headerlink" title="4.4 Excursion: The Number of Spanning Trees"></a>4.4 Excursion: The Number of Spanning Trees</h3><p><strong>THeorem 4.15</strong> <em>The number of distinct trees of order n with a specified vertex set is $n^{n-2}$</em>.</p><p><strong>Matrix Tree Theorem</strong></p><h2 id="Traversability"><a href="#Traversability" class="headerlink" title="Traversability"></a>Traversability</h2><h3 id="6-1-Eulerian-Graphs"><a href="#6-1-Eulerian-Graphs" class="headerlink" title="6.1 Eulerian Graphs"></a>6.1 Eulerian Graphs</h3><p>A circuit $C$ in a graph $G$ is called an <strong>Eulerian circuit</strong> if $C$ contains every edge of $G$. Since no edges is repeated in a circuit, every edge appears exactly once in an Eulerian circuit. A connected graph that contains an Eulerian circuit is called an <strong>Eulerian graph</strong>.</p><p>For a connected graph $G$, we refer to an open trial that contains every edge of $G$ as an <strong>Eulerian trial</strong>.</p><h3 id="6-2-Hamiltonian-Graphs"><a href="#6-2-Hamiltonian-Graphs" class="headerlink" title="6.2 Hamiltonian Graphs"></a>6.2 Hamiltonian Graphs</h3><p>A cycle in a graph $G$ that contains every vertex of $G$ is called a <strong>Hamiltonian cycle</strong> of $G$. A <strong>Hamiltonian graph</strong> is a graph that contains a Hamiltonian cycle.</p><p>A path in a graph $G$ that contains every vertex of $G$ is called a <strong>Hamiltonian path</strong> in $G$.</p><h2 id="Matchings-and-Factorization"><a href="#Matchings-and-Factorization" class="headerlink" title="Matchings and Factorization"></a>Matchings and Factorization</h2><h3 id="8-1-Matchings"><a href="#8-1-Matchings" class="headerlink" title="8.1 Matchings"></a>8.1 Matchings</h3><p>A set of edges in a graph is <strong>independent</strong> if no two edges in the set are adjacent.</p><p>By a <strong>macthing</strong> in a graph $G$ , we mean an independent set of edges in $G$.</p><p>The graph $G$ is said to satisfy <strong>Hall’s condition</strong> if $|N(X)\ge|X||$ for every nonempty subset $X$ of $U$.</p><p>A matching of maximum cardinality is called a <strong>maximum matching</strong>.  </p><p>If a graph $G$ of order $2k$ has a matching $M$ of cardinality $k$, then this (necessarily maximum)  matching $M$ is called a <strong>perfect matching</strong> as $M$ matches every vertex of $G$ to some vertex of $G$ .</p><p>The <strong>edge independence number</strong> $\alpha’(G)$ of a graph $G$  is the maximum cardinality of an independent set of edges.</p><p>A vertex and an incident edge are said to <strong>cover</strong> each other.</p><p>An <strong>edge cover</strong> of a graph $G$ without isolated vertices is a set of edges of $G$ that covers all vertices of $G$.</p><p>The <strong>edge covering number</strong> $\beta’(G)$ of a graph $G$ is the minimum cardlinality of an edge cover of $G$.  An edge cover of $G$ of cardinality $\beta’(G)$ is a <strong>minimum edge cover</strong> of $G$.</p><p>A set of vertices in a graph is <strong>independent</strong> if  no two vertices in the set are adjacent. The <strong>vertex independence number</strong> (or the <strong>independence number</strong>) $\alpha(G)$ of a graph $G$ is the maximum cardinality of an independent set of vertices in $G$. An independent set in $G$ of cardinality $\alpha(G)$ is called a <strong>maximum independent set</strong>. </p><p>A <strong>vertex cover</strong> in a graph $G$ is a set of vertices that covers all edges of $G$. The minimum number of vertices in a vertex cover of $G$  is the <strong>vertex covering number</strong> $\beta(G)$  of $G$. A vertex cover of cardinality $\beta(G)$ is a <strong>minimum vertex cover</strong> in $G$.</p><h3 id="8-2-Factorization"><a href="#8-2-Factorization" class="headerlink" title="8.2 Factorization"></a>8.2 Factorization</h3><p>A 1-regular spanning subgraph of a graph $G$ is also called a <strong>1-factor</strong> of $G$. A graph $G$ has a 1-factor if and only if $G$ has a perfect matching.</p><p>A graph $G$ is said to be <strong>1-factorable</strong> if there exists 1-factors $F_1,F_2,…,F_r$ of $G$ such that ${E(F_1),E(F_2),..,E(F_r)}$ is a partition of $E(G)$.  We then say that $G$ is <strong>factored</strong> into the 1-factors $F_1.F_2,…,F_r$ , which form a <strong>1-factorization</strong> of $G$.</p><p>A <strong>2-factor</strong> in a graph $G$ is a spanning 2-regular subgraph of $G$. Every component of a 2-factor is therefore a cycle. A graph $G$ is said to be <strong>2-factorable</strong> if there exist 2-factors $F_1,F_2,..,F_k$ such that ${E(F_1),E(F_2),…,E(F_k)}$ is a partition of $E(G)$.</p><p>A spanning subgraph $F$ of a graph $G$ is called a <strong>factor</strong> of $G$. The graph $G$ is said to be <strong>factorable</strong> into the factors $F_1,F_2,…,F_k$ if ${E(F_1),E(F_2),…,E(F_k)}$ is a partition of $E(G)$. If each factor $F_i$ is isomorphic to some graph $G$, then $G$ is <strong>F-factorable</strong>.</p><h3 id="8-3-Decompositions-and-Graceful-Labelings"><a href="#8-3-Decompositions-and-Graceful-Labelings" class="headerlink" title="8.3 Decompositions and Graceful Labelings"></a>8.3 Decompositions and Graceful Labelings</h3><p>A graph $G$ is said to be <strong>decomposable</strong> into the subgraphs $H_1,H_2,…,H_k$ if ${E(H_1),E(H_2),…,E(H_k)}$ is a partition of $E(G)$. Such a partition produces a <strong>decomposition</strong> of $G$.  If each $H_i$ is isomorphic to some graph $H$, then the graph $G$ is $H-$ <strong>decomposable</strong>  and the decomposition is an $H-$ <strong>decomposition</strong>. </p><p>A <strong>Steiner triple system</strong> of order $n$ is a set $S$ of cardinality $n$ and a collection $T$ of 3-element subsets, called <strong>triples</strong>, such that every two distinct elements of $S$ belong to a unique triple in $T$.</p><h2 id="Planarity"><a href="#Planarity" class="headerlink" title="Planarity"></a>Planarity</h2><h3 id="9-1-Planar-Graphs"><a href="#9-1-Planar-Graphs" class="headerlink" title="9.1 Planar Graphs"></a>9.1 Planar Graphs</h3><p>A graph $G$  is called a <strong>planar graph</strong> if $G$  can be drawn in the plane so that no two of its edges cross each other. A graph that is not planar is called <strong>nonplanar</strong>. A graph $G$ is called a <strong>plane graph</strong>  if it is drawn in the plane so that no two edges of $G$ cross. </p><p>A plane graph divides the plane into connected pieces called <strong>regions</strong>. In every plane graph, there is always one region that is unbounded. This is the <strong>exterior region</strong>.  The subgraph of a plane graph whose vertices and edges are incident with a given region $R$  is the <strong>boundary</strong> of $R$. </p><p>A graph $G$ is <strong>maximal planar</strong> if $G$ is planar but the addition of an edge between any two nonadjacent vertices of $G$  results in a nonplanar graph.</p><h2 id="Coloring-Graphs"><a href="#Coloring-Graphs" class="headerlink" title="Coloring Graphs"></a>Coloring Graphs</h2><h3 id="10-2-Vertex-Coloring"><a href="#10-2-Vertex-Coloring" class="headerlink" title="10.2 Vertex Coloring"></a>10.2 Vertex Coloring</h3><p>With each map, there is associated a graph $G$  called the  <strong>dual</strong> of the map, whose vertices are the regions of the map and such that two vertices of $G$  are adjacent if the corresponding regions are neighboring regions.</p><p>By a <strong>proper coloring</strong> (or, more simply, a <strong>coloring</strong>)  of a graph $G$  ,  we mean an assignment of colors (elements of some set) to the vertices of $G$ , one color to each vertex, such that adjacent vertices are colored differently.  </p><p>The smallest number of colors in any coloring of a graph $G$  is called the <strong>chromatic number</strong>  of $G$  and is denoted by $\chi(G)$.  If it is possible to color $G$ from a set of $k$  colors, then $G$  is said to be <strong>k-colorable</strong>. A coloring that uses $k$ colors is called a <strong>k-coloring</strong>. If $\chi(G)=k$, then $G$ is said to be <strong>k-chromatic</strong> and every $k-coloring$ of $G$ is a <strong>minimum coloring</strong> of $G$. </p><p>Reference:</p><p>[1] G.Chartrand and P.Zhang, First Course in Graph Theory, New York: Dover Publications, 2012.</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Summary-of-definitions-and-theorems-in-graph-theory&quot;&gt;&lt;a href=&quot;#Summary-of-definitions-and-theorems-in-graph-theory&quot; class=&quot;headerlink&quot; title=&quot;Summary of definitions and theorems in graph theory&quot;&gt;&lt;/a&gt;Summary of definitions and theorems in graph theory&lt;/h1&gt;&lt;h2 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h2&gt;&lt;h3 id=&quot;1-1-Graphs-and-Graph-Models&quot;&gt;&lt;a href=&quot;#1-1-Graphs-and-Graph-Models&quot; class=&quot;headerlink&quot; title=&quot;1.1 Graphs and Graph Models&quot;&gt;&lt;/a&gt;1.1 Graphs and Graph Models&lt;/h3&gt;&lt;p&gt;A &lt;strong&gt;Graph&lt;/strong&gt; G consists of a finite nonempty set $V$ of objects called &lt;strong&gt;vertices&lt;/strong&gt; and a set $E$ of 2-element subsets of $V$ called &lt;strong&gt;edges&lt;/strong&gt;. The ses $V$ and $E$ are the &lt;strong&gt;vertex set&lt;/strong&gt; and &lt;strong&gt;edge set&lt;/strong&gt; of $G$, respectively. Write $G=(V,E)$.&lt;/p&gt;
&lt;p&gt;Two graphs $G$ and $H$ are &lt;strong&gt;equal&lt;/strong&gt; if $V(G)=V(H)$ and $E(G)=E(H)$, in which case we write $G=H$.&lt;/p&gt;
&lt;p&gt;If $uv$ is an edge of $G$, then $u$ and $v$ are said to be &lt;strong&gt;adjacent&lt;/strong&gt; in $G$.&lt;/p&gt;
&lt;p&gt;The number of vertices in $G$ is often called the &lt;strong&gt;order&lt;/strong&gt; of $G$, while the number of edges is its &lt;strong&gt;size&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;A graph with exactly one vertex is called a &lt;strong&gt;trivial graph&lt;/strong&gt;, implying that the order of a &lt;strong&gt;nontrivial graph&lt;/strong&gt; is at least 2.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;labeled graph&lt;/strong&gt; and &lt;strong&gt;unlabeled graph&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A graph $G$ is called a &lt;strong&gt;word graph&lt;/strong&gt; if $G$ is the word graph of some set $S$ of 3-letter words.&lt;/p&gt;
&lt;h3 id=&quot;1-2-Connected-Graphs&quot;&gt;&lt;a href=&quot;#1-2-Connected-Graphs&quot; class=&quot;headerlink&quot; title=&quot;1.2 Connected Graphs&quot;&gt;&lt;/a&gt;1.2 Connected Graphs&lt;/h3&gt;&lt;p&gt;The adjacent vertices $u$ and $v$ are said to be &lt;strong&gt;joined&lt;/strong&gt; by the edge $e$. The vertices $u$ and $v$ are referred to as &lt;strong&gt;neighbors&lt;/strong&gt; of each other. &lt;/p&gt;
&lt;p&gt;Distinct edges incident with a common vertex are &lt;strong&gt;adjacent edges&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;A graph $H$ is called a &lt;strong&gt;subgraph&lt;/strong&gt; of a graph $G$, written $H \subseteq G$, if $V(H) \subseteq V(G)$ and $E(H) \subseteq E(G)$. We also say that $G$ contains $H$ as a subgraph. If $H \subseteq G$ and either $V(H)$ is a proper subset of $V(G)$ or $E(H)$ is a proper subset of $E(G)$, then $H$ is a &lt;strong&gt;proper subgraph&lt;/strong&gt; of $G$. If a subgraph of a graph $G$ has the same vertex set as $G$, then it is a &lt;strong&gt;spanning subgraph&lt;/strong&gt; of $G$.&lt;/p&gt;
&lt;p&gt;A subgraph $F$ of a graph $G$ is called an &lt;strong&gt;induced subgraph&lt;/strong&gt; of $G$ if whenever $u$ and $v$ are vertices of $F$ and $uv$ is an edge of $G$, then $uv$ is an edge of $F$ as well.&lt;/p&gt;
&lt;p&gt;If $S$ is a nonempty set of vertices of a graph $G$, then the &lt;strong&gt;subgraph&lt;/strong&gt; of $G$ &lt;strong&gt;induced by&lt;/strong&gt; $S$ is the induced subgraph with vertex set $S$. This induced subgraph is denoted by $G[S]$.&lt;/p&gt;
&lt;p&gt;For a nonempty set $X$ of edges, the &lt;strong&gt;subgraph G[X] induced by&lt;/strong&gt; $X$ has edge set $X$ and consists of all vertices that are incident with at least one edge in $X$. This subgraph is called an &lt;strong&gt;edge-induced subgraph&lt;/strong&gt; of $G$.   &lt;/p&gt;
&lt;p&gt;A $u-v$ &lt;strong&gt;walk&lt;/strong&gt; $W$ in $G$ is a sequence of vertices in $G$, beginning with $u$ and ending at $v$ such that consecutives vertices in the sequence are adjacent. If $u=v$, then the walk $W$ is &lt;strong&gt;closed&lt;/strong&gt;; while if $u\not=v$, then $W$ is &lt;strong&gt;open&lt;/strong&gt;. A walk of length 0 is a &lt;strong&gt;trivial walk&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;We define a $u-v$ &lt;strong&gt;trial&lt;/strong&gt; in a graph $G$ to be a $u-v$ walk in which no edges is traversed more than once.&lt;/p&gt;
&lt;p&gt;A $u-v$ walk in a graph in which no vertices are repeated is a $u-v$ &lt;strong&gt;path&lt;/strong&gt;. &lt;/p&gt;
&lt;p&gt;A &lt;strong&gt;circuit&lt;/strong&gt; in a graph $G$ is a closed trail of length 3 or more. Hence a circuit begins and ends at the same vertex but repeats no edges.&lt;/p&gt;
&lt;p&gt;A circuit that repeats no vertex, except for the first and last, is a &lt;strong&gt;cycle&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;If $G$ contains a $u-v$ path, then $u$ and $v$ are said to be &lt;strong&gt;connected&lt;/strong&gt; and $u$ is &lt;strong&gt;connected to&lt;/strong&gt; $v$.&lt;/p&gt;
&lt;p&gt;A graph $G$ is &lt;strong&gt;connected&lt;/strong&gt; if every two vertices of $G$ are connected. A graph that is not connected is called &lt;strong&gt;disconnected&lt;/strong&gt;. A connected subgraph of $G$ that is not a proper subgraph of any other connected subgraph of $G$ is a &lt;strong&gt;component&lt;/strong&gt; of $G$. The number of components of a graph $G$ is denoted by $k(G)$. Every graph is the union of its components.&lt;/p&gt;
&lt;p&gt;The &lt;strong&gt;distance&lt;/strong&gt; between $u$ and $v$ is the smallest length of any $u-v$ path in $G$ and is denoted by $d_{G}(u,v)$ or simply $d(u,v)$. A $u-v$ path of length $d(u,v)$ is called a $u-v$ &lt;strong&gt;geodesic&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;The greatest distance between any two vertices of a connected graph $G$ is called the &lt;strong&gt;diameter&lt;/strong&gt; of $G$ and is denoted by $diam(G)$.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Theorem 1.10&lt;/strong&gt; Let $G$ be a graph of order 3 or more. Then $G$  is connected if and only if $G$ contains two distinct vertices $u$  and $v$  such that $G-u$ and $G-v$ are connected.&lt;/p&gt;
&lt;h3 id=&quot;1-3-Common-Classes-of-Graphs&quot;&gt;&lt;a href=&quot;#1-3-Common-Classes-of-Graphs&quot; class=&quot;headerlink&quot; title=&quot;1.3 Common Classes of Graphs&quot;&gt;&lt;/a&gt;1.3 Common Classes of Graphs&lt;/h3&gt;&lt;p&gt;$G$ is called a &lt;strong&gt;path&lt;/strong&gt; if …&lt;/p&gt;
&lt;p&gt;$G$ is called a &lt;strong&gt;cycle&lt;/strong&gt; if …&lt;/p&gt;
&lt;p&gt;A graph $G$ is &lt;strong&gt;complete&lt;/strong&gt; if every two distinct vertices of $G$ are adjacent. A complete graph of order $n$ is denoted by $K_n$.&lt;/p&gt;
&lt;p&gt;The &lt;strong&gt;complement&lt;/strong&gt; $\bar{G}$ of a graph $G$ is that graph whose vertex set is $V(G)$ and such that for each pair $u,v$ of distinct vertices of $G$, $uv$ is an edge of $\bar{G}$ if and only if $uv$ is not an edge of $G$.&lt;/p&gt;
&lt;p&gt;The graph $\bar{K_n}$ has $n$ vertices and no edges, it is called the &lt;strong&gt;empty graph&lt;/strong&gt; of order $n$.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Theorem 1.11&lt;/strong&gt; If $G$  is a disconnected graph, then $\bar{G}$ is connected.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Theorem 1.12&lt;/strong&gt; A nontrivial graph $G$ is a bipartite graph if and only if $G$ contains no odd cycles.&lt;/p&gt;
&lt;p&gt;A graph $G$ is a &lt;strong&gt;bipartite graph&lt;/strong&gt; if $V(G)$ can be partitioned into two subsets $U$ and $W$, called &lt;strong&gt;partite sets&lt;/strong&gt;, such that every edge of $G$ joins a vertex of $U$ and a vertex of $W$.&lt;/p&gt;
&lt;p&gt;If every vertex of $U$  is adjacent to every vertex of $W$ , then we call $G$  a &lt;strong&gt;complete bipartite graph&lt;/strong&gt; . A complete graph with $|U|=s$  and $|W|=t$ is denoted by $K&lt;em&gt;{s,t}$ or $K&lt;/em&gt;{t,s}$. If either $s=1$ or $t=1$, then $K_{s,t}$ is a &lt;strong&gt;star&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;A graph $G$  is a $k$&lt;strong&gt;-partite graph&lt;/strong&gt; if $V(G)$ can be partitioned into $k$ subsets $V_1$,$V_2$,…,$V_k$,(called &lt;strong&gt;partite sets&lt;/strong&gt;) such that if $uv$ is an edge of $G$, then $u$ and $v$ belong to different partite sets. If, in addition, every  two vertices in different partite sets are joined by an edge, then $G$ is a &lt;strong&gt;complete k-partite graph&lt;/strong&gt;. If $|V_i|=n&lt;em&gt;i$ for $1 \le i \le k$, then we denote this graph by $K&lt;/em&gt;{n1,n2,…,nk}$. &lt;/p&gt;
&lt;p&gt;The &lt;strong&gt;join&lt;/strong&gt; $G+H$ consists of $G \cup H$ and all edges joining a vertex of $G$ and a vertex of $H$.&lt;/p&gt;
&lt;p&gt;The &lt;strong&gt;Cartesian product&lt;/strong&gt; $G \times H$ has vertex set $V(G \times H) = V(G) \times V(H)$ . Two distinct vertices $(u,v$) and $(x,y)$ are adjacent in $G \times H$ if either (1) $u=x$ and $vy\in E(H)$ or (2) $v=y$ and $ux\in E(G)$.&lt;/p&gt;
&lt;p&gt;We define $Q_1$ to be $K_2$ and for $n \ge 2$, define $Q&lt;em&gt;n$ to be $Q&lt;/em&gt;{n-1} \times K_2$. The graphs $Q_n$ are then called $n$&lt;strong&gt;-cubes&lt;/strong&gt; or &lt;strong&gt;hypercubes&lt;/strong&gt;.&lt;/p&gt;
&lt;h3 id=&quot;1-4-Multigraphs-and-Digraphs&quot;&gt;&lt;a href=&quot;#1-4-Multigraphs-and-Digraphs&quot; class=&quot;headerlink&quot; title=&quot;1.4 Multigraphs and Digraphs&quot;&gt;&lt;/a&gt;1.4 Multigraphs and Digraphs&lt;/h3&gt;&lt;p&gt;A &lt;strong&gt;multigraph&lt;/strong&gt; $M$ consists of a finite nonempty set $V$ of vertices and a set $E$ of edges, where every two vertices of M are joined by a finite number of edges(possibly zero). If two or more edges join the same pair of (distinct) vertices, then these edges are called &lt;strong&gt;parallel&lt;/strong&gt; edges.&lt;/p&gt;
&lt;p&gt;In a &lt;strong&gt;pseudograph&lt;/strong&gt;, not only are parallel edges permitted but an edge is also permitted to join a vertex to itself. Such an edge is called a &lt;strong&gt;loop&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;A &lt;strong&gt;digraph&lt;/strong&gt;(or &lt;strong&gt;directed graph&lt;/strong&gt;) $D$ is a finite nonempty set $V$ of objects called &lt;strong&gt;vertices&lt;/strong&gt; together with a set $E$ of ordered pairs of distinct vertices. The elements of $E$ are called &lt;strong&gt;directed edges&lt;/strong&gt; or &lt;strong&gt;arcs&lt;/strong&gt;. If $(u,v)$ is a directed edge, then we indicate this in a diagram representing $D$ by drawing a directed line segment or curve from $u$ to $v$. Then u is said to be &lt;strong&gt;adjacent to&lt;/strong&gt; v and v is &lt;strong&gt;adjacent from&lt;/strong&gt; u.&lt;/p&gt;
&lt;p&gt;If, in the definition of digraph, for each pair $u,v$ of distinct vertices, at most one of $(u,v)$ and $(v,u)$ is a directed edge, then the resulting digraph is an &lt;strong&gt;oriented graph&lt;/strong&gt;  &lt;/p&gt;
&lt;h2 id=&quot;Degrees&quot;&gt;&lt;a href=&quot;#Degrees&quot; class=&quot;headerlink&quot; title=&quot;Degrees&quot;&gt;&lt;/a&gt;Degrees&lt;/h2&gt;&lt;h3 id=&quot;2-1-The-Degree-of-a-Vertex&quot;&gt;&lt;a href=&quot;#2-1-The-Degree-of-a-Vertex&quot; class=&quot;headerlink&quot; title=&quot;2.1 The Degree of a Vertex&quot;&gt;&lt;/a&gt;2.1 The Degree of a Vertex&lt;/h3&gt;&lt;p&gt;The &lt;strong&gt;degree of a vertex&lt;/strong&gt; $v$ in a graph $G$ is the number of edges incident with $v$ and is denoted by $deg_G \ v$ or simply by $deg \ v$ if the graph $G$ is clear from the context.  The set $N(v)$ of neighbors of a vertex $v$  is called the &lt;strong&gt;neighborhood&lt;/strong&gt; of $v$. Thus $deg \ v = |N(v)|$.&lt;/p&gt;
&lt;p&gt;A vertex of degree 0 is referred to as an &lt;strong&gt;isolated vertex&lt;/strong&gt; and a vertex of degree 1 is an &lt;strong&gt;end-vertex&lt;/strong&gt;(or a &lt;strong&gt;leaf&lt;/strong&gt;). &lt;/p&gt;
&lt;p&gt;The &lt;strong&gt;minimum degree&lt;/strong&gt; of $G$  is the minimum degree among the vertices of $G$ and is denoted by $\delta(G)$, the &lt;strong&gt;maximum degree&lt;/strong&gt; of $G$ is denoted by $\Delta(G)$.&lt;/p&gt;
&lt;p&gt;For $G$ of order $n$, we have $0 \le \delta(G) \le deg \ v \le \Delta(G) \le n-1$.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Theorem 2.1(The First Theorem of Graph Theory)&lt;/strong&gt;  If $G$  is a graph of size $m$, then $\sum \limits_{v\in V(G)} deg \ v =2m$.&lt;/p&gt;
&lt;p&gt;A vertex of even degree is called an &lt;strong&gt;even vertex&lt;/strong&gt;, while a vertex of odd degree is an &lt;strong&gt;odd vertex&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Corollary 2.3&lt;/strong&gt; Every graph has an even number of odd vertices.&lt;/p&gt;
&lt;p&gt;If a graph $G$ order $n$ contains a vertex of degree $n-1$, then $G$ is connected. However, this is not a necessary condition.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Theorem 2.4&lt;/strong&gt; Let $G$ be a graph of order $n$. If $deg \ u + deg \ v \ge n-1$, for every two nonadjacent vertices $u$ and $v$ of $G$ , then $G$ is connected and $diam(G) \le 2$.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The bound of &lt;strong&gt;Theorem 2.4&lt;/strong&gt; is sharp.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;What if there is only one pair?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Corollary 2.5&lt;/strong&gt; If $G$  is a graph of order $n$ with $\delta(G) \ge (n-1)/2$, then $G$ is connected.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;outdegree&lt;/strong&gt; and &lt;strong&gt;indegree&lt;/strong&gt;.&lt;/p&gt;
&lt;h3 id=&quot;2-2-Regular-Graphs&quot;&gt;&lt;a href=&quot;#2-2-Regular-Graphs&quot; class=&quot;headerlink&quot; title=&quot;2.2 Regular Graphs&quot;&gt;&lt;/a&gt;2.2 Regular Graphs&lt;/h3&gt;&lt;p&gt;If $\delta(G)=\Delta(G)$, then the vertices of $G$  have the same degree and $G$  is called &lt;strong&gt;regular&lt;/strong&gt;. If $deg \ r=r$ for every vertex $v$  of $G$, where $0 \le r \le n-1$, then $G$  is $r$ &lt;strong&gt;-regular&lt;/strong&gt; or &lt;strong&gt;regular of degree r&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;A 3-regular graph is also referred to as a &lt;strong&gt;cubic graph&lt;/strong&gt;. The best known cubic graph may very well be the &lt;strong&gt;Petersen graph&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;There are no r-regular graphs of order $n$ if $r$ and $n$  are both odd.&lt;/p&gt;
&lt;h2 id=&quot;Trees&quot;&gt;&lt;a href=&quot;#Trees&quot; class=&quot;headerlink&quot; title=&quot;Trees&quot;&gt;&lt;/a&gt;Trees&lt;/h2&gt;&lt;h3 id=&quot;4-1-Bridges&quot;&gt;&lt;a href=&quot;#4-1-Bridges&quot; class=&quot;headerlink&quot; title=&quot;4.1 Bridges&quot;&gt;&lt;/a&gt;4.1 Bridges&lt;/h3&gt;&lt;p&gt;An edge $e=uv$ of a connected graph $G$ is called a &lt;strong&gt;bridge&lt;/strong&gt; of $G$ if $G-e$ is disconnected.&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Daily Records for 2018 Oct</title>
    <link href="https://ricky-ting.github.io/2018/10/01/Daily-Records-for-2018-Oct/"/>
    <id>https://ricky-ting.github.io/2018/10/01/Daily-Records-for-2018-Oct/</id>
    <published>2018-10-01T11:48:48.000Z</published>
    <updated>2018-10-07T15:11:45.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Oct-1-7"><a href="#Oct-1-7" class="headerlink" title="Oct 1-7"></a>Oct 1-7</h1><ul><li>Did some Lab1</li><li>Completed PA2.1</li><li>Completed ProblemSolving3-4</li><li>Completed Expr03 and Expr04 of Digital Logical Circuits</li><li>Did some further reading</li></ul><h1 id="Oct-8"><a href="#Oct-8" class="headerlink" title="Oct 8"></a>Oct 8</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Oct-1-7&quot;&gt;&lt;a href=&quot;#Oct-1-7&quot; class=&quot;headerlink&quot; title=&quot;Oct 1-7&quot;&gt;&lt;/a&gt;Oct 1-7&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Did some Lab1&lt;/li&gt;
&lt;li&gt;Completed PA2.1&lt;/li&gt;

      
    
    </summary>
    
    
      <category term="记录" scheme="https://ricky-ting.github.io/tags/%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>PA拾慧</title>
    <link href="https://ricky-ting.github.io/2018/09/16/PA%E6%8B%BE%E6%85%A7/"/>
    <id>https://ricky-ting.github.io/2018/09/16/PA拾慧/</id>
    <published>2018-09-16T15:03:19.000Z</published>
    <updated>2018-10-07T15:30:53.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>天将降PA于斯人也，必先使其STFW,RTFM,RTFSC, 所以动心忍性，曾益其所不能</strong></p><h1 id="tmux-分屏工具"><a href="#tmux-分屏工具" class="headerlink" title="tmux(分屏工具)"></a>tmux(分屏工具)</h1><p>Prefix: <code>Ctrl+B</code></p><p>左右分屏:<code>Prefix + %</code> 上下分屏: <code>Prefix + &quot;</code></p><p>切换: <code>Prefix + 方向键</code></p><h1 id="Vim配置"><a href="#Vim配置" class="headerlink" title="Vim配置"></a>Vim配置</h1><h2 id="vim分屏："><a href="#vim分屏：" class="headerlink" title="vim分屏："></a>vim分屏：</h2><p><code>Ctrl+W s</code>:上下分割当前打开的文件</p><p><code>:sp filename</code>:上下分割，并打开一个新的文件</p><p><code>Ctrl+W v</code>: 左右分割当前打开的文件</p><p><code>:vsp filename</code>: 左右分割，并打开一个新的文件</p><p><code>Ctrl+W l,h,k,j</code>: 在窗格见切换</p><h2 id="vim函数跳转"><a href="#vim函数跳转" class="headerlink" title="vim函数跳转:"></a>vim函数跳转:</h2><ol><li>安装ctags: ‘sudo apt-get install ctags’</li><li>测试ctags是否安装成功: <code>whereis ctags</code></li><li>为源代码生成tags文件，建议在项目根目录下生成: <code>ctags -R</code>,更多高级选项请自行查询或man</li><li>配置vimrc: <code>sudo vim ~/.vimrc</code></li><li>修改vimrc: 加入下面两行 </li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set tags=[path]/tags</span><br><span class="line">set tags=./tags,tags;$HOME</span><br></pre></td></tr></table></figure><h2 id="vim配置选项"><a href="#vim配置选项" class="headerlink" title="vim配置选项"></a>vim配置选项</h2><p><code>set laststatus=2</code></p><p>跳转快捷键: <code>Ctrl+]</code>跳转,  <code>Ctrl+t</code> or <code>Ctrl+o</code>返回.</p><p>在终端里输入<code>vim -t functionname</code> 可以直接跳转至你想跳转的函数.(来自StardustDL的补充)</p><p>vim函数跳转部分参考<a href="https://mengzelev.github.io/2018/09/12/pa-inspirations/" target="_blank" rel="noopener">Mengzelve’s Blog</a> </p><h1 id="C语言相关"><a href="#C语言相关" class="headerlink" title="C语言相关"></a>C语言相关</h1><p>顺时针法则</p><p>strcmp返回值为0是两个字符串相等</p><p>结构体里利用位域实现位级访问</p><h1 id="Linux相关"><a href="#Linux相关" class="headerlink" title="Linux相关"></a>Linux相关</h1><p>linux里的管道(pipeline)将不同程序的输入输出连起来。</p><p><code>time ./a.out</code> 可以测程序运行的时间。</p><p>在shell中使用终端设置别名:<code>alias cdblog=&#39;cd ~/Desktop/Github/Blog&#39;</code></p><p>统计代码行数: <code>find . | grep -E &#39;\.c$|\.h$&#39; | xargs cat | wc -l</code></p><p>统计代码行数(不含空格): <code>find . | grep -E &#39;\.c$|\.h$&#39; | xargs cat | grep -v ‘^$’ | wc -l</code></p><h1 id="一些好的文章："><a href="#一些好的文章：" class="headerlink" title="一些好的文章："></a>一些好的文章：</h1><p><a href="https://i.linuxtoy.org/docs/guide/index.html" target="_blank" rel="noopener">开源世界旅行手册</a></p><p><a href="http://songshuhui.net/archives/70194" target="_blank" rel="noopener">计算的极限</a></p><p><a href="https://eli.thegreenplace.net/2011/01/23/how-debuggers-work-part-1/#id7" target="_blank" rel="noopener">How debuggers work</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;天将降PA于斯人也，必先使其STFW,RTFM,RTFSC, 所以动心忍性，曾益其所不能&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;tmux-分屏工具&quot;&gt;&lt;a href=&quot;#tmux-分屏工具&quot; class=&quot;headerlink&quot; title=&quot;tmux(
      
    
    </summary>
    
    
      <category term="记录" scheme="https://ricky-ting.github.io/tags/%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Debian install sudo</title>
    <link href="https://ricky-ting.github.io/2018/09/06/Debian-install-sudo/"/>
    <id>https://ricky-ting.github.io/2018/09/06/Debian-install-sudo/</id>
    <published>2018-09-06T01:08:13.000Z</published>
    <updated>2018-09-06T07:39:19.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Debian-install-sudo"><a href="#Debian-install-sudo" class="headerlink" title="Debian install sudo"></a>Debian install sudo</h1><ol><li><code>su</code>切换至root</li><li><code>apt-get install sudo</code></li><li><code>visudo</code> 在<code>root ALL(ALL:ALL) ALL</code>后面加入一行<code>&lt;user&gt; ALL=(ALL:ALL) ALL</code></li><li>然后Ctrl-O 保存文件，要把文件名里的<code>.tmp</code>删除，两次yes， Ctrl-X退出编辑</li></ol><p><code>sudoers</code>文件目录为<code>/etc/sudoers</code></p><p><code>su</code>进入root, <code>exit</code>退出root</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Debian-install-sudo&quot;&gt;&lt;a href=&quot;#Debian-install-sudo&quot; class=&quot;headerlink&quot; title=&quot;Debian install sudo&quot;&gt;&lt;/a&gt;Debian install sudo&lt;/h1&gt;&lt;ol&gt;

      
    
    </summary>
    
    
      <category term="bug" scheme="https://ricky-ting.github.io/tags/bug/"/>
    
      <category term="solution" scheme="https://ricky-ting.github.io/tags/solution/"/>
    
  </entry>
  
  <entry>
    <title>Daily-Records for 2018-Sept</title>
    <link href="https://ricky-ting.github.io/2018/09/01/Daily-Records-for-2018-Sept/"/>
    <id>https://ricky-ting.github.io/2018/09/01/Daily-Records-for-2018-Sept/</id>
    <published>2018-09-01T14:42:22.000Z</published>
    <updated>2018-10-07T15:10:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Sept-1"><a href="#Sept-1" class="headerlink" title="Sept 1"></a>Sept 1</h1><ul><li>复习汇编</li><li>汇编考试(2:00 pm - 4:00 pm)</li><li>重新搭建Hadoop环境(进度50%),修复了好多bug</li><li><p>装Windows XP 虚拟机(玩了三维弹球)</p><a id="more"></a></li></ul><h1 id="Sept-2"><a href="#Sept-2" class="headerlink" title="Sept 2"></a>Sept 2</h1><ul><li>搭建Hadoop环境完成</li><li>学习java(进度55/689)</li><li>吃火锅</li><li>看big bang(S1E1-S1E3)</li></ul><h1 id="Sept-3-开学第一天"><a href="#Sept-3-开学第一天" class="headerlink" title="Sept 3(开学第一天)"></a>Sept 3(开学第一天)</h1><ul><li>装windows7虚拟机，并安装Quartus，重新做了实验0(数字逻辑电路真好玩 雾)</li><li>学习Verilog(1/13)</li></ul><p><img src="/images/dailyrecordfor2018sept/sept3_1.JPG" alt=""></p><h1 id="Sept-4"><a href="#Sept-4" class="headerlink" title="Sept 4"></a>Sept 4</h1><ul><li>问题求解3-1(7/11)</li></ul><h1 id="Sept-5"><a href="#Sept-5" class="headerlink" title="Sept 5"></a>Sept 5</h1><ul><li>问题求解3-1(11/11)</li><li>PA0(1/5)</li></ul><h1 id="Sept-6"><a href="#Sept-6" class="headerlink" title="Sept 6"></a>Sept 6</h1><ul><li>配置PA环境</li><li>学习使用vim</li></ul><h1 id="Sept-7"><a href="#Sept-7" class="headerlink" title="Sept 7"></a>Sept 7</h1><ul><li>completed Java OJ</li><li>Went to Shanghai </li></ul><h1 id="Sept-8"><a href="#Sept-8" class="headerlink" title="Sept 8"></a>Sept 8</h1><ul><li>Went to Shanghai Natrual History Museum with girlfriend</li><li>Walk along the river with girlfriend</li><li>Went to BBQ with girlfriend</li></ul><h1 id="Sept-9"><a href="#Sept-9" class="headerlink" title="Sept 9"></a>Sept 9</h1><ul><li>Went to Jiangwan Stadium with girlfriend</li><li>Had some dessert.</li><li>Went back to Nanjing</li><li>Completed PA0</li></ul><h1 id="Sept-10"><a href="#Sept-10" class="headerlink" title="Sept 10"></a>Sept 10</h1><ul><li>Completed Linear Algebra Exercise 1</li><li>Completed the cpu_state part of PA1</li><li>Completed exp02 in Digital Logical Circuits</li></ul><h1 id="Sept-11"><a href="#Sept-11" class="headerlink" title="Sept 11"></a>Sept 11</h1><ul><li>Completed PA1 stage1</li><li>Completed University Physics Homework</li></ul><h1 id="Sept-12"><a href="#Sept-12" class="headerlink" title="Sept 12"></a>Sept 12</h1><ul><li>Completed OJ(1/4)</li><li>Learned Java</li></ul><h1 id="Sept-13"><a href="#Sept-13" class="headerlink" title="Sept 13"></a>Sept 13</h1><ul><li>Completed OJ(4/4)</li><li>Completed Linear Algebra (4/4)</li><li>Completed ICS homework</li></ul><h1 id="Sept-14"><a href="#Sept-14" class="headerlink" title="Sept 14"></a>Sept 14</h1><ul><li>Completed Linear Algebra (3/3)</li></ul><h1 id="Sept-15"><a href="#Sept-15" class="headerlink" title="Sept 15"></a>Sept 15</h1><ul><li>Met the research supervisor</li><li>Did some problem solving</li><li>Played with my Hadoop</li></ul><h1 id="Sept-16"><a href="#Sept-16" class="headerlink" title="Sept 16"></a>Sept 16</h1><ul><li>Completed Problem Solving 3-2</li></ul><h1 id="Sept-17"><a href="#Sept-17" class="headerlink" title="Sept 17"></a>Sept 17</h1><h1 id="Sept-18"><a href="#Sept-18" class="headerlink" title="Sept 18"></a>Sept 18</h1><ul><li>Finished 形势与政策 homework</li><li>Did Expr04 of Digital Logical Circuits</li></ul><h1 id="Sept-19"><a href="#Sept-19" class="headerlink" title="Sept 19"></a>Sept 19</h1><ul><li>Completed PA1.2</li><li>Completed Linear Algebra(6/6)</li><li>Completed OJ(3/3)</li></ul><h1 id="Sept-20"><a href="#Sept-20" class="headerlink" title="Sept 20"></a>Sept 20</h1><ul><li>Completed OJ(1/1)</li><li>Completed Problem-Solving 3-3</li><li>Bug-fixing for PA1.2</li></ul><h1 id="Sept-21"><a href="#Sept-21" class="headerlink" title="Sept 21"></a>Sept 21</h1><ul><li>Completed Linear Algebra (3/3)</li></ul><h1 id="Sept-22"><a href="#Sept-22" class="headerlink" title="Sept 22"></a>Sept 22</h1><ul><li>Went downtown with girlfriend</li><li>Had a meal in Nanjing Univer(Xianling Campus) with girlfriend</li><li>Had a tour around the campus with girlfirend</li><li>Had some fruit mixed with yoghurt with girlfriend</li><li>Watched the Europe.Raiders with girlfriend</li></ul><h1 id="Sept-23"><a href="#Sept-23" class="headerlink" title="Sept 23"></a>Sept 23</h1><ul><li>Studied with girlfriend</li><li>Watched The.Little.Prince with girlfriend</li><li>Went to Nanjing University(Gulou Campus) for dinner with girlfriend</li><li>Went to Librairie Avant-Garde (Mount Wutai Branch) with girlfriend and bought a lucky package</li></ul><h1 id="Sept-24"><a href="#Sept-24" class="headerlink" title="Sept 24"></a>Sept 24</h1><ul><li>Went to a cat-featured coffee shop with girlfriend </li><li>Said farewell with girlfriend </li><li>Completed the OO-2 homework(Java)</li></ul><h1 id="Sept-25"><a href="#Sept-25" class="headerlink" title="Sept 25"></a>Sept 25</h1><ul><li>Finished Watchpoint of PA1.3</li></ul><h1 id="Sept-26"><a href="#Sept-26" class="headerlink" title="Sept 26"></a>Sept 26</h1><ul><li>Finished the report of PA1</li><li>Watched several episodes of Big Bang</li><li>Did some reading and learned something about philosophy</li></ul><h1 id="Sept-27"><a href="#Sept-27" class="headerlink" title="Sept 27"></a>Sept 27</h1><ul><li>Did some coding</li></ul><h1 id="Sept-28"><a href="#Sept-28" class="headerlink" title="Sept 28"></a>Sept 28</h1><ul><li>Did some coding</li></ul><h1 id="Sept-29"><a href="#Sept-29" class="headerlink" title="Sept 29"></a>Sept 29</h1><ul><li>Did some coding</li><li>Did some Lab1</li></ul><h1 id="Sept-30"><a href="#Sept-30" class="headerlink" title="Sept 30"></a>Sept 30</h1><ul><li>Completed Linear Algebra(1/1)</li><li>Went home</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Sept-1&quot;&gt;&lt;a href=&quot;#Sept-1&quot; class=&quot;headerlink&quot; title=&quot;Sept 1&quot;&gt;&lt;/a&gt;Sept 1&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;复习汇编&lt;/li&gt;
&lt;li&gt;汇编考试(2:00 pm - 4:00 pm)&lt;/li&gt;
&lt;li&gt;重新搭建Hadoop环境(进度50%),修复了好多bug&lt;/li&gt;
&lt;li&gt;&lt;p&gt;装Windows XP 虚拟机(玩了三维弹球)&lt;/p&gt;
    
    </summary>
    
    
      <category term="记录" scheme="https://ricky-ting.github.io/tags/%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Bug-Fix for hadoop installing</title>
    <link href="https://ricky-ting.github.io/2018/09/01/Bug-Fix-for-hadoop-installing/"/>
    <id>https://ricky-ting.github.io/2018/09/01/Bug-Fix-for-hadoop-installing/</id>
    <published>2018-09-01T14:26:44.000Z</published>
    <updated>2018-09-01T14:39:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>启动守护进程的时候(<code>start-dfs.sh</code>)报错：<code>master: ssh: Could not resolve hostname master: Name or Service not knwon</code>。</p><p>解决方法: 在host文件中添加master解析。</p><p><code>sudo vim /etc/hosts</code></p><p><code>127.0.0.1  master</code></p><p><a href="http://www.powerxing.com/install-hadoop/comment-page-1/" target="_blank" rel="noopener">贴一篇超详细的教程</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;启动守护进程的时候(&lt;code&gt;start-dfs.sh&lt;/code&gt;)报错：&lt;code&gt;master: ssh: Could not resolve hostname master: Name or Service not knwon&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;解决方
      
    
    </summary>
    
    
      <category term="bug" scheme="https://ricky-ting.github.io/tags/bug/"/>
    
  </entry>
  
  <entry>
    <title>shared folder in virtual machine</title>
    <link href="https://ricky-ting.github.io/2018/09/01/shared-folder-in-virtual-machine/"/>
    <id>https://ricky-ting.github.io/2018/09/01/shared-folder-in-virtual-machine/</id>
    <published>2018-09-01T11:35:31.000Z</published>
    <updated>2018-09-11T13:12:20.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="shared-folder-in-virtual-machine"><a href="#shared-folder-in-virtual-machine" class="headerlink" title="shared folder in virtual machine"></a>shared folder in virtual machine</h1><ol><li>首先在virtual box点击 <code>Insert Guest Additions CD Image</code></li><li>在虚拟机中运行弹出来的窗口</li><li>在Terminal中输入<code>sudo adduser $YourUserName vboxsf</code></li><li>Restart</li></ol><p><a href="https://stackoverflow.com/questions/26740113/virtualbox-shared-folder-permissions" target="_blank" rel="noopener">Stack Overflow相关链接</a></p><p>But when you cannot mount the disk automatically, you have to do it manually. Steps are as follows:</p><ol><li><p>Devices -&gt; Install Guest Additions..</p></li><li><p>Type the following in the guest terminal</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir --p /media/cdrom</span><br><span class="line">sudo mount -t auto /dev/cdrom /media/cdrom/</span><br><span class="line">cd /media/cdrom/</span><br><span class="line">sudo sh VBoxLinuxAdditions.run</span><br></pre></td></tr></table></figure><ol><li>Then<code>sudo adduser $YourUserName vboxsf</code></li><li>Restart.</li></ol><p><a href="https://askubuntu.com/questions/80341/unable-to-mount-virtualbox-guest-additions-as-a-guest-win7-host" target="_blank" rel="noopener">相关链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;shared-folder-in-virtual-machine&quot;&gt;&lt;a href=&quot;#shared-folder-in-virtual-machine&quot; class=&quot;headerlink&quot; title=&quot;shared folder in virtual mac
      
    
    </summary>
    
    
      <category term="bug" scheme="https://ricky-ting.github.io/tags/bug/"/>
    
  </entry>
  
  <entry>
    <title>回顾与展望(2018.8.25)</title>
    <link href="https://ricky-ting.github.io/2018/08/25/%E5%9B%9E%E9%A1%BE%E4%B8%8E%E5%B1%95%E6%9C%9B-2018-8-25/"/>
    <id>https://ricky-ting.github.io/2018/08/25/回顾与展望-2018-8-25/</id>
    <published>2018-08-25T02:05:06.000Z</published>
    <updated>2018-08-25T02:21:35.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="暑假里干的事"><a href="#暑假里干的事" class="headerlink" title="暑假里干的事"></a>暑假里干的事</h2><a id="more"></a><ol><li>看了《数学之美》</li><li>看了《黑客与画家》</li><li>看了《1Q84》</li><li>看完CSAPP前三章，并完成汇编实验和作业，拆炸弹</li><li>进行《挑战程序设计竞赛》里的编程训练</li><li>看完《计算机系统基础》前三章，并看完ICS网课相应部分</li><li>完成《Hadoop技术内幕》的源代码分析环境搭建，并阅读前两章(意识到要先学习java)</li><li>看了n(&gt;20)部电影</li><li>湖北五日游</li><li>练车，过了科三</li><li>社会实践(扬州二日游)</li></ol><p>总结：感觉效率还是不高，在家易涣散。技术学习和课外拓展较少。<del>导师的邮件让我意识到暑假里一事无成,趁着还有几天亡羊补牢吧</del></p><p>思考：</p><ul><li>计算机专业涵盖面太广，想学很多东西，但往往局限于了解。</li><li>其次需要学的多了的时候，易浮躁。</li><li>学会在信息的洪流中认准自己需要的，贪多不易得。</li><li>学习方法需要改进，经常在网上学习新知识的时候，易陷入递归状态，不断地点击超链接和查询新名词，导致经常开了十几个页面，最后只了解了皮毛，自暴自弃把所有页面关了。</li><li>要养成随时学习的习惯，保持对技术和知识的热情。</li><li>在做中学。 </li><li>ddl是第一生产力，没有ddl，就只能靠自己自觉了。</li><li><del>大神们的博客太有趣了，看着看着就荒废了一天。</del></li></ul><h2 id="新学期展望"><a href="#新学期展望" class="headerlink" title="新学期展望"></a>新学期展望</h2><h3 id="需要养成的习惯或改掉的坏习惯"><a href="#需要养成的习惯或改掉的坏习惯" class="headerlink" title="需要养成的习惯或改掉的坏习惯"></a>需要养成的习惯或改掉的坏习惯</h3><ul><li>养成daily record的习惯，追踪自己的进展，不要到最后才发现一事无成。</li><li>并且对短期设立计划。</li><li>进行学习思考。</li><li>不浮躁，用心学习</li></ul><h3 id="新学期要做的事"><a href="#新学期要做的事" class="headerlink" title="新学期要做的事"></a>新学期要做的事</h3><ol><li>多看书 (阅读经典，技术书籍等)</li><li>专业课好好上，实验好好做</li><li>大数据学习和实践(java Hadoop spark)</li><li>广泛涉猎技术</li><li>练科二，争取寒假考过</li></ol><h3 id="大数据、云计算学习方面"><a href="#大数据、云计算学习方面" class="headerlink" title="大数据、云计算学习方面"></a>大数据、云计算学习方面</h3><ol><li>多动手，多找一些示例跑一跑。</li><li>养成借助google、Stack Overflow解决配置、运行时出现的问题</li><li>对源代码进行分析</li><li>学习java</li><li>多读经典paper，广泛涉猎</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;暑假里干的事&quot;&gt;&lt;a href=&quot;#暑假里干的事&quot; class=&quot;headerlink&quot; title=&quot;暑假里干的事&quot;&gt;&lt;/a&gt;暑假里干的事&lt;/h2&gt;
    
    </summary>
    
    
      <category term="计划" scheme="https://ricky-ting.github.io/tags/%E8%AE%A1%E5%88%92/"/>
    
      <category term="记录" scheme="https://ricky-ting.github.io/tags/%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>挑战程序设计竞赛笔记</title>
    <link href="https://ricky-ting.github.io/2018/08/24/%E6%8C%91%E6%88%98%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%E7%AC%94%E8%AE%B0/"/>
    <id>https://ricky-ting.github.io/2018/08/24/挑战程序设计竞赛笔记/</id>
    <published>2018-08-24T11:24:53.000Z</published>
    <updated>2018-08-24T11:26:19.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="三角形"><a href="#三角形" class="headerlink" title="三角形"></a>三角形</h2><h3 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h3><p>从一堆绳子中找出三根绳子使得围成的三角形的周长最大。</p><a id="more"></a><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><ol><li>穷举，O($n^3$)</li><li>先排序，看最大的三根可不可以，不可以，将最大的一根剔除，然后递归。O($n \log_{}n$)</li></ol><h2 id="Ants-POJ-1852"><a href="#Ants-POJ-1852" class="headerlink" title="Ants(POJ 1852)"></a>Ants(POJ 1852)</h2><h3 id="描述：-1"><a href="#描述：-1" class="headerlink" title="描述："></a>描述：</h3><p>一堆蚂蚁在一根绳子上，不知道初始朝向，两个蚂蚁相遇会各自掉头，给出每个蚂蚁距离左端的距离和绳子，求出所有蚂蚁掉下绳子的最长时间和最短时间。</p><h3 id="题解：-1"><a href="#题解：-1" class="headerlink" title="题解："></a>题解：</h3><p>两个蚂蚁相遇掉头就相当于两个蚂蚁穿过对方继续前进。O(n)</p><h2 id="Lake-Counting-POJ-2386"><a href="#Lake-Counting-POJ-2386" class="headerlink" title="Lake Counting(POJ 2386)"></a>Lake Counting(POJ 2386)</h2><h3 id="描述：-2"><a href="#描述：-2" class="headerlink" title="描述："></a>描述：</h3><p>和W相邻的八个square可以认为是连在一起的，构成水洼，计算有多少块水洼。</p><h3 id="题解：-2"><a href="#题解：-2" class="headerlink" title="题解："></a>题解：</h3><p>用DFS，把和W相邻的变为<code>.</code>,一次DFS解决一块水洼，多少次DFS就有多少块水洼。复杂度：O(8 $\times$ N $\times$ M)</p><h2 id="迷宫的最短路径"><a href="#迷宫的最短路径" class="headerlink" title="迷宫的最短路径"></a>迷宫的最短路径</h2><h3 id="描述：-3"><a href="#描述：-3" class="headerlink" title="描述："></a>描述：</h3><p>寻找迷宫的最短路径</p><h3 id="题解：-3"><a href="#题解：-3" class="headerlink" title="题解："></a>题解：</h3><p>BFS，用数组记录每一点的距离，不断更新，用队列实现BFS。</p><h2 id="硬币问题"><a href="#硬币问题" class="headerlink" title="硬币问题"></a>硬币问题</h2><h3 id="描述：-4"><a href="#描述：-4" class="headerlink" title="描述："></a>描述：</h3><p>1元、5元、十元、50元、100元的硬币，如何找钱是个数最少。</p><h3 id="题解：-4"><a href="#题解：-4" class="headerlink" title="题解："></a>题解：</h3><p>贪心算法，但有条件，所有大的硬币的面额都得是小的硬币的倍数。如果上面加入20元的硬币，贪心算法就无法使用</p><h2 id="区间调度问题"><a href="#区间调度问题" class="headerlink" title="区间调度问题"></a>区间调度问题</h2><h3 id="描述：-5"><a href="#描述：-5" class="headerlink" title="描述："></a>描述：</h3><p>有很多工作区间，同时只能干一件事，要求在一段时间内完成最多的工作(个数)</p><h3 id="题解：-5"><a href="#题解：-5" class="headerlink" title="题解："></a>题解：</h3><p>总是在可选的工作中选取结束时间最早的工作</p><h2 id="Best-Cow-Line-POJ-3617"><a href="#Best-Cow-Line-POJ-3617" class="headerlink" title="Best Cow Line(POJ 3617)"></a>Best Cow Line(POJ 3617)</h2><h3 id="描述：-6"><a href="#描述：-6" class="headerlink" title="描述："></a>描述：</h3><p>每次可以从S的头部或尾部取一个字符加入到T的尾部，使得最终T的字典序最小</p><h3 id="题解：-6"><a href="#题解：-6" class="headerlink" title="题解："></a>题解：</h3><p>比较S和反转后S的字典序，取字典序小的那边，贪心。</p><h2 id="Saruman’s-Army-POJ-3069"><a href="#Saruman’s-Army-POJ-3069" class="headerlink" title="Saruman’s Army (POJ 3069)"></a>Saruman’s Army (POJ 3069)</h2><h3 id="描述：-7"><a href="#描述：-7" class="headerlink" title="描述："></a>描述：</h3><p>点覆盖问题，半径R</p><h3 id="题解：-7"><a href="#题解：-7" class="headerlink" title="题解："></a>题解：</h3><p>贪心</p><h2 id="Fence-Repair-POJ-3253"><a href="#Fence-Repair-POJ-3253" class="headerlink" title="Fence Repair (POJ 3253)"></a>Fence Repair (POJ 3253)</h2><h3 id="描述：-8"><a href="#描述：-8" class="headerlink" title="描述："></a>描述：</h3><p>切木板开销问题</p><h3 id="题解：-8"><a href="#题解：-8" class="headerlink" title="题解："></a>题解：</h3><p>两个最小板应该是一起切得，贪心。</p><h2 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h2><h3 id="描述：-9"><a href="#描述：-9" class="headerlink" title="描述："></a>描述：</h3><p>背包容量有限，拿或不拿。</p><h3 id="题解：-9"><a href="#题解：-9" class="headerlink" title="题解："></a>题解：</h3><p>动态规划</p><h2 id="最长公共子序列问题"><a href="#最长公共子序列问题" class="headerlink" title="最长公共子序列问题"></a>最长公共子序列问题</h2><h3 id="描述：-10"><a href="#描述：-10" class="headerlink" title="描述："></a>描述：</h3><p>求两个字符串的最大公共子序列长度，子序列可不连续</p><h3 id="题解：-10"><a href="#题解：-10" class="headerlink" title="题解："></a>题解：</h3><p>DP</p><h2 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h2><h3 id="描述：-11"><a href="#描述：-11" class="headerlink" title="描述："></a>描述：</h3><p>每种物品可选任意多件</p><h3 id="题解：-11"><a href="#题解：-11" class="headerlink" title="题解："></a>题解：</h3><p>改改递推关系式</p><h2 id="多重部分和关系"><a href="#多重部分和关系" class="headerlink" title="多重部分和关系"></a>多重部分和关系</h2><h3 id="描述：-12"><a href="#描述：-12" class="headerlink" title="描述："></a>描述：</h3><p>有n种不同大小的数字$a_i$,每种各$m_i$个。判断是否可以从这些数字之中选出若干使它们的和恰好为K.</p><h3 id="题解：-12"><a href="#题解：-12" class="headerlink" title="题解："></a>题解：</h3><p>需要记录剩余的数字个数，DP</p><h2 id="最长上升子序列问题"><a href="#最长上升子序列问题" class="headerlink" title="最长上升子序列问题"></a>最长上升子序列问题</h2><h3 id="描述：-13"><a href="#描述：-13" class="headerlink" title="描述："></a>描述：</h3><p>求一个序列的最长上升子序列</p><h3 id="题解：-13"><a href="#题解：-13" class="headerlink" title="题解："></a>题解：</h3><p>DP，记录以$a_i$结尾的最长上升子序列长度</p><h2 id="划分数"><a href="#划分数" class="headerlink" title="划分数"></a>划分数</h2><h3 id="描述：-14"><a href="#描述：-14" class="headerlink" title="描述："></a>描述：</h3><p>有n个无区别的物品，将它们划分成不超过m组，求出划分方法数模M的余数</p><h3 id="题解：-14"><a href="#题解：-14" class="headerlink" title="题解："></a>题解：</h3><p>DP，找出状态转移，设dp[i][j]是j的i划分数，有关系dp[i][j]=dp[i][j-i]+dp[i-1][j]</p><h2 id="多重集组合数"><a href="#多重集组合数" class="headerlink" title="多重集组合数"></a>多重集组合数</h2><h3 id="描述：-15"><a href="#描述：-15" class="headerlink" title="描述："></a>描述：</h3><p>n种物品，第i种有$a_i$个，然后一共取m个，有多少种取法</p><h3 id="题解：-15"><a href="#题解：-15" class="headerlink" title="题解："></a>题解：</h3><p>DP，$dp[i+1][j]=\sum_{k=0}^{min(j,a[i])} dp[i][j-k]$, 可以进一步化简得到: $dp[i+1][j]=dp[i+1][j-1]+dp[i][j]-dp[i][j-1-a_i]$</p><h2 id="Expedition-POJ-2431"><a href="#Expedition-POJ-2431" class="headerlink" title="Expedition (POJ 2431)"></a>Expedition (POJ 2431)</h2><h3 id="描述：-16"><a href="#描述：-16" class="headerlink" title="描述："></a>描述：</h3><p>加油问题，要求次数最少</p><h3 id="题解：-16"><a href="#题解：-16" class="headerlink" title="题解："></a>题解：</h3><p>贪心+优先队列。 不断行驶，当油量为0时，选择经过的最大加油量的加油站。</p><h2 id="食物链-POJ-1182"><a href="#食物链-POJ-1182" class="headerlink" title="食物链 (POJ 1182)"></a>食物链 (POJ 1182)</h2><h3 id="描述：-17"><a href="#描述：-17" class="headerlink" title="描述："></a>描述：</h3><p>有N只动物，分三类，形成循环状的捕食关系，循环给出两种信息：x和y属于同一类和x吃y，一共K条。其中可能出错，求出出错的消息数。</p><h3 id="题解：-17"><a href="#题解：-17" class="headerlink" title="题解："></a>题解：</h3><p>用并查集，维护3*N种状态，看是否有矛盾，进行合并操作和查询操作。</p><h2 id="二分图判定"><a href="#二分图判定" class="headerlink" title="二分图判定"></a>二分图判定</h2><h3 id="描述：-18"><a href="#描述：-18" class="headerlink" title="描述："></a>描述：</h3><p>给定一个n个顶点的图，能否最多用两个颜色染色，相邻顶点颜色不同</p><h3 id="题解：-18"><a href="#题解：-18" class="headerlink" title="题解："></a>题解：</h3><p>用dfs，把相邻的染上不同色，看是否有矛盾</p><h2 id="Minimum-Scalar-Product-GCJ-2008-Round1A-A"><a href="#Minimum-Scalar-Product-GCJ-2008-Round1A-A" class="headerlink" title="Minimum Scalar Product (GCJ 2008 Round1A A)"></a>Minimum Scalar Product (GCJ 2008 Round1A A)</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述:"></a>描述:</h3><p>两个向量，内部换序，使得最后的向量积最小。</p><h3 id="题解：-19"><a href="#题解：-19" class="headerlink" title="题解："></a>题解：</h3><p>设a&lt;b,c&lt;d, 可以证明ad+bc最小。所以只要将两个向量分别排序，最大的和最小的乘就可以。 对于large数据，要用long long</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">long long a[802],b[802];</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">int t,n;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line">long long ans;</span><br><span class="line">for(int i=0;i&lt;t;i++)</span><br><span class="line">&#123;</span><br><span class="line">ans=0;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">for(int j=0;j&lt;n;j++)</span><br><span class="line">cin&gt;&gt;a[j];</span><br><span class="line">for(int j=0;j&lt;n;j++)</span><br><span class="line">cin&gt;&gt;b[j];</span><br><span class="line">sort(a,a+n);</span><br><span class="line">sort(b,b+n);</span><br><span class="line">for(int j=0;j&lt;n;j++)</span><br><span class="line">ans+=(a[j]*b[n-j-1]);</span><br><span class="line">cout&lt;&lt;&quot;Case #&quot;&lt;&lt;i+1&lt;&lt;&quot;: &quot;&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Crazy-Rows-GCJ-2009-Round2-A"><a href="#Crazy-Rows-GCJ-2009-Round2-A" class="headerlink" title="Crazy Rows (GCJ 2009 Round2 A)"></a>Crazy Rows (GCJ 2009 Round2 A)</h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述:"></a>描述:</h3><p>只交换相邻行，使得主对角线上方的元素都是0，求最小交换次数。</p><h3 id="题解：-20"><a href="#题解：-20" class="headerlink" title="题解："></a>题解：</h3><p>对于每一行循环，寻找最近的符合条件的，然后交换</p><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code:"></a>Code:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int a[41];</span><br><span class="line">int t,n;</span><br><span class="line">int counter;</span><br><span class="line">void solve(void);</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line">for(int i=0;i&lt;t;i++)</span><br><span class="line">&#123;</span><br><span class="line">solve();</span><br><span class="line">cout&lt;&lt;&quot;Case #&quot;&lt;&lt;i+1&lt;&lt;&quot;: &quot;&lt;&lt;counter&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void solve(void)</span><br><span class="line">&#123;</span><br><span class="line">counter=0;</span><br><span class="line">string s;</span><br><span class="line">int tmp;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">a[i]=-1;</span><br><span class="line">cin&gt;&gt;s;</span><br><span class="line">for(int j=0;j&lt;n;j++)</span><br><span class="line">if(s[j]==&apos;1&apos;)</span><br><span class="line">a[i]=j;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">int pos=-1;</span><br><span class="line">for(int j=i;j&lt;n;j++)</span><br><span class="line">if(a[j]&lt;=i)</span><br><span class="line">&#123;</span><br><span class="line">pos=j;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">for(int j=pos;j&gt;i;j--)</span><br><span class="line">&#123;</span><br><span class="line">tmp=a[j];</span><br><span class="line">a[j]=a[j-1];</span><br><span class="line">a[j-1]=tmp;</span><br><span class="line">counter++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;三角形&quot;&gt;&lt;a href=&quot;#三角形&quot; class=&quot;headerlink&quot; title=&quot;三角形&quot;&gt;&lt;/a&gt;三角形&lt;/h2&gt;&lt;h3 id=&quot;描述：&quot;&gt;&lt;a href=&quot;#描述：&quot; class=&quot;headerlink&quot; title=&quot;描述：&quot;&gt;&lt;/a&gt;描述：&lt;/h3&gt;&lt;p&gt;从一堆绳子中找出三根绳子使得围成的三角形的周长最大。&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="https://ricky-ting.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>数学之美笔记</title>
    <link href="https://ricky-ting.github.io/2018/08/24/%E6%95%B0%E5%AD%A6%E4%B9%8B%E7%BE%8E%E7%AC%94%E8%AE%B0/"/>
    <id>https://ricky-ting.github.io/2018/08/24/数学之美笔记/</id>
    <published>2018-08-24T11:18:55.000Z</published>
    <updated>2018-08-24T11:23:01.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数学之美笔记"><a href="#数学之美笔记" class="headerlink" title="数学之美笔记"></a>数学之美笔记</h1><h2 id="一、统计语言模型"><a href="#一、统计语言模型" class="headerlink" title="一、统计语言模型"></a>一、统计语言模型</h2><p>利用数学犯法来解决自然语言处理问题，而非传统的语法分析。基于概率的模型</p><p>P(S)=P(w1)P(w2|w1)P(w3|w1&amp;w2)…P(wn|w1&amp;w2…&amp;wn-1)</p><p>利用马尔可夫假设，可以简化为：</p><p>P(S)=P(w1)P(w2|w1)P(w3|w2)…P(wi|wi-1)</p><a id="more"></a><h2 id="二、谈谈中文分词"><a href="#二、谈谈中文分词" class="headerlink" title="二、谈谈中文分词"></a>二、谈谈中文分词</h2><p>1.查字典法,最大匹配-&gt;最小分割法。但对于二义性无能为力</p><p>2.最大概率分词法。用统计语言模型计算出每种分词后句子出现的概率，并找出其中概率最大的。</p><p>找到复合词的嵌套结构</p><h2 id="三、隐含马尔科夫模型在语言处理中的应用"><a href="#三、隐含马尔科夫模型在语言处理中的应用" class="headerlink" title="三、隐含马尔科夫模型在语言处理中的应用"></a>三、隐含马尔科夫模型在语言处理中的应用</h2><p>(s1 s2 s3)-&gt;(o1 o2 o3)</p><p>求P(s1,s2,s3|o1,o2,o3)最大，利用贝叶斯公式：</p><p>P(o1,o2,o3,…|s1,s3,s3)*P(s1,s2,s3)</p><p>做两个假设：</p><ol><li>s1,s2,s3,..是一个马尔科夫链,即，si只由si-1决定</li><li>第i时刻的接受信号oi只由发送信号si决定,又称独立输出假设,即P(o1,o2,o3..|s1,s2,s3,..)=P(o1|s1)<em> P(o2|s2) </em> P(o3|s3)…</li></ol><h2 id="四、怎么度量信息？"><a href="#四、怎么度量信息？" class="headerlink" title="四、怎么度量信息？"></a>四、怎么度量信息？</h2><p>香农：信息熵。</p><p>一条信息的信息量大小和它的不确定性有直接关系。它越不确定，信息量越大。</p><p>用bit的概念来度量信息量</p><p>$$ H(X)=- \sum_{x}P(x)\log_2[P(x)] $$</p><p>实际信息的表示和信息熵的差距称作”冗余度”(redundancy)</p><h2 id="五、简单之美：布尔代数和搜索引擎的索引"><a href="#五、简单之美：布尔代数和搜索引擎的索引" class="headerlink" title="五、简单之美：布尔代数和搜索引擎的索引"></a>五、简单之美：布尔代数和搜索引擎的索引</h2><p>最简单的索引是用一个很长的二进制数，每一位代表一个关键词，如果有，则为1，否则为0</p><h2 id="六、图论和网络爬虫"><a href="#六、图论和网络爬虫" class="headerlink" title="六、图论和网络爬虫"></a>六、图论和网络爬虫</h2><p>BFS和DFS</p><p>网络爬虫，通过hash来判断是否爬过</p><h2 id="七、信息论在信息处理中的应用"><a href="#七、信息论在信息处理中的应用" class="headerlink" title="七、信息论在信息处理中的应用"></a>七、信息论在信息处理中的应用</h2><p>不确定性越小，模型越好。信息熵可以直接用于衡量统计语言模型的好坏。</p><p>两个概念：“互信息”(Mutual Information)和”相对熵”(Kullback-Leibler Divergence)</p><ul><li>互信息:是对两个随机事件相关性的度量。可以很好地解决二义性</li><li>相对熵：衡量两个正函数是否相似。对于两个完全相同的函数，它们的相对熵等于零。</li></ul><h2 id="八、贾里尼克的故事和现代语言处理"><a href="#八、贾里尼克的故事和现代语言处理" class="headerlink" title="八、贾里尼克的故事和现代语言处理"></a>八、贾里尼克的故事和现代语言处理</h2><h2 id="九、如何确定网页和查询的相关性"><a href="#九、如何确定网页和查询的相关性" class="headerlink" title="九、如何确定网页和查询的相关性"></a>九、如何确定网页和查询的相关性</h2><p>对关键词次数进行归一化(否则长文章占优),即求频次：称为”关键词频率“或“单文本词汇频率”(Term Frequency)</p><p>还有要去除介词等”应删除词”(Stopwords)，</p><p>对不同的关键词给予不同的权重，如专业词比通用词权重高。有下面两个条件：</p><ol><li><p>一个词预测主题能力越强，权重越大，反之越小</p></li><li><p>应删除词权重为零</p></li></ol><p>使用最多的权重是”逆文本频率指数(Inverse document frequency)“: log(D/Dw),D为全部网页数</p><p>所以计算公式为：TF1 <em> IDF1 + TF2 </em> IDF2+.. + TFN * IDFN</p><p>给定查询，网页的综合排名由相关性和网页排名乘积决定</p><p>IDFN的计算公式为什么取log有待学习</p><h2 id="十、有限状态机和地址识别"><a href="#十、有限状态机和地址识别" class="headerlink" title="十、有限状态机和地址识别"></a>十、有限状态机和地址识别</h2><p>类似于时序逻辑里的状态转移</p><p>为了能进行模糊匹配，提出基于概率的有限状态机，和离散的马尔科夫链基本等效</p><h2 id="十二、余弦定理和新闻的分类"><a href="#十二、余弦定理和新闻的分类" class="headerlink" title="十二、余弦定理和新闻的分类"></a>十二、余弦定理和新闻的分类</h2><p>基于TF/IDF，生成新闻的特征向量，用余弦定理计算它们的夹角，计算它们的相似度。</p><p>疑问：关于同义词、近义词是否有很好的映射工具</p><h2 id="十三、信息指纹及其应用"><a href="#十三、信息指纹及其应用" class="headerlink" title="十三、信息指纹及其应用"></a>十三、信息指纹及其应用</h2><p>其实就是hash函数，如MD5,SHA1等</p><h2 id="十四、浅谈数学模型的重要性"><a href="#十四、浅谈数学模型的重要性" class="headerlink" title="十四、浅谈数学模型的重要性"></a>十四、浅谈数学模型的重要性</h2><ol><li>一个正确的数学模型应当在形式上是简单的。</li><li>一个正确的模型在它开始的时候可能还不如一个精雕细琢的错误的模型来的准确，但是，如果我们认定大方向是对的，就应该坚持下去。</li><li>大量准确的数据对研发很重要。</li><li>正确的模型也可能受噪音干扰，而显得不准确：这时我们不应该用一种凑合的修正方法来弥补它，而是要找到噪音的根源，这也许能通往重大发现。</li></ol><h2 id="十六-上-、不要把所有的鸡蛋放在一个篮子里–谈谈最大熵模型"><a href="#十六-上-、不要把所有的鸡蛋放在一个篮子里–谈谈最大熵模型" class="headerlink" title="十六(上)、不要把所有的鸡蛋放在一个篮子里–谈谈最大熵模型"></a>十六(上)、不要把所有的鸡蛋放在一个篮子里–谈谈最大熵模型</h2><p>最大熵原理：要保留全部的不确定性，将风险降到最小。</p><p>最大熵原理指出，当我们需要对一个随机事件的概率分布进行预测时，我们的预测应当满足全部已知的条件，而对未知的情况不要做任何主观假设。</p><p>希萨证明，对任何一组不自相矛盾的信息，这个最大熵模型不仅存在，而且是唯一的，都有同一个非常简单的形式–指数函数。</p><p>$$ P(w3|w1,w2,subject)=\frac{e^{\lambda_1(w1,w2,w3)+\lambda_2(subject,w3)}}{Z(w1,w2,subject)}$$</p><p>$\lambda$ 和 Z需要通过观测数据训练出来。</p><h2 id="十六-下-、不要把所有的鸡蛋放在一个篮子里–最大熵模型"><a href="#十六-下-、不要把所有的鸡蛋放在一个篮子里–最大熵模型" class="headerlink" title="十六(下)、不要把所有的鸡蛋放在一个篮子里–最大熵模型"></a>十六(下)、不要把所有的鸡蛋放在一个篮子里–最大熵模型</h2><p>最原始的最大熵模型的训练方法是一种称为通用迭代算法GIS(Generalized iterative scaling)的迭代算法。分为以下几个步骤</p><ol><li>假定第零次迭代的初始模型为等概率的均匀分布。</li><li>用第N次迭代的模型来估算每种信息特征在训练数据中的分布，如果超过了实际的，就把相应的模型参数变小；否则，将它们变大。</li><li>重复步骤2直到收敛</li></ol><p>实际应用中很少用，只是通过它了解最大熵模型的算法，迭代时间长，次数多，不太稳定，容易溢出</p><p>后来有很多改进工作</p><h2 id="十七、闪光的不一定是金子，谈谈搜索引擎作弊问题-Search-Engine-Anti-SPAM"><a href="#十七、闪光的不一定是金子，谈谈搜索引擎作弊问题-Search-Engine-Anti-SPAM" class="headerlink" title="十七、闪光的不一定是金子，谈谈搜索引擎作弊问题(Search Engine Anti_SPAM)"></a>十七、闪光的不一定是金子，谈谈搜索引擎作弊问题(Search Engine Anti_SPAM)</h2><p>常见作弊方法：增加关键词，创建专门放链接的网站</p><p>相当于声音中加入了噪音，而混入噪音，在数学上相当于两个信号做卷积。噪音消除的过程就是解卷积的过程。</p><h2 id="十八、矩阵运算和文本处理中的分类问题"><a href="#十八、矩阵运算和文本处理中的分类问题" class="headerlink" title="十八、矩阵运算和文本处理中的分类问题"></a>十八、矩阵运算和文本处理中的分类问题</h2><p>分类需要计算相关性，而用内积方法的话，两两配对，计算量很大</p><p>另一种方法是利用矩阵运算中的奇异值分解(Single Value Decomposition 简称SVD)：大矩阵拆分成小矩阵</p><h2 id="十九、马尔科夫链的扩展–贝叶斯网络-Bayesian-Networks"><a href="#十九、马尔科夫链的扩展–贝叶斯网络-Bayesian-Networks" class="headerlink" title="十九、马尔科夫链的扩展–贝叶斯网络(Bayesian Networks)"></a>十九、马尔科夫链的扩展–贝叶斯网络(Bayesian Networks)</h2><p>把有向图看成一个网络，就是贝叶斯网络，每个圆圈代表状态，状态之间的连线表示它们的因果关系。这些关系都有一个可以量化的可信度(belief)</p><p>贝叶斯网络的训练是NP-complete问题。</p><h2 id="二十一、布隆过滤器-Bloom-Filter"><a href="#二十一、布隆过滤器-Bloom-Filter" class="headerlink" title="二十一、布隆过滤器(Bloom Filter)"></a>二十一、布隆过滤器(Bloom Filter)</h2><p>实际上是一个很长的二进制向量和一系列随机映射函数。</p><p>n个随机函数选择位，然后设为1。</p><p>有误判概率</p><h2 id="二十二、由电视剧《暗算》所想到的-谈谈密码学的数学原理"><a href="#二十二、由电视剧《暗算》所想到的-谈谈密码学的数学原理" class="headerlink" title="二十二、由电视剧《暗算》所想到的-谈谈密码学的数学原理"></a>二十二、由电视剧《暗算》所想到的-谈谈密码学的数学原理</h2><p>RSA加密</p><h2 id="二十三、输入一个汉字需要敲多少个键——谈谈香农第一定律"><a href="#二十三、输入一个汉字需要敲多少个键——谈谈香农第一定律" class="headerlink" title="二十三、输入一个汉字需要敲多少个键——谈谈香农第一定律"></a>二十三、输入一个汉字需要敲多少个键——谈谈香农第一定律</h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数学之美笔记&quot;&gt;&lt;a href=&quot;#数学之美笔记&quot; class=&quot;headerlink&quot; title=&quot;数学之美笔记&quot;&gt;&lt;/a&gt;数学之美笔记&lt;/h1&gt;&lt;h2 id=&quot;一、统计语言模型&quot;&gt;&lt;a href=&quot;#一、统计语言模型&quot; class=&quot;headerlink&quot; title=&quot;一、统计语言模型&quot;&gt;&lt;/a&gt;一、统计语言模型&lt;/h2&gt;&lt;p&gt;利用数学犯法来解决自然语言处理问题，而非传统的语法分析。基于概率的模型&lt;/p&gt;
&lt;p&gt;P(S)=P(w1)P(w2|w1)P(w3|w1&amp;amp;w2)…P(wn|w1&amp;amp;w2…&amp;amp;wn-1)&lt;/p&gt;
&lt;p&gt;利用马尔可夫假设，可以简化为：&lt;/p&gt;
&lt;p&gt;P(S)=P(w1)P(w2|w1)P(w3|w2)…P(wi|wi-1)&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="https://ricky-ting.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>插入代码注意事项</title>
    <link href="https://ricky-ting.github.io/2018/08/03/%E6%8F%92%E5%85%A5%E4%BB%A3%E7%A0%81%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <id>https://ricky-ting.github.io/2018/08/03/插入代码注意事项/</id>
    <published>2018-08-03T08:26:43.000Z</published>
    <updated>2018-08-03T08:28:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>开启mathjax后排版混乱，本来以为是mathjax的锅，后发现```之后多加了一个空格。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;开启mathjax后排版混乱，本来以为是mathjax的锅，后发现```之后多加了一个空格。&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="bug" scheme="https://ricky-ting.github.io/tags/bug/"/>
    
  </entry>
  
  <entry>
    <title>2018 Spring Problem Solving 2</title>
    <link href="https://ricky-ting.github.io/2018/07/08/2018-Spring-Problem-Solving-2/"/>
    <id>https://ricky-ting.github.io/2018/07/08/2018-Spring-Problem-Solving-2/</id>
    <published>2018-07-08T01:12:08.000Z</published>
    <updated>2018-08-03T08:25:50.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2018春问题求解笔记"><a href="#2018春问题求解笔记" class="headerlink" title="2018春问题求解笔记"></a>2018春问题求解笔记</h1><h2 id="2-1-算法正确性-2018-3-7"><a href="#2-1-算法正确性-2018-3-7" class="headerlink" title="2-1 算法正确性(2018.3.7)"></a>2-1 算法正确性(2018.3.7)</h2><p>程序和算法不等同</p><p>算法正确性是基础</p> <a id="more"></a><p>“Program testing can be used to show the presence of bugs, but never to show their absence!”</p><p>封闭环境内同一个输入会产生同样的错误，但网络环境以及并行下不一定。错误的难重现</p><p>部分正确性(if terminates)和完全正确性(indeed terminates)</p><p>循环不变式</p><p>show converge</p><p>assertion和checkpoint：我们可以在算法的任意位置，设置assertion，这个“位置”就是check point</p><p>证明就是断言的序列</p><p>一条链</p><p>递归：数学归纳法</p><p>证明多个变量的数学归纳法：$\forall$ m, 对n做归纳</p><h3 id="习题讲解-2018-3-12"><a href="#习题讲解-2018-3-12" class="headerlink" title="习题讲解(2018.3.12)"></a>习题讲解(2018.3.12)</h3><p>totalwork = workdone + worktodo</p><p>(1)-&gt;(2)-&gt;(2’)-&gt;(3)-&gt;(4)</p><h3 id="open-topic"><a href="#open-topic" class="headerlink" title="open topic"></a>open topic</h3><h4 id="1-证明插入排序的完全正确性"><a href="#1-证明插入排序的完全正确性" class="headerlink" title="1.证明插入排序的完全正确性"></a>1.证明插入排序的完全正确性</h4><p>两层循环 内层 外层</p><h4 id="2-证明旋转汉诺塔的完全正确性"><a href="#2-证明旋转汉诺塔的完全正确性" class="headerlink" title="2.证明旋转汉诺塔的完全正确性"></a>2.证明旋转汉诺塔的完全正确性</h4><p>状态数 操作数：操作数&gt;状态数，则非最优解</p><h2 id="2-2-算法的效率"><a href="#2-2-算法的效率" class="headerlink" title="2-2 算法的效率"></a>2-2 算法的效率</h2><h3 id="open-topic-1"><a href="#open-topic-1" class="headerlink" title="open topic"></a>open topic</h3><h4 id="Algorithmic-Gap"><a href="#Algorithmic-Gap" class="headerlink" title="Algorithmic Gap"></a>Algorithmic Gap</h4><p>Decision Tree</p><p>Adversary Argument</p><h2 id="2-3-组合与计数"><a href="#2-3-组合与计数" class="headerlink" title="2-3 组合与计数"></a>2-3 组合与计数</h2><p>计数在算法分析中很重要</p><p>抽象</p><p>加法原理 乘法原理</p><p>kth falling factorial power of n</p><p>Pascal’s triangle</p><p>Pascal relationship</p><p>multiset：放入k个后取</p><p>等价关系用于计数 等价类 商集</p><h2 id="2-4-分治法与递归"><a href="#2-4-分治法与递归" class="headerlink" title="2-4 分治法与递归"></a>2-4 分治法与递归</h2><p>Divide-and-Conquer: 3steps(Divid -&gt; Conquer -&gt; Combine)</p><p>递归中subproblem出现的两种case:recursive case, base case</p><h3 id="three-methods-for-solving-recurrences"><a href="#three-methods-for-solving-recurrences" class="headerlink" title="three methods for solving recurrences:"></a>three methods for solving recurrences:</h3><ul><li>substitution method</li><li>recursion-tree method</li><li>master method</li></ul><h3 id="maximum-subarray-problem"><a href="#maximum-subarray-problem" class="headerlink" title="maximum-subarray problem"></a>maximum-subarray problem</h3><p>consider the daily change in price</p><p>divide-and-conquer解法: 把序列一分为二，然后最长的有三种情况，全在左边一半，全在右边一半，横跨中点。然后重点如何处理第三种情况，在中点向两边分别找，然后合并。复杂度为O(nlogn).</p><p>有O(n)算法 类似于DP</p><h3 id="Strassen’s-algorithm-for-matrix-multiplication"><a href="#Strassen’s-algorithm-for-matrix-multiplication" class="headerlink" title="Strassen’s algorithm for matrix multiplication"></a>Strassen’s algorithm for matrix multiplication</h3><p>$O(n^3) -&gt; O(n^{2.81})[O(n^{lg7})]$</p><h3 id="substituition-method"><a href="#substituition-method" class="headerlink" title="substituition method"></a>substituition method</h3><p>Guess and then prove. Mathematical Induction.</p><ol><li>Guess the form of the solution.</li><li>Use mathemarical induction to find the constants and show that the solution works.</li></ol><p>一些证明中的小技巧:改变起始项，更换变量</p><h3 id="Recursion-tree-method"><a href="#Recursion-tree-method" class="headerlink" title="Recursion-tree method"></a>Recursion-tree method</h3><p>A recursion-tree is best used to generate a good guess.</p><p>Analyse and then sum.</p><h3 id="master-method"><a href="#master-method" class="headerlink" title="master method"></a>master method</h3><p>prove</p><p>为什么分治法能降低时间复杂度？</p><h2 id="2-5-递归及其数学基础"><a href="#2-5-递归及其数学基础" class="headerlink" title="2-5 递归及其数学基础"></a>2-5 递归及其数学基础</h2><p>求解精确解</p><h3 id="Mathematical-Induction"><a href="#Mathematical-Induction" class="headerlink" title="Mathematical Induction"></a>Mathematical Induction</h3><ul><li>base case  </li><li>inductive hypothesis</li><li>inductive step</li><li>inductive conclusion</li></ul><p>The terms weak and strong arise from what is assumed in the inductive hypothesis. Adding more restrictions strengthens an assertion, while removing restrictions weakens the assertion</p><p>recursion和mathematical induction有密切联系<br>一个自上而下(分解问题) 一个自下而上(组合问题)</p><p>structural induction</p><p>triangulated polygon<br>Ear Lemma</p><p>等比数列</p><p>ﬁrst-order linear recurrence ：T(n) = f (n)T(n − 1) + g(n)</p><p>巧用微积分知识</p><p>解一阶线性：直接展开</p><p>解线性齐次：解特征方程</p><h2 id="2-6-算法方法"><a href="#2-6-算法方法" class="headerlink" title="2-6 算法方法"></a>2-6 算法方法</h2><p>问题求解：压缩解空间</p><p>Maximal Polygon Distance问题</p><p>Minimal Spanning Tree</p><p>Greedy DP(本质上还是穷竭搜索 但空间换时间)</p><p>DFS BFS</p><p>Bin packing NPC问题</p><h2 id="2-7-离散概率"><a href="#2-7-离散概率" class="headerlink" title="2-7 离散概率"></a>2-7 离散概率</h2><p>Complementary Probabilities</p><p>The Uniform Probability Distribution</p><p>(Principle of Inclusion and Exclusion for Probability)<br>Proof1: 算P(x)的系数 用二项式定理 Proof2:待理解</p><p>Conditional probability: P(E|F)=P(E \cap F) / P(F) [P(E|F)=P(E) when P(F)=0]</p><p>We say E is independent of F if P(E|F) = P(E). 我认为P(E|F)不是由公式导出的。存疑</p><p><strong>Bayes’ Theorem</strong>：P(E|F)P(F) = P(F|E)P(E).</p><p>product principle for independent probabilities: P(E \cap F) = P(E)P(F)</p><p>independent trials process</p><p>our model of hashing is an independent trials process.</p><p>probability tree</p><p>A random variable for an experiment with a sample space S is a function that assigns a number to each element of S.</p><p>Bernoulli trials process</p><p>expected value</p><p>indicator random variable</p><p>The Number of Trials until the First Success</p><p>指示器随机变量提供了一个便利的工具实现事件A发生的概率和期望之间的转换：求某个随机变量的期望往往可以简化为若干个和该随机变量相关的事件的概率之和</p><h2 id="2-8-概率分析与随机化算法"><a href="#2-8-概率分析与随机化算法" class="headerlink" title="2-8 概率分析与随机化算法"></a>2-8 概率分析与随机化算法</h2><p>conditional expected value</p><p>Randomized Algorithms</p><p>Quicksort分析</p><p>normal curve</p><p>variance</p><p>Central limit theorem.</p><p>normal distribution</p><h2 id="2-9-排序与选择"><a href="#2-9-排序与选择" class="headerlink" title="2-9 排序与选择"></a>2-9 排序与选择</h2><p>The Coupon Collector’s Problem</p><p>$n log n + (m-1)nloglogn + nC_m + o(n), n \rightarrow \infty, m fixed$</p><p>Tony Hoare: Quicksort, Hoare Logic: {P}S{Q}, null pointer “I call it my billion-dollar mistake”.</p><p>证明下界：1. decision tree 2. adversary strategy</p><p>Adversary Argument：证下界</p><p>检测01、同时找最大最小、找第二小，k=3 is still open， 找中间值</p><h2 id="2-10-基本数据结构"><a href="#2-10-基本数据结构" class="headerlink" title="2-10 基本数据结构"></a>2-10 基本数据结构</h2><p>tail指向最后一个元素的后一个 为什么</p><p>Why Numbering Should Start at Zero(EWD831)</p><h2 id="2-11-堆与堆排序"><a href="#2-11-堆与堆排序" class="headerlink" title="2-11 堆与堆排序"></a>2-11 堆与堆排序</h2><h2 id="2-12-Hashing方法"><a href="#2-12-Hashing方法" class="headerlink" title="2-12 Hashing方法"></a>2-12 Hashing方法</h2><h2 id="2-13-搜索树"><a href="#2-13-搜索树" class="headerlink" title="2-13 搜索树"></a>2-13 搜索树</h2><p>A tree is a recursive abstract data type</p><h3 id="Binary-Search-Tree"><a href="#Binary-Search-Tree" class="headerlink" title="Binary Search Tree"></a>Binary Search Tree</h3><p>Operations: Search(用while), Minimum(当子节点不为nil一直下去), Maximum, Predecessor(分两种情况:有右子树 无右子树), Successor, Insert and Delete(分三种情况).  Transplant(不管子节点)</p><p>The expected height of a randomly built binary search tree is $O(\lg{n})$.</p><p>B-trees are particularly good for maintaining databases on secondary(disk) storage</p><h4 id="Binary-search-tree-property"><a href="#Binary-search-tree-property" class="headerlink" title="Binary-search-tree property"></a>Binary-search-tree property</h4><p> If y is a node of left subtree of x, then $y.key \le x.key$.</p><p> If x is a node of right subtree of x, then $y.key \ge x.key$</p><h4 id="tree-walk"><a href="#tree-walk" class="headerlink" title="tree walk"></a>tree walk</h4><p>inorder tree walk   Inorder-tree-walk(T.root)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">INORDER-TREE-WALK(x)</span><br><span class="line">if x!=NIL</span><br><span class="line">INORDER-TREE-WALK(x.left)</span><br><span class="line">print x.key</span><br><span class="line">INORDER-TREE-WALK(x.right)</span><br></pre></td></tr></table></figure><p>如何证明其正确性<br>效率$\Theta(n) 用master直观 用替代法证明$</p><p>preorder tree walk</p><p>postorder tree walk.</p><h4 id="Tree-Search-and-Tree-Insert"><a href="#Tree-Search-and-Tree-Insert" class="headerlink" title="Tree-Search and Tree-Insert"></a>Tree-Search and Tree-Insert</h4><h4 id="Minimum-and-maximum"><a href="#Minimum-and-maximum" class="headerlink" title="Minimum and maximum"></a>Minimum and maximum</h4><h4 id="Successor-and-Predecessor"><a href="#Successor-and-Predecessor" class="headerlink" title="Successor and Predecessor"></a>Successor and Predecessor</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Tree-Successor(x)</span><br><span class="line">if x.right!=NIL</span><br><span class="line">return Tree-Minimum(x.right)</span><br><span class="line">y=x.p</span><br><span class="line">while y!=NIL &amp;&amp; x=y.right</span><br><span class="line">x=y</span><br><span class="line">y=x.p</span><br><span class="line">return y</span><br></pre></td></tr></table></figure><h4 id="Insertion-and-Deletion"><a href="#Insertion-and-Deletion" class="headerlink" title="Insertion and Deletion"></a>Insertion and Deletion</h4><p>插入找空位就可</p><p>删除分三种情况：没有孩子(直接删除)、有一个孩子(直接登基)、有两个孩子(找后继)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Transplant(T,u,v)</span><br><span class="line">if u.p==NIL</span><br><span class="line">T.root=v</span><br><span class="line">elseif u==u.p.left</span><br><span class="line">u.p.left=v</span><br><span class="line">else</span><br><span class="line">u.p.right=v</span><br><span class="line">if v!=NIL</span><br><span class="line">v.p=u.p</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Tree-Delete(T,z)</span><br><span class="line">if z.left==NIL</span><br><span class="line">Transplant(T,z,z.right)</span><br><span class="line">elseif z.right==NIL</span><br><span class="line">Transplant(T,z,z.left)</span><br><span class="line">else</span><br><span class="line">y=Tree-Minimum(z.right)</span><br><span class="line">if y.p!=z</span><br><span class="line">Transplant(T,y,y.right)</span><br><span class="line">y.right=z.right</span><br><span class="line">y.right.p=y</span><br><span class="line">Transplant(T,z,y)</span><br><span class="line">y.left=z.left</span><br><span class="line">y.left.p=y</span><br></pre></td></tr></table></figure><h3 id="Red-Black-Tree"><a href="#Red-Black-Tree" class="headerlink" title="Red Black Tree"></a>Red Black Tree</h3><h4 id="red-black-properties"><a href="#red-black-properties" class="headerlink" title="red-black properties"></a>red-black properties</h4><ol><li>Every node is either red or black</li><li>The root is black</li><li>Every leaf(NIL) is black</li><li>If a node is red, then both its children are black.</li><li>For each node, all simple paths from the node to descendant leaves contain the same number of black nodes.</li></ol><p>A red-black tree with n internal nodes has height at most $2\lg{n+1}$</p><h4 id="Rotations"><a href="#Rotations" class="headerlink" title="Rotations"></a>Rotations</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Left-Rotate(T,x)</span><br><span class="line">y=x.right</span><br><span class="line">x.right=y.left</span><br><span class="line">if y.left!=T.nil</span><br><span class="line">y.left.p=x</span><br><span class="line">y.p=x.p</span><br><span class="line">if x.p==T.nil</span><br><span class="line">T.root=y</span><br><span class="line">elseif x==x.p.left</span><br><span class="line">x.p.left=y</span><br><span class="line">else</span><br><span class="line">x.p.right=y</span><br><span class="line">y.left=x</span><br><span class="line">x.p=y</span><br></pre></td></tr></table></figure><p>In every n-node binary search tree, there are exactly n-1 possible rotations.</p><h4 id="Insertion"><a href="#Insertion" class="headerlink" title="Insertion"></a>Insertion</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">RB-INSERT(T,z)</span><br><span class="line">y=T.nil</span><br><span class="line">x=T.root</span><br><span class="line">while x!=T.nil</span><br><span class="line">y=x</span><br><span class="line">if z.key&lt;x.key</span><br><span class="line">x=x.left</span><br><span class="line">else x=x.right</span><br><span class="line">z.p=y</span><br><span class="line">if y==T.nil</span><br><span class="line">T.root=z</span><br><span class="line">elseif z.key&lt;y.key</span><br><span class="line">y.left=z</span><br><span class="line">else y.right=z</span><br><span class="line">z.left=T.nil</span><br><span class="line">z.right=T.nil</span><br><span class="line">z.color = RED</span><br><span class="line">RB-INSERT-FIXUP(T,z)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">RB-INSERT-FIXUP(T,z)</span><br><span class="line">while z.p.color==RED</span><br><span class="line">if z.p==z.p.p.left</span><br><span class="line">y=z.p.p.right</span><br><span class="line">if y.color==RED</span><br><span class="line">z.p.color=BLACK//case1</span><br><span class="line">y.color=BLACK//case1</span><br><span class="line">z.p.p.color=RED//case1</span><br><span class="line">z=z.p.p//case1</span><br><span class="line">else if z==z.p.right</span><br><span class="line">z=z.p//case2</span><br><span class="line">LEFT-ROTATE(T,z)//case2</span><br><span class="line">z.p.color=BLACK//case3</span><br><span class="line">z.p.p.color=RED//case3</span><br><span class="line">RIGHT-ROTATE(T,z.p.p)//case3</span><br><span class="line">else (same as then clause with &quot;right&quot; and &quot;left&quot; exchanged) </span><br><span class="line">T.root.color=BLACK</span><br></pre></td></tr></table></figure><h2 id="2-14-B树"><a href="#2-14-B树" class="headerlink" title="2-14 B树"></a>2-14 B树</h2><h2 id="Appendix-C"><a href="#Appendix-C" class="headerlink" title="Appendix C"></a>Appendix C</h2><p>Binomial bounds: C_n^k &gt;= (n/k)^k</p><p>对于自然数集N: <code>E[X]=\sum_{i=0}^{\infty} i*Pr{X=i} =\sum_{i=0}^{\infty} i*(Pr{X&gt;=i}-Pr{X&gt;=i+1}) = \sum_{i=1}^{\infty} Pr{X&gt;=i}</code></p><p>Var[X]=E[X^2]-E^2[X]</p><p>Var[aX]=a^2Var[X]</p><p>Var[X+Y]=Var[X]+Var[Y]</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;2018春问题求解笔记&quot;&gt;&lt;a href=&quot;#2018春问题求解笔记&quot; class=&quot;headerlink&quot; title=&quot;2018春问题求解笔记&quot;&gt;&lt;/a&gt;2018春问题求解笔记&lt;/h1&gt;&lt;h2 id=&quot;2-1-算法正确性-2018-3-7&quot;&gt;&lt;a href=&quot;#2-1-算法正确性-2018-3-7&quot; class=&quot;headerlink&quot; title=&quot;2-1 算法正确性(2018.3.7)&quot;&gt;&lt;/a&gt;2-1 算法正确性(2018.3.7)&lt;/h2&gt;&lt;p&gt;程序和算法不等同&lt;/p&gt;
&lt;p&gt;算法正确性是基础&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="https://ricky-ting.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>数字逻辑电路笔记</title>
    <link href="https://ricky-ting.github.io/2018/07/01/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E7%AC%94%E8%AE%B0/"/>
    <id>https://ricky-ting.github.io/2018/07/01/数字逻辑电路笔记/</id>
    <published>2018-07-01T04:55:38.000Z</published>
    <updated>2018-07-01T04:57:25.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数字逻辑电路笔记"><a href="#数字逻辑电路笔记" class="headerlink" title="数字逻辑电路笔记"></a>数字逻辑电路笔记</h1><p>给定输入 给出输出 用布尔逻辑实现</p><p>晶体管的开关特性是数字电路研究的重点。</p><p>数字逻辑中考虑电路模拟的特性，如时延问题。</p><p>数字设计中一些层次问题</p> <a id="more"></a><p>数字电路特性：</p><ul><li>稳定性好</li><li>速度快</li><li>集成度高且成本低</li><li>设计容易、功能灵活</li><li>可编程性</li></ul><p>模数转换：取样、量化 数模转换：合成</p><p>传输门？？？</p><p>摩尔定律即电子定律：集成电路的集成度每18个月翻一番（1965年）</p><p>超摩尔定律即光子定律：光纤传输的数据总量每9个月翻一番；</p><p>迈特卡夫Metcalfe定律：网络的价值与联网设备数（用户数）的平方关系成正比</p><p>时序逻辑 组合逻辑</p><h2 id="数制与编码"><a href="#数制与编码" class="headerlink" title="数制与编码"></a>数制与编码</h2><p>按位计数制(positional number system):加权</p><p>二进制八进制互转，二进制十六进制互转。</p><p>十进制转任意进制，任意进制转十进制。</p><p>除以基数去余法：倒序。 乘基数取整法：正序(到fraction为0，或达到最大有效位数)</p><h3 id="通用转换过程："><a href="#通用转换过程：" class="headerlink" title="通用转换过程："></a>通用转换过程：</h3><h4 id="算法1："><a href="#算法1：" class="headerlink" title="算法1："></a>算法1：</h4><p>A进制数N转换成B进制数。</p><ul><li>(a) 用B进制数取代展开序列中的数字，并计算结果，或</li><li>(b) 基于A进制运算，计算B基数的乘除法。</li></ul><h4 id="算法2："><a href="#算法2：" class="headerlink" title="算法2："></a>算法2：</h4><p>A进制数N转换成B进制数。</p><ul><li>(a) 用序列替代法将A进制数转换成10进制。</li><li>(b) 用基数乘除法，将10进制数转换成B进制数。</li></ul><p>各种数制之间的表达能力不一样，是否存在最强表达能力的数制？</p><p>符号位+数值的表示法，正数和负数个数相同，0有两个表示，但电路设计复杂。但一旦做了加法器，减法器就不用再做了。</p><p><strong>补码等于反码加1的证明</strong>：写成 反码=补码-1</p><p>补码 两次取补仍为原数 减去或取反加1 最高位权为负 符号扩展：将符号位扩展(如果是0，全补0，如果是1，全补1) 如果减小位数 从左边减，丢弃的位要与符号位相同。正数表示。</p><p>补码下： -2-(-8) 还是成立的  会不会判溢出？？？？</p><p>反码 ：    取反。对称和易于求反。</p><p>余码: 除符号位相反，对任何数，补码和余码两种表示法中的其他位都是一样的(仅适用于偏离为$2^{m-1}$的情况)。余码表示常用在浮点数系统中。余码表示用在浮点数系统中指数的表示。</p><h3 id="二进制补码的加法与减法"><a href="#二进制补码的加法与减法" class="headerlink" title="二进制补码的加法与减法"></a>二进制补码的加法与减法</h3><h4 id="加法："><a href="#加法：" class="headerlink" title="加法："></a>加法：</h4><p>忽略超过MSB的进位，只要不超过计数系统的范围，该结果就总是正确的和。</p><p>加法中有简便的规则判断溢出：如果加数的符号相同，而和的符号与加数的符号不同，则有加法的溢出。 不同符号的加数不会溢出</p><h4 id="减法："><a href="#减法：" class="headerlink" title="减法："></a>减法：</h4><p>减数取反，初始进位为1</p><h3 id="二进制反码的加法和减法"><a href="#二进制反码的加法和减法" class="headerlink" title="二进制反码的加法和减法"></a>二进制反码的加法和减法</h3><p>计数经过$1111_2$时要额外多加一个1. 循环进位(end-around carry).即符号位有进位则+1</p><p>溢出判断：异号相加不溢出，同号相加结果异号则溢出。或进位和符号位不一致。</p><h3 id="二进制补码的乘法"><a href="#二进制补码的乘法" class="headerlink" title="二进制补码的乘法"></a>二进制补码的乘法</h3><p>要在每一步做符号位扩展，最高位的权为负</p><h3 id="二进制补码的除法？？？"><a href="#二进制补码的除法？？？" class="headerlink" title="二进制补码的除法？？？"></a>二进制补码的除法？？？</h3><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><p>{对象集，码字集，编码方案}</p><h3 id="十进制数的二进制编码"><a href="#十进制数的二进制编码" class="headerlink" title="十进制数的二进制编码"></a>十进制数的二进制编码</h3><p>BCD编码又称8421码</p><p>加法需要修正：超过1001需要修正 要加6</p><p>2421码，是自反码。</p><p>余3码，也是自反码：BCD码+0011</p><p>二五混合码(biquinary code)</p><p>10中取1码(1-out-of-10 code)</p><h3 id="格雷码-Gray-code"><a href="#格雷码-Gray-code" class="headerlink" title="格雷码(Gray code)"></a>格雷码(Gray code)</h3><p>1) 镜像法: 1位格雷码有2个码字：0  1,<br>N+1位格雷码中的前$2^N$个码字是N位格雷码顺序排列，且前面加0。<br>N+1位格雷码中的后$2^N$个码字是N位格雷码逆序排列，且前面加1</p><p>2）相邻异或法: N位二进制数字从右向左，从0到n-1编号；<br>如果第i位和第i+1位相同，则对应格雷码的第i位为0，否则为1。</p><p>编码:{对象集，码字集，编码方案}</p><h3 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h3><p>ASCII</p><h3 id="动作、条件和状态的编码"><a href="#动作、条件和状态的编码" class="headerlink" title="动作、条件和状态的编码"></a>动作、条件和状态的编码</h3><p>n中取1码，n中取m码</p><h3 id="n维体与距离"><a href="#n维体与距离" class="headerlink" title="n维体与距离"></a>n维体与距离</h3><p>寻找Gray code即寻找一条遍历所有点的路径。</p><p>汉明距离(Hamming distance)</p><p>n维体的m维子集(m-subcube)</p><h3 id="检错码和纠错码"><a href="#检错码和纠错码" class="headerlink" title="检错码和纠错码"></a>检错码和纠错码</h3><p>差错模式(error model) 独立差错模式(independent error model):单一物理故障只影响单一的数据位。</p><h4 id="检错码-error-detecting-code"><a href="#检错码-error-detecting-code" class="headerlink" title="检错码(error-detecting code)"></a>检错码(error-detecting code)</h4><p>最小汉明距离$ge$2</p><p>奇偶校验位(parity bit)</p><h4 id="纠错码与多重检错码"><a href="#纠错码与多重检错码" class="headerlink" title="纠错码与多重检错码"></a>纠错码与多重检错码</h4><p>待看课件 不理解 ？？？<br>纠错准则？</p><h4 id="汉明码"><a href="#汉明码" class="headerlink" title="汉明码"></a>汉明码</h4><p>纠1位错 判两位错</p><p>位置是2的幂的那些位都是校验位，其余为信息位。校验矩阵(parity-check matrix) </p><p>偶校验</p><p>最小距离为3的编码</p><p>对于任意i值，可产生2^i-1位的编码，其中包含i个校验位，2^i-i-1个信息位。</p><p>信息位长度D增加时，检验位长度P增长缓慢: 2^P &gt;= P+D+1</p><h4 id="循环冗余校验码-cyclic-redundancy-check-CRC"><a href="#循环冗余校验码-cyclic-redundancy-check-CRC" class="headerlink" title="循环冗余校验码(cyclic-redundancy-check,CRC)"></a>循环冗余校验码(cyclic-redundancy-check,CRC)</h4><p>两个重要的应用是磁盘驱动器和数据网络</p><h4 id="二维码-two-dimensional-code"><a href="#二维码-two-dimensional-code" class="headerlink" title="二维码(two-dimensional code)"></a>二维码(two-dimensional code)</h4><p>一个重要的应用是用在RAID储存系统中。RAID表示(redundant array of inexpensive disks)</p><p>BCD加法减法</p><p>每个位元出现在传输线上的实际信号格式取决于线路码（line code）。</p><h4 id="校验和码"><a href="#校验和码" class="headerlink" title="校验和码"></a>校验和码</h4><h3 id="补充：变长编码-待拓展？？？"><a href="#补充：变长编码-待拓展？？？" class="headerlink" title="补充：变长编码 待拓展？？？"></a>补充：变长编码 待拓展？？？</h3><p>原理：基于概率分布特性,采用可变字长编码.</p><p>Huffman编码：</p><ul><li>每个编码均非其它码的前缀，因此唯一可译</li><li>简单,易实现</li><li>编码效率较高(但还不是最高的，参考JPEG)</li></ul><h2 id="组合逻辑设计原理"><a href="#组合逻辑设计原理" class="headerlink" title="组合逻辑设计原理"></a>组合逻辑设计原理</h2><h3 id="布尔代数"><a href="#布尔代数" class="headerlink" title="布尔代数"></a>布尔代数</h3><p>一致律(冗余项): XY+X’Z+YZ=XY+X’Z  (X+Y)(X’+Z)(Y+Z)=(X+Y)(X’+Z)</p><p>1.代入定理：所谓代入定理，是指在逻辑等式中任何一个变量A，都可以用任意逻辑表达式代入，则等式仍然成立。</p><p>2.反演定理：所谓反演定理，是指对于任意一个逻辑式Y，若将其中所有的“·”与“+”互换，“0”和“1”互换，原变量与反变量互换，则得到的结果就是原函数的反函数  Y’  。</p><p>3.对偶定理： 若两逻辑式相等，则它们的对偶式也相等，这就是对偶定理。所谓对偶式，即：对于任何一个逻辑式Y，若将其中的“·”与“+”互换，“0”和“1”互换，则得到Y的对偶式YD，或者Y与YD互为对偶式。？？？？？？</p><p>逻辑函数化简基本方法：</p><ul><li>并项法: AB+A’B=B</li><li>吸收法: AB+B=B</li><li>消去法: A+A’B=A+B</li><li>配项法: AB+A’C+BC=AB+A’C</li><li>摩根定理</li></ul><h3 id="组合逻辑"><a href="#组合逻辑" class="headerlink" title="组合逻辑"></a>组合逻辑</h3><p>逻辑电路分为两大类：“组合的”和“时序的”. 组合逻辑电路(combinational logic circuit) 和 时序逻辑电路(sequential logic circuit)。</p><p>电路的分析和设计</p><p>正逻辑和负逻辑</p><p>完备归纳法(perfect induction)</p><p>一致性定理有两个重要的应用:在组合逻辑电路中，它可以用来去掉某些定时冒险;也是用于寻找主蕴涵项的迭代一致法的基础。</p><p>与非=非或,可以用CMOS直接实现</p><p>对偶性原理：可以运用对偶性原理证明广义德摩根定理。（待加深 P135）</p><p>逻辑函数的标准表示法：</p><ul><li>文字(literal): 一个自变量或反变量</li><li>乘积项(product term):单个文字或2个以上文字的逻辑积</li><li>“积之和”表达式(sum-of-products expression):是乘积项的逻辑和</li><li>求和项(sum term):单个文字或2个以上文字的逻辑和</li><li>“和之积”表达式(product-of-sum expression):求和项的逻辑积</li><li>标准项(normal term):是一个乘积项或求和项，每个变量当且仅当只出现一次</li><li>n变量最小项(minterm):是具有n个文字的标准乘积项</li><li>n变量最大项(maxterm):是具有n个文字的标准求和项</li><li>主蕴含项</li><li>质主蕴含项</li><li>奇异1：只被单一主蕴含项覆盖的输入组合</li></ul><p>和之积表达式？？？？</p><p>相同变量相同编号的最小项和最大项互为反函数。</p><p>时延问题</p><p>多类门技术中，类似与非门和或非门那样的带取反的门比不取反的门要快。</p><p>证明反演定理，曾考过？？？？ 反演定理是否是对偶定理的一个推论</p><p>ASIC设计和PLD设计中，化简都很重要</p><p>考试可能栽在配项法</p><p>电路分析最后一步：通常情况下描述电路的功能：投票电路，校验电路，加法器</p><p>设计：一般</p><h4 id="卡诺图化简："><a href="#卡诺图化简：" class="headerlink" title="卡诺图化简："></a>卡诺图化简：</h4><ul><li>如何化简逻辑函数——最小化： (主蕴涵项)定理：最简“积之和”是主蕴涵项之和(为什么不是质主蕴含项的和)</li><li>蕴涵项： 任何积项都称为蕴涵项，与卡诺图中的圈对应</li><li>主蕴含项：定义若逻辑函数的积项P再也不能同其它积项合并以组成变量个数更少的积项，则称P为主蕴涵项，对应卡诺图中最大的圈</li><li>质主蕴涵项： 定义：不能被其它蕴涵项代替的主蕴涵项；至少包含一个不能被其它任何主蕴涵项所覆盖的最小项</li><li>覆盖：若逻辑函数的所有最小项被1组蕴涵项所包含，则该组蕴涵项称为函数的1个覆盖</li><li>最小覆盖： 是1个包含最少主蕴涵项和最少符号数的覆盖</li></ul><p>奎因——穆克鲁斯基算法(Quine-McCluskey algorithm)</p><h3 id="定时冒险"><a href="#定时冒险" class="headerlink" title="定时冒险"></a>定时冒险</h3><p>一个信号，以两种形式出现在输出端，因传输时间不同，使二者某段时间不具有相应逻辑关系，造成错误输出，称为冒险或险象（ Hazard ）</p><p>竞争：门电路的两个输入端同时向相反的逻辑电平跳变。</p><h4 id="静态冒险"><a href="#静态冒险" class="headerlink" title="静态冒险"></a>静态冒险</h4><p>静态冒险(Static hazard) ：一个周期内，输出只出现一次瞬时改变。</p><p>静态-1型冒险：在输出1的过程中，出现0尖峰。通常产生于最小项生成电路中</p><p>静态-0型冒险：通常产生于最大项生成电路中</p><p>利用卡诺图发现静态冒险：卡诺图检测：在卡诺图中存在两个质主蕴涵项相切，当从一个质主蕴涵项向另一个转换时，一旦有传递延迟，则产生险态。</p><p>消除冒险：添加一致项consensus:增加新的质蕴涵项，覆盖相切的两个质蕴涵。</p><p>动态冒险：一个输入转变一次而引起输出变化多次。由于多个不同的延迟路径所产生。</p><p>2、3、4变量的卡诺图：不断翻折    </p><h3 id="无关项处理"><a href="#无关项处理" class="headerlink" title="无关项处理"></a>无关项处理</h3><p>禁止态检测电路通常是必须的, 若不影响电路运行,此时可不必刻意区分禁止态和其它状态，可以处理成0，也可以处理成1，按照化简的需要酌情确定。</p><h3 id="QM算法"><a href="#QM算法" class="headerlink" title="QM算法"></a>QM算法</h3><h2 id="组合逻辑设计实践"><a href="#组合逻辑设计实践" class="headerlink" title="组合逻辑设计实践"></a>组合逻辑设计实践</h2><p>有时要求输入变量只能用原变量形式，可作相应的变换</p><h3 id="设计文档"><a href="#设计文档" class="headerlink" title="设计文档"></a>设计文档</h3><p>设计文档是项目设计正确、可维护的重要基础。</p><p>设计文档可以是综合性的单文档描述，也可以是分列的多文档描述形态。</p><ul><li>规格说明书：准确描述电路或系统的输入、输出及功能。主要是外部特性的描述。</li><li>方框图：系统主要功能模块及其基本互连的非正式图示描述。展示系统的输入、输出，功能模块、内部数据通路和重要的控制信号</li><li>原理图：系统的电气元件、元件间互连和构建系统所需的全部细节的正式说明，包括IC类型、参考标志符和引脚编号。（和常说的逻辑图不同）能够生成生产用的材料清单。</li><li>定时图：说明各种逻辑信号的值随时间的变化情况。关键信号之间的因果延迟。</li><li>结构化逻辑器件描述：描述PLD、FPGA或者ASIC的内部功能设计。通常用HDL描述；也可以用逻辑表达式、状态表、状态图等形式。</li><li>电路描述：电路功能设计的描述性文本，和其它文档一起解释电路的工作原理。应该包括设计的假设、限制等。</li></ul><p>方框图：</p><ul><li>能展示最重要的系统元素以及工作原理。</li><li>每个方框图不要超过1页。</li><li>大型系统可以另附页描述子系统。</li><li>重要的控制信号和总线要命名。</li><li>明确表明控制流和数据流。</li><li>不要包含细节。</li></ul><p>圏到圈逻辑设计(目的：使用包含有效电平标识的逻辑符号或信号命名方式使得逻辑电路更容易理解。)</p><h3 id="可编程逻辑器件"><a href="#可编程逻辑器件" class="headerlink" title="可编程逻辑器件"></a>可编程逻辑器件</h3><p>PLA:</p><p>PAL:或门阵列固定、与门阵列可编程、双向输入/输出引脚。</p><p>GAL通用阵列逻辑：GAL16V8是一个时序逻辑器件，但可以编程设置为组合逻辑器件。此时，其结构和PAL16L8类似。多了一个输出极性控制的异或门。</p><p>CPLD复杂可编程逻辑器件：是将多个PLD集成到单个芯片上，并提供可编程的互连和输入/输出结构。可以把CPLD的基本结构看成由可编程逻辑阵列（LAB）、可编程I/O控制模块和可编程内部连线（PIA）等三部分组成。</p><h3 id="译码器"><a href="#译码器" class="headerlink" title="译码器"></a>译码器</h3><p>译码器的输出编码通常比其输入编码位数多</p><p>真值表</p><p>逻辑图</p><p>上低下高</p><p>2-4译码器 3-8译码器 级联二进制译码器：4-16译码器 5-32译码器</p><p>译码器的级联</p><p>七段显示译码器</p><p>半导体显示：LED 液晶显示：LCD</p><h3 id="编码器"><a href="#编码器" class="headerlink" title="编码器"></a>编码器</h3><p>器件的输出编码比其输入编码位数少</p><p>8-3编码器</p><p>3位二进制优先编码器：允许几个信号同时输入，但只对优先级别最高<br>的进行编码</p><h3 id="三态器件"><a href="#三态器件" class="headerlink" title="三态器件"></a>三态器件</h3><p>三态缓冲器</p><p>三态器件允许多个信号源共享单个线路</p><h4 id="三态缓冲器"><a href="#三态缓冲器" class="headerlink" title="三态缓冲器"></a>三态缓冲器</h4><p>三态门进入和离开高阻态的延迟时间不同，会造成输出线路上值的混乱，造成同时驱动的冲突现象。解决的方法：设计控制逻辑，保证一段截止时间（dead time），这段时间不应该有任何器件驱动同线。</p><h3 id="数据选择器-多路选择器"><a href="#数据选择器-多路选择器" class="headerlink" title="数据选择器(多路选择器)"></a>数据选择器(多路选择器)</h3><p>一种多路输入，单路输出的逻辑构件。</p><p>2-1 multiplexer</p><p>n个输入变量 需要m=log n 个控制信号</p><p>多路选择器除完成对多路数据进行选择的基本功能外，在逻辑设计中主要用来实现各种逻辑函数功能。用多路选择器实现分时多路转换电路。(将并行输入的数据转换成串行输出)。</p><p>方法I：用具有n个选择变量的MUX实现n个变量的函数。</p><p>方法Ⅱ：用具有n-1个选择控制变量的MUX实现n个变量函数功能：即从函数的n个变量中任n-1个作为MUX的选择控制变量，并根据所选定的选择控制变量将函数变换成F=∑miDi的形式，以确定各数据输入Di。假定剩余变量为X，则Di的取值只可能是0、1、X或X’四者之一。</p><p>把并行处理的数据放在Di端上。在地址端上，周期性的循环加载 00-&gt;01-&gt;10-&gt;11  如此，在输出端上，顺序地送出原先并行的数据。</p><h3 id="数据分配器-Demultiplexers"><a href="#数据分配器-Demultiplexers" class="headerlink" title="数据分配器(Demultiplexers)"></a>数据分配器(Demultiplexers)</h3><p>其功能和多路数据选择器相反。是一种单路输入，多路输出的逻辑构件。从哪一端输出依赖于当时的地址控制端输入。</p><p>【例】利用DMUX和MUX设计一个实现8路数据传输的逻辑电路。 </p><p>多路分配器常与多路选择器联用，以实现多通道数据分时传送。通常在发送端由MUX将各路数据分时送上公共传输线(总线)，接收端再由DEMUX将公共线上的数据适时分配到相应的输出端。</p><p>大扇出处理：每个输出端增加一个三态缓冲</p><p>扇入系数大会有什么影响？</p><h3 id="校验电路"><a href="#校验电路" class="headerlink" title="校验电路"></a>校验电路</h3><p>异或门和异或非门 用与或非三个门或者用与非门实现</p><p>奇偶校验电路</p><p>奇偶校验器件74x280:9个输入 2个输出</p><p>chapter6-3 ppt 第七张重点</p><p>奇偶校验应用：7位海明码纠错电路。</p><h3 id="比较器"><a href="#比较器" class="headerlink" title="比较器"></a>比较器</h3><p>两种类型：比较器  大小比较器</p><p>大小比较器</p><p>内部电路图</p><p>级联</p><p>74x682 只有相等和大于输出  扩展判断输出</p><h3 id="加法器、减法器和ALU"><a href="#加法器、减法器和ALU" class="headerlink" title="加法器、减法器和ALU"></a>加法器、减法器和ALU</h3><p>ALU:可以根据操作码完成加法、减法等运算功能的电路。</p><p>行波进位加法器 属于迭代电路 延迟： t add = t XYCout + (n-2) tCinCout +tCinS</p><p>用加法器实现减法器</p><p>chapter6-3 第33张ppt存疑</p><p>chapter6-3 第35张ppt存疑 如何化简</p><p>74x283(4位先行进位加法器) ’283的进位信号c0到c4的延迟很短相当于2个反相门，可以级联扩展计算位数，组间串行进位加法器</p><p>74x181 4位ALU</p><p>组间先行进位：不同于组间串行进位，先行进位信号直接由输入的操作数决定，没有组间串行的进位信号。</p><h3 id="组合乘法器"><a href="#组合乘法器" class="headerlink" title="组合乘法器"></a>组合乘法器</h3><p>移位-累加算法的电路实现：最坏20级延迟 延迟估计  进位保留加法(14级延迟)？？？？</p><h2 id="时序逻辑"><a href="#时序逻辑" class="headerlink" title="时序逻辑"></a>时序逻辑</h2><p>时序电路的输出不仅取决于当前的输入，而且取决于过去的输入序列（状态）。</p><p>状态：是一个状态变量集合。包含了在当前输入的基础上预测当前输出的所有的历史信息。</p><p>时序电路的状态个数有限：有限状态机</p><p>有效电平：通常在时钟的触发沿内状态发生改变。</p><p>时钟周期tper、时钟频率、时钟触发沿、占空比</p><h3 id="时序电路的类型"><a href="#时序电路的类型" class="headerlink" title="时序电路的类型"></a>时序电路的类型</h3><ul><li>反馈时序电路：采用普通门电路和反馈回路来实现逻辑电路中的记忆能力，由此构成时序逻辑电路</li><li>时钟同步时序电路：也采用逻辑构件来构建电路，但输入由统一的时钟信号控制。</li><li>其它类型：通用基本型、多脉冲型等</li></ul><h3 id="双稳态器件"><a href="#双稳态器件" class="headerlink" title="双稳态器件"></a>双稳态器件</h3><p>所谓的双稳态元件（或者电路），是指电路有两个稳定的状态，即置位状态和复位状态。Q为1的状态称为置位状态，而Q为0的状态称为复位状态。</p><p>双稳态电路的内在特性(inherent)</p><ul><li>2 稳定点（stable points）</li><li>1亚稳定点（metastable point）</li></ul><p>亚稳态，非有效的逻辑信号，但满足回路方程</p><p>任何时序电路都存在亚稳态现象</p><ul><li>开机：存在亚稳态</li><li>工作：外部激励必须满足最短时间要求, 才能生效, 否则…</li></ul><h3 id="单稳态"><a href="#单稳态" class="headerlink" title="单稳态"></a>单稳态</h3><p>to be or not to be</p><h3 id="锁存器与触发器"><a href="#锁存器与触发器" class="headerlink" title="锁存器与触发器"></a>锁存器与触发器</h3><ul><li>时序电路的基本构件。</li><li>都是双稳态元件。</li><li>锁存器(Latch)：连续地监测其输入，并且独立于时钟信号而在任何时候都可以改变输出</li><li>触发器(Flip-Flop)：连续地监测输入信号，并只在时钟信号所确定的时刻改变其输出</li></ul><h4 id="RS锁存器"><a href="#RS锁存器" class="headerlink" title="RS锁存器"></a>RS锁存器</h4><p>S置位 R 复位  S=R=1时,Q=QN=0   S=R=0时,Q=last Q, QN=last QN  R和S不能同时取消，否则会导致震荡状态或亚稳态</p><p>输入信号宽度必须大于最小脉冲宽度</p><h4 id="R’-S’锁存器"><a href="#R’-S’锁存器" class="headerlink" title="R’-S’锁存器"></a>R’-S’锁存器</h4><p>R非S非锁存器：低态有效的置位和复位，可以用与非门实现。</p><h4 id="具有使能端的RS锁存器"><a href="#具有使能端的RS锁存器" class="headerlink" title="具有使能端的RS锁存器"></a>具有使能端的RS锁存器</h4><p>S-R Latch with Enable, 带使能端的RS锁存器(RS闩锁)<br>受使能信号控制，C为写入条件或指令</p><h4 id="D锁存器"><a href="#D锁存器" class="headerlink" title="D锁存器"></a>D锁存器</h4><p>数据经非门产生一对互补信号，D型锁存器(D Latch)</p><p>建立时间(Set-up time) 保持时间(Hold time)</p><h4 id="如何实现边沿触发"><a href="#如何实现边沿触发" class="headerlink" title="如何实现边沿触发"></a>如何实现边沿触发</h4><p>用 to be or not to be 电路</p><h4 id="边沿触发式-Edge-Triggered-触发器"><a href="#边沿触发式-Edge-Triggered-触发器" class="headerlink" title="边沿触发式(Edge Triggered)触发器"></a>边沿触发式(Edge Triggered)触发器</h4><p>只在时钟信号的上升沿或者下降沿改变状态</p><h4 id="主从D触发器-存疑"><a href="#主从D触发器-存疑" class="headerlink" title="主从D触发器  存疑"></a>主从D触发器  存疑</h4><p>第1个锁存器称为主(master)锁存器，第2个称为从(slave)锁存器。</p><p>传播延迟 (from CLK) 建立时间 (D before CLK) 保持时间 (D after CLK)</p><p>具有预置和清零端的正边沿D触发器</p><p>具有使能端的边沿触发式D触发器</p><h4 id="扫描触发器"><a href="#扫描触发器" class="headerlink" title="扫描触发器"></a>扫描触发器</h4><p>扫描触发器除了D输入端以外，还有两个输入端。</p><p>TI即Test Input，用来输入测试序列（测试向量）。</p><p>TE即Test Enable，用来控制触发器工作状态。</p><h4 id="主从式触发器"><a href="#主从式触发器" class="headerlink" title="主从式触发器"></a>主从式触发器</h4><ul><li>在时钟脉冲信号高电平期间数据进入触发器，在下降沿输出反映输入的变化</li><li>主从式触发器也称为脉冲触发型触发器(Pulse Triggered Flip-flops)</li><li>为了使得输出能正确地反映输入的变化，要求在时钟脉冲信号为高期间，输入不发生变化。</li><li>其特点是数据在第一个边沿锁入触发器，第二个边沿后数据出现在输出端。</li><li>主从式触发器基本上已经被边沿触发式触发器所取代。</li></ul><h4 id="主从式JK触发器"><a href="#主从式JK触发器" class="headerlink" title="主从式JK触发器"></a>主从式JK触发器</h4><p>同时有效则翻转</p><p>在触发脉冲的后沿，JK输入的状态变化可能无效。 使用中，尽量保持JK稳定</p><p>0钳位 1钳位????</p><h4 id="边沿触发式JK触发器"><a href="#边沿触发式JK触发器" class="headerlink" title="边沿触发式JK触发器"></a>边沿触发式JK触发器</h4><p>解决主从JK触发器中1和0钳位的问题。</p><p>在上升沿时采样输入信号。</p><h4 id="T触发器"><a href="#T触发器" class="headerlink" title="T触发器"></a>T触发器</h4><ul><li>T触发器：在每一个时钟脉冲的有效边沿都会改变状态。</li><li>常用在计数器和分频器。</li><li>具有使能端的T触发器</li></ul><h4 id="维持-阻塞D触发器"><a href="#维持-阻塞D触发器" class="headerlink" title="维持-阻塞D触发器"></a>维持-阻塞D触发器</h4><h4 id="锁存器和触发器的描述"><a href="#锁存器和触发器的描述" class="headerlink" title="锁存器和触发器的描述"></a>锁存器和触发器的描述</h4><h5 id="特征方程"><a href="#特征方程" class="headerlink" title="特征方程"></a>特征方程</h5><p>SR锁存器： Q* = S + R’Q</p><p>JK触发器： Q* = JQ’ + K’Q</p><p>T触发器： Q* = Q’</p><p>D触发器： Q* = D</p><h3 id="状态转移图"><a href="#状态转移图" class="headerlink" title="状态转移图"></a>状态转移图</h3><ul><li>用来描述电路状态，也可以对现实世界中任何有状态的事物进行建模</li><li>列举出该事物所有可能的状态，每个状态用一个圈表示</li><li>状态之间可以相互转换。状态转换用带箭头的弧线表示。</li><li>在弧线上标明状态发生变化的条件（即系统的输入）。也可以标明该状态转移导致的结果（输出）。</li></ul><h3 id="时钟控制时序逻辑电路分析"><a href="#时钟控制时序逻辑电路分析" class="headerlink" title="时钟控制时序逻辑电路分析"></a>时钟控制时序逻辑电路分析</h3><p>Sequential-Circuit：组合逻辑+记忆电路</p><ul><li>同步时序电路（Synchronous Sequential Logic）</li><li>异步时序电路（Asynchronous Sequential Logic）</li></ul><p>Synchronous Sequential Logic</p><ul><li>统一时钟驱动，触发时刻更新记忆电路状态</li><li>状态转移图描述</li><li>设计方法、工具相对规范成熟</li></ul><p>Asynchronous Sequential Logic</p><ul><li>状态变化时刻不一致</li><li>状态转移图描述</li><li>异步电路多用在接口电路设计方面</li></ul><h4 id="同步时序电路的类型"><a href="#同步时序电路的类型" class="headerlink" title="同步时序电路的类型"></a>同步时序电路的类型</h4><p>按照输出方程的不同，分为：</p><ul><li>Mealy型电路(Mealy State Machine)： 某时刻输出是该电路当前时刻输入和当前状态的函数</li><li>Moore型电路(Moore State Machine)：某时刻输出仅是该电路当前状态的函数，与当前时刻的输入无关，如某些计数器</li></ul><h4 id="状态机分析的步骤"><a href="#状态机分析的步骤" class="headerlink" title="状态机分析的步骤"></a>状态机分析的步骤</h4><ol><li>确定下一状态函数F和输出函数G</li><li>用F和G构造状态/输出表(state/output table)，列出所有当前状态和输入的组合，指定电路的下一状态和输出</li><li>画出状态图（state diagram）。</li><li>描述电路的功能。</li></ol><h4 id="状态图"><a href="#状态图" class="headerlink" title="状态图"></a>状态图</h4><p>State Diagram(状态图)中，离开某个特定状态的所有转移条件，满足:</p><ul><li>Mutually Exclusive(互斥性)，每种输入组合都有唯一的下一状态。否则相同输入组合对应不同的下一状态(二义性)</li><li>All Inclusion(完备性)，所有输入组合都有确定的下一状态(有时需要根据设计需求，在不违背题意的前提下作出合理安排)</li><li>称为完全确定的时序电路</li></ul><h4 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h4><ul><li>利用转移、状态和输出表，可构造定时图</li><li>定时图：表示出状态机在任何期望的起始状态和输入序列的作用下所产生的行为。</li></ul><h4 id="同步时序电路的分析步骤"><a href="#同步时序电路的分析步骤" class="headerlink" title="同步时序电路的分析步骤"></a>同步时序电路的分析步骤</h4><ol><li>写出各触发器的激励方程。</li><li>把得到的激励方程代入到触发器的特征方程，得到转移方程/次态方程。</li><li>确定输出方程。</li><li>根据转移方程构造转移表，在转移表中对每一种状态/输入组合添加输出值，构成状态/输出表</li><li>利用状态名得到时序电路的状态图。</li><li>画出时序图。</li></ol><h3 id="时钟同步状态机设计"><a href="#时钟同步状态机设计" class="headerlink" title="时钟同步状态机设计"></a>时钟同步状态机设计</h3><ol><li>根据文字描述，构造状态/输出表</li><li>（可选）将状态/输出表中的状态数目最小化</li><li>状态赋值，选择一组状态变量编码组合赋给状态</li><li>将状态变量组合代入状态/输出表，建立转移/输出表。</li><li>选择一种触发器作为状态存储器</li><li>构造激励表</li><li>由激励表推导出激励方程</li><li>由转移/输出表推导出输出方程</li><li>画出逻辑电路图。</li></ol><h4 id="状态化简"><a href="#状态化简" class="headerlink" title="状态化简"></a>状态化简</h4><p>等价状态：设状态S1和S2是完全确定状态表中的两个状态,如果对于所有可能的输入序列，分别从状态S1    和状态S2出发，所得到的输出响应序列完全相同，    则状态S1和S2是等价的，记作(S1, S2) .    或说，状态S1和S2是等价对。等价状态可以合并。</p><p>等价状态具有传递性 </p><p>等价类：彼此等价的状态集合</p><p>状态简化的任务是要在原始状态表中找出全部最大等价类(最大等价类集合)，并将每一个最大等价类用一个状态来表示。</p><p>假定状态S1和S2是完全确定原始状态表中的两个现态，那么S1和S2等价的条件可归纳为在输入的各种取值组合下：</p><ul><li>第一、它们的输出完全相同；</li><li>第二、它们的次态满足下列条件之一，即：(1) 次态相同；(2) 次态交错 (3) 次态循环 (4) 次态对等价</li></ul><p>隐含表法化简</p><h5 id="不完全确定状态表的简化"><a href="#不完全确定状态表的简化" class="headerlink" title="不完全确定状态表的简化"></a>不完全确定状态表的简化</h5><p>不完全确定状态表： 状态表中存在不确定的次态或输出，这些不确定的次态或输出将有利于状态简化。</p><p> 相容状态：设状态S1和S2是不完全确定状态表中    的两个状态，如果对于所有的有效输入序列，分别从状态S1和S2出发，所得到的输出响应序列(除不确定的那些位之外)是完全相同的，那么状态S1和S2是相容的，或者说状    态S1和S2是相容对，记作(S1,S2)。相容状态可以合并。</p><p> 状态相容无传递性</p><p> 相容类：彼此相容的状态集合  最大相容类：不被其他相容类所包含的相容类</p><p>作最小化状态表: 最小化状态表(又称最小闭覆盖) 应满足下列三个条件：</p><ul><li>覆盖性－－所选相容类集合应包含原始状态表中    的全部状态。</li><li>最小性－－所选相容类集合中相容类的个数应最    少。</li><li>闭合性－－所选相容类集合中的任一相容类，在    原始状态表中任一输入条件下产生的次态应    该属于该集合中的某一个相容类。</li></ul><h4 id="状态赋值-状态编码"><a href="#状态赋值-状态编码" class="headerlink" title="状态赋值(状态编码)"></a>状态赋值(状态编码)</h4><ul><li>确定表示状态表的状态需要多少位二进制变量，并且对每一个已命名的状态赋予一个特定的组合（编码）。</li><li>状态编码(coded state)：赋给一个特定状态的二进制数的组合。</li></ul><p>状态分配方案的种数：排列数计算</p><p>如果两种状态分配在实现逻辑时产生相同的结果，则认为它们是等价的。状态编码分配互补，或状态编码左右互换，都是等价的。</p><p>独立状态数: N=(2^K - 1)! / ((2^K-n)!K!)</p><p>在同步时序电路中状态分配目的在于：在逻辑化简时，生成尽可能大的必要质蕴含。状态分配的标准就是使得质蕴含达到最大程度。寻找较好的结果。</p><p>状态编码：从2^n种可能组合中选择S种编码</p><p>遗憾的是：至今没有找到普遍有效的算法实现最佳状态分配，唯一途径是将所有分配方案都试个遍</p><p>次佳状态分配方案：相邻状态分配法，建立通用方程法，减少相关性</p><h5 id="次佳状态分配方案"><a href="#次佳状态分配方案" class="headerlink" title="次佳状态分配方案"></a>次佳状态分配方案</h5><p>相邻状态分配法</p><ul><li>次态相同，现态相邻: 使下一个状态较少依赖于当前状态变量</li><li>同一现态，次态相邻：使下一状态较少依赖于输入变量</li><li>输出相同，现态相邻：使输出较少依赖于当前状态变量</li></ul><h5 id="处理未用状态方法"><a href="#处理未用状态方法" class="headerlink" title="处理未用状态方法"></a>处理未用状态方法</h5><p>最小风险法 最小成本法</p><h4 id="反馈时序电路"><a href="#反馈时序电路" class="headerlink" title="反馈时序电路"></a>反馈时序电路</h4><p>异步时序电路特征：状态变化不受“统一时钟信号控制”</p><p>依电路结构和输入信号形式不同，异步时序电路分类：</p><ul><li>脉冲型Pulsed Asynchronous Circuit(脉冲信号):记忆电路为“触发器”</li><li>电平型Level Asynchronous Circuit(电平信号)：记忆电路为“反馈加延时”</li></ul><p>双稳态电路、锁存器和触发器等都是反馈时序电路。反馈回路是记忆元件，存储0或1。</p><p>基本模式电路，对输入信号的约束：</p><ul><li>不允许两个或两个以上输入同时变化(每时刻仅允许1个输入发生变化)</li><li>仅当电路处于稳态时，允许输入信号发生变化</li></ul><h5 id="反馈时序电路的分析步骤"><a href="#反馈时序电路的分析步骤" class="headerlink" title="反馈时序电路的分析步骤"></a>反馈时序电路的分析步骤</h5><ul><li>切断反馈路径，写出激励函数和输出函数</li><li>列出状态转移表</li><li>作出状态图和时序(间)图</li><li>说明电路的逻辑功能</li></ul><h5 id="反馈时序电路的分析"><a href="#反馈时序电路的分析" class="headerlink" title="反馈时序电路的分析"></a>反馈时序电路的分析</h5><ul><li>现态和次态只是在时间上有延迟，经过一段时间后，现态和次态的值趋于一致。</li><li>总态Total State：用来描述异步时序机的行为。包括输入状态I和次态S，并记为(I，S)。</li><li>稳定状态：如某一现态y在输入x发生变化时，若次态Y和现态y的值相同，则称次态Y为稳定状态；若次态Y和现态y的值不等，则称进入的次态Y为不稳定状态。不稳定状态是不能保持不变，经过一段延迟时间后，现态和次态趋于一致，进入稳定状态，则称为状态迁移。</li><li>状态表：状态命名，且将稳定的总状态用圆圈圈住。</li><li>总态可以是稳定的也可以是不稳定的，不稳定的总态要发生状态迁移，而达到一个稳定的状态或循环不稳态。稳定的总态，如果输入不改变，则始终保存稳定状态，不会发生状态迁移。</li><li>异步电路的基本工作方式是保证电路稳定工作，使电路状态的转移是可以预测的。</li><li>输入状态的改变仅能引起次态在状态表作相邻方格的水平移动。</li><li>二次状态的改变则引起次态在状态表中作垂直方向的移动。</li></ul><p>多反馈回路中，必须断开所有的反馈，设置虚构的缓冲器和状态变量。</p><p>最小割集(cut set)：断点数最少的集合</p><h5 id="竞争"><a href="#竞争" class="headerlink" title="竞争"></a>竞争</h5><p>一个输入信号的变化，引起多个内部状态变量改变，称之为发生了竞争</p><ul><li>非临界竞争(Noncritical race)，最终状态与状态变量变化顺序无关，结果可预测。</li><li>临界竞争(Critical race)，最终状态取决于状态变量变化顺序和速度，结果不可预测。</li></ul><p>对于竞争的处理</p><ul><li>允许非临界竞争</li><li>避免临界竞争</li></ul><h5 id="状态表与流程表"><a href="#状态表与流程表" class="headerlink" title="状态表与流程表"></a>状态表与流程表</h5><ul><li>状态表：状态命名，且将稳定的总状态用圆圈圈住。</li><li>跳程hop：单个输入变量变化时，电路达到新的稳定总状态时所发生的不稳定的状态。</li><li>流程表Flow table：由现态和在不同输入条件下的次态及输出组成。删除状态表中的跳程，只表示出每次转移过程的最终目标，去除未用内部状态的那些行，去掉那些稳定的总状态在单个输入变化时从不会到达的下一状态项。</li></ul><h4 id="反馈时序电路设计"><a href="#反馈时序电路设计" class="headerlink" title="反馈时序电路设计"></a>反馈时序电路设计</h4><ol><li>根据逻辑要求，建立原始流程表</li><li>将原始状态表简化，得到最简流程表</li><li>对最简流程表进行状态分配</li><li>建立激励表和输出表</li><li>列出激励函数和输出函数表达式</li><li>画出逻辑电路图</li></ol><p>原始流程表:每一行含有一个稳态 每个状态决定于上一个状态和输入</p><h5 id="本质冒险"><a href="#本质冒险" class="headerlink" title="本质冒险"></a>本质冒险</h5><p>本质冒险：当输入信号变化时，电路进入错误状态的可能性。：如果最终状态变量的变化被传回到激励电路输入端之前，输入的变化未被所有的激励电路接收到，就会发生错误。</p><p>通俗定义：如果从状态S出发，X的一次变化和三次变化的最终结果状态不一致，就存在本质冒险。</p><p>本质冒险是电路中固有的问题，可通过增加延迟解决问题。</p><h3 id="时序逻辑设计实践"><a href="#时序逻辑设计实践" class="headerlink" title="时序逻辑设计实践"></a>时序逻辑设计实践</h3><p>定时图： </p><p>建立时间容限=tclk-tffpd(max)-tcomb(max)-tsetup&gt;0</p><p>保持时间容限=tffpd(min)+tcomb(min)-thold&gt;0</p><h4 id="开关消颤"><a href="#开关消颤" class="headerlink" title="开关消颤"></a>开关消颤</h4><p>双稳态电路消颤</p><p>锁存器和上拉电阻消颤</p><h4 id="S’-R’锁存器消除击键抖动"><a href="#S’-R’锁存器消除击键抖动" class="headerlink" title="S’-R’锁存器消除击键抖动"></a>S’-R’锁存器消除击键抖动</h4><h4 id="总线保持电路"><a href="#总线保持电路" class="headerlink" title="总线保持电路"></a>总线保持电路</h4><p>在三态总线中，悬空总线的处理方法</p><ul><li>上拉电阻：价格贵、占用印刷电路的面积 大小选择比较困难，过大，转换慢；过小，则消耗过多的电流</li><li>有源总线保持电路：带电阻反馈回路的双稳态电路</li></ul><p>为什么要？？？？</p><h4 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h4><p>共用一个时钟信号的2个或2个以上的D触发器组合在一起，称为寄存器，通常用来存储一组相关的二进制数。</p><p>锁存器和触发器的区别:</p><ul><li>前者是电位信号控制，后者是同步时钟边沿信号控制。</li><li>使用的场合不同：取决于控制方式、控制信号和数据之间的时间关系。：数据有效滞后于控制信息时，使用锁存器。反之，可使用寄存器。</li></ul><h4 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h4><p>计数器：在状态图中包含一个循环的时序电路。</p><p>1.功能：对时钟脉冲 CLK 计数。<br>2.应用：分频、定时、产生节拍脉冲和脉冲序列、进行数字运算等。</p><p>按数制分：二进制计数器 十进制计数器 N进制(任意进制)计数器</p><p>按计数方式分： 加法计数器 减法计数器 可逆计数（Up-Down Counter）</p><h5 id="行波计数器：进位信息像波浪一样由低位向高位，每次传送一次。"><a href="#行波计数器：进位信息像波浪一样由低位向高位，每次传送一次。" class="headerlink" title="行波计数器：进位信息像波浪一样由低位向高位，每次传送一次。"></a>行波计数器：进位信息像波浪一样由低位向高位，每次传送一次。</h5><p>延迟时间很长</p><h5 id="同步计数器"><a href="#同步计数器" class="headerlink" title="同步计数器"></a>同步计数器</h5><p>同步计数器：所有的触发器共用一个CLK信号 使用带有使能端的T触发器</p><p>串行同步4位二进制计数器 并行同步4位二进制计数器(最快的二进制计数器)</p><p>一次状态转移中有2个以上的计数位同时变化，在译码端可能产生尖峰脉冲(glitch)。 属于功能性冒险</p><p>无冒险译码输出：输出延迟一个时钟周期 可使用环形计数器实现</p><p>可逆同步计数器169</p><p>N进制计数器：用触发器和门电路设计或用集成计数器构成。</p><p>十进制异步计数器</p><p>提高归零可靠性？</p><h5 id="移位寄存器"><a href="#移位寄存器" class="headerlink" title="移位寄存器"></a>移位寄存器</h5><p>移位寄存器shift register：是一个n位寄存器，在每一个时钟触发沿到来时就将所存储的数据移一位。</p><ul><li>处理串行数据</li><li>用于rs232,modem通信、以太网连接等</li><li>串入串出</li></ul><p>也可以串入并出、并入串出、并入并出</p><h6 id="移位寄存器的应用"><a href="#移位寄存器的应用" class="headerlink" title="移位寄存器的应用"></a>移位寄存器的应用</h6><ul><li>串并转换是移位寄存器的“数据应用”。</li><li>与组合电路构成具有循环状态图的状态机，“非数据应用”，称为移位寄存器计数器shift-register counter。</li><li>计数顺序既不是升序也不是降序。</li></ul><h5 id="环形计数器"><a href="#环形计数器" class="headerlink" title="环形计数器"></a>环形计数器</h5><h5 id="自校正环形计数器"><a href="#自校正环形计数器" class="headerlink" title="自校正环形计数器"></a>自校正环形计数器</h5><h5 id="Johnson计数器"><a href="#Johnson计数器" class="headerlink" title="Johnson计数器"></a>Johnson计数器</h5><p>扭环计数器，把n位移位寄存器的串行输出取反，得到具有2n种状态的计数器。 有2n-2n个非正常状态，存在健壮性问题。</p><h5 id="线性反馈移位寄存器计数器"><a href="#线性反馈移位寄存器计数器" class="headerlink" title="线性反馈移位寄存器计数器"></a>线性反馈移位寄存器计数器</h5><ul><li>n位线性反馈移位寄存器计数器(n-bit linear feedback shift-register counter,LFSR)有2n-1种有效状态，通常称为最大长度序列发生器(maximum-length sequence generator)。</li><li>基于有限域理论（finite field），对于任意值n，至少可以找到一种反馈方程，使得计数器的计数循环包含所有2n-1种非零状态。</li><li>最大长度序列。</li><li>n大于3，有多个反馈方程可实现最大长度序列。</li><li>用于伪随机数生成器、检错码、纠错码，加扰和解扰通信数据等。</li></ul><h4 id="计数器的应用"><a href="#计数器的应用" class="headerlink" title="计数器的应用"></a>计数器的应用</h4><p>序列信号发生器</p><h4 id="迭代电路与时序电路"><a href="#迭代电路与时序电路" class="headerlink" title="迭代电路与时序电路"></a>迭代电路与时序电路</h4><ul><li>一个由n个模块构成的迭代电路，其功能可以用一个模块加暂存机制构成的时序电路来完成，需经过n个时钟周期才能得到结果。</li><li>数字设计中的空间/时间折中。</li></ul><h2 id="存储器、CPLD和FPGA"><a href="#存储器、CPLD和FPGA" class="headerlink" title="存储器、CPLD和FPGA"></a>存储器、CPLD和FPGA</h2><h3 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h3><h4 id="ROM"><a href="#ROM" class="headerlink" title="ROM"></a>ROM</h4><ul><li>只读存储器简称ROM (read-only memory)：是一种具有n个输入b个输出的组合逻辑电路。</li><li>包含地址输入（地址译码）、数据输出（输出缓冲）和存储矩阵三部分。</li><li>与真正存储器的区别：非易失性存储器(non volatile memory)。即使电源断电，ROM中存储的数据不会丢失。</li><li>ROM = 最小项译码器+ 可编程或矩阵</li><li>ROM = 存真值表的存储器</li></ul><h4 id="ROM的应用"><a href="#ROM的应用" class="headerlink" title="ROM的应用"></a>ROM的应用</h4><ul><li>字符发生器：实现字符发生器的基本原理是:将字符的点阵预先存储在ROM中，然后顺序给出地址码，从存储矩阵中逐行读出字符的点阵，并送入显示器即可显示出字符。</li><li>数学函数表：实现计算机中的运算有两种方法，一种是编写运算程序，存入ROM中，通过计算机执行运算程序。另一种方法是把因变量和自变量的函数关系存在ROM中，好像查函数表一样。</li></ul><h4 id="RAM"><a href="#RAM" class="headerlink" title="RAM"></a>RAM</h4><ul><li>读/写存储器(Read/Write Memory RWM)是指可以在任何时候存储和检索信息的存储器阵列</li><li>现在数字系统中的读写存储器大多数是随机存取存储器（Random-access Memory, RAM），意思说读或写存储器的1个位所花费的时间与该位在RAM中的位置无关。</li><li>静态存储器Static RAM,SRAM：一旦在某个存储位置写入数据，只要电源不被切断，其存储内容保持不变，除非重新写入新内容。</li><li>动态存储器Dynamic RAM,DRAM：必须对存储数据进行周期性读出和写入刷新，否则存储器中的数据将会消失。</li></ul><p>存储器的容量扩展：位扩展 字扩展  字位同时扩展</p><h4 id="CPLD"><a href="#CPLD" class="headerlink" title="CPLD"></a>CPLD</h4><p>基本结构：大多由内部PLD、输入输出块和可编程内部连线组成。</p><h4 id="FPGA"><a href="#FPGA" class="headerlink" title="FPGA"></a>FPGA</h4><ul><li>与CPLD相比，具有更高的集成度、更强的逻辑功能和更大的灵活性</li><li>FPGA属于阵列型PLD</li><li>有三个可编程电路块和一个用于存放编程数据的SRAM组成：可编程逻辑块（CLB）  输入/输出模块（IOB）  可编程互连线（PI）</li></ul><h4 id="FPGA和CPLD的区别"><a href="#FPGA和CPLD的区别" class="headerlink" title="FPGA和CPLD的区别"></a>FPGA和CPLD的区别</h4><ul><li>编程技术与数据易失性：通常FPGA采用SRAM进行功能配置，可以重复编程，但系统掉电后，SRAM中的数据丢失。因此，需在FPGA外加EPROM，将配置数据写入其中，系统每次上电自动将数据引入SRAM中。而一般CPLD器件采用EEPROM存储技术，可重复编程，且系统掉电后，EEPROM中的数据不会丢失，适于数据的保密。</li><li>触发器资源：FPGA器件由于含有丰富的触发器资源，容易实现时序逻辑，若要求实现比较复杂的组合电路则需要几个CLB结合起来实现。CPLD的与或阵列结构，使它更适合于实现大规模的组合逻辑功能，而它的触发器资源相对比较少。</li><li>芯片利用率：FPGA多为细粒度结构。FPGA内部有丰富连线资源，CLB分块比较小，芯片利用率比较高。CPLD多为粗粒度结构。 CPLD宏单元的与或阵列较大，通常不能完全被应用，而且宏单元之间主要通过高速数据通道连接，容量有限，限制了器件的灵活布线，因此CPLD利用率比FPGA低。</li><li>布线结构与延时预测性：FPGA为非连续式布线。FPGA器件在每次编程时实现的逻辑功能一样，但走的路线不同，因此延时难以预测，要求开发软件允许工程师对关键的路线给予限制。CPLD为连续式布线。CPLD每次布线路径一样，其连续式互连结构利用具有同样长度的一些金属线实现逻辑单元之间的互连，消除了分段式互连结构在定时上的差异，并且在逻辑单元之间提供快速而且具有固定延时的通路。另外，CPLD的延时比较小。</li></ul><h2 id="数字系统"><a href="#数字系统" class="headerlink" title="数字系统"></a>数字系统</h2><p>数字系统的基本模型：由输入部件、输出部件及逻辑系统组成。逻辑系统包括存储部件、处理部件、控制部件三大子系统。</p><p>基本子系统：是指构成数字系统时最基本的逻辑功能部件。这些逻辑功能部件有：算术逻辑运算单元ALU、寄存器、RAM、数据总线、控制器。</p><p>ALU：是数字系统中对数据进行加工处理的功能部件。</p><p>寄存器：加法器和ALU均由门电路组成，它们没有记忆功能，因此运算的结果需要寄存器保存起来。而参与运算的两个数也要取自寄存器。寄存器是数字系统中必不可少的逻辑子系统。  寄存器的分类：通用寄存器 、专用寄存器。</p><p>存储器RAM：当存储大量数据时，从经济和成本上考虑，只能使用随机读写的RAM存储器。</p><p>总线的概念 ：在数字系统中，总线是多个逻辑子系统的联系纽带。所谓总线，就是多个信息源分时传送数据到多个目的地的传送通路。单向总线 双向总线</p><p>给不给器件的原理图 ？？？</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数字逻辑电路笔记&quot;&gt;&lt;a href=&quot;#数字逻辑电路笔记&quot; class=&quot;headerlink&quot; title=&quot;数字逻辑电路笔记&quot;&gt;&lt;/a&gt;数字逻辑电路笔记&lt;/h1&gt;&lt;p&gt;给定输入 给出输出 用布尔逻辑实现&lt;/p&gt;
&lt;p&gt;晶体管的开关特性是数字电路研究的重点。&lt;/p&gt;
&lt;p&gt;数字逻辑中考虑电路模拟的特性，如时延问题。&lt;/p&gt;
&lt;p&gt;数字设计中一些层次问题&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="https://ricky-ting.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>BST</title>
    <link href="https://ricky-ting.github.io/2018/06/07/BST/"/>
    <id>https://ricky-ting.github.io/2018/06/07/BST/</id>
    <published>2018-06-07T07:09:17.000Z</published>
    <updated>2018-06-07T07:11:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>下面是基于C++的BST类实现</p> <a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">//  main.cpp</span><br><span class="line">//  debugger</span><br><span class="line">//</span><br><span class="line">//  Created by 丁保荣 on 2018/6/6.</span><br><span class="line">//  Copyright © 2018 丁保荣. All rights reserved.</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">    node * p;</span><br><span class="line">    node * l;</span><br><span class="line">    node * r;</span><br><span class="line">    int key;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class BST</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    node * root;</span><br><span class="line">    node mynil;</span><br><span class="line">    void Initial()</span><br><span class="line">    &#123;</span><br><span class="line">        root=&amp;mynil;</span><br><span class="line">    &#125;</span><br><span class="line">    void Inorder_tree_walk(node * x);</span><br><span class="line">    void Preorder_tree_walk(node * x);</span><br><span class="line">    void Postorder_tree_walk(node * x);</span><br><span class="line">    node * Search(node * x, int k);</span><br><span class="line">    node * Minimum(node * z);</span><br><span class="line">    node * Maximum(node * z);</span><br><span class="line">    node * Successor(node * x);</span><br><span class="line">    node * Predecessor(node * x);</span><br><span class="line">    void Insert(node * z);</span><br><span class="line">    void Transplant(node * u, node * v);</span><br><span class="line">    void Delete(node * z);</span><br><span class="line">    </span><br><span class="line">private:</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void BST::Inorder_tree_walk(node * x)</span><br><span class="line">&#123;</span><br><span class="line">    if(x!=&amp;mynil)</span><br><span class="line">    &#123;</span><br><span class="line">        BST::Inorder_tree_walk((*x).l);</span><br><span class="line">        cout&lt;&lt;(*x).key;</span><br><span class="line">        BST::Inorder_tree_walk((*x).r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void BST::Preorder_tree_walk(node * x)</span><br><span class="line">&#123;</span><br><span class="line">    if(x!=&amp;mynil)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;(*x).key;</span><br><span class="line">        BST::Preorder_tree_walk((*x).l);</span><br><span class="line">        BST::Preorder_tree_walk((*x).r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void BST::Postorder_tree_walk(node * x)</span><br><span class="line">&#123;</span><br><span class="line">    if(x!=&amp;mynil)</span><br><span class="line">    &#123;</span><br><span class="line">        BST::Postorder_tree_walk((*x).l);</span><br><span class="line">        BST::Postorder_tree_walk((*x).r);</span><br><span class="line">        cout&lt;&lt;(*x).key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">node * BST::Search(node * x,int k)</span><br><span class="line">&#123;</span><br><span class="line">    if(x==&amp;mynil || k==(*x).key)</span><br><span class="line">        return x;</span><br><span class="line">    if(k&lt;(*x).key)</span><br><span class="line">        return BST::Search((*x).l,k);</span><br><span class="line">    else</span><br><span class="line">        return BST::Search((*x).r,k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">node * BST::Minimum(node * z)</span><br><span class="line">&#123;</span><br><span class="line">    while((*z).l!=&amp;mynil)</span><br><span class="line">        z=(*z).l;</span><br><span class="line">    return z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">node * BST::Maximum(node * z)</span><br><span class="line">&#123;</span><br><span class="line">    while((*z).r!=&amp;mynil)</span><br><span class="line">        z=(*z).r;</span><br><span class="line">    return z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">node * BST::Successor(node * x)</span><br><span class="line">&#123;</span><br><span class="line">    if((*x).r!=&amp;mynil)</span><br><span class="line">        return BST::Minimum((*x).r);</span><br><span class="line">    node * y=(*x).p;</span><br><span class="line">    while(y!=&amp;mynil &amp;&amp; x==(*y).r)</span><br><span class="line">    &#123;</span><br><span class="line">        x=y;</span><br><span class="line">        y=(*y).p;</span><br><span class="line">    &#125;</span><br><span class="line">    return y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">node * BST::Predecessor(node * x)</span><br><span class="line">&#123;</span><br><span class="line">    if((*x).l!=&amp;mynil)</span><br><span class="line">        return BST::Maximum((*x).l);</span><br><span class="line">    node * y=(*x).p;</span><br><span class="line">    while(y!=&amp;mynil &amp;&amp; x==(*y).l)</span><br><span class="line">    &#123;</span><br><span class="line">        x=y;</span><br><span class="line">        y=(*y).p;</span><br><span class="line">    &#125;</span><br><span class="line">    return y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void BST::Insert(node * z)</span><br><span class="line">&#123;</span><br><span class="line">    node * y=&amp;mynil;</span><br><span class="line">    node * x=root;</span><br><span class="line">    while(x!=&amp;mynil)</span><br><span class="line">    &#123;</span><br><span class="line">        y=x;</span><br><span class="line">        if((*z).key&lt;(*x).key)</span><br><span class="line">            x=(*x).l;</span><br><span class="line">        else</span><br><span class="line">            x=(*x).r;</span><br><span class="line">    &#125;</span><br><span class="line">    (*z).p=y;</span><br><span class="line">    if(y==&amp;mynil)</span><br><span class="line">        root=z;</span><br><span class="line">    else if((*z).key&lt;(*y).key)</span><br><span class="line">        (*y).l=z;</span><br><span class="line">    else</span><br><span class="line">        (*y).r=z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void BST::Transplant(node * u, node * v)</span><br><span class="line">&#123;</span><br><span class="line">    if((*u).p==&amp;mynil)</span><br><span class="line">        root=v;</span><br><span class="line">    else if(u==(*(*u).p).l)</span><br><span class="line">        (*(*u).p).l=v;</span><br><span class="line">    else</span><br><span class="line">        (*(*u).p).r=v;</span><br><span class="line">    if(v!=&amp;mynil)</span><br><span class="line">        (*v).p=(*u).p;</span><br><span class="line">&#125;</span><br><span class="line">void BST::Delete(node * z)</span><br><span class="line">&#123;</span><br><span class="line">    node * y;</span><br><span class="line">    if((*z).l==&amp;mynil)</span><br><span class="line">        BST::Transplant(z,(*z).r);</span><br><span class="line">    else if((*z).r==&amp;mynil)</span><br><span class="line">        BST::Transplant(z,(*z).l);</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        y=BST::Minimum((*z).r);</span><br><span class="line">        if((*y).p!=z)</span><br><span class="line">        &#123;</span><br><span class="line">            BST::Transplant(y,(*y).r);</span><br><span class="line">            (*y).r=(*z).r;</span><br><span class="line">            (*(*y).r).p=y;</span><br><span class="line">        &#125;</span><br><span class="line">        BST::Transplant(z,y);</span><br><span class="line">        (*y).l=(*z).l;</span><br><span class="line">        (*(*y).l).p=y;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BST T;</span><br><span class="line"></span><br><span class="line">void myinsert(int key)</span><br><span class="line">&#123;</span><br><span class="line">    node * p=new node;</span><br><span class="line">    (*p).key=key;</span><br><span class="line">    p-&gt;l=&amp;T.mynil;</span><br><span class="line">    p-&gt;r=&amp;T.mynil;</span><br><span class="line">    T.Insert(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void mydelete(int key)</span><br><span class="line">&#123;</span><br><span class="line">    node * p = T.Search(T.root,key);</span><br><span class="line">    T.Delete(p);</span><br><span class="line">    delete(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是基于C++的RB-Tree类实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">//  main.cpp</span><br><span class="line">//  debugger</span><br><span class="line">//</span><br><span class="line">//  Created by 丁保荣 on 2018/6/6.</span><br><span class="line">//  Copyright © 2018 丁保荣. All rights reserved.</span><br><span class="line">//</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int counter=0;</span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">    bool c; // true is black and false is red.</span><br><span class="line">    int key;</span><br><span class="line">    node * p;</span><br><span class="line">    node * l;</span><br><span class="line">    node * r;</span><br><span class="line">&#125;;</span><br><span class="line">class myRB_Tree</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    node mynil;</span><br><span class="line">    node * root;</span><br><span class="line">    void Initial()</span><br><span class="line">    &#123;</span><br><span class="line">        mynil.c=true;</span><br><span class="line">        mynil.p=mynil.l=mynil.r=NULL;</span><br><span class="line">        mynil.key=-1;</span><br><span class="line">        root=&amp;mynil;</span><br><span class="line">    &#125;</span><br><span class="line">    void Insert(node * z);</span><br><span class="line">    void Delete(node * z);</span><br><span class="line">    node * Search(node * x, int k);</span><br><span class="line">    node * Minimum(node * z);</span><br><span class="line">    void Preorder_tree_walk(node * x);</span><br><span class="line">    </span><br><span class="line">private:</span><br><span class="line">    void Insert_Fixup(node * z);</span><br><span class="line">    void Transplant(node * u, node * v);</span><br><span class="line">    void Left_Rotate(node * x);</span><br><span class="line">    void Right_Rotate(node * x);</span><br><span class="line">    void Delete_Fixup(node * x);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void myRB_Tree::Preorder_tree_walk(node * x)</span><br><span class="line">&#123;</span><br><span class="line">    if(x!=&amp;mynil)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;(*x).key&lt;&lt;&quot;:&quot;&lt;&lt;((*x).c?&quot;black&quot;:&quot;red&quot;)&lt;&lt;endl;</span><br><span class="line">        myRB_Tree::Preorder_tree_walk((*x).l);</span><br><span class="line">        myRB_Tree::Preorder_tree_walk((*x).r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void myRB_Tree::Insert(node * z)</span><br><span class="line">&#123;</span><br><span class="line">    node * y=&amp;mynil;</span><br><span class="line">    node * x=root;</span><br><span class="line">    while(x!=&amp;mynil)</span><br><span class="line">    &#123;</span><br><span class="line">        y=x;</span><br><span class="line">        if((*z).key&lt;(*x).key)</span><br><span class="line">            x=(*x).l;</span><br><span class="line">        else</span><br><span class="line">            x=(*x).r;</span><br><span class="line">    &#125;</span><br><span class="line">    (*z).p=y;</span><br><span class="line">    if(y==&amp;mynil)</span><br><span class="line">        root=z;</span><br><span class="line">    else if((*z).key&lt;(*y).key)</span><br><span class="line">        (*y).l=z;</span><br><span class="line">    else</span><br><span class="line">        (*y).r=z;</span><br><span class="line">    (*z).l=&amp;mynil;</span><br><span class="line">    (*z).r=&amp;mynil;</span><br><span class="line">    (*z).c=0;</span><br><span class="line">    myRB_Tree::Insert_Fixup(z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void myRB_Tree::Insert_Fixup(node * z)</span><br><span class="line">&#123;</span><br><span class="line">    while((*(*z).p).c==false)</span><br><span class="line">    &#123;</span><br><span class="line">        if((*z).p==(*(*(*z).p).p).l)</span><br><span class="line">        &#123;</span><br><span class="line">            node * y=(*(*(*z).p).p).r;</span><br><span class="line">            if((*y).c==false)</span><br><span class="line">            &#123;</span><br><span class="line">                (*(*z).p).c=true;</span><br><span class="line">                (*y).c=true;</span><br><span class="line">                (*(*(*z).p).p).c=false;</span><br><span class="line">                z=(*(*z).p).p;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                if(z==(*(*z).p).r)</span><br><span class="line">                &#123;</span><br><span class="line">                    z=(*z).p;</span><br><span class="line">                    myRB_Tree::Left_Rotate(z);</span><br><span class="line">                &#125;</span><br><span class="line">                (*(*z).p).c=true;</span><br><span class="line">                (*(*(*z).p).p).c=false;</span><br><span class="line">                myRB_Tree::Right_Rotate((*(*z).p).p);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            node * y=(*(*(*z).p).p).l;</span><br><span class="line">            if((*y).c==false)</span><br><span class="line">            &#123;</span><br><span class="line">                (*(*z).p).c=true;</span><br><span class="line">                (*y).c=true;</span><br><span class="line">                (*(*(*z).p).p).c=false;</span><br><span class="line">                z=(*(*z).p).p;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                if(z==(*(*z).p).l)</span><br><span class="line">                &#123;</span><br><span class="line">                    z=(*z).p;</span><br><span class="line">                    myRB_Tree::Right_Rotate(z);</span><br><span class="line">                &#125;</span><br><span class="line">                (*(*z).p).c=true;</span><br><span class="line">                (*(*(*z).p).p).c=false;</span><br><span class="line">                myRB_Tree::Left_Rotate((*(*z).p).p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    (*root).c=true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void myRB_Tree::Left_Rotate(node * x)</span><br><span class="line">&#123;</span><br><span class="line">    node * y= (*x).r;</span><br><span class="line">    (*x).r=(*y).l;</span><br><span class="line">    if((*y).l!=&amp;mynil)</span><br><span class="line">        (*(*y).l).p=x;</span><br><span class="line">    (*y).p=(*x).p;</span><br><span class="line">    if((*x).p==&amp;mynil)</span><br><span class="line">        root=y;</span><br><span class="line">    else if(x==(*(*x).p).l)</span><br><span class="line">        (*(*x).p).l=y;</span><br><span class="line">    else</span><br><span class="line">        (*(*x).p).r=y;</span><br><span class="line">    (*y).l=x;</span><br><span class="line">    (*x).p=y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void myRB_Tree::Right_Rotate(node * x)</span><br><span class="line">&#123;</span><br><span class="line">    node * y= (*x).l;</span><br><span class="line">    (*x).l=(*y).r;</span><br><span class="line">    if((*y).r!=&amp;mynil)</span><br><span class="line">        (*(*y).r).p=x;</span><br><span class="line">    (*y).p=(*x).p;</span><br><span class="line">    if((*x).p==&amp;mynil)</span><br><span class="line">        root=y;</span><br><span class="line">    else if(x==(*(*x).p).r)</span><br><span class="line">        (*(*x).p).r=y;</span><br><span class="line">    else</span><br><span class="line">        (*(*x).p).l=y;</span><br><span class="line">    (*y).r=x;</span><br><span class="line">    (*x).p=y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void myRB_Tree::Transplant(node * u, node * v)</span><br><span class="line">&#123;</span><br><span class="line">    if((*u).p==&amp;mynil)</span><br><span class="line">        root=v;</span><br><span class="line">    else if(u==(*(*u).p).l)</span><br><span class="line">        (*(*u).p).l=v;</span><br><span class="line">    else</span><br><span class="line">        (*(*u).p).r=v;</span><br><span class="line">    (*v).p=(*u).p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void myRB_Tree::Delete(node * z)</span><br><span class="line">&#123;</span><br><span class="line">    node * y=z;</span><br><span class="line">    node * x;</span><br><span class="line">    bool y_original_color=(*y).c;</span><br><span class="line">    if((*z).l==&amp;mynil)</span><br><span class="line">    &#123;</span><br><span class="line">        x=(*z).r;</span><br><span class="line">        myRB_Tree::Transplant(z,(*z).r);</span><br><span class="line">    &#125;</span><br><span class="line">    else if((*z).r==&amp;mynil)</span><br><span class="line">    &#123;</span><br><span class="line">        x=(*z).l;</span><br><span class="line">        myRB_Tree::Transplant(z,(*z).l);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        y=myRB_Tree::Minimum((*z).r);</span><br><span class="line">        y_original_color=(*y).c;</span><br><span class="line">        x=(*y).r;</span><br><span class="line">        if((*y).p==z)</span><br><span class="line">            (*x).p=y;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            myRB_Tree::Transplant(y,(*y).r);</span><br><span class="line">            (*y).r=(*z).r;</span><br><span class="line">            (*(*y).r).p=y;</span><br><span class="line">        &#125;</span><br><span class="line">        myRB_Tree::Transplant(z,y);</span><br><span class="line">        (*y).l=(*z).l;</span><br><span class="line">        (*(*y).l).p=y;</span><br><span class="line">        (*y).c=(*z).c;</span><br><span class="line">    &#125;</span><br><span class="line">    if(y_original_color==true)</span><br><span class="line">        myRB_Tree::Delete_Fixup(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void myRB_Tree::Delete_Fixup(node * x)</span><br><span class="line">&#123;</span><br><span class="line">    node * w;</span><br><span class="line">    while(x!=root and (*x).c==true)</span><br><span class="line">    &#123;</span><br><span class="line">        if(x==(*(*x).p).l)</span><br><span class="line">        &#123;</span><br><span class="line">            w=(*(*x).p).r;</span><br><span class="line">            if((*w).c==false)</span><br><span class="line">            &#123;</span><br><span class="line">                (*w).c=true;</span><br><span class="line">                (*(*x).p).c=false;</span><br><span class="line">                myRB_Tree::Right_Rotate((*x).p);</span><br><span class="line">                w=(*(*x).p).r;</span><br><span class="line">            &#125;</span><br><span class="line">            if((*(*w).l).c==true &amp;&amp; (*(*w).r).c==true)</span><br><span class="line">            &#123;</span><br><span class="line">                (*w).c=false;</span><br><span class="line">                x=(*x).p;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                if((*(*w).r).c==true)</span><br><span class="line">                &#123;</span><br><span class="line">                    (*(*w).l).c=true;</span><br><span class="line">                    (*w).c=false;</span><br><span class="line">                    myRB_Tree::Left_Rotate(w);</span><br><span class="line">                    w=(*(*x).p).r;</span><br><span class="line">                &#125;</span><br><span class="line">                (*w).c=(*(*x).p).c;</span><br><span class="line">                (*(*x).p).c=true;</span><br><span class="line">                (*(*w).r).c=true;</span><br><span class="line">                myRB_Tree::Right_Rotate((*x).p);</span><br><span class="line">                x=root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            w=(*(*x).p).l;</span><br><span class="line">            if((*w).c==false)</span><br><span class="line">            &#123;</span><br><span class="line">                (*w).c=true;</span><br><span class="line">                (*(*x).p).c=false;</span><br><span class="line">                myRB_Tree::Right_Rotate((*x).p);</span><br><span class="line">                w=(*(*x).p).l;</span><br><span class="line">            &#125;</span><br><span class="line">            if((*(*w).r).c==true &amp;&amp; (*(*w).l).c==true)</span><br><span class="line">            &#123;</span><br><span class="line">                (*w).c=false;</span><br><span class="line">                x=(*x).p;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                if((*(*w).l).c==true)</span><br><span class="line">                &#123;</span><br><span class="line">                    (*(*w).r).c=true;</span><br><span class="line">                    (*w).c=false;</span><br><span class="line">                    myRB_Tree::Left_Rotate(w);</span><br><span class="line">                    w=(*(*x).p).l;</span><br><span class="line">                &#125;</span><br><span class="line">                (*w).c=(*(*x).p).c;</span><br><span class="line">                (*(*x).p).c=true;</span><br><span class="line">                (*(*w).l).c=true;</span><br><span class="line">                myRB_Tree::Right_Rotate((*x).p);</span><br><span class="line">                x=root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">node * myRB_Tree::Minimum(node * z)</span><br><span class="line">&#123;</span><br><span class="line">    while((*z).l!=&amp;mynil)</span><br><span class="line">        z=(*z).l;</span><br><span class="line">    return z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">node * myRB_Tree::Search(node * x,int k)</span><br><span class="line">&#123;</span><br><span class="line">    if(x==&amp;mynil || k==(*x).key)</span><br><span class="line">        return x;</span><br><span class="line">    if(k&lt;(*x).key)</span><br><span class="line">    &#123;</span><br><span class="line">        counter++;</span><br><span class="line">        return myRB_Tree::Search((*x).l,k);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        counter++;</span><br><span class="line">        return myRB_Tree::Search((*x).r,k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">myRB_Tree T;</span><br><span class="line">void myinsert(int key)</span><br><span class="line">&#123;</span><br><span class="line">    node * p=new node;</span><br><span class="line">    (*p).key=key;</span><br><span class="line">    p-&gt;l=&amp;T.mynil;</span><br><span class="line">    p-&gt;r=&amp;T.mynil;</span><br><span class="line">    T.Insert(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void mydelete(int key)</span><br><span class="line">&#123;</span><br><span class="line">    node * p = T.Search(T.root,key);</span><br><span class="line">    T.Delete(p);</span><br><span class="line">    delete(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;下面是基于C++的BST类实现&lt;/p&gt;
    
    </summary>
    
    
      <category term="algorithm" scheme="https://ricky-ting.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>微积分五讲</title>
    <link href="https://ricky-ting.github.io/2018/05/14/%E5%BE%AE%E7%A7%AF%E5%88%86%E4%BA%94%E8%AE%B2/"/>
    <id>https://ricky-ting.github.io/2018/05/14/微积分五讲/</id>
    <published>2018-05-14T12:47:58.000Z</published>
    <updated>2018-05-14T12:49:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="微积分五讲-笔记"><a href="#微积分五讲-笔记" class="headerlink" title="微积分五讲 笔记"></a>微积分五讲 笔记</h1><p>希尔伯特的演讲：数学中每一步真正的发展都与更有力的工具和更简单的方法的发现密切联系着，这些工具和方法同时会有助于理解已有的理论并把陈旧的、复杂的东西抛到一边。数学科学发展的这种特点是根深蒂固。</p><a id="more"></a><p>黎曼几何  爱因斯坦的相对论正是以“Riemann几何”作为其数学工具的</p><p>学习数学实际上就是一个以”高级“替代“低级”的过程，否则靠死记硬背，最后将会忘掉一切。</p><p>一元微积分的微积分基本定理的建立标志着微积分的诞生；分析算术化的胜利标志着微积分严格化的完成；外微分形式的产生，建立了多元微积分的微积分基本定理，标志着微积分的完成，并从古典走向近代。</p><p>非标准分析</p><p>分析算术化不是微积分严格化的唯一途径。</p><p>可微一定可积吗？ 不一定 导函数可能无界</p><p>扩展微积分：Lebesgue积分理论，现在称为实变函数或实分析</p><p>形象表述：先按钞票面值的大小分类，然后计算每一类的面额总值，再相加，这就是我的积分思想。如不按面值大小分类，而是按从钱袋中摸出的先后次序来计算总是，那就是Riemann积分的思想</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;微积分五讲-笔记&quot;&gt;&lt;a href=&quot;#微积分五讲-笔记&quot; class=&quot;headerlink&quot; title=&quot;微积分五讲 笔记&quot;&gt;&lt;/a&gt;微积分五讲 笔记&lt;/h1&gt;&lt;p&gt;希尔伯特的演讲：数学中每一步真正的发展都与更有力的工具和更简单的方法的发现密切联系着，这些工具和方法同时会有助于理解已有的理论并把陈旧的、复杂的东西抛到一边。数学科学发展的这种特点是根深蒂固。&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="https://ricky-ting.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>git笔记</title>
    <link href="https://ricky-ting.github.io/2018/04/15/git%E7%AC%94%E8%AE%B0/"/>
    <id>https://ricky-ting.github.io/2018/04/15/git笔记/</id>
    <published>2018-04-15T07:11:08.000Z</published>
    <updated>2018-04-15T07:12:18.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="git笔记"><a href="#git笔记" class="headerlink" title="git笔记"></a>git笔记</h1><p><code>git init</code> 初始化</p> <a id="more"></a><p>单独执行”git”指令会显示辅助说明;执行”git help -a”则显示完整的指令列表;执行 “git 指令 -help”(例如 “git init -help”) 则会显示该指令的网页说明文件。</p><p><code>git add filename</code></p><p><code>git commit -m &quot;description&quot; --author=&quot;name &lt;email&gt;&quot;</code>        </p><p><code>git commit --amend -m &#39;new description&#39; --author=&quot;name &lt;email&gt;&quot;</code></p><p><code>exit</code></p><p><code>.gitignore</code>忽略特定文件</p><p>Git有三个不同级别的配置文件,它们有不同的优先权.</p><ol><li>文件夹”.git”子文件夹内的config文件(只对它所在的文档库有效)</li><li>登陆账号的home directory中的.gitconfig文件(只对此账号登陆的用户有效)</li><li>Git程序的安装文件夹中的etc\gitconfig文件(对所有登陆账号和所有Git文档库都有效)</li></ol><p><code>git congif -l</code> 显示当前git的设置值。会显示三个配置文件中所有的设置项，顺序是先显示优先权最低的设置</p><p><code>git config --system -l</code><br><code>git config --global -l</code></p><p><code>git config user.name &quot;name&quot;</code><br><code>git config user.email &quot;email&quot;</code></p><p><code>git config --unset user.name</code></p><p><code>git config alias.指令别名 &#39;正式的指令和选项&#39;</code> 别名    </p><p><code>git commit</code> 启动文本编辑器来输入commit</p><p><code>git diff</code>    </p><p>Git 会将文件和文件夹分成以下三类:</p><ol><li>被追踪的(tracked);</li><li>忽略的(ignored);</li><li>不被追踪的(untracked);</li></ol><p><code>touch .gitignore</code></p><p><code>git rm --cached 文件名</code> add之后删除 这个文件将从tracked状态变成untracked状态</p><p><code>git reset HEAD 文件名</code> commit之后</p><p>取出文件:<code>git checkout commit 节点标识符或标签 文件1 文件2 ...</code>文件夹中的文件会被取出的文件覆盖</p><p><code>git grep</code></p><p><code>git blame</code></p><p><code>git mb 原文件名 新文件名</code> </p><p><code>git gc</code> 清理文档库</p><p><code>git log</code></p><p><code>git branch</code></p><p>一般情况下在切换分支之前，会先把最新的文件内容存入文档库</p><p><code>git branch -d 要删除的分支名称</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;git笔记&quot;&gt;&lt;a href=&quot;#git笔记&quot; class=&quot;headerlink&quot; title=&quot;git笔记&quot;&gt;&lt;/a&gt;git笔记&lt;/h1&gt;&lt;p&gt;&lt;code&gt;git init&lt;/code&gt; 初始化&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="https://ricky-ting.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="git" scheme="https://ricky-ting.github.io/tags/git/"/>
    
  </entry>
  
</feed>
