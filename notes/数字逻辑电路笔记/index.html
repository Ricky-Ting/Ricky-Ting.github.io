<!DOCTYPE html>
<html lang="zh-CN">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<meta name="theme-color" content="#494f5c">
	<meta name="msapplication-TileColor" content="#494f5c">
<meta itemprop="name" content="数字逻辑电路笔记">
<meta itemprop="description" content="数字逻辑电路笔记 给定输入 给出输出 用布尔逻辑实现 晶体管的开关特性是数字电路研究的重点。 数字逻辑中考虑电路模拟的特性，如时延问题。 数字设计中一些">
<meta itemprop="datePublished" content="2018-07-01T12:55:38&#43;08:00" />
<meta itemprop="dateModified" content="2018-07-01T12:55:38&#43;08:00" />
<meta itemprop="wordCount" content="13541">



<meta itemprop="keywords" content="untagged," /><meta property="og:title" content="数字逻辑电路笔记" />
<meta property="og:description" content="数字逻辑电路笔记 给定输入 给出输出 用布尔逻辑实现 晶体管的开关特性是数字电路研究的重点。 数字逻辑中考虑电路模拟的特性，如时延问题。 数字设计中一些" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://ricky-ting.github.io/notes/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E7%AC%94%E8%AE%B0/" />
<meta property="article:published_time" content="2018-07-01T12:55:38+08:00" />
<meta property="article:modified_time" content="2018-07-01T12:55:38+08:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="数字逻辑电路笔记"/>
<meta name="twitter:description" content="数字逻辑电路笔记 给定输入 给出输出 用布尔逻辑实现 晶体管的开关特性是数字电路研究的重点。 数字逻辑中考虑电路模拟的特性，如时延问题。 数字设计中一些"/>

	<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
	<link rel="manifest" href="/site.webmanifest">
	<link rel="mask-icon" href="/safari-pinned-tab.svg" color="">
	<link rel="shortcut icon" href="/favicon.ico">

	<title>数字逻辑电路笔记</title>
	<link rel="stylesheet" href="https://ricky-ting.github.io/css/style.min.657bcb7af31123e4156b1a3d2ff60a636717e54ead74f882136b5114cf72b55e.css" integrity="sha256-ZXvLevMRI+QVaxo9L/YKY2cX5U6tdPiCE2tRFM9ytV4=" crossorigin="anonymous">
	
</head>

<body id="page">
	
	<header id="site-header" class="animated slideInUp faster">
		<div class="hdr-wrapper section-inner">
			<div class="hdr-left">
				<div class="site-branding">
					<a href="https://ricky-ting.github.io">Ricky Ting&#39;s Blog</a>
				</div>
				<nav class="site-nav hide-in-mobile">
					
				<a href="https://ricky-ting.github.io/posts/">Posts</a>
				<a href="https://ricky-ting.github.io/notes/">Notes</a>
				<a href="https://ricky-ting.github.io/slides/">Slides</a>
				<a href="https://ricky-ting.github.io/about-hugo/">About</a>
				<a href="https://ricky-ting.github.io/links/">Links</a>

				</nav>
			</div>
			<div class="hdr-right hdr-icons">
				<button id="toc-btn" class="hdr-btn desktop-only-ib" title=""><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-list"><line x1="8" y1="6" x2="21" y2="6"></line><line x1="8" y1="12" x2="21" y2="12"></line><line x1="8" y1="18" x2="21" y2="18"></line><line x1="3" y1="6" x2="3" y2="6"></line><line x1="3" y1="12" x2="3" y2="12"></line><line x1="3" y1="18" x2="3" y2="18"></line></svg></button><span class="hdr-social hide-in-mobile"><a href="https://github.com/Ricky-Ting/" target="_blank" rel="noopener me" title="Github"><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path></svg></a></span><button id="menu-btn" class="hdr-btn" title=""><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></button>
			</div>
		</div>
	</header>
	<div id="mobile-menu" class="animated fast">
		<ul>
			<li><a href="https://ricky-ting.github.io/posts/">Posts</a></li>
			<li><a href="https://ricky-ting.github.io/notes/">Notes</a></li>
			<li><a href="https://ricky-ting.github.io/slides/">Slides</a></li>
			<li><a href="https://ricky-ting.github.io/about-hugo/">About</a></li>
			<li><a href="https://ricky-ting.github.io/links/">Links</a></li>
		</ul>
	</div>


	<main class="site-main section-inner thin animated fadeIn faster">
		<h1>数字逻辑电路笔记</h1>
		<div class="content">
			<h1 id="数字逻辑电路笔记">数字逻辑电路笔记<a href="#数字逻辑电路笔记" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h1>
<p>给定输入 给出输出 用布尔逻辑实现</p>
<p>晶体管的开关特性是数字电路研究的重点。</p>
<p>数字逻辑中考虑电路模拟的特性，如时延问题。</p>
<p>数字设计中一些层次问题</p>
<!-- raw HTML omitted -->
<p>数字电路特性：</p>
<ul>
<li>稳定性好</li>
<li>速度快</li>
<li>集成度高且成本低</li>
<li>设计容易、功能灵活</li>
<li>可编程性</li>
</ul>
<p>模数转换：取样、量化 数模转换：合成</p>
<p>传输门？？？</p>
<p>摩尔定律即电子定律：集成电路的集成度每18个月翻一番（1965年）</p>
<p>超摩尔定律即光子定律：光纤传输的数据总量每9个月翻一番；</p>
<p>迈特卡夫Metcalfe定律：网络的价值与联网设备数（用户数）的平方关系成正比</p>
<p>时序逻辑 组合逻辑</p>
<h2 id="数制与编码">数制与编码<a href="#数制与编码" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>按位计数制(positional number system):加权</p>
<p>二进制八进制互转，二进制十六进制互转。</p>
<p>十进制转任意进制，任意进制转十进制。</p>
<p>除以基数去余法：倒序。 乘基数取整法：正序(到fraction为0，或达到最大有效位数)</p>
<h3 id="通用转换过程">通用转换过程：<a href="#通用转换过程" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<h4 id="算法1">算法1：<a href="#算法1" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>A进制数N转换成B进制数。</p>
<ul>
<li>(a) 用B进制数取代展开序列中的数字，并计算结果，或</li>
<li>(b) 基于A进制运算，计算B基数的乘除法。</li>
</ul>
<h4 id="算法2">算法2：<a href="#算法2" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>A进制数N转换成B进制数。</p>
<ul>
<li>(a) 用序列替代法将A进制数转换成10进制。</li>
<li>(b) 用基数乘除法，将10进制数转换成B进制数。</li>
</ul>
<p>各种数制之间的表达能力不一样，是否存在最强表达能力的数制？</p>
<p>符号位+数值的表示法，正数和负数个数相同，0有两个表示，但电路设计复杂。但一旦做了加法器，减法器就不用再做了。</p>
<p><strong>补码等于反码加1的证明</strong>：写成 反码=补码-1</p>
<p>补码 两次取补仍为原数 减去或取反加1 最高位权为负 符号扩展：将符号位扩展(如果是0，全补0，如果是1，全补1) 如果减小位数 从左边减，丢弃的位要与符号位相同。正数表示。</p>
<p>补码下： -2-(-8) 还是成立的  会不会判溢出？？？？</p>
<p>反码 ：	取反。对称和易于求反。</p>
<p>余码: 除符号位相反，对任何数，补码和余码两种表示法中的其他位都是一样的(仅适用于偏离为$2^{m-1}$的情况)。余码表示常用在浮点数系统中。余码表示用在浮点数系统中指数的表示。</p>
<h3 id="二进制补码的加法与减法">二进制补码的加法与减法<a href="#二进制补码的加法与减法" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<h4 id="加法">加法：<a href="#加法" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>忽略超过MSB的进位，只要不超过计数系统的范围，该结果就总是正确的和。</p>
<p>加法中有简便的规则判断溢出：如果加数的符号相同，而和的符号与加数的符号不同，则有加法的溢出。 不同符号的加数不会溢出</p>
<h4 id="减法">减法：<a href="#减法" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>减数取反，初始进位为1</p>
<h3 id="二进制反码的加法和减法">二进制反码的加法和减法<a href="#二进制反码的加法和减法" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>计数经过$1111_2$时要额外多加一个1. 循环进位(end-around carry).即符号位有进位则+1</p>
<p>溢出判断：异号相加不溢出，同号相加结果异号则溢出。或进位和符号位不一致。</p>
<h3 id="二进制补码的乘法">二进制补码的乘法<a href="#二进制补码的乘法" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>要在每一步做符号位扩展，最高位的权为负</p>
<h3 id="二进制补码的除法">二进制补码的除法？？？<a href="#二进制补码的除法" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<h3 id="编码">编码<a href="#编码" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>{对象集，码字集，编码方案}</p>
<h3 id="十进制数的二进制编码">十进制数的二进制编码<a href="#十进制数的二进制编码" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>BCD编码又称8421码</p>
<p>加法需要修正：超过1001需要修正 要加6</p>
<p>2421码，是自反码。</p>
<p>余3码，也是自反码：BCD码+0011</p>
<p>二五混合码(biquinary code)</p>
<p>10中取1码(1-out-of-10 code)</p>
<h3 id="格雷码gray-code">格雷码(Gray code)<a href="#格雷码gray-code" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<ol>
<li>镜像法: 1位格雷码有2个码字：0  1,
N+1位格雷码中的前$2^N$个码字是N位格雷码顺序排列，且前面加0。
N+1位格雷码中的后$2^N$个码字是N位格雷码逆序排列，且前面加1</li>
</ol>
<p>2）相邻异或法: N位二进制数字从右向左，从0到n-1编号；
如果第i位和第i+1位相同，则对应格雷码的第i位为0，否则为1。</p>
<p>编码:{对象集，码字集，编码方案}</p>
<h3 id="字符编码">字符编码<a href="#字符编码" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>ASCII</p>
<h3 id="动作条件和状态的编码">动作、条件和状态的编码<a href="#动作条件和状态的编码" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>n中取1码，n中取m码</p>
<h3 id="n维体与距离">n维体与距离<a href="#n维体与距离" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>寻找Gray code即寻找一条遍历所有点的路径。</p>
<p>汉明距离(Hamming distance)</p>
<p>n维体的m维子集(m-subcube)</p>
<h3 id="检错码和纠错码">检错码和纠错码<a href="#检错码和纠错码" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>差错模式(error model) 独立差错模式(independent error model):单一物理故障只影响单一的数据位。</p>
<h4 id="检错码error-detecting-code">检错码(error-detecting code)<a href="#检错码error-detecting-code" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>最小汉明距离$ge$2</p>
<p>奇偶校验位(parity bit)</p>
<h4 id="纠错码与多重检错码">纠错码与多重检错码<a href="#纠错码与多重检错码" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>待看课件 不理解 ？？？
纠错准则？</p>
<h4 id="汉明码">汉明码<a href="#汉明码" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>纠1位错 判两位错</p>
<p>位置是2的幂的那些位都是校验位，其余为信息位。校验矩阵(parity-check matrix)</p>
<p>偶校验</p>
<p>最小距离为3的编码</p>
<p>对于任意i值，可产生2^i-1位的编码，其中包含i个校验位，2^i-i-1个信息位。</p>
<p>信息位长度D增加时，检验位长度P增长缓慢: 2^P &gt;= P+D+1</p>
<h4 id="循环冗余校验码cyclic-redundancy-checkcrc">循环冗余校验码(cyclic-redundancy-check,CRC)<a href="#循环冗余校验码cyclic-redundancy-checkcrc" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>两个重要的应用是磁盘驱动器和数据网络</p>
<h4 id="二维码two-dimensional-code">二维码(two-dimensional code)<a href="#二维码two-dimensional-code" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>一个重要的应用是用在RAID储存系统中。RAID表示(redundant array of inexpensive disks)</p>
<p>BCD加法减法</p>
<p>每个位元出现在传输线上的实际信号格式取决于线路码（line code）。</p>
<h4 id="校验和码">校验和码<a href="#校验和码" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<h3 id="补充变长编码-待拓展">补充：变长编码 待拓展？？？<a href="#补充变长编码-待拓展" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>原理：基于概率分布特性,采用可变字长编码.</p>
<p>Huffman编码：</p>
<ul>
<li>每个编码均非其它码的前缀，因此唯一可译</li>
<li>简单,易实现</li>
<li>编码效率较高(但还不是最高的，参考JPEG)</li>
</ul>
<h2 id="组合逻辑设计原理">组合逻辑设计原理<a href="#组合逻辑设计原理" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<h3 id="布尔代数">布尔代数<a href="#布尔代数" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>一致律(冗余项): XY+X&rsquo;Z+YZ=XY+X&rsquo;Z  (X+Y)(X'+Z)(Y+Z)=(X+Y)(X'+Z)</p>
<p>1.代入定理：所谓代入定理，是指在逻辑等式中任何一个变量A，都可以用任意逻辑表达式代入，则等式仍然成立。</p>
<p>2.反演定理：所谓反演定理，是指对于任意一个逻辑式Y，若将其中所有的“·”与“+”互换，“0”和“1”互换，原变量与反变量互换，则得到的结果就是原函数的反函数  Y’  。</p>
<p>3.对偶定理： 若两逻辑式相等，则它们的对偶式也相等，这就是对偶定理。所谓对偶式，即：对于任何一个逻辑式Y，若将其中的“·”与“+”互换，“0”和“1”互换，则得到Y的对偶式YD，或者Y与YD互为对偶式。？？？？？？</p>
<p>逻辑函数化简基本方法：</p>
<ul>
<li>并项法: AB+A&rsquo;B=B</li>
<li>吸收法: AB+B=B</li>
<li>消去法: A+A&rsquo;B=A+B</li>
<li>配项法: AB+A&rsquo;C+BC=AB+A&rsquo;C</li>
<li>摩根定理</li>
</ul>
<h3 id="组合逻辑">组合逻辑<a href="#组合逻辑" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>逻辑电路分为两大类：“组合的”和“时序的”. 组合逻辑电路(combinational logic circuit) 和 时序逻辑电路(sequential logic circuit)。</p>
<p>电路的分析和设计</p>
<p>正逻辑和负逻辑</p>
<p>完备归纳法(perfect induction)</p>
<p>一致性定理有两个重要的应用:在组合逻辑电路中，它可以用来去掉某些定时冒险;也是用于寻找主蕴涵项的迭代一致法的基础。</p>
<p>与非=非或,可以用CMOS直接实现</p>
<p>对偶性原理：可以运用对偶性原理证明广义德摩根定理。（待加深 P135）</p>
<p>逻辑函数的标准表示法：</p>
<ul>
<li>文字(literal): 一个自变量或反变量</li>
<li>乘积项(product term):单个文字或2个以上文字的逻辑积</li>
<li>&ldquo;积之和&quot;表达式(sum-of-products expression):是乘积项的逻辑和</li>
<li>求和项(sum term):单个文字或2个以上文字的逻辑和</li>
<li>“和之积”表达式(product-of-sum expression):求和项的逻辑积</li>
<li>标准项(normal term):是一个乘积项或求和项，每个变量当且仅当只出现一次</li>
<li>n变量最小项(minterm):是具有n个文字的标准乘积项</li>
<li>n变量最大项(maxterm):是具有n个文字的标准求和项</li>
<li>主蕴含项</li>
<li>质主蕴含项</li>
<li>奇异1：只被单一主蕴含项覆盖的输入组合</li>
</ul>
<p>和之积表达式？？？？</p>
<p>相同变量相同编号的最小项和最大项互为反函数。</p>
<p>时延问题</p>
<p>多类门技术中，类似与非门和或非门那样的带取反的门比不取反的门要快。</p>
<p>证明反演定理，曾考过？？？？ 反演定理是否是对偶定理的一个推论</p>
<p>ASIC设计和PLD设计中，化简都很重要</p>
<p>考试可能栽在配项法</p>
<p>电路分析最后一步：通常情况下描述电路的功能：投票电路，校验电路，加法器</p>
<p>设计：一般</p>
<h4 id="卡诺图化简">卡诺图化简：<a href="#卡诺图化简" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<ul>
<li>如何化简逻辑函数——最小化： (主蕴涵项)定理：最简“积之和”是主蕴涵项之和(为什么不是质主蕴含项的和)</li>
<li>蕴涵项： 任何积项都称为蕴涵项，与卡诺图中的圈对应</li>
<li>主蕴含项：定义若逻辑函数的积项P再也不能同其它积项合并以组成变量个数更少的积项，则称P为主蕴涵项，对应卡诺图中最大的圈</li>
<li>质主蕴涵项： 定义：不能被其它蕴涵项代替的主蕴涵项；至少包含一个不能被其它任何主蕴涵项所覆盖的最小项</li>
<li>覆盖：若逻辑函数的所有最小项被1组蕴涵项所包含，则该组蕴涵项称为函数的1个覆盖</li>
<li>最小覆盖： 是1个包含最少主蕴涵项和最少符号数的覆盖</li>
</ul>
<p>奎因——穆克鲁斯基算法(Quine-McCluskey algorithm)</p>
<h3 id="定时冒险">定时冒险<a href="#定时冒险" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>一个信号，以两种形式出现在输出端，因传输时间不同，使二者某段时间不具有相应逻辑关系，造成错误输出，称为冒险或险象（ Hazard ）</p>
<p>竞争：门电路的两个输入端同时向相反的逻辑电平跳变。</p>
<h4 id="静态冒险">静态冒险<a href="#静态冒险" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>静态冒险(Static hazard) ：一个周期内，输出只出现一次瞬时改变。</p>
<p>静态-1型冒险：在输出1的过程中，出现0尖峰。通常产生于最小项生成电路中</p>
<p>静态-0型冒险：通常产生于最大项生成电路中</p>
<p>利用卡诺图发现静态冒险：卡诺图检测：在卡诺图中存在两个质主蕴涵项相切，当从一个质主蕴涵项向另一个转换时，一旦有传递延迟，则产生险态。</p>
<p>消除冒险：添加一致项consensus:增加新的质蕴涵项，覆盖相切的两个质蕴涵。</p>
<p>动态冒险：一个输入转变一次而引起输出变化多次。由于多个不同的延迟路径所产生。</p>
<p>2、3、4变量的卡诺图：不断翻折</p>
<h3 id="无关项处理">无关项处理<a href="#无关项处理" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>禁止态检测电路通常是必须的, 若不影响电路运行,此时可不必刻意区分禁止态和其它状态，可以处理成0，也可以处理成1，按照化简的需要酌情确定。</p>
<h3 id="qm算法">QM算法<a href="#qm算法" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<h2 id="组合逻辑设计实践">组合逻辑设计实践<a href="#组合逻辑设计实践" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>有时要求输入变量只能用原变量形式，可作相应的变换</p>
<h3 id="设计文档">设计文档<a href="#设计文档" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>设计文档是项目设计正确、可维护的重要基础。</p>
<p>设计文档可以是综合性的单文档描述，也可以是分列的多文档描述形态。</p>
<ul>
<li>规格说明书：准确描述电路或系统的输入、输出及功能。主要是外部特性的描述。</li>
<li>方框图：系统主要功能模块及其基本互连的非正式图示描述。展示系统的输入、输出，功能模块、内部数据通路和重要的控制信号</li>
<li>原理图：系统的电气元件、元件间互连和构建系统所需的全部细节的正式说明，包括IC类型、参考标志符和引脚编号。（和常说的逻辑图不同）能够生成生产用的材料清单。</li>
<li>定时图：说明各种逻辑信号的值随时间的变化情况。关键信号之间的因果延迟。</li>
<li>结构化逻辑器件描述：描述PLD、FPGA或者ASIC的内部功能设计。通常用HDL描述；也可以用逻辑表达式、状态表、状态图等形式。</li>
<li>电路描述：电路功能设计的描述性文本，和其它文档一起解释电路的工作原理。应该包括设计的假设、限制等。</li>
</ul>
<p>方框图：</p>
<ul>
<li>能展示最重要的系统元素以及工作原理。</li>
<li>每个方框图不要超过1页。</li>
<li>大型系统可以另附页描述子系统。</li>
<li>重要的控制信号和总线要命名。</li>
<li>明确表明控制流和数据流。</li>
<li>不要包含细节。</li>
</ul>
<p>圏到圈逻辑设计(目的：使用包含有效电平标识的逻辑符号或信号命名方式使得逻辑电路更容易理解。)</p>
<h3 id="可编程逻辑器件">可编程逻辑器件<a href="#可编程逻辑器件" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>PLA:</p>
<p>PAL:或门阵列固定、与门阵列可编程、双向输入/输出引脚。</p>
<p>GAL通用阵列逻辑：GAL16V8是一个时序逻辑器件，但可以编程设置为组合逻辑器件。此时，其结构和PAL16L8类似。多了一个输出极性控制的异或门。</p>
<p>CPLD复杂可编程逻辑器件：是将多个PLD集成到单个芯片上，并提供可编程的互连和输入/输出结构。可以把CPLD的基本结构看成由可编程逻辑阵列（LAB）、可编程I/O控制模块和可编程内部连线（PIA）等三部分组成。</p>
<h3 id="译码器">译码器<a href="#译码器" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>译码器的输出编码通常比其输入编码位数多</p>
<p>真值表</p>
<p>逻辑图</p>
<p>上低下高</p>
<p>2-4译码器 3-8译码器 级联二进制译码器：4-16译码器 5-32译码器</p>
<p>译码器的级联</p>
<p>七段显示译码器</p>
<p>半导体显示：LED 液晶显示：LCD</p>
<h3 id="编码器">编码器<a href="#编码器" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>器件的输出编码比其输入编码位数少</p>
<p>8-3编码器</p>
<p>3位二进制优先编码器：允许几个信号同时输入，但只对优先级别最高
的进行编码</p>
<h3 id="三态器件">三态器件<a href="#三态器件" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>三态缓冲器</p>
<p>三态器件允许多个信号源共享单个线路</p>
<h4 id="三态缓冲器">三态缓冲器<a href="#三态缓冲器" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>三态门进入和离开高阻态的延迟时间不同，会造成输出线路上值的混乱，造成同时驱动的冲突现象。解决的方法：设计控制逻辑，保证一段截止时间（dead time），这段时间不应该有任何器件驱动同线。</p>
<h3 id="数据选择器多路选择器">数据选择器(多路选择器)<a href="#数据选择器多路选择器" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>一种多路输入，单路输出的逻辑构件。</p>
<p>2-1 multiplexer</p>
<p>n个输入变量 需要m=log n 个控制信号</p>
<p>多路选择器除完成对多路数据进行选择的基本功能外，在逻辑设计中主要用来实现各种逻辑函数功能。用多路选择器实现分时多路转换电路。(将并行输入的数据转换成串行输出)。</p>
<p>方法I：用具有n个选择变量的MUX实现n个变量的函数。</p>
<p>方法Ⅱ：用具有n-1个选择控制变量的MUX实现n个变量函数功能：即从函数的n个变量中任n-1个作为MUX的选择控制变量，并根据所选定的选择控制变量将函数变换成F=∑miDi的形式，以确定各数据输入Di。假定剩余变量为X，则Di的取值只可能是0、1、X或X’四者之一。</p>
<p>把并行处理的数据放在Di端上。在地址端上，周期性的循环加载 00-&gt;01-&gt;10-&gt;11  如此，在输出端上，顺序地送出原先并行的数据。</p>
<h3 id="数据分配器demultiplexers">数据分配器(Demultiplexers)<a href="#数据分配器demultiplexers" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>其功能和多路数据选择器相反。是一种单路输入，多路输出的逻辑构件。从哪一端输出依赖于当时的地址控制端输入。</p>
<p>【例】利用DMUX和MUX设计一个实现8路数据传输的逻辑电路。</p>
<p>多路分配器常与多路选择器联用，以实现多通道数据分时传送。通常在发送端由MUX将各路数据分时送上公共传输线(总线)，接收端再由DEMUX将公共线上的数据适时分配到相应的输出端。</p>
<p>大扇出处理：每个输出端增加一个三态缓冲</p>
<p>扇入系数大会有什么影响？</p>
<h3 id="校验电路">校验电路<a href="#校验电路" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>异或门和异或非门 用与或非三个门或者用与非门实现</p>
<p>奇偶校验电路</p>
<p>奇偶校验器件74x280:9个输入 2个输出</p>
<p>chapter6-3 ppt 第七张重点</p>
<p>奇偶校验应用：7位海明码纠错电路。</p>
<h3 id="比较器">比较器<a href="#比较器" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>两种类型：比较器  大小比较器</p>
<p>大小比较器</p>
<p>内部电路图</p>
<p>级联</p>
<p>74x682 只有相等和大于输出  扩展判断输出</p>
<h3 id="加法器减法器和alu">加法器、减法器和ALU<a href="#加法器减法器和alu" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>ALU:可以根据操作码完成加法、减法等运算功能的电路。</p>
<p>行波进位加法器 属于迭代电路 延迟： t add = t XYCout + (n-2) tCinCout +tCinS</p>
<p>用加法器实现减法器</p>
<p>chapter6-3 第33张ppt存疑</p>
<p>chapter6-3 第35张ppt存疑 如何化简</p>
<p>74x283(4位先行进位加法器) ’283的进位信号c0到c4的延迟很短相当于2个反相门，可以级联扩展计算位数，组间串行进位加法器</p>
<p>74x181 4位ALU</p>
<p>组间先行进位：不同于组间串行进位，先行进位信号直接由输入的操作数决定，没有组间串行的进位信号。</p>
<h3 id="组合乘法器">组合乘法器<a href="#组合乘法器" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>移位-累加算法的电路实现：最坏20级延迟 延迟估计  进位保留加法(14级延迟)？？？？</p>
<h2 id="时序逻辑">时序逻辑<a href="#时序逻辑" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>时序电路的输出不仅取决于当前的输入，而且取决于过去的输入序列（状态）。</p>
<p>状态：是一个状态变量集合。包含了在当前输入的基础上预测当前输出的所有的历史信息。</p>
<p>时序电路的状态个数有限：有限状态机</p>
<p>有效电平：通常在时钟的触发沿内状态发生改变。</p>
<p>时钟周期tper、时钟频率、时钟触发沿、占空比</p>
<h3 id="时序电路的类型">时序电路的类型<a href="#时序电路的类型" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<ul>
<li>反馈时序电路：采用普通门电路和反馈回路来实现逻辑电路中的记忆能力，由此构成时序逻辑电路</li>
<li>时钟同步时序电路：也采用逻辑构件来构建电路，但输入由统一的时钟信号控制。</li>
<li>其它类型：通用基本型、多脉冲型等</li>
</ul>
<h3 id="双稳态器件">双稳态器件<a href="#双稳态器件" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>所谓的双稳态元件（或者电路），是指电路有两个稳定的状态，即置位状态和复位状态。Q为1的状态称为置位状态，而Q为0的状态称为复位状态。</p>
<p>双稳态电路的内在特性(inherent)</p>
<ul>
<li>2 稳定点（stable points）</li>
<li>1亚稳定点（metastable point）</li>
</ul>
<p>亚稳态，非有效的逻辑信号，但满足回路方程</p>
<p>任何时序电路都存在亚稳态现象</p>
<ul>
<li>开机：存在亚稳态</li>
<li>工作：外部激励必须满足最短时间要求, 才能生效, 否则…</li>
</ul>
<h3 id="单稳态">单稳态<a href="#单稳态" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>to be or not to be</p>
<h3 id="锁存器与触发器">锁存器与触发器<a href="#锁存器与触发器" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<ul>
<li>时序电路的基本构件。</li>
<li>都是双稳态元件。</li>
<li>锁存器(Latch)：连续地监测其输入，并且独立于时钟信号而在任何时候都可以改变输出</li>
<li>触发器(Flip-Flop)：连续地监测输入信号，并只在时钟信号所确定的时刻改变其输出</li>
</ul>
<h4 id="rs锁存器">RS锁存器<a href="#rs锁存器" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>S置位 R 复位  S=R=1时,Q=QN=0   S=R=0时,Q=last Q, QN=last QN  R和S不能同时取消，否则会导致震荡状态或亚稳态</p>
<p>输入信号宽度必须大于最小脉冲宽度</p>
<h4 id="r-s锁存器">R&rsquo;-S'锁存器<a href="#r-s锁存器" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>R非S非锁存器：低态有效的置位和复位，可以用与非门实现。</p>
<h4 id="具有使能端的rs锁存器">具有使能端的RS锁存器<a href="#具有使能端的rs锁存器" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>S-R Latch with Enable, 带使能端的RS锁存器(RS闩锁)
受使能信号控制，C为写入条件或指令</p>
<h4 id="d锁存器">D锁存器<a href="#d锁存器" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>数据经非门产生一对互补信号，D型锁存器(D Latch)</p>
<p>建立时间(Set-up time) 保持时间(Hold time)</p>
<h4 id="如何实现边沿触发">如何实现边沿触发<a href="#如何实现边沿触发" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>用 to be or not to be 电路</p>
<h4 id="边沿触发式edge-triggered触发器">边沿触发式(Edge Triggered)触发器<a href="#边沿触发式edge-triggered触发器" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>只在时钟信号的上升沿或者下降沿改变状态</p>
<h4 id="主从d触发器--存疑">主从D触发器  存疑<a href="#主从d触发器--存疑" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>第1个锁存器称为主(master)锁存器，第2个称为从(slave)锁存器。</p>
<p>传播延迟 (from CLK) 建立时间 (D before CLK) 保持时间 (D after CLK)</p>
<p>具有预置和清零端的正边沿D触发器</p>
<p>具有使能端的边沿触发式D触发器</p>
<h4 id="扫描触发器">扫描触发器<a href="#扫描触发器" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>扫描触发器除了D输入端以外，还有两个输入端。</p>
<p>TI即Test Input，用来输入测试序列（测试向量）。</p>
<p>TE即Test Enable，用来控制触发器工作状态。</p>
<h4 id="主从式触发器">主从式触发器<a href="#主从式触发器" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<ul>
<li>在时钟脉冲信号高电平期间数据进入触发器，在下降沿输出反映输入的变化</li>
<li>主从式触发器也称为脉冲触发型触发器(Pulse Triggered Flip-flops)</li>
<li>为了使得输出能正确地反映输入的变化，要求在时钟脉冲信号为高期间，输入不发生变化。</li>
<li>其特点是数据在第一个边沿锁入触发器，第二个边沿后数据出现在输出端。</li>
<li>主从式触发器基本上已经被边沿触发式触发器所取代。</li>
</ul>
<h4 id="主从式jk触发器">主从式JK触发器<a href="#主从式jk触发器" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>同时有效则翻转</p>
<p>在触发脉冲的后沿，JK输入的状态变化可能无效。 使用中，尽量保持JK稳定</p>
<p>0钳位 1钳位????</p>
<h4 id="边沿触发式jk触发器">边沿触发式JK触发器<a href="#边沿触发式jk触发器" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>解决主从JK触发器中1和0钳位的问题。</p>
<p>在上升沿时采样输入信号。</p>
<h4 id="t触发器">T触发器<a href="#t触发器" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<ul>
<li>T触发器：在每一个时钟脉冲的有效边沿都会改变状态。</li>
<li>常用在计数器和分频器。</li>
<li>具有使能端的T触发器</li>
</ul>
<h4 id="维持-阻塞d触发器">维持-阻塞D触发器<a href="#维持-阻塞d触发器" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<h4 id="锁存器和触发器的描述">锁存器和触发器的描述<a href="#锁存器和触发器的描述" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<h5 id="特征方程">特征方程<a href="#特征方程" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h5>
<p>SR锁存器： Q* = S + R&rsquo;Q</p>
<p>JK触发器： Q* = JQ&rsquo; + K&rsquo;Q</p>
<p>T触发器： Q* = Q&rsquo;</p>
<p>D触发器： Q* = D</p>
<h3 id="状态转移图">状态转移图<a href="#状态转移图" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<ul>
<li>用来描述电路状态，也可以对现实世界中任何有状态的事物进行建模</li>
<li>列举出该事物所有可能的状态，每个状态用一个圈表示</li>
<li>状态之间可以相互转换。状态转换用带箭头的弧线表示。</li>
<li>在弧线上标明状态发生变化的条件（即系统的输入）。也可以标明该状态转移导致的结果（输出）。</li>
</ul>
<h3 id="时钟控制时序逻辑电路分析">时钟控制时序逻辑电路分析<a href="#时钟控制时序逻辑电路分析" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>Sequential-Circuit：组合逻辑+记忆电路</p>
<ul>
<li>同步时序电路（Synchronous Sequential Logic）</li>
<li>异步时序电路（Asynchronous Sequential Logic）</li>
</ul>
<p>Synchronous Sequential Logic</p>
<ul>
<li>统一时钟驱动，触发时刻更新记忆电路状态</li>
<li>状态转移图描述</li>
<li>设计方法、工具相对规范成熟</li>
</ul>
<p>Asynchronous Sequential Logic</p>
<ul>
<li>状态变化时刻不一致</li>
<li>状态转移图描述</li>
<li>异步电路多用在接口电路设计方面</li>
</ul>
<h4 id="同步时序电路的类型">同步时序电路的类型<a href="#同步时序电路的类型" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>按照输出方程的不同，分为：</p>
<ul>
<li>Mealy型电路(Mealy State Machine)： 某时刻输出是该电路当前时刻输入和当前状态的函数</li>
<li>Moore型电路(Moore State Machine)：某时刻输出仅是该电路当前状态的函数，与当前时刻的输入无关，如某些计数器</li>
</ul>
<h4 id="状态机分析的步骤">状态机分析的步骤<a href="#状态机分析的步骤" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<ol>
<li>确定下一状态函数F和输出函数G</li>
<li>用F和G构造状态/输出表(state/output table)，列出所有当前状态和输入的组合，指定电路的下一状态和输出</li>
<li>画出状态图（state diagram）。</li>
<li>描述电路的功能。</li>
</ol>
<h4 id="状态图">状态图<a href="#状态图" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>State Diagram(状态图)中，离开某个特定状态的所有转移条件，满足:</p>
<ul>
<li>Mutually Exclusive(互斥性)，每种输入组合都有唯一的下一状态。否则相同输入组合对应不同的下一状态(二义性)</li>
<li>All Inclusion(完备性)，所有输入组合都有确定的下一状态(有时需要根据设计需求，在不违背题意的前提下作出合理安排)</li>
<li>称为完全确定的时序电路</li>
</ul>
<h4 id="时序图">时序图<a href="#时序图" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<ul>
<li>利用转移、状态和输出表，可构造定时图</li>
<li>定时图：表示出状态机在任何期望的起始状态和输入序列的作用下所产生的行为。</li>
</ul>
<h4 id="同步时序电路的分析步骤">同步时序电路的分析步骤<a href="#同步时序电路的分析步骤" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<ol>
<li>写出各触发器的激励方程。</li>
<li>把得到的激励方程代入到触发器的特征方程，得到转移方程/次态方程。</li>
<li>确定输出方程。</li>
<li>根据转移方程构造转移表，在转移表中对每一种状态/输入组合添加输出值，构成状态/输出表</li>
<li>利用状态名得到时序电路的状态图。</li>
<li>画出时序图。</li>
</ol>
<h3 id="时钟同步状态机设计">时钟同步状态机设计<a href="#时钟同步状态机设计" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<ol>
<li>根据文字描述，构造状态/输出表</li>
<li>（可选）将状态/输出表中的状态数目最小化</li>
<li>状态赋值，选择一组状态变量编码组合赋给状态</li>
<li>将状态变量组合代入状态/输出表，建立转移/输出表。</li>
<li>选择一种触发器作为状态存储器</li>
<li>构造激励表</li>
<li>由激励表推导出激励方程</li>
<li>由转移/输出表推导出输出方程</li>
<li>画出逻辑电路图。</li>
</ol>
<h4 id="状态化简">状态化简<a href="#状态化简" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>等价状态：设状态S1和S2是完全确定状态表中的两个状态,如果对于所有可能的输入序列，分别从状态S1	和状态S2出发，所得到的输出响应序列完全相同，	则状态S1和S2是等价的，记作(S1, S2) .	或说，状态S1和S2是等价对。等价状态可以合并。</p>
<p>等价状态具有传递性</p>
<p>等价类：彼此等价的状态集合</p>
<p>状态简化的任务是要在原始状态表中找出全部最大等价类(最大等价类集合)，并将每一个最大等价类用一个状态来表示。</p>
<p>假定状态S1和S2是完全确定原始状态表中的两个现态，那么S1和S2等价的条件可归纳为在输入的各种取值组合下：</p>
<ul>
<li>第一、它们的输出完全相同；</li>
<li>第二、它们的次态满足下列条件之一，即：(1) 次态相同；(2) 次态交错 (3) 次态循环 (4) 次态对等价</li>
</ul>
<p>隐含表法化简</p>
<h5 id="不完全确定状态表的简化">不完全确定状态表的简化<a href="#不完全确定状态表的简化" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h5>
<p>不完全确定状态表： 状态表中存在不确定的次态或输出，这些不确定的次态或输出将有利于状态简化。</p>
<p>相容状态：设状态S1和S2是不完全确定状态表中	的两个状态，如果对于所有的有效输入序列，分别从状态S1和S2出发，所得到的输出响应序列(除不确定的那些位之外)是完全相同的，那么状态S1和S2是相容的，或者说状	态S1和S2是相容对，记作(S1,S2)。相容状态可以合并。</p>
<p>状态相容无传递性</p>
<p>相容类：彼此相容的状态集合  最大相容类：不被其他相容类所包含的相容类</p>
<p>作最小化状态表: 最小化状态表(又称最小闭覆盖) 应满足下列三个条件：</p>
<ul>
<li>覆盖性－－所选相容类集合应包含原始状态表中	的全部状态。</li>
<li>最小性－－所选相容类集合中相容类的个数应最	少。</li>
<li>闭合性－－所选相容类集合中的任一相容类，在	原始状态表中任一输入条件下产生的次态应	该属于该集合中的某一个相容类。</li>
</ul>
<h4 id="状态赋值状态编码">状态赋值(状态编码)<a href="#状态赋值状态编码" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<ul>
<li>确定表示状态表的状态需要多少位二进制变量，并且对每一个已命名的状态赋予一个特定的组合（编码）。</li>
<li>状态编码(coded state)：赋给一个特定状态的二进制数的组合。</li>
</ul>
<p>状态分配方案的种数：排列数计算</p>
<p>如果两种状态分配在实现逻辑时产生相同的结果，则认为它们是等价的。状态编码分配互补，或状态编码左右互换，都是等价的。</p>
<p>独立状态数: N=(2^K - 1)! / ((2^K-n)!K!)</p>
<p>在同步时序电路中状态分配目的在于：在逻辑化简时，生成尽可能大的必要质蕴含。状态分配的标准就是使得质蕴含达到最大程度。寻找较好的结果。</p>
<p>状态编码：从2^n种可能组合中选择S种编码</p>
<p>遗憾的是：至今没有找到普遍有效的算法实现最佳状态分配，唯一途径是将所有分配方案都试个遍</p>
<p>次佳状态分配方案：相邻状态分配法，建立通用方程法，减少相关性</p>
<h5 id="次佳状态分配方案">次佳状态分配方案<a href="#次佳状态分配方案" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h5>
<p>相邻状态分配法</p>
<ul>
<li>次态相同，现态相邻: 使下一个状态较少依赖于当前状态变量</li>
<li>同一现态，次态相邻：使下一状态较少依赖于输入变量</li>
<li>输出相同，现态相邻：使输出较少依赖于当前状态变量</li>
</ul>
<h5 id="处理未用状态方法">处理未用状态方法<a href="#处理未用状态方法" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h5>
<p>最小风险法 最小成本法</p>
<h4 id="反馈时序电路">反馈时序电路<a href="#反馈时序电路" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>异步时序电路特征：状态变化不受“统一时钟信号控制”</p>
<p>依电路结构和输入信号形式不同，异步时序电路分类：</p>
<ul>
<li>脉冲型Pulsed Asynchronous Circuit(脉冲信号):记忆电路为“触发器”</li>
<li>电平型Level Asynchronous Circuit(电平信号)：记忆电路为“反馈加延时”</li>
</ul>
<p>双稳态电路、锁存器和触发器等都是反馈时序电路。反馈回路是记忆元件，存储0或1。</p>
<p>基本模式电路，对输入信号的约束：</p>
<ul>
<li>不允许两个或两个以上输入同时变化(每时刻仅允许1个输入发生变化)</li>
<li>仅当电路处于稳态时，允许输入信号发生变化</li>
</ul>
<h5 id="反馈时序电路的分析步骤">反馈时序电路的分析步骤<a href="#反馈时序电路的分析步骤" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h5>
<ul>
<li>切断反馈路径，写出激励函数和输出函数</li>
<li>列出状态转移表</li>
<li>作出状态图和时序(间)图</li>
<li>说明电路的逻辑功能</li>
</ul>
<h5 id="反馈时序电路的分析">反馈时序电路的分析<a href="#反馈时序电路的分析" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h5>
<ul>
<li>现态和次态只是在时间上有延迟，经过一段时间后，现态和次态的值趋于一致。</li>
<li>总态Total State：用来描述异步时序机的行为。包括输入状态I和次态S，并记为(I，S)。</li>
<li>稳定状态：如某一现态y在输入x发生变化时，若次态Y和现态y的值相同，则称次态Y为稳定状态；若次态Y和现态y的值不等，则称进入的次态Y为不稳定状态。不稳定状态是不能保持不变，经过一段延迟时间后，现态和次态趋于一致，进入稳定状态，则称为状态迁移。</li>
<li>状态表：状态命名，且将稳定的总状态用圆圈圈住。</li>
<li>总态可以是稳定的也可以是不稳定的，不稳定的总态要发生状态迁移，而达到一个稳定的状态或循环不稳态。稳定的总态，如果输入不改变，则始终保存稳定状态，不会发生状态迁移。</li>
<li>异步电路的基本工作方式是保证电路稳定工作，使电路状态的转移是可以预测的。</li>
<li>输入状态的改变仅能引起次态在状态表作相邻方格的水平移动。</li>
<li>二次状态的改变则引起次态在状态表中作垂直方向的移动。</li>
</ul>
<p>多反馈回路中，必须断开所有的反馈，设置虚构的缓冲器和状态变量。</p>
<p>最小割集(cut set)：断点数最少的集合</p>
<h5 id="竞争">竞争<a href="#竞争" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h5>
<p>一个输入信号的变化，引起多个内部状态变量改变，称之为发生了竞争</p>
<ul>
<li>非临界竞争(Noncritical race)，最终状态与状态变量变化顺序无关，结果可预测。</li>
<li>临界竞争(Critical race)，最终状态取决于状态变量变化顺序和速度，结果不可预测。</li>
</ul>
<p>对于竞争的处理</p>
<ul>
<li>允许非临界竞争</li>
<li>避免临界竞争</li>
</ul>
<h5 id="状态表与流程表">状态表与流程表<a href="#状态表与流程表" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h5>
<ul>
<li>状态表：状态命名，且将稳定的总状态用圆圈圈住。</li>
<li>跳程hop：单个输入变量变化时，电路达到新的稳定总状态时所发生的不稳定的状态。</li>
<li>流程表Flow table：由现态和在不同输入条件下的次态及输出组成。删除状态表中的跳程，只表示出每次转移过程的最终目标，去除未用内部状态的那些行，去掉那些稳定的总状态在单个输入变化时从不会到达的下一状态项。</li>
</ul>
<h4 id="反馈时序电路设计">反馈时序电路设计<a href="#反馈时序电路设计" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<ol>
<li>根据逻辑要求，建立原始流程表</li>
<li>将原始状态表简化，得到最简流程表</li>
<li>对最简流程表进行状态分配</li>
<li>建立激励表和输出表</li>
<li>列出激励函数和输出函数表达式</li>
<li>画出逻辑电路图</li>
</ol>
<p>原始流程表:每一行含有一个稳态 每个状态决定于上一个状态和输入</p>
<h5 id="本质冒险">本质冒险<a href="#本质冒险" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h5>
<p>本质冒险：当输入信号变化时，电路进入错误状态的可能性。：如果最终状态变量的变化被传回到激励电路输入端之前，输入的变化未被所有的激励电路接收到，就会发生错误。</p>
<p>通俗定义：如果从状态S出发，X的一次变化和三次变化的最终结果状态不一致，就存在本质冒险。</p>
<p>本质冒险是电路中固有的问题，可通过增加延迟解决问题。</p>
<h3 id="时序逻辑设计实践">时序逻辑设计实践<a href="#时序逻辑设计实践" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>定时图：</p>
<p>建立时间容限=tclk-tffpd(max)-tcomb(max)-tsetup&gt;0</p>
<p>保持时间容限=tffpd(min)+tcomb(min)-thold&gt;0</p>
<h4 id="开关消颤">开关消颤<a href="#开关消颤" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>双稳态电路消颤</p>
<p>锁存器和上拉电阻消颤</p>
<h4 id="s-r锁存器消除击键抖动">S&rsquo;-R'锁存器消除击键抖动<a href="#s-r锁存器消除击键抖动" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<h4 id="总线保持电路">总线保持电路<a href="#总线保持电路" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>在三态总线中，悬空总线的处理方法</p>
<ul>
<li>上拉电阻：价格贵、占用印刷电路的面积 大小选择比较困难，过大，转换慢；过小，则消耗过多的电流</li>
<li>有源总线保持电路：带电阻反馈回路的双稳态电路</li>
</ul>
<p>为什么要？？？？</p>
<h4 id="寄存器">寄存器<a href="#寄存器" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>共用一个时钟信号的2个或2个以上的D触发器组合在一起，称为寄存器，通常用来存储一组相关的二进制数。</p>
<p>锁存器和触发器的区别:</p>
<ul>
<li>前者是电位信号控制，后者是同步时钟边沿信号控制。</li>
<li>使用的场合不同：取决于控制方式、控制信号和数据之间的时间关系。：数据有效滞后于控制信息时，使用锁存器。反之，可使用寄存器。</li>
</ul>
<h4 id="计数器">计数器<a href="#计数器" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>计数器：在状态图中包含一个循环的时序电路。</p>
<p>1.功能：对时钟脉冲 CLK 计数。
2.应用：分频、定时、产生节拍脉冲和脉冲序列、进行数字运算等。</p>
<p>按数制分：二进制计数器 十进制计数器 N进制(任意进制)计数器</p>
<p>按计数方式分： 加法计数器 减法计数器 可逆计数（Up-Down Counter）</p>
<h5 id="行波计数器进位信息像波浪一样由低位向高位每次传送一次">行波计数器：进位信息像波浪一样由低位向高位，每次传送一次。<a href="#行波计数器进位信息像波浪一样由低位向高位每次传送一次" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h5>
<p>延迟时间很长</p>
<h5 id="同步计数器">同步计数器<a href="#同步计数器" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h5>
<p>同步计数器：所有的触发器共用一个CLK信号 使用带有使能端的T触发器</p>
<p>串行同步4位二进制计数器 并行同步4位二进制计数器(最快的二进制计数器)</p>
<p>一次状态转移中有2个以上的计数位同时变化，在译码端可能产生尖峰脉冲(glitch)。 属于功能性冒险</p>
<p>无冒险译码输出：输出延迟一个时钟周期 可使用环形计数器实现</p>
<p>可逆同步计数器169</p>
<p>N进制计数器：用触发器和门电路设计或用集成计数器构成。</p>
<p>十进制异步计数器</p>
<p>提高归零可靠性？</p>
<h5 id="移位寄存器">移位寄存器<a href="#移位寄存器" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h5>
<p>移位寄存器shift register：是一个n位寄存器，在每一个时钟触发沿到来时就将所存储的数据移一位。</p>
<ul>
<li>处理串行数据</li>
<li>用于rs232,modem通信、以太网连接等</li>
<li>串入串出</li>
</ul>
<p>也可以串入并出、并入串出、并入并出</p>
<h6 id="移位寄存器的应用">移位寄存器的应用<a href="#移位寄存器的应用" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h6>
<ul>
<li>串并转换是移位寄存器的“数据应用”。</li>
<li>与组合电路构成具有循环状态图的状态机，“非数据应用”，称为移位寄存器计数器shift-register counter。</li>
<li>计数顺序既不是升序也不是降序。</li>
</ul>
<h5 id="环形计数器">环形计数器<a href="#环形计数器" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h5>
<h5 id="自校正环形计数器">自校正环形计数器<a href="#自校正环形计数器" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h5>
<h5 id="johnson计数器">Johnson计数器<a href="#johnson计数器" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h5>
<p>扭环计数器，把n位移位寄存器的串行输出取反，得到具有2n种状态的计数器。 有2n-2n个非正常状态，存在健壮性问题。</p>
<h5 id="线性反馈移位寄存器计数器">线性反馈移位寄存器计数器<a href="#线性反馈移位寄存器计数器" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h5>
<ul>
<li>n位线性反馈移位寄存器计数器(n-bit linear feedback shift-register counter,LFSR)有2n-1种有效状态，通常称为最大长度序列发生器(maximum-length sequence generator)。</li>
<li>基于有限域理论（finite field），对于任意值n，至少可以找到一种反馈方程，使得计数器的计数循环包含所有2n-1种非零状态。</li>
<li>最大长度序列。</li>
<li>n大于3，有多个反馈方程可实现最大长度序列。</li>
<li>用于伪随机数生成器、检错码、纠错码，加扰和解扰通信数据等。</li>
</ul>
<h4 id="计数器的应用">计数器的应用<a href="#计数器的应用" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>序列信号发生器</p>
<h4 id="迭代电路与时序电路">迭代电路与时序电路<a href="#迭代电路与时序电路" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<ul>
<li>一个由n个模块构成的迭代电路，其功能可以用一个模块加暂存机制构成的时序电路来完成，需经过n个时钟周期才能得到结果。</li>
<li>数字设计中的空间/时间折中。</li>
</ul>
<h2 id="存储器cpld和fpga">存储器、CPLD和FPGA<a href="#存储器cpld和fpga" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<h3 id="存储器">存储器<a href="#存储器" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<h4 id="rom">ROM<a href="#rom" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<ul>
<li>只读存储器简称ROM (read-only memory)：是一种具有n个输入b个输出的组合逻辑电路。</li>
<li>包含地址输入（地址译码）、数据输出（输出缓冲）和存储矩阵三部分。</li>
<li>与真正存储器的区别：非易失性存储器(non volatile memory)。即使电源断电，ROM中存储的数据不会丢失。</li>
<li>ROM = 最小项译码器+ 可编程或矩阵</li>
<li>ROM = 存真值表的存储器</li>
</ul>
<h4 id="rom的应用">ROM的应用<a href="#rom的应用" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<ul>
<li>字符发生器：实现字符发生器的基本原理是:将字符的点阵预先存储在ROM中，然后顺序给出地址码，从存储矩阵中逐行读出字符的点阵，并送入显示器即可显示出字符。</li>
<li>数学函数表：实现计算机中的运算有两种方法，一种是编写运算程序，存入ROM中，通过计算机执行运算程序。另一种方法是把因变量和自变量的函数关系存在ROM中，好像查函数表一样。</li>
</ul>
<h4 id="ram">RAM<a href="#ram" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<ul>
<li>读/写存储器(Read/Write Memory RWM)是指可以在任何时候存储和检索信息的存储器阵列</li>
<li>现在数字系统中的读写存储器大多数是随机存取存储器（Random-access Memory, RAM），意思说读或写存储器的1个位所花费的时间与该位在RAM中的位置无关。</li>
<li>静态存储器Static RAM,SRAM：一旦在某个存储位置写入数据，只要电源不被切断，其存储内容保持不变，除非重新写入新内容。</li>
<li>动态存储器Dynamic RAM,DRAM：必须对存储数据进行周期性读出和写入刷新，否则存储器中的数据将会消失。</li>
</ul>
<p>存储器的容量扩展：位扩展 字扩展  字位同时扩展</p>
<h4 id="cpld">CPLD<a href="#cpld" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>基本结构：大多由内部PLD、输入输出块和可编程内部连线组成。</p>
<h4 id="fpga">FPGA<a href="#fpga" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<ul>
<li>与CPLD相比，具有更高的集成度、更强的逻辑功能和更大的灵活性</li>
<li>FPGA属于阵列型PLD</li>
<li>有三个可编程电路块和一个用于存放编程数据的SRAM组成：可编程逻辑块（CLB）  输入/输出模块（IOB）  可编程互连线（PI）</li>
</ul>
<h4 id="fpga和cpld的区别">FPGA和CPLD的区别<a href="#fpga和cpld的区别" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<ul>
<li>编程技术与数据易失性：通常FPGA采用SRAM进行功能配置，可以重复编程，但系统掉电后，SRAM中的数据丢失。因此，需在FPGA外加EPROM，将配置数据写入其中，系统每次上电自动将数据引入SRAM中。而一般CPLD器件采用EEPROM存储技术，可重复编程，且系统掉电后，EEPROM中的数据不会丢失，适于数据的保密。</li>
<li>触发器资源：FPGA器件由于含有丰富的触发器资源，容易实现时序逻辑，若要求实现比较复杂的组合电路则需要几个CLB结合起来实现。CPLD的与或阵列结构，使它更适合于实现大规模的组合逻辑功能，而它的触发器资源相对比较少。</li>
<li>芯片利用率：FPGA多为细粒度结构。FPGA内部有丰富连线资源，CLB分块比较小，芯片利用率比较高。CPLD多为粗粒度结构。 CPLD宏单元的与或阵列较大，通常不能完全被应用，而且宏单元之间主要通过高速数据通道连接，容量有限，限制了器件的灵活布线，因此CPLD利用率比FPGA低。</li>
<li>布线结构与延时预测性：FPGA为非连续式布线。FPGA器件在每次编程时实现的逻辑功能一样，但走的路线不同，因此延时难以预测，要求开发软件允许工程师对关键的路线给予限制。CPLD为连续式布线。CPLD每次布线路径一样，其连续式互连结构利用具有同样长度的一些金属线实现逻辑单元之间的互连，消除了分段式互连结构在定时上的差异，并且在逻辑单元之间提供快速而且具有固定延时的通路。另外，CPLD的延时比较小。</li>
</ul>
<h2 id="数字系统">数字系统<a href="#数字系统" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>数字系统的基本模型：由输入部件、输出部件及逻辑系统组成。逻辑系统包括存储部件、处理部件、控制部件三大子系统。</p>
<p>基本子系统：是指构成数字系统时最基本的逻辑功能部件。这些逻辑功能部件有：算术逻辑运算单元ALU、寄存器、RAM、数据总线、控制器。</p>
<p>ALU：是数字系统中对数据进行加工处理的功能部件。</p>
<p>寄存器：加法器和ALU均由门电路组成，它们没有记忆功能，因此运算的结果需要寄存器保存起来。而参与运算的两个数也要取自寄存器。寄存器是数字系统中必不可少的逻辑子系统。  寄存器的分类：通用寄存器 、专用寄存器。</p>
<p>存储器RAM：当存储大量数据时，从经济和成本上考虑，只能使用随机读写的RAM存储器。</p>
<p>总线的概念 ：在数字系统中，总线是多个逻辑子系统的联系纽带。所谓总线，就是多个信息源分时传送数据到多个目的地的传送通路。单向总线 双向总线</p>
<p>给不给器件的原理图 ？？？</p>

		</div>
	</main>

	<footer id="site-footer" class="section-inner thin animated fadeIn faster">
		<p>&copy; 2020 <a href="https://ricky-ting.github.io">Ricky Ting</a> &#183; <a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0</a></p>
		<p>
			Made with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> &#183; Theme <a href="https://github.com/Track3/hermit" target="_blank" rel="noopener">Hermit</a> &#183; <a href="https://ricky-ting.github.io/posts/index.xml" target="_blank" title="rss"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg></a>
		</p>
	</footer>



	<script src="https://ricky-ting.github.io/js/bundle.min.4a9a0ac3d2217822c7865b4161e6c2a71de1d70492264337755427898dd718f6.js" integrity="sha256-SpoKw9IheCLHhltBYebCpx3h1wSSJkM3dVQniY3XGPY=" crossorigin="anonymous"></script>
	

</body>

</html>
