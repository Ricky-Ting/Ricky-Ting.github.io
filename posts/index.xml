<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Posts on Ricky Ting&#39;s Blog</title>
		<link>https://ricky-ting.github.io/posts/</link>
		<description>Recent content in Posts on Ricky Ting&#39;s Blog</description>
		<generator>Hugo -- gohugo.io</generator>
		<language>zh-cn</language>
		<copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
		<lastBuildDate>Sat, 09 Jan 2021 16:49:39 +0800</lastBuildDate>
		<atom:link href="https://ricky-ting.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
		
		<item>
			<title>Pregel</title>
			<link>https://ricky-ting.github.io/posts/pregel/</link>
			<pubDate>Sat, 09 Jan 2021 16:49:39 +0800</pubDate>
			
			<guid>https://ricky-ting.github.io/posts/pregel/</guid>
			<description>Introduction Pregel是Google在2010年发表的一篇文章。主要提出了一个富有表达性的和易于编程的图计算框架。Pregel是Euler七桥问题中</description>
			<content type="html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>Pregel是Google在2010年发表的一篇文章。主要提出了一个富有表达性的和易于编程的图计算框架。Pregel是Euler七桥问题中那条河的名字。</p>
<p>Pregel的几大特点：</p>
<ol>
<li>大规模(large-scale)</li>
<li>可扩展性(scalability)</li>
<li>容错性(fault-tolerant): 通过heartbeat、checkpointing和logging。</li>
<li>高效(efficient): MR也可以用来进行图计算，不过太过低效。</li>
</ol>
<h2 id="contribution">Contribution</h2>
<h2 id="methods">Methods</h2>
<h3 id="why-pregelmotivation">Why Pregel?(Motivation)</h3>
<p>进行分布式图计算的几种方法：</p>
<ol>
<li>使用已有的分布式基础设施：对使用者较为复杂，而且每个新的算法都需要重新实现一遍一些较为基础的功能。总的来说，还是抽象层次较低，已有的分布式基础设施的API较为难用。给使用者提供一个抽象层次更高的东西即为框架，如何把这个抽象层做的通用(general)和高效(efficient)就是值得研究的问题了。(All problems in computer science can be solved by another level of indirection.)</li>
<li>使用类似于Mapreduce这样的已有的分布式计算框架：问题的pattern不同，可以做，但不高效。我们需要一个为图计算这种计算模式(pattern)设计一个特有的框架来提高效率。</li>
<li>使用已有的单机图计算库：不能scale。</li>
<li>已有的并行图计算系统(BGL、CGMgraph): 没有具体看，也不清楚这里并行是否可以进行分布式部署。文章中说：这些系统没有考虑容错性。</li>
</ol>
<p>因此，pregel的作者们认为这些现有的东西都不能满足他们的需求(高效、容错性、可扩展性等)，所以设计了Pregel。</p>
<h3 id="计算模型">计算模型</h3>
<p>采用BSP(Bulk Synchronous Parallel)和消息传递(Message Passing)，并以节点为中心(vertice-centric)。</p>
<p>关于BSP，我从wiki上找了张图：<img src="/image/Pregel/BSP.png" alt="BSP计算模型"></p>
<p>整个Pregel的计算模型也就是这张图，Pregel的计算是由一系列的superstep组成的，每个superstep就是上图的流程。这里的Local Computation就是每台机器对于自己所拥有的顶点展开计算。具体来说，对于每一个节点，先收集上一轮中传递过来的messages(已经存在本地了)，然后做一些计算，得出需要发送的messages。在Communication阶段，将这些messages发送出去。</p>
<p>关于算法如何终止：只有活跃(active)的顶点才会进行Local Computation。当某一轮开始的时候，所有的顶点都不活跃了，那整个算法也就终止了。</p>
<p>关于活跃和不活跃的状态转换，paper中给了一张图：</p>
<p><img src="/image/Pregel/VertexStateMachine.png" alt="活跃和不活跃的状态转换"></p>
<p>当然在第一轮的时候，所有顶点都是活跃状态的，不然程序直接结束了。</p>
<h4 id="一些组件">一些组件</h4>
<p>Combiners: 聚合msg来减少通信量，一般是在msg发送端部署，比如在SSSP问题中，我们可以对发往同一个顶点的所有msg取MIN。基本上是个优化操作，没有也没什么关系，本质上是把下一轮Compute()里的操作提前了，在发送之前。</p>
<p>Aggregators: 一般用于全局通信，对所有节点提供的值进行规约，形成一个值，供下一轮使用。感觉halt的条件就可以看做是一个aggregator(AND(v1.isHalt(), v2.isHalt(), &hellip;))</p>
<p>Topology Mutations: 这个算个feature，可以动态改变拓扑结构(增删顶点和边)。可能会导致冲突，两个解决方法：</p>
<ul>
<li>偏序(partial ordering): 删边-删点-增点-增边</li>
<li>handlers: 可以user-defined，也可以default(随机选择)</li>
</ul>
<p>但没看明白它的同步过程：猜测也是在message passing阶段，传递mutation，然后由每个顶点handle在Computate之前。顶点管理着自己和它的出边。</p>
<h3 id="implementation">Implementation</h3>
<p>顶点的分配就是hash: 即 hash(ID) % N, N是划分数。</p>
<p>整个集群的架构是Maste/Slave架构，整个流程如下：</p>
<ol>
<li>Worker向Master进行注册，并保持heartbeat。</li>
<li>master进行数据集的划分，并给每个worker分配一些partition(可以多于一个)，并且所有worker都知道整体的分配情况，这样worker就知道该往哪发msg。</li>
<li>master给每个worker分配一部分输入文件，worker读取。对于不属于自己的数据，通过msg发送给相应的worker。所有的顶点现在都是活跃状态。</li>
<li>master让所有worker开启一轮superstep，superstep的过程前面已经说过。实现上有一点优化：计算和通信是overlap的，可以提高效率。当所有worker完成后，告诉master一些信息，包括活跃顶点数，发送的msg数量等。如果有活跃顶点或者发送的msg，继续进行这一步。</li>
<li>计算结束，每个worker保存自己的那部分结果。</li>
</ol>
<p>容错性：每几轮(freq可以指定)中worker保存顶点值、边值和收到的msg，master保存聚合的值，这叫checkpoint。通过heartbeat来探测状态。如果不保存发送的msg，所有partition都需要从某一个checkpoint重新计算。但是如果保存了发送的msg，只需要失败的partition重来即可, 但会使得保存的数据变多，这叫confined recovery. 随机算法需要保存随机数种子来使用confined recovery。</p>
<p>Worker实现：对于每个顶点：一份顶点值、一份边值、两份incoming queue(本轮和下一轮)。 对于out queue，应该是每个target worker有一个，queue是异步发送，到达一个threshold就发送。Combiner既在out queue上作用(节约带宽)，也在incoming queue上作用(节约内存)。</p>
<p>Master实现：Master主要做一些管理工作，不多做赘述。</p>
<p>Aggregator: tree-based 而不是streaming，提高并行度。</p>
<h3 id="evaluation">Evaluation</h3>
<p>Evaluation比较简单：大致是scalability比较好。</p>
<p>我的观察：Worker越多，cross edge也就越多(对于相同的图)，因此scale不是线性的，也可能和一些固有的overhead有关。</p>
<h2 id="drawback">Drawback</h2>
<p>paper中没有提到，但我认为计算应该是完全基于incoming msg的，即不能随意读取非本节点的状态。</p>
<p>节点度比较大的时候，communication会比较大，可能需要较好的划分方法，让cross edge尽量少。</p>
<h2 id="related-works">Related Works</h2>
<h2 id="miscs">Miscs</h2>
<p><a href="https://static.googleusercontent.com/media/research.google.com/en//archive/googlecluster-ieee.pdf">Web search for a planet: The Google Cluster Architecture.</a>: 是03年的一篇文章，可以看到Google Web search的整个流程(比较老了，考古级文章)。从google的很多早期论文中都可以看出，google一直喜欢采用commodity PCs(注重performance per price)，把reliability放在软件(replica)上，并通过shard等机制提高scalability。P.S. 第一次看到commodity PC这个词应该就是在google的文章里。 这篇文章里也总结了这几个principle：</p>
<ol>
<li>Software reliability</li>
<li>Use replication for better requset throughput and availability</li>
<li>Price/performance beats peak performance.</li>
<li>Using commodity PCs reduces the cost of computation.</li>
</ol>
<p>Google的当时的策略是选择中端产品，每隔至多三年全部替换(CPU性能在当时提升得很快)。</p>
<h2 id="reference">Reference</h2>
<p>[1]. <a href="https://www.slideshare.net/riyadparvez/pregel-35504069">Pregel Slides</a></p>
<p>[2]. <a href="https://en.wikipedia.org/wiki/Bulk_synchronous_parallel">BSP wikipedia</a></p>
]]></content>
		</item>
		
		<item>
			<title>浅谈loop Unrolling</title>
			<link>https://ricky-ting.github.io/posts/%E6%B5%85%E8%B0%88loop-unrolling/</link>
			<pubDate>Sat, 18 Apr 2020 22:44:55 +0800</pubDate>
			
			<guid>https://ricky-ting.github.io/posts/%E6%B5%85%E8%B0%88loop-unrolling/</guid>
			<description>最近在做体系结构的实验，正好接触到了loop unrolling，就来简单地写一写。 为什么要有loop unrolling 这要从现代处理器的微架构讲起，现代CP</description>
			<content type="html"><![CDATA[<p>最近在做体系结构的实验，正好接触到了loop unrolling，就来简单地写一写。</p>
<h1 id="为什么要有loop-unrolling">为什么要有loop unrolling</h1>
<p>这要从现代处理器的微架构讲起，现代CPU为了提升性能一般都采用了流水线(Pipeline)。流水线能够流水线的引入提升了CPU的吞吐量，也增加了CPU function unit的利用率。</p>
<p>但流水线的引入也带来了很多问题，比如data hazard, control hazard。在现代处理器中，data hazard一般通过forwarding来解决，而control hazard一般通过分支预测(Branch prediction)来解决。</p>
<p>我们这里着重关注control hazard，即由于条件跳转，我们得等待一定的延迟才能得到准确的跳转地址(taken or not taken, that&rsquo;s a question)。如果我们在得到准确的跳转地址之前什么都不做，我们会白白浪费很多CPU资源，这时我们就引入了分支预测，我们先去猜这个分支到底跳转还是不跳转，然后直接去执行相应的指令。当然这个猜也不是毫无根据地猜，一般会根据之前的跳转结果来猜，具体的实现可以有很多种。</p>
<p>既然是预测，就有可能预测得不对，这就会导致CPU执行了错误的指令，需要冲刷流水线，并重新去取得正确的指令，而且现代处理器流水线都是比较深的(Intel Haswell架构有14-19级流水线)，所以预测错误的代价是比较大的。</p>
<p>为了提升程序这部分的性能，我们有三条路：</p>
<ol>
<li>提升分支预测的性能，这是Intel等硬件厂商在干的事(好像现在已经能达到90%以上的正确率)。</li>
<li>推测执行(Predicated execution)，cmov就是推测执行。</li>
<li>减少分支的数量，这是编译器或者软件编写者去干的事</li>
</ol>
<p>Loop unrolling 就属于上述的第三条路，我们将循环展开来减少分支的数量。</p>
<h1 id="如何实现loop-unrolling">如何实现loop unrolling</h1>
<p>Loop unrolling的思路就如下所示：</p>
<div class="highlight"><pre class="chroma"><code class="language-C++" data-lang="C++"><span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">+=</span><span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
  <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div><p>我们每次执行两次加法，就把分支的数量减少了一半。不过上述代码只是一个思路，其实并不正确，它没有考虑到N为奇数的情况。</p>
<p>我们下面来看看正确的写法：</p>
<div class="highlight"><pre class="chroma"><code class="language-C++" data-lang="C++"><span class="c1">// k为展开的次数，上面的代码就是k=2的情况, 注意具体代码中k应该是常数
</span><span class="c1"></span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span><span class="p">(;</span> <span class="n">i</span><span class="o">+</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="o">&lt;=</span><span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">+=</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="p">....</span>
	<span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">for</span><span class="p">(;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div><p>第一个for循环处理0~k-1, k~2k-1,.. 这些情况，第二个循环处理最后剩下的少于k个情况。</p>
<p>我闲逛的时候发现还有一种精巧(<del>奇技淫巧</del>)的方法，叫做Duff&rsquo;s device, 它利用了C语言switch-case语句fall-through的特性。我们来看看它的代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-C++" data-lang="C++"><span class="k">switch</span><span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
<span class="k">case</span> <span class="mi">0</span><span class="o">:</span> 
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">];</span>
		<span class="k">case</span> <span class="nl">k</span><span class="p">:</span>
			<span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">];</span>
		<span class="k">case</span> <span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span>
			 <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">];</span>
		<span class="p">...</span>
		<span class="k">case</span> <span class="mi">1</span><span class="o">:</span>
			<span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">];</span>
	<span class="p">}</span> <span class="k">while</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">);</span>
<span class="p">}</span>


</code></pre></div><h1 id="loop-unrolling的利弊">loop unrolling的利弊</h1>
<p>优势:</p>
<ul>
<li>分支减少，如果你展开了$k$倍，分支指令就减少到$1/k$.</li>
<li>相比较编译器的循环展开，自己做循环展开更加可控，而且能对动态循环做展开，即循环的次数不是常量。</li>
</ul>
<p>劣势：</p>
<ul>
<li>代码膨胀，如果你展开了$k$倍，代码就膨胀$k$倍，不过我们只会对critical path上的代码做优化，所以整个程序的代码不会膨胀得那么厉害。</li>
<li>程序可读性下降。</li>
</ul>
<h1 id="参考文献">参考文献</h1>
<ul>
<li>[1] <a href="https://en.wikipedia.org/wiki/Loop_unrolling">Wikipedia: Loop unrolling</a></li>
<li>[2] <a href="https://en.wikipedia.org/wiki/Haswell_(microarchitecture)">Wikipedia: Haswell (microarchitecture)</a></li>
<li>[3] <a href="https://en.wikipedia.org/wiki/Duff%27s_device">Wikipedia: Duff&rsquo;s Device</a></li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>How to Read a Paper</title>
			<link>https://ricky-ting.github.io/posts/how-to-read-a-paper/</link>
			<pubDate>Sat, 11 Apr 2020 11:47:21 +0800</pubDate>
			
			<guid>https://ricky-ting.github.io/posts/how-to-read-a-paper/</guid>
			<description>前言 在这篇文章中，作者提出了一种three-pass的论文阅读方法，由浅入深，并且根据自己的需要来选择了解的深度。其实不只是论文阅读，平时的</description>
			<content type="html"><![CDATA[<h1 id="前言">前言</h1>
<p>在<a href="https://web.stanford.edu/class/ee384m/Handouts/HowtoReadPaper.pdf">这篇文章</a>中，作者提出了一种three-pass的论文阅读方法，由浅入深，并且根据自己的需要来选择了解的深度。其实不只是论文阅读，平时的文章阅读、学习也是这样的。对于电子书，我一直觉得需要比较好的TOC，而且最好能在侧边栏显示，这样在阅读的过程中，才不会迷失在细节中，在很多需要长时间努力的活动中，保持方向感是很重要的。</p>
<h1 id="读论文的three-pass">读论文的three-pass</h1>
<p>首先我们要明确每一个pass的目的：</p>
<ul>
<li>First pass: 掌握论文的general idea，梳理论文的脉络。</li>
<li>Second pass: 抓住论文的主要内容，而不是迷失在细节中。</li>
<li>Third pass: 更深地去理解论文。</li>
</ul>
<h2 id="the-first-pass">The first pass</h2>
<p>文章中用了一个词叫&quot;bird&rsquo;s-eye view&quot;，这遍的目的主要是快速扫一遍，花大概五到十分钟。文章中列出了具体的步骤，如下：</p>
<ol>
<li>Carefully read the title, abstract, and introduction</li>
<li>Read the section and sub-section headings, but ignore everything else</li>
<li>Read the conclusions</li>
<li>Glance over the references, mentally ticking off the ones you’ve already read</li>
</ol>
<p>那么如何才能知道这一遍是否达到想要的目的呢，你可以问自己这么几个问题：</p>
<ol>
<li>Category: What type of paper is this? A measure- ment paper? An analysis of an existing system? A description of a research prototype?</li>
<li>Context: Which other papers is it related to? Which theoretical bases were used to analyze the problem?</li>
<li>Correctness: Do the assumptions appear to be valid?</li>
<li>Contributions: What are the paper’s main contribu-
tions?</li>
<li>Clarity: Is the paper well written?</li>
</ol>
<p>这样就能快速地了解一篇论文，看看它是否契合你的兴趣，以及是否有比较大的contribution，来决定是否要进行第二遍阅读。</p>
<h2 id="the-second-pass">The second pass</h2>
<p>这一遍要比第一遍更细致一点，但不要纠结于细节(比如证明)，这一遍读的时候最好能圈圈画画，标记出你认为重要的，以及需要在第三遍中进一步理解的。文章中也总结了一些步骤：</p>
<ol>
<li>Look carefully at the figures, diagrams and other illus- trations in the paper. Pay special attention to graphs. Are the axes properly labeled? Are results shown with error bars, so that conclusions are statistically sig- nificant? Common mistakes like these will separate rushed, shoddy work from the truly excellent.</li>
<li>Remember to mark relevant unread references for fur- ther reading (this is a good way to learn more about the background of the paper).</li>
</ol>
<p>要注意参考文献，里面可能有一些比较fundamental的文章，可能会在将来需要阅读。</p>
<p>这遍阅读大概要花一个小时，第二遍阅读完了之后，你有这么几种选择：</p>
<ul>
<li>放弃这篇论文</li>
<li>先去了解一些背景知识，再接着读这篇论文。(看文章的时候也是一样，当遇到了自己context中没有概念可能会造成阅读障碍，当这些概念过多，影响到理解的时候，就需要停下来去补补相关概念。)</li>
<li>接着读第三遍</li>
</ul>
<h2 id="the-third-pass">The third pass</h2>
<p>第三遍的目的是重新发现或者发明，是一个在论文的引导下逐步自己进行整个process的过程，时不时停下来问问自己：自己面临这个问题会怎么做，这个问题论文解决地合理吗。我这里引用作者文章中的原话：</p>
<blockquote>
<p>The key to the third pass is to attempt to virtually re-implement the paper: that is, making the same assumptions as the authors, re-create the work. By comparing this re-creation with the actual paper, you can easily identify not only a paper’s innovations, but also its hidden failings and assumptions.</p>
</blockquote>
<p>在这遍的过程中，你应该把自己化身为一个&quot;杠精&quot;，对于论文作者的每一个assumption都要challenge。</p>
<p>第三遍对于新手大概需要四到五个小时，但对于老司机可能一个小时就够了。第三遍完成之后，要能在脑中重建整个论文。</p>
<h1 id="做文献调研literature-survey">做文献调研(Literature survey)</h1>
<p>作者还介绍了应该怎么做文献调研，也要分三步走(凡事皆可三步)。</p>
<ol>
<li>去Google Schorlar之类的平台根据关键字去找某个领域最新的三到五篇论文。对他们进行one-pass, 然后着重看related work，如果能找到survey性质的文章，你就大功告成了。</li>
<li>否则的话，你要找重合度比较高的参考文献，即被多篇文章引用的，一般来说这种文章都是这个领域比较fundamental或者key的文章。可以把这些文章加入你的阅读列表，你还要关注这些作者，去看看他们发的文章，也要注意他们发表的平台，一般来说，顶尖的作者都会在top conference上发表。(其实不一定要通过作者找top conference，一般每个领域都会有公认的top conference，直接去这些top conference找就可以了)。</li>
<li>在这些top conference上找找文章。</li>
</ol>
<h1 id="日常学习">日常学习</h1>
<p>我们日常学习中也会经常碰到很多新的名词、工具、概念等等。我觉得这些的学习也可以用three-pass来概括：&ldquo;是什么&rdquo;，&ldquo;怎么做&rdquo;，&ldquo;为什么&rdquo;。当然&quot;怎么做&quot;和&quot;为什么&quot;是可以交替的。但一般来说，如果我们不去深入研究的话，一般知道&quot;是什么&quot;和&quot;怎么做&quot;就可以了，然后再稍微了解一下&quot;为什么&quot;。当然有时间和兴趣的话，还是要去了解了解&quot;为什么&quot;，因为了解背后的原理更重要。</p>
]]></content>
		</item>
		
		<item>
			<title>如何发布slides</title>
			<link>https://ricky-ting.github.io/posts/%E5%A6%82%E4%BD%95%E5%8F%91%E5%B8%83slides/</link>
			<pubDate>Thu, 09 Apr 2020 23:29:38 +0800</pubDate>
			
			<guid>https://ricky-ting.github.io/posts/%E5%A6%82%E4%BD%95%E5%8F%91%E5%B8%83slides/</guid>
			<description>这里介绍一下我是怎么用Markdown做slides，并发布在自己的博客 制作slides 之前一直用latex写slides，感觉还是有点麻烦</description>
			<content type="html"><![CDATA[<p>这里介绍一下我是怎么用Markdown做slides，并发布在自己的博客</p>
<h1 id="制作slides">制作slides</h1>
<p>之前一直用latex写slides，感觉还是有点麻烦，后来发现原来Markdown也可以写slides(爱了爱了)，因为最近正好有门课程需要做一个presentation，索性就试试Markdown吧。</p>
<h2 id="安装reveal-md">安装reveal-md</h2>
<p><a href="https://github.com/webpro/reveal-md">reveal-md</a>可以将Markdown文件转换成一个静态网页，这样就方便我们在博客上进行部署了。</p>
<p>先安装npm:</p>
<pre><code>brew install npm
</code></pre><p>然后安装reveal-md</p>
<pre><code>npm install -g reveal-md
</code></pre><h2 id="生成静态网页">生成静态网页</h2>
<p>用reveal-md生成静态网页</p>
<pre><code>reveal-md slides.md --static test
</code></pre><h1 id="部署到博客上">部署到博客上</h1>
<p>因为网页是静态的，所以我们只要把静态网页(比如上面的test)放到<code>public</code>下面，然后通过<code>https://username.github.io/test</code>就可以访问到了。</p>
<p>但这样手动拷贝比较麻烦，我们可以把这些slides都放入某一文件夹，比如我这里就是<code>slides_content</code>， 然后在我们之前的构建脚本里加上这样一行就可以自动部署到<code>public</code>中了</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># Add slides</span>
rm -r public/slides_content
cp -r slides_content public/slides_content
</code></pre></div><p>然后我们在自己的Slides页面加入相应的链接就可以了，这个后续可以尝试用一个自动化脚本讲slides_content中的网页自动加入到Slides页面中，最好的效果是写完Markdown之后，直接用deploy.sh能够自动构建整个网站。</p>
]]></content>
		</item>
		
		<item>
			<title>博客迁移记录</title>
			<link>https://ricky-ting.github.io/posts/%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E8%AE%B0%E5%BD%95/</link>
			<pubDate>Tue, 07 Apr 2020 22:46:23 +0800</pubDate>
			
			<guid>https://ricky-ting.github.io/posts/%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E8%AE%B0%E5%BD%95/</guid>
			<description>前言 为什么要迁移博客 之前的博客效果不是很满意(太丑)，文章的质量也不是很满意(基本都是抄抄书，记记笔记)，正好改头换面，希望后面能提高文章的</description>
			<content type="html"><![CDATA[<h2 id="前言">前言</h2>
<h3 id="为什么要迁移博客">为什么要迁移博客</h3>
<p>之前的博客效果不是很满意(<del>太丑</del>)，文章的质量也不是很满意(<del>基本都是抄抄书，记记笔记</del>)，正好改头换面，希望后面能提高文章的质量。</p>
<h3 id="从hexo到hugo">从Hexo到Hugo</h3>
<p>之前的博客一直用的是hexo，感觉部署起来确实有点慢，听说Hugo是用go写的(好感度++)而且部署起来还贼快(毕竟号称&quot;The world&rsquo;s fastest framework for building websites&quot;)。</p>
<h2 id="hugo安装与配置">hugo安装与配置</h2>
<h3 id="安装hugo">安装hugo</h3>
<p>Mac用户的福音，只需一行：</p>
<pre><code>brew install hugo
</code></pre><h3 id="创建站点">创建站点</h3>
<pre><code>hugo new site blog
</code></pre><p>然后我们就可以看到<code>blog</code>目录下一堆文件和目录：</p>
<pre><code>blog
├── archetypes 		# 主要是文档文件的模板，预定义了一些头部信息
│   └── default.md
├── config.toml 	# 配置文件
├── content 			# 内容文件
├── data 					# 可以存放一些JSON格式之类的数据
├── layouts 			# 生成html用的模板文件
├── static 				# 放一些图片、CSS、js等静态资源文件
└── themes 				# 存放主题
</code></pre><p>建议在这个时候进行<code>git init</code>, 为后续的博客备份做准备</p>
<h3 id="安装主题">安装主题</h3>
<p>我这里选择的是Hermit主题</p>
<pre><code>git submodule add https://github.com/Track3/hermit.git themes/hermit
</code></pre><p>覆盖原有的配置文件</p>
<pre><code>cp cp themes/hermit/exampleSite/config.toml ./
</code></pre><p>然后根据配置文件中的提示做相应的修改。</p>
<h2 id="旧博文迁移">旧博文迁移</h2>
<p>就博文的head是用hexo生成的，要转换成hugo的话，主要是时间的格式，还有多了<code>draft</code>字段，所以只要改改head就可以了。</p>
<h2 id="迁移到github上">迁移到Github上</h2>
<p>你可以首先在github上建立一个<code>Blog</code>私有仓库，作为整个blog的备份。</p>
<p>将本地的仓库关联到github上：</p>
<pre><code>git remote add origin git@github.com:&lt;your-username&gt;/Blog.git
</code></pre><p>然后<code>public</code>和github pages相关联：</p>
<pre><code>git submodule add -b master git@github.com &lt;your-username&gt;/&lt;your-username&gt;.github.io.git public

</code></pre><p>然后就可以进行部署了：</p>
<pre><code>cd public
git add .
git commit -m &quot;msg&quot;
git push origin master
cd ..
</code></pre><p>我们可以把这个写进一个自动化脚本里：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="c1"># Generating your websites</span>
<span class="nb">echo</span> <span class="s2">&#34;Generating websites&#34;</span>

<span class="c1"># Build website</span>
hugo -t hermit

<span class="c1"># commit public</span>
<span class="nb">cd</span> public
git add .
<span class="nv">msg</span><span class="o">=</span><span class="s2">&#34;update website `date`&#34;</span>
git commit --allow-empty  -m <span class="s2">&#34;</span><span class="nv">$msg</span><span class="s2">&#34;</span>

<span class="c1"># push to origin</span>
git push origin master

<span class="c1"># Back to Blog</span>
<span class="nb">cd</span> ..
</code></pre></div><h2 id="后续待做">后续待做</h2>
<p>为博客添加评论</p>
<p>希望为博客添加自动化部署，每次commit就能自动发布。</p>
]]></content>
		</item>
		
		<item>
			<title>Android Studio Installation</title>
			<link>https://ricky-ting.github.io/posts/android-studio-installation/</link>
			<pubDate>Wed, 03 Apr 2019 11:07:18 +0800</pubDate>
			
			<guid>https://ricky-ting.github.io/posts/android-studio-installation/</guid>
			<description>出现错误的话，把~/.gradle删除, 并把代理全部关掉，重新打开build。</description>
			<content type="html"><![CDATA[<p>出现错误的话，把<code>~/.gradle</code>删除, 并把代理全部关掉，重新打开build。</p>
]]></content>
		</item>
		
		<item>
			<title>proxy for bash</title>
			<link>https://ricky-ting.github.io/posts/proxy-for-bash/</link>
			<pubDate>Mon, 01 Apr 2019 11:04:55 +0800</pubDate>
			
			<guid>https://ricky-ting.github.io/posts/proxy-for-bash/</guid>
			<description>export ALL_PROXY=socks5://127.0.0.1:1086 </description>
			<content type="html"><![CDATA[<pre><code>export ALL_PROXY=socks5://127.0.0.1:1086
</code></pre>]]></content>
		</item>
		
		<item>
			<title>mac下ssh打开X11转发</title>
			<link>https://ricky-ting.github.io/posts/mac%E4%B8%8Bssh%E6%89%93%E5%BC%80x11%E8%BD%AC%E5%8F%91/</link>
			<pubDate>Thu, 17 Jan 2019 15:13:44 +0800</pubDate>
			
			<guid>https://ricky-ting.github.io/posts/mac%E4%B8%8Bssh%E6%89%93%E5%BC%80x11%E8%BD%AC%E5%8F%91/</guid>
			<description>mac下ssh打开X11转发 1.首先确认linux下已开启X11转发： ``` sudo vim /etc/ssh/sshd_config X11Forwarding yes X11DisplayOffset 10 service ssh restart ``` 2.安装XQuartz 3.在mac端下开启： ```bash</description>
			<content type="html"><![CDATA[<h1 id="mac下ssh打开x11转发">mac下ssh打开X11转发</h1>
<p>1.首先确认linux下已开启X11转发：</p>
<pre><code>```
sudo vim /etc/ssh/sshd_config

X11Forwarding yes
X11DisplayOffset 10

service ssh restart
```
</code></pre>
<p>2.安装XQuartz</p>
<p>3.在mac端下开启：</p>
<pre><code>```bash
sudo vim /etc/ssh/ssh_config

ForwardX11 yes
```
</code></pre>
<p>4.ssh登陆</p>
<pre><code>```bash
ssh -X username@ip
```</code></pre>
]]></content>
		</item>
		
		<item>
			<title>如何解决项目子模块git冲突</title>
			<link>https://ricky-ting.github.io/posts/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E9%A1%B9%E7%9B%AE%E5%AD%90%E6%A8%A1%E5%9D%97git%E5%86%B2%E7%AA%81/</link>
			<pubDate>Thu, 03 Jan 2019 23:02:20 +0800</pubDate>
			
			<guid>https://ricky-ting.github.io/posts/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E9%A1%B9%E7%9B%AE%E5%AD%90%E6%A8%A1%E5%9D%97git%E5%86%B2%E7%AA%81/</guid>
			<description>如何解决项目子模块git冲突 起因 在将这学期做的PA提交到github时，因为ics2018中原有git与github上创建的git冲突，因此</description>
			<content type="html"><![CDATA[<h1 id="如何解决项目子模块git冲突">如何解决项目子模块git冲突</h1>
<h2 id="起因">起因</h2>
<p>在将这学期做的PA提交到github时，因为ics2018中原有git与github上创建的git冲突，因此上传之后ics2018的图标为灰。</p>
<h2 id="解决方案">解决方案</h2>
<ul>
<li>
<p>git rm &ndash;cache ics2018</p>
</li>
<li>
<p>git add ics2018/</p>
</li>
</ul>
<h2 id="参考">参考</h2>
<p><a href="https://upupming.site/2018/05/31/git-submodules/#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88">参考链接</a></p>
]]></content>
		</item>
		
		<item>
			<title>How to make an installation USB for Linux or other OS in Mac OS X</title>
			<link>https://ricky-ting.github.io/posts/how-to-make-an-installation-usb-for-linux-or-other-os-in-mac-os-x/</link>
			<pubDate>Wed, 17 Oct 2018 20:55:11 +0800</pubDate>
			
			<guid>https://ricky-ting.github.io/posts/how-to-make-an-installation-usb-for-linux-or-other-os-in-mac-os-x/</guid>
			<description>&lt;h1 id=&#34;how-to-make-an-installation-usb-for-linux-or-other-os-in-mac-os-x&#34;&gt;How to make an installation USB for Linux or other OS in Mac OS X&lt;/h1&gt;
&lt;p&gt;Step1: Download the image(iso) file from the Internet.&lt;/p&gt;
&lt;p&gt;Step2: Open a Terminal(the following command are all completed in a terminal)&lt;/p&gt;</description>
			<content type="html"><![CDATA[<h1 id="how-to-make-an-installation-usb-for-linux-or-other-os-in-mac-os-x">How to make an installation USB for Linux or other OS in Mac OS X</h1>
<p>Step1: Download the image(iso) file from the Internet.</p>
<p>Step2: Open a Terminal(the following command are all completed in a terminal)</p>
<p>Step3: Trun <code>.iso</code> file into <code>.img</code> file by <code>hdiutil convert -format UDRW -o ~/path/to/target.img ~/path/from/src.iso</code>(The file created may end with <code>.dmg</code>)</p>
<p>Step4: <code>diskutil list</code> to obtain the devices mounted.</p>
<p>Step5: Insert your USB.</p>
<p>Step6: <code>diskutil list</code> to see which is added(/dev/diskN).</p>
<p>Step7: <code>diskutil unmountDisk /dev/diskN</code> to unmount USB</p>
<p>Step8: <code>sudo dd if=/path/to/target.img of=/dev/rdiskN bs=1m</code> to write the installation file into the USB</p>
<p>Step9: <code>diskutil eject /dev/diskN</code> to eject your USB.</p>]]></content>
		</item>
		
		<item>
			<title>PA拾慧</title>
			<link>https://ricky-ting.github.io/posts/pa%E6%8B%BE%E6%85%A7/</link>
			<pubDate>Sun, 16 Sep 2018 23:03:19 +0800</pubDate>
			
			<guid>https://ricky-ting.github.io/posts/pa%E6%8B%BE%E6%85%A7/</guid>
			<description>天将降PA于斯人也，必先使其STFW,RTFM,RTFSC, 所以动心忍性，曾益其所不能 tmux(分屏工具) Prefix: Ctrl+B 左右分屏:Prefix + % 上下</description>
			<content type="html"><![CDATA[<p><strong>天将降PA于斯人也，必先使其STFW,RTFM,RTFSC, 所以动心忍性，曾益其所不能</strong></p>
<h1 id="tmux分屏工具">tmux(分屏工具)</h1>
<p>Prefix: <code>Ctrl+B</code></p>
<p>左右分屏:<code>Prefix + %</code> 上下分屏: <code>Prefix + &quot;</code></p>
<p>切换: <code>Prefix + 方向键</code></p>
<h1 id="vim配置">Vim配置</h1>
<h2 id="vim分屏">vim分屏：</h2>
<p><code>Ctrl+W s</code>:上下分割当前打开的文件</p>
<p><code>:sp filename</code>:上下分割，并打开一个新的文件</p>
<p><code>Ctrl+W v</code>: 左右分割当前打开的文件</p>
<p><code>:vsp filename</code>: 左右分割，并打开一个新的文件</p>
<p><code>Ctrl+W l,h,k,j</code>: 在窗格见切换</p>
<h2 id="vim函数跳转">vim函数跳转:</h2>
<ol>
<li>安装ctags: &lsquo;sudo apt-get install ctags&rsquo;</li>
<li>测试ctags是否安装成功: <code>whereis ctags</code></li>
<li>为源代码生成tags文件，建议在项目根目录下生成: <code>ctags -R</code>,更多高级选项请自行查询或man</li>
<li>配置vimrc: <code>sudo vim ~/.vimrc</code></li>
<li>修改vimrc: 加入下面两行</li>
</ol>
<pre><code>set tags=[path]/tags
set tags=./tags,tags;$HOME
</code></pre><h2 id="vim配置选项">vim配置选项</h2>
<p><code>set laststatus=2</code></p>
<p>跳转快捷键: <code>Ctrl+]</code>跳转,  <code>Ctrl+t</code> or <code>Ctrl+o</code>返回.</p>
<p>在终端里输入<code>vim -t functionname</code> 可以直接跳转至你想跳转的函数.(来自StardustDL的补充)</p>
<p>vim函数跳转部分参考<a href="https://mengzelev.github.io/2018/09/12/pa-inspirations/">Mengzelve&rsquo;s Blog</a></p>
<h1 id="c语言相关">C语言相关</h1>
<p>顺时针法则</p>
<p>strcmp返回值为0是两个字符串相等</p>
<p>结构体里利用位域实现位级访问</p>
<h1 id="linux相关">Linux相关</h1>
<p>linux里的管道(pipeline)将不同程序的输入输出连起来。</p>
<p><code>time ./a.out </code> 可以测程序运行的时间。</p>
<p>在shell中使用终端设置别名:<code>alias cdblog='cd ~/Desktop/Github/Blog'</code></p>
<p>统计代码行数: <code>find . | grep -E '\.c$|\.h$' | xargs cat | wc -l</code></p>
<p>统计代码行数(不含空格): <code>find . | grep -E '\.c$|\.h$' | xargs cat | grep -v ‘^$’ | wc -l</code></p>
<h1 id="一些好的文章">一些好的文章：</h1>
<p><a href="https://i.linuxtoy.org/docs/guide/index.html">开源世界旅行手册</a></p>
<p><a href="http://songshuhui.net/archives/70194">计算的极限</a></p>
<p><a href="https://eli.thegreenplace.net/2011/01/23/how-debuggers-work-part-1/#id7">How debuggers work</a></p>
]]></content>
		</item>
		
		<item>
			<title>Debian install sudo</title>
			<link>https://ricky-ting.github.io/posts/debian-install-sudo/</link>
			<pubDate>Thu, 06 Sep 2018 09:08:13 +0800</pubDate>
			
			<guid>https://ricky-ting.github.io/posts/debian-install-sudo/</guid>
			<description>Debian install sudo su切换至root apt-get install sudo visudo 在root ALL(ALL:ALL) ALL后面加入一行&amp;lt;user&amp;gt; ALL=(ALL:ALL) ALL 然后Ctrl-O 保存文件，要把文件名里的.tmp删</description>
			<content type="html"><![CDATA[<h1 id="debian-install-sudo">Debian install sudo</h1>
<ol>
<li><code>su</code>切换至root</li>
<li><code>apt-get install sudo</code></li>
<li><code>visudo</code> 在<code>root ALL(ALL:ALL) ALL</code>后面加入一行<code>&lt;user&gt; ALL=(ALL:ALL) ALL</code></li>
<li>然后Ctrl-O 保存文件，要把文件名里的<code>.tmp</code>删除，两次yes， Ctrl-X退出编辑</li>
</ol>
<p><code>sudoers</code>文件目录为<code>/etc/sudoers</code></p>
<p><code>su</code>进入root, <code>exit</code>退出root</p>
]]></content>
		</item>
		
		<item>
			<title>shared folder in virtual machine</title>
			<link>https://ricky-ting.github.io/posts/shared-folder-in-virtual-machine/</link>
			<pubDate>Sat, 01 Sep 2018 19:35:31 +0800</pubDate>
			
			<guid>https://ricky-ting.github.io/posts/shared-folder-in-virtual-machine/</guid>
			<description>shared folder in virtual machine 首先在virtual box点击 Insert Guest Additions CD Image 在虚拟机中运行弹出来的窗口 在Terminal中输入sudo adduser $YourUserName vboxsf Restart Stack Overflow相关链</description>
			<content type="html"><![CDATA[<h1 id="shared-folder-in-virtual-machine">shared folder in virtual machine</h1>
<ol>
<li>首先在virtual box点击 <code>Insert Guest Additions CD Image</code></li>
<li>在虚拟机中运行弹出来的窗口</li>
<li>在Terminal中输入<code>sudo adduser $YourUserName vboxsf</code></li>
<li>Restart</li>
</ol>
<p><a href="https://stackoverflow.com/questions/26740113/virtualbox-shared-folder-permissions">Stack Overflow相关链接</a></p>
<p>But when you cannot mount the disk automatically, you have to do it manually. Steps are as follows:</p>
<ol>
<li>
<p>Devices -&gt; Install Guest Additions..</p>
</li>
<li>
<p>Type the following in the guest terminal</p>
</li>
</ol>
<pre><code>sudo mkdir --p /media/cdrom
sudo mount -t auto /dev/cdrom /media/cdrom/
cd /media/cdrom/
sudo sh VBoxLinuxAdditions.run
</code></pre><ol start="3">
<li>Then<code>sudo adduser $YourUserName vboxsf</code></li>
<li>Restart.</li>
</ol>
<p><a href="https://askubuntu.com/questions/80341/unable-to-mount-virtualbox-guest-additions-as-a-guest-win7-host">相关链接</a></p>
]]></content>
		</item>
		
		<item>
			<title>BST</title>
			<link>https://ricky-ting.github.io/posts/bst/</link>
			<pubDate>Thu, 07 Jun 2018 15:09:17 +0800</pubDate>
			
			<guid>https://ricky-ting.github.io/posts/bst/</guid>
			<description>下面是基于C++的BST类实现 // // main.cpp // debugger // // Created by 丁保荣 on 2018/6/6. // Copyright © 2018 丁保荣. All rights reserved. // #include&amp;lt;iostream&amp;gt; using namespace std; struct node { node * p; node * l; node * r; int key; }; class BST { public: node * root; node mynil; void</description>
			<content type="html"><![CDATA[<p>下面是基于C++的BST类实现</p>
<!-- raw HTML omitted -->
<pre><code>//
//  main.cpp
//  debugger
//
//  Created by 丁保荣 on 2018/6/6.
//  Copyright © 2018 丁保荣. All rights reserved.
//

#include&lt;iostream&gt;
using namespace std;
struct node
{
    node * p;
    node * l;
    node * r;
    int key;
};

class BST
{
public:
    node * root;
    node mynil;
    void Initial()
    {
        root=&amp;mynil;
    }
    void Inorder_tree_walk(node * x);
    void Preorder_tree_walk(node * x);
    void Postorder_tree_walk(node * x);
    node * Search(node * x, int k);
    node * Minimum(node * z);
    node * Maximum(node * z);
    node * Successor(node * x);
    node * Predecessor(node * x);
    void Insert(node * z);
    void Transplant(node * u, node * v);
    void Delete(node * z);
    
private:
    
};

void BST::Inorder_tree_walk(node * x)
{
    if(x!=&amp;mynil)
    {
        BST::Inorder_tree_walk((*x).l);
        cout&lt;&lt;(*x).key;
        BST::Inorder_tree_walk((*x).r);
    }
}

void BST::Preorder_tree_walk(node * x)
{
    if(x!=&amp;mynil)
    {
        cout&lt;&lt;(*x).key;
        BST::Preorder_tree_walk((*x).l);
        BST::Preorder_tree_walk((*x).r);
    }
}

void BST::Postorder_tree_walk(node * x)
{
    if(x!=&amp;mynil)
    {
        BST::Postorder_tree_walk((*x).l);
        BST::Postorder_tree_walk((*x).r);
        cout&lt;&lt;(*x).key;
    }
}

node * BST::Search(node * x,int k)
{
    if(x==&amp;mynil || k==(*x).key)
        return x;
    if(k&lt;(*x).key)
        return BST::Search((*x).l,k);
    else
        return BST::Search((*x).r,k);
}

node * BST::Minimum(node * z)
{
    while((*z).l!=&amp;mynil)
        z=(*z).l;
    return z;
}

node * BST::Maximum(node * z)
{
    while((*z).r!=&amp;mynil)
        z=(*z).r;
    return z;
}

node * BST::Successor(node * x)
{
    if((*x).r!=&amp;mynil)
        return BST::Minimum((*x).r);
    node * y=(*x).p;
    while(y!=&amp;mynil &amp;&amp; x==(*y).r)
    {
        x=y;
        y=(*y).p;
    }
    return y;
}

node * BST::Predecessor(node * x)
{
    if((*x).l!=&amp;mynil)
        return BST::Maximum((*x).l);
    node * y=(*x).p;
    while(y!=&amp;mynil &amp;&amp; x==(*y).l)
    {
        x=y;
        y=(*y).p;
    }
    return y;
}

void BST::Insert(node * z)
{
    node * y=&amp;mynil;
    node * x=root;
    while(x!=&amp;mynil)
    {
        y=x;
        if((*z).key&lt;(*x).key)
            x=(*x).l;
        else
            x=(*x).r;
    }
    (*z).p=y;
    if(y==&amp;mynil)
        root=z;
    else if((*z).key&lt;(*y).key)
        (*y).l=z;
    else
        (*y).r=z;
}

void BST::Transplant(node * u, node * v)
{
    if((*u).p==&amp;mynil)
        root=v;
    else if(u==(*(*u).p).l)
        (*(*u).p).l=v;
    else
        (*(*u).p).r=v;
    if(v!=&amp;mynil)
        (*v).p=(*u).p;
}
void BST::Delete(node * z)
{
    node * y;
    if((*z).l==&amp;mynil)
        BST::Transplant(z,(*z).r);
    else if((*z).r==&amp;mynil)
        BST::Transplant(z,(*z).l);
    else
    {
        y=BST::Minimum((*z).r);
        if((*y).p!=z)
        {
            BST::Transplant(y,(*y).r);
            (*y).r=(*z).r;
            (*(*y).r).p=y;
        }
        BST::Transplant(z,y);
        (*y).l=(*z).l;
        (*(*y).l).p=y;
        
    }
}

BST T;

void myinsert(int key)
{
    node * p=new node;
    (*p).key=key;
    p-&gt;l=&amp;T.mynil;
    p-&gt;r=&amp;T.mynil;
    T.Insert(p);
}

void mydelete(int key)
{
    node * p = T.Search(T.root,key);
    T.Delete(p);
    delete(p);
}
</code></pre><p>以下是基于C++的RB-Tree类实现</p>
<pre><code>//
//  main.cpp
//  debugger
//
//  Created by 丁保荣 on 2018/6/6.
//  Copyright © 2018 丁保荣. All rights reserved.
//
#include&lt;iostream&gt;
using namespace std;
int counter=0;
struct node
{
    bool c; // true is black and false is red.
    int key;
    node * p;
    node * l;
    node * r;
};
class myRB_Tree
{
public:
    node mynil;
    node * root;
    void Initial()
    {
        mynil.c=true;
        mynil.p=mynil.l=mynil.r=NULL;
        mynil.key=-1;
        root=&amp;mynil;
    }
    void Insert(node * z);
    void Delete(node * z);
    node * Search(node * x, int k);
    node * Minimum(node * z);
    void Preorder_tree_walk(node * x);
    
private:
    void Insert_Fixup(node * z);
    void Transplant(node * u, node * v);
    void Left_Rotate(node * x);
    void Right_Rotate(node * x);
    void Delete_Fixup(node * x);
};


void myRB_Tree::Preorder_tree_walk(node * x)
{
    if(x!=&amp;mynil)
    {
        cout&lt;&lt;(*x).key&lt;&lt;&quot;:&quot;&lt;&lt;((*x).c?&quot;black&quot;:&quot;red&quot;)&lt;&lt;endl;
        myRB_Tree::Preorder_tree_walk((*x).l);
        myRB_Tree::Preorder_tree_walk((*x).r);
    }
}



void myRB_Tree::Insert(node * z)
{
    node * y=&amp;mynil;
    node * x=root;
    while(x!=&amp;mynil)
    {
        y=x;
        if((*z).key&lt;(*x).key)
            x=(*x).l;
        else
            x=(*x).r;
    }
    (*z).p=y;
    if(y==&amp;mynil)
        root=z;
    else if((*z).key&lt;(*y).key)
        (*y).l=z;
    else
        (*y).r=z;
    (*z).l=&amp;mynil;
    (*z).r=&amp;mynil;
    (*z).c=0;
    myRB_Tree::Insert_Fixup(z);
}

void myRB_Tree::Insert_Fixup(node * z)
{
    while((*(*z).p).c==false)
    {
        if((*z).p==(*(*(*z).p).p).l)
        {
            node * y=(*(*(*z).p).p).r;
            if((*y).c==false)
            {
                (*(*z).p).c=true;
                (*y).c=true;
                (*(*(*z).p).p).c=false;
                z=(*(*z).p).p;
            }
            else
            {
                if(z==(*(*z).p).r)
                {
                    z=(*z).p;
                    myRB_Tree::Left_Rotate(z);
                }
                (*(*z).p).c=true;
                (*(*(*z).p).p).c=false;
                myRB_Tree::Right_Rotate((*(*z).p).p);
            }
            
        }
        else
        {
            node * y=(*(*(*z).p).p).l;
            if((*y).c==false)
            {
                (*(*z).p).c=true;
                (*y).c=true;
                (*(*(*z).p).p).c=false;
                z=(*(*z).p).p;
            }
            else
            {
                if(z==(*(*z).p).l)
                {
                    z=(*z).p;
                    myRB_Tree::Right_Rotate(z);
                }
                (*(*z).p).c=true;
                (*(*(*z).p).p).c=false;
                myRB_Tree::Left_Rotate((*(*z).p).p);
            }
        }
    }
    (*root).c=true;
}


void myRB_Tree::Left_Rotate(node * x)
{
    node * y= (*x).r;
    (*x).r=(*y).l;
    if((*y).l!=&amp;mynil)
        (*(*y).l).p=x;
    (*y).p=(*x).p;
    if((*x).p==&amp;mynil)
        root=y;
    else if(x==(*(*x).p).l)
        (*(*x).p).l=y;
    else
        (*(*x).p).r=y;
    (*y).l=x;
    (*x).p=y;
}

void myRB_Tree::Right_Rotate(node * x)
{
    node * y= (*x).l;
    (*x).l=(*y).r;
    if((*y).r!=&amp;mynil)
        (*(*y).r).p=x;
    (*y).p=(*x).p;
    if((*x).p==&amp;mynil)
        root=y;
    else if(x==(*(*x).p).r)
        (*(*x).p).r=y;
    else
        (*(*x).p).l=y;
    (*y).r=x;
    (*x).p=y;
}

void myRB_Tree::Transplant(node * u, node * v)
{
    if((*u).p==&amp;mynil)
        root=v;
    else if(u==(*(*u).p).l)
        (*(*u).p).l=v;
    else
        (*(*u).p).r=v;
    (*v).p=(*u).p;
}

void myRB_Tree::Delete(node * z)
{
    node * y=z;
    node * x;
    bool y_original_color=(*y).c;
    if((*z).l==&amp;mynil)
    {
        x=(*z).r;
        myRB_Tree::Transplant(z,(*z).r);
    }
    else if((*z).r==&amp;mynil)
    {
        x=(*z).l;
        myRB_Tree::Transplant(z,(*z).l);
    }
    else
    {
        y=myRB_Tree::Minimum((*z).r);
        y_original_color=(*y).c;
        x=(*y).r;
        if((*y).p==z)
            (*x).p=y;
        else
        {
            myRB_Tree::Transplant(y,(*y).r);
            (*y).r=(*z).r;
            (*(*y).r).p=y;
        }
        myRB_Tree::Transplant(z,y);
        (*y).l=(*z).l;
        (*(*y).l).p=y;
        (*y).c=(*z).c;
    }
    if(y_original_color==true)
        myRB_Tree::Delete_Fixup(x);
}

void myRB_Tree::Delete_Fixup(node * x)
{
    node * w;
    while(x!=root and (*x).c==true)
    {
        if(x==(*(*x).p).l)
        {
            w=(*(*x).p).r;
            if((*w).c==false)
            {
                (*w).c=true;
                (*(*x).p).c=false;
                myRB_Tree::Right_Rotate((*x).p);
                w=(*(*x).p).r;
            }
            if((*(*w).l).c==true &amp;&amp; (*(*w).r).c==true)
            {
                (*w).c=false;
                x=(*x).p;
            }
            else
            {
                if((*(*w).r).c==true)
                {
                    (*(*w).l).c=true;
                    (*w).c=false;
                    myRB_Tree::Left_Rotate(w);
                    w=(*(*x).p).r;
                }
                (*w).c=(*(*x).p).c;
                (*(*x).p).c=true;
                (*(*w).r).c=true;
                myRB_Tree::Right_Rotate((*x).p);
                x=root;
            }
        }
        else
        {
            w=(*(*x).p).l;
            if((*w).c==false)
            {
                (*w).c=true;
                (*(*x).p).c=false;
                myRB_Tree::Right_Rotate((*x).p);
                w=(*(*x).p).l;
            }
            if((*(*w).r).c==true &amp;&amp; (*(*w).l).c==true)
            {
                (*w).c=false;
                x=(*x).p;
            }
            else
            {
                if((*(*w).l).c==true)
                {
                    (*(*w).r).c=true;
                    (*w).c=false;
                    myRB_Tree::Left_Rotate(w);
                    w=(*(*x).p).l;
                }
                (*w).c=(*(*x).p).c;
                (*(*x).p).c=true;
                (*(*w).l).c=true;
                myRB_Tree::Right_Rotate((*x).p);
                x=root;
            }
        }
    }
}

node * myRB_Tree::Minimum(node * z)
{
    while((*z).l!=&amp;mynil)
        z=(*z).l;
    return z;
}

node * myRB_Tree::Search(node * x,int k)
{
    if(x==&amp;mynil || k==(*x).key)
        return x;
    if(k&lt;(*x).key)
    {
        counter++;
        return myRB_Tree::Search((*x).l,k);
    }
    else
    {
        counter++;
        return myRB_Tree::Search((*x).r,k);
    }
}
myRB_Tree T;
void myinsert(int key)
{
    node * p=new node;
    (*p).key=key;
    p-&gt;l=&amp;T.mynil;
    p-&gt;r=&amp;T.mynil;
    T.Insert(p);
}

void mydelete(int key)
{
    node * p = T.Search(T.root,key);
    T.Delete(p);
    delete(p);
}
</code></pre>]]></content>
		</item>
		
	</channel>
</rss>
