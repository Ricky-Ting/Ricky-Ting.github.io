<!DOCTYPE html>
<html lang="zh-CN">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<meta name="theme-color" content="#494f5c">
	<meta name="msapplication-TileColor" content="#494f5c">
<meta itemprop="name" content="人工智能">
<meta itemprop="description" content="人工智能 课程概述 参考教材 George F. Luger, Artificial Intelligence: Structures and Strategies for Complex Problem Solving. Fifth Edition, Addison Wesley. Stuart Russell and Peter Norvig. Artificial Intelligence: A Modern Approach. Third Edition. 参考网站 CMU, http://www.cs.cmu.edu MIT, http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-034-artificial-intelligence-fall-2010/index.htm. Stanford University, http://www.stanford.edu/class/cs221/. 前8周讲授完毕，并进行期中闭卷考试(4">
<meta itemprop="datePublished" content="2019-12-02T22:38:13&#43;08:00" />
<meta itemprop="dateModified" content="2019-12-02T22:38:13&#43;08:00" />
<meta itemprop="wordCount" content="16498">



<meta itemprop="keywords" content="untagged," /><meta property="og:title" content="人工智能" />
<meta property="og:description" content="人工智能 课程概述 参考教材 George F. Luger, Artificial Intelligence: Structures and Strategies for Complex Problem Solving. Fifth Edition, Addison Wesley. Stuart Russell and Peter Norvig. Artificial Intelligence: A Modern Approach. Third Edition. 参考网站 CMU, http://www.cs.cmu.edu MIT, http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-034-artificial-intelligence-fall-2010/index.htm. Stanford University, http://www.stanford.edu/class/cs221/. 前8周讲授完毕，并进行期中闭卷考试(4" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://ricky-ting.github.io/notes/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/" />
<meta property="article:published_time" content="2019-12-02T22:38:13+08:00" />
<meta property="article:modified_time" content="2019-12-02T22:38:13+08:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="人工智能"/>
<meta name="twitter:description" content="人工智能 课程概述 参考教材 George F. Luger, Artificial Intelligence: Structures and Strategies for Complex Problem Solving. Fifth Edition, Addison Wesley. Stuart Russell and Peter Norvig. Artificial Intelligence: A Modern Approach. Third Edition. 参考网站 CMU, http://www.cs.cmu.edu MIT, http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-034-artificial-intelligence-fall-2010/index.htm. Stanford University, http://www.stanford.edu/class/cs221/. 前8周讲授完毕，并进行期中闭卷考试(4"/>

	<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
	<link rel="manifest" href="/site.webmanifest">
	<link rel="mask-icon" href="/safari-pinned-tab.svg" color="">
	<link rel="shortcut icon" href="/favicon.ico">

	<title>人工智能</title>
	<link rel="stylesheet" href="https://ricky-ting.github.io/css/style.min.657bcb7af31123e4156b1a3d2ff60a636717e54ead74f882136b5114cf72b55e.css" integrity="sha256-ZXvLevMRI+QVaxo9L/YKY2cX5U6tdPiCE2tRFM9ytV4=" crossorigin="anonymous">
	
</head>

<body id="page">
	
	<header id="site-header" class="animated slideInUp faster">
		<div class="hdr-wrapper section-inner">
			<div class="hdr-left">
				<div class="site-branding">
					<a href="https://ricky-ting.github.io">Ricky Ting&#39;s Blog</a>
				</div>
				<nav class="site-nav hide-in-mobile">
					
				<a href="https://ricky-ting.github.io/posts/">Posts</a>
				<a href="https://ricky-ting.github.io/notes/">Notes</a>
				<a href="https://ricky-ting.github.io/slides/">Slides</a>
				<a href="https://ricky-ting.github.io/about-hugo/">About</a>
				<a href="https://ricky-ting.github.io/links/">Links</a>

				</nav>
			</div>
			<div class="hdr-right hdr-icons">
				<button id="toc-btn" class="hdr-btn desktop-only-ib" title=""><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-list"><line x1="8" y1="6" x2="21" y2="6"></line><line x1="8" y1="12" x2="21" y2="12"></line><line x1="8" y1="18" x2="21" y2="18"></line><line x1="3" y1="6" x2="3" y2="6"></line><line x1="3" y1="12" x2="3" y2="12"></line><line x1="3" y1="18" x2="3" y2="18"></line></svg></button><span class="hdr-social hide-in-mobile"><a href="https://github.com/Ricky-Ting/" target="_blank" rel="noopener me" title="Github"><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path></svg></a></span><button id="menu-btn" class="hdr-btn" title=""><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></button>
			</div>
		</div>
	</header>
	<div id="mobile-menu" class="animated fast">
		<ul>
			<li><a href="https://ricky-ting.github.io/posts/">Posts</a></li>
			<li><a href="https://ricky-ting.github.io/notes/">Notes</a></li>
			<li><a href="https://ricky-ting.github.io/slides/">Slides</a></li>
			<li><a href="https://ricky-ting.github.io/about-hugo/">About</a></li>
			<li><a href="https://ricky-ting.github.io/links/">Links</a></li>
		</ul>
	</div>


	<main class="site-main section-inner thin animated fadeIn faster">
		<h1>人工智能</h1>
		<div class="content">
			<h1 id="人工智能">人工智能<a href="#人工智能" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h1>
<h2 id="课程概述">课程概述<a href="#课程概述" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>参考教材</p>
<ul>
<li>
<p>George F. Luger, Artificial Intelligence: Structures and Strategies for Complex Problem Solving. Fifth Edition, Addison Wesley.</p>
</li>
<li>
<p>Stuart Russell and Peter Norvig. Artificial Intelligence: A Modern Approach. Third Edition.</p>
</li>
</ul>
<p>参考网站</p>
<ul>
<li>
<p>CMU, <a href="http://www.cs.cmu.edu">http://www.cs.cmu.edu</a></p>
</li>
<li>
<p>MIT, <a href="http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-034-artificial-intelligence-fall-2010/index.htm">http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-034-artificial-intelligence-fall-2010/index.htm</a>.</p>
</li>
<li>
<p>Stanford University, <a href="http://www.stanford.edu/class/cs221/">http://www.stanford.edu/class/cs221/</a>.</p>
</li>
</ul>
<p>前8周讲授完毕，并进行期中闭卷考试(40分)</p>
<p>全自动区分计算机和人类的图灵测试：Completely Automated Public Turing test to tell Computers and Humans Apart，简称CAPTCHA</p>
<!-- raw HTML omitted -->
<h2 id="搜索">搜索<a href="#搜索" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<h3 id="状态空间搜索">状态空间搜索<a href="#状态空间搜索" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>状态空间的表示</p>
<ul>
<li>状态空间图：节点N和连接(弧)A</li>
<li>初始状态：S是N的非空子集</li>
<li>目标状态：G是N的非空子集</li>
<li>状态空间搜索：寻找从初始状态到目标状态的解路径(solution path)</li>
<li>状态转移图：有向无环图DAG，但也可能存在回路</li>
<li>状态转移树</li>
</ul>
<p>图搜索：需要检测和消除解路径上的循环</p>
<p>树搜索：免除检测的开销</p>
<p>搜索树</p>
<ul>
<li>根节点：初始状态</li>
<li>连接：父节点上的合法动作</li>
<li>后继：在父节点上采用合法动作所达到的子节点</li>
<li>搜索树：删除后继节点中已经出现的等价状态，所形成的树</li>
</ul>
<p>状态空间的搜索方向</p>
<ul>
<li>数据驱动-前向搜索，由数据向目标搜索</li>
<li>目标驱动-后向搜索，由目标向数据搜索</li>
</ul>
<p>回溯技术：通过试错方式搜索状态空间所有解路径</p>
<p>宽度优先搜索：</p>
<ul>
<li>先入先出FIFO，从右侧加入列表，左侧移出</li>
<li>可保证发现目标状态的最短路径</li>
<li>组合爆炸</li>
</ul>
<p>深度优先搜索：</p>
<ul>
<li>后入先出LIFO，从左侧加入列表，左侧移出</li>
<li>不保证发现目标状态的最短路径</li>
<li>“可能迷失”在深度空间中</li>
</ul>
<p>所以，将两者结合我们得到了迭代加深深度优先：有近似于BFS的时间复杂度和近似于DFS的空间复杂度，避免组合爆炸。</p>
<p>迭代加深深度优先与广度优先等价</p>
<h4 id="启发式搜索">启发式搜索<a href="#启发式搜索" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>为什么需要启发：1.没有精确解；2.约简搜索的状态空间</p>
<p>爬山搜索：</p>
<ul>
<li>第一步:扩展当前节点以及其子节点，并进行评估;</li>
<li>第二步:选择“最优”的子节点作为下一节点;</li>
<li>第三步:如果所有子节点的评估，都比当前节点“劣”， 则算法终止。</li>
</ul>
<p>但爬山搜索容易陷入局部最优，我们可以增加回溯机制</p>
<p>最佳优先搜索，类似于宽度优先搜索，但把队列换成了优先队列</p>
<p>错位牌数是什么？？ 距离又是什么？？？</p>
<p>$A*$算法</p>
<ul>
<li>评估函数：$f(n)=g(n)+h(n)$</li>
<li>最优评估函数：$f^*(n) = g^*(n) +h^*(n)$</li>
<li>$g(n) \ge g^*(n)$</li>
<li>如果$h(n) \le h^*(n)$, 则$A$算法为$A^*$算法</li>
</ul>
<p>把$h(n)$定义为0，且边权为1，就是BFS。DFS?</p>
<p>$A^*$算法具有可采纳性和单调性</p>
<p>可采纳性(admissible):最优评估函数一个算法是可采纳的，当存在一个解路径时，算法总是终止在此最优解路径上。</p>
<p>可采纳启发式是指它从不会过高估计到达目标的代价。</p>
<p>$A^*$算法是可采纳的：</p>
<ul>
<li>$A^*$可以终止</li>
<li>解路径上的节点总是会被$A^*$展开(访问到)</li>
<li>当存在解路径时,$A^*$算法终止在此解路径上</li>
</ul>
<p>$A^<em>$最优性：如果$h_1(n) &lt; h_2(n) $, 则$A_2^</em>$展开的节点数小于$A_1^*$  P92</p>
<p>$A^*$单调性：启发函数$h$是单调的</p>
<ul>
<li>$n_j$是$n_i$的后继节点，如果$h(n_i) - h(n_j) \le cost(n_i,n_j) $ 就是三角不等式</li>
<li>$h(goal) = 0$</li>
</ul>
<p>单调性：在首次访问的目标状态的路径，保证一定是最短路径。</p>
<p>$A^<em>$有如下性质：如果$h(n)$是可采纳的，那么$A^</em>$的树搜索版本是最优的；如果$h(n)$是一致的，那么图搜索的$A^*$算法是最优的。</p>
<h4 id="博弈树搜索">博弈树搜索<a href="#博弈树搜索" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>极小极大过程</p>
<ul>
<li>MAX:代表我方玩家，最大化其收益(赢得博弈)</li>
<li>MIN:代表对手，最小化MAX的收益</li>
</ul>
<p>将启发值自底向上传播</p>
<ul>
<li>如果父状态是MAX节点，将孩子节点中最大值传给它</li>
<li>如果父状态是MIN节点，将孩子节点中最小值传给它</li>
</ul>
<p>但这样状态数仍然很多，本质上还是穷竭搜索，所以要剪枝：</p>
<p>$\alpha - \beta$ 过程</p>
<p>极小极大过程：</p>
<ul>
<li>在预判层应用启发式评估</li>
<li>展开所有的后继分支</li>
<li>沿树向上传播评估值</li>
</ul>
<p>$\alpha -\beta$剪枝</p>
<ul>
<li>当确定是一个dead end时，停止展开其后继节点</li>
<li>对博弈树的深度优先搜索，且维护
<ul>
<li>$\alpha$:与MAX节点关联，从不减小</li>
<li>$\beta$:与MIN节点关联，从不增大</li>
</ul>
</li>
<li>剪枝规则
<ul>
<li>$Alpha$剪枝：任一MIN节点，如果其Beta值小于等于其祖先MAX节点的Alpha值，则停止搜索</li>
<li>Beta剪枝：任一MAX节点，如果其Alpha值大于等于其祖先MIN节点的Beta值，则停止搜索。</li>
</ul>
</li>
<li>特点
<ul>
<li>对子节点排序非常敏感</li>
<li>静态启发：吃子启发</li>
<li>动态启发：历史启发、杀手启发、置换表启发</li>
</ul>
</li>
</ul>
<h3 id="monte-caro-树搜索">Monte Caro 树搜索<a href="#monte-caro-树搜索" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p><a href="https://www.jiqizhixin.com/articles/monte-carlo-tree-search-beginners-guide">参考资料</a></p>
<p>基本原理；随机抽样+假设检验+树搜索</p>
<p>解决：迭代产生游戏树，解决树空间太大的问题</p>
<p>性质：用概率的方式，产生合理的推理，但并不保证一定最优</p>
<p>预测值：</p>
<ul>
<li>第一个数字：代表在这个子树上赢的次数</li>
<li>第二个数字：在这个子树上模拟的次数</li>
</ul>
<p>SELECTION步骤：利用树策略选择节点</p>
<p>蒙特卡洛树的选择策略：</p>
<ul>
<li>UCT策略：
<ul>
<li>平衡Exploration和Exploitation。</li>
<li>Exploration approach 促使去探索尚未发现的树的其他领域。 这会将倾向于探索树的广度，而不是深度。</li>
<li>Exploitation approach 倾向于选择拥有最大预测值的路径。这 种是属于贪心算法，趋于探索树的深度。</li>
<li>$UCT(node) = \frac{W(node)}{N(node)} + c \sqrt{\frac{\ln{N(parentNode)}}{N(node)}}$</li>
</ul>
</li>
</ul>
<p>Expansion:添加一个 “?”的叶子节点。这是每次迭代中唯一添加的节点。</p>
<p>SImulation:又称 playout 或者 rollout。执行操作，直到达到结束状态，或者 满足设定的阈值，就停止该操作。然后基于模拟的结果，建立新 添加节点的值。</p>
<p>Backpropagation:利用新添加节点的值，对之前的树进行更新。从新的节点开始，
算法反向遍历回到根节点。</p>
<h2 id="推理">推理<a href="#推理" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>合取范式(CNF),析取范式(DNF)</p>
<p>谓词演算的五大推理规则:取式假言推理、拒式假言推理、与消除、与引入、全称例化</p>
<ul>
<li>取式假言推理：如果已知语句$P$和$P \rightarrow Q$ 为真，那么$Q$为真</li>
<li>拒式假言推理：如果已知$P \rightarrow Q$ 为真，且$Q$为假，那么$P$为假</li>
<li>与消除：$P \wedge Q$ 为真，那么$P$、$Q$分别为真</li>
<li>与引入：$P$和$Q$都为真，$P \wedge Q$ 为真</li>
<li>全称例化：$\forall X, p(X)$ 为真，且$a$ 为$X$定义域中一值，$p(a)$为真。</li>
</ul>
<h3 id="合一">合一<a href="#合一" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>合一：判断什么样的替换可以使两个谓词表达式匹配的算法。</p>
<p>合一表明了两个或多个表达式在什么条件下可以称为等价的。</p>
<p>替换：一个替换(Substitution)就是形如${t1/x1,t2/x2,&hellip;,tn/xn}$的有限集合，$x1,x2,&hellip;,xn$是互不相同的个体变元，$ti$不同于$xi$, $xi$也不循环出现在$tj$中。</p>
<p>斯柯伦标准化:去掉所有的存在量词：$(\forall X)(\exists Y) (mother(X,Y))$ 转换为$(\forall X) (mother(X,m(X))) $</p>
<p>组合：在合一过程中，如果先后产生$S$和$S'$的替换，那么将S中的某个元素应用$S'$,所产生的新的替换，称为组合</p>
<p>最一般的合一式(MGU,Most Generalize Unify): 如果$g$是表达式$E$的最一般合一式，那么对于任何的其他合一式$s$,都存在另一个合一式$s'$,使$Es = Egs'$. 其中$Es$和$Egs'$是应用到表达式$E$的合一式的组合。</p>
<p>合一算法</p>
<pre><code>1. 递归地对表达式的初始成分合一。如果成功，这次合一返回的任何代入式被用到两个表达式的剩下部分，然后以这两个表达式为参数。
2. 当两个参数之一为一个符号(谓词名，函词名，变元，常元)， 或两个表达式的每一元素都已匹配了，算法终止。
</code></pre><pre><code>UNIFY
case
	E1, E2或者是常元或者是空表: %递归终止
		If E1=E2 then return {};
		else return FAIL;
	E1是一个变元：
		If E1在E2中出现 then return FAIL;
		else return {E2/E1};
	E2是一个变元：
		If E2在E1中出现then return FAIL;
		else return {E1/E2};
	其他情况: %E1和E2都是表
		begin
			HE1:=E1的第一个元素;
			HE2:=E2的第二个元素;
			SUBS1:=unify*HE1,HE2;
			if(SUBS1=FAIL) then return FAIL;
			TE1:=apply(SUBS1,E1的后半部);
			TE2:=apply(SUBS1,E2的后半部);
			SUBS2:=unify(TE1,TE2);
			if(SUBS2=FAIL) then return FAIL;
			else return SUBS1与SUBS2的并集;
		end
</code></pre><h3 id="归结">归结<a href="#归结" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>归结法的基本思想：</p>
<ul>
<li>反证法：为了证明一个命题$P$恒真，则证明其反命题$\neg P$恒假。即不存在使得$\neg P$为真的解释。</li>
<li>设$F_1,F_2,&hellip;,F_n,G$为公式，$G$为$F_1,&hellip;,F_n$的逻辑推论,当且仅当公式$ (F_1 \wedge &hellip; \wedge F_n \wedge \neg G )$ 是不可满足的</li>
</ul>
<p>消解是一种应用于谓词演算中的定理证明技术，是人工智 能问题求解的一个组成部分。消解描述了如何用最少的合一次数在一个子句数据库中发现矛盾的方法。</p>
<p>消解否证包含以下步骤：</p>
<ul>
<li>具体方法为把前提或公理转换成子句形式。</li>
<li>把求证目标的否定的子句形式加到公理集合中。</li>
<li>对所有这些子句进行消解，产生它们的逻辑结果子句。</li>
<li>用产生空子句的方法来得出矛盾。</li>
</ul>
<p>产生子句的一系列过程：最后转换成不含量词的合取范式</p>
<p>归结的策略：</p>
<ul>
<li>宽度优先策略：时空开销大，保证能发现最短的解路径</li>
<li>支持策略
<ul>
<li>本策略要求每次归结的归结式之一至少有一个是由 目标公式的否定所得到的 子句，或者是它们的后裔。</li>
<li>可以证明，该策略是完备的。</li>
</ul>
</li>
<li>单个优先策略：
<ul>
<li>只要存在个体子句(一个文字的子句)就是用个体子句归结。</li>
<li>单个优先策略与成组支持策略一起使用，可以得到 了更加有效的完备策略。</li>
</ul>
</li>
</ul>
<h2 id="知识表示">知识表示<a href="#知识表示" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>常见的知识表示方法：</p>
<ul>
<li>一阶谓词表示(First Order Predicate)</li>
<li>产生式表示(Production)</li>
<li>语义网络表示(Semantic Network)</li>
<li>框架表示(Framework)</li>
<li>脚本表示(Script)</li>
</ul>
<h3 id="一阶谓词知识表示">一阶谓词知识表示<a href="#一阶谓词知识表示" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>优点：精确、自然、严密，易于实现</p>
<p>缺点：表示和处理分离，组合爆炸导致效率低</p>
<h3 id="产生式表示">产生式表示<a href="#产生式表示" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>一阶谓词中蕴含式表示的知识是精确的(真或假)，而产生式表示的知识可以是不精确的(可信度)，产生式的推理匹配过程也可以是部分匹配。</p>
<p>产生式系统：一组产生式，互相配合/协调，其中一个产生式产生的结论可以作为另一个产生式的事实使用，以求解问题。有三个组件：数据库、规则库、</p>
<p>规则库：</p>
<ul>
<li>有效表达领域内的过程性知识。</li>
<li>对知识进行合理的组织与管理，提高问题求解效率。</li>
</ul>
<p>数据库(工作内存)：</p>
<ul>
<li>存放问题求解过程中的各种信息的数据结构，包括初始
状态、原始证据、中间结论、最终结论。</li>
<li>其内容在推理过程中在动态、不断变化的。</li>
</ul>
<p>控制系统：</p>
<ul>
<li>从规则库中选择规则，并与数据库中的已知事实进行匹配。</li>
<li>发生冲突时调用相应策略进行消解。</li>
<li>如果执行规则的右部是一个或多个结论，则将结论加入到数据库中。</li>
<li>如果执行规则的右部是一个或多个的操作，则执行这些操作。并将操作产生的 事实加入到数据库中。</li>
<li>对不确定性的知识，也计算结论的不确定性。</li>
<li>在适当时候终止系统运行。</li>
</ul>
<p>产生式表示/系统的优点：</p>
<ul>
<li>知识和控制的分离;</li>
<li>自然映射到状态空间搜索;</li>
<li>产生式规则的模块性;</li>
<li>模式导向控制;</li>
<li>多种启发式控制;</li>
<li>易于跟踪和解释;</li>
<li>问题求解的模型之一。</li>
</ul>
<p>产生式表示适用范围</p>
<ul>
<li>领域中知识单元相对独立，不存在结构关系;</li>
<li>具有经验型或者不确定性的知识，领域对这些知识缺少完整
的理论模型;</li>
<li>领域问题的求解过程可表示为一些列相对独立的操作，每个
操作也可表示为一条或多条的产生式规则。</li>
</ul>
<h3 id="语义网络表示法">语义网络表示法<a href="#语义网络表示法" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>通过有向图，其顶点表示概念，边表示概念间的语义关系，来表达复杂的概念及其相互关系。</p>
<p>语义网络的推理</p>
<ul>
<li>继承：
<ul>
<li>把对事物的描述从抽象节点传递到具体节点，通常沿着类
属关系ISA, AKO等具有继承关系的边进行。</li>
</ul>
</li>
<li>匹配
<ul>
<li>把待求解问题构造为网络片段，其中某些节点或边的标识 是空的，称为询问点。</li>
<li>将网络片段与知识库中的某个语义网络片段进行匹配，则 与询问点相匹配的事实就是该问题的解。</li>
</ul>
</li>
</ul>
<p>语义网络表示的优缺点：</p>
<ul>
<li>优点：结构性、联想性、自索引性、自然语言的转换性</li>
<li>缺点：不严格性、处理复杂。本质和谓词演算等价。</li>
<li>强大在于:连接和推理规则的丰富和定义!</li>
</ul>
<h3 id="框架表示">框架表示<a href="#框架表示" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>定义：是描述对象(一个事物、一个事件、一个概念)属性的一 种数据结构。在框架表示法中，框架被认为是知识表示的 最基本单元</p>
<p>表示形式：框架名、槽名(描述某一方面的属性)、侧面(描述属性的某 一方面)、值组成</p>
<p>框架网络系统：将多个相互关联的框架连接起来组织的知识表示和推理系统</p>
<ul>
<li>纵向联系：通过框架中增加&quot;继承&quot;槽来实现</li>
<li>横向联系：通过槽值或侧面值为另一个框架民</li>
</ul>
<p>框架表示的优缺点</p>
<ul>
<li>优点：
<ul>
<li>结构性(不同于语义网络的结构性)、继承性、自然性</li>
<li>是语义网络的重要扩展</li>
<li>面向对象语言OO的产生</li>
</ul>
</li>
<li>缺点：
<ul>
<li>缺乏过程性知识表示</li>
</ul>
</li>
</ul>
<h2 id="不确定性推理">不确定性推理<a href="#不确定性推理" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>从不确定性的初始事实（证据），运用不确定性的知识，获得不确定性但却合理的结论，获得不确定性但却合理的结论。</p>
<h3 id="反绎推理">反绎推理<a href="#反绎推理" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>$P \rightarrow Q$ 与$Q$, 可能推出P</p>
<p>是一种寻找最佳解释的推理，是不可靠的推理。也称为溯因推理。</p>
<h4 id="基于谓词逻辑的推理">基于谓词逻辑的推理<a href="#基于谓词逻辑的推理" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>三个重要假设（传统）</p>
<ul>
<li>谓词对领域描述是充分的；</li>
<li>知识库必须是一致的；</li>
<li>应用推理规则得到的信息，必须是单调增长的</li>
</ul>
<p>但如果假设不成立</p>
<h4 id="非单调推理">非单调推理<a href="#非单调推理" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>模态操作符的扩充</p>
<ul>
<li>unless操作符
<ul>
<li>$ (p(x) \text{ unless } q(x)) \rightarrow r(x) $, $r(x) \rightarrow s(x)$</li>
<li>如果$p(W)$成立,且不知道$q(W)$是否为真，则$r(W)$, 进而$s(W)$为真</li>
<li>进一步已知$q(W)$为真，则$r(W)$和$s(W)$需要被撤回。</li>
<li>abnormal默认规则 $p(x) \text{ unless ab } p(x) \rightarrow r(x)$
<ul>
<li>除非$p$有个反常的实例</li>
</ul>
</li>
</ul>
</li>
<li>is consistent with操作符
<ul>
<li>$\forall x \ good_student(x) \wedge M \ study_hard(x) \rightarrow graduates(x) $</li>
<li>如何判定&quot;与&hellip;.相一致&rdquo;
<ul>
<li>第一种方法：证明其反$\neg study_hard(x)$; 如果不能证明，则与&hellip;相一致</li>
<li>第二种方法：在有限空间上做启发式搜索</li>
</ul>
</li>
</ul>
</li>
<li>默认逻辑
<ul>
<li>$A(x) \wedge : B(x) \rightarrow C(x)$</li>
<li>&ldquo;如果A可被证实，且它与对B的假设相一致，则&hellip;&rdquo;</li>
</ul>
</li>
</ul>
<h4 id="真值维护系统">真值维护系统<a href="#真值维护系统" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>目标：维持推理系统的逻辑完整性</p>
<p>原理：通过存储每条推理的理由，再重新推断根据新的信念所得出的结论的支持情况</p>
<p>实现方式：</p>
<ol>
<li>时序回溯：从死状态或者末状态返回，系统的遍历所有可能路径。(低效!)</li>
<li>相关性指导回溯:直接回溯到出问题的点，并在那个状态 对解进行修正。
<ul>
<li>TMS实现机制
<ul>
<li>关联机制：将每条结论和其理由联系在一起</li>
<li>定位机制：当给定矛盾和其理由时，直接定位错误的假设。</li>
<li>回收机制：收回错误的假设</li>
<li>追溯机制：收回错误的假设的结论</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>基于理由的真值维护系统JTMS</p>
<ul>
<li>检查理由网络
<ul>
<li>通过问题求解程序的查询(是否相信命题p, 为什么要相信命题p, 哪些假设支持命题p)进行触发</li>
</ul>
</li>
<li>修改相关性网络
<ul>
<li>由问题求解程序所提供的信息进行修改。添加新命题、
添加或删除前提等</li>
</ul>
</li>
<li>更新网络
<ul>
<li>重新计算与现存理由相一致的命题</li>
</ul>
</li>
</ul>
<p>构造理由网络，并将网络与推理过程分离</p>
<p>理由网络</p>
<ul>
<li>结点：知识库中的信念</li>
<li>理由：支持结点上的信念</li>
<li>联系：IN,支持结点成立的信念集合; OUT,不支持结点成立的信念集合</li>
</ul>
<h4 id="基于最小模型的逻辑">基于最小模型的逻辑<a href="#基于最小模型的逻辑" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>模型:对所有变量赋值均满足谓词表达式集合S的解释</p>
<p>存在问题:实际的领域无需任意多的谓词</p>
<p>最小模型:对所有变量赋值满足谓词表达式S的模型中，最小的那个模型</p>
<h4 id="集合覆盖">集合覆盖<a href="#集合覆盖" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>考虑反绎推理中解释的产生:一个反绎的解释为谓词的覆盖。</p>
<h4 id="确信度理论">确信度理论<a href="#确信度理论" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>MB(H|E):给定证据E时，假设H的可信度量</p>
<p>MD(H|E):给定证据E时，假设H的不可信度量</p>
<p>不确定性知识的表示：在CF模型中，知识是用产生式规则表示的，其一般形式为: IF E THEN H (CF(H|E))</p>
<h4 id="不可信度量和概率">(不)可信度量和概率<a href="#不可信度量和概率" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>$MB(H|E) = \begin{cases} 1 &amp; P(H)=1 \ \frac{\max{P(H|E),P(H)}-P(H) }{1-P(H)} &amp; \text{otherwise} \end{cases}$</p>
<p>$MD(H|E) = \begin{cases} 1 &amp; P(H)=0 \ \frac{\min{P(H|E),P(H)}-P(H) }{-P(H)} &amp; \text{otherwise} \end{cases}$</p>
<ol>
<li>当$MB(H,E) &gt;0$时,有$P(H|E) &gt; P(H)$, $E$的出现增加了$H$的概率。</li>
<li>当$MD(H,E)&gt;0$时,有$P(H|E)&lt;P(H)$,$E$的出现降低了$H$的概率</li>
</ol>
<h4 id="确信度的性质">确信度的性质<a href="#确信度的性质" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>互斥性：同一证据不可能既增加对$H$的信任程度，又同时增加对$H$的不信任程序，故$MB$和$MD$是互斥的。即有如下互斥性：</p>
<ul>
<li>当$MB(H,E)&gt;0$时，$MD(H,E)=0$;</li>
<li>当$MD(H,E)&gt;0$时，$MB(H,E)=0$;</li>
</ul>
<p>值域： $0 \le MB(H|E) \le 1$, $0 \le MD(H|E) \le 1$, $-1 \le CF(H|E) \le 1$</p>
<p>典型值：</p>
<ol>
<li>当$CF(H|E)=1$时，有$P(H|E)=1$, $E$所对应证据的出现使$H$为真。此时，$MB(H|E)=1, MD(H|E)=0$</li>
<li>当$CF(H|E)=-1$时，有$P(H|E)=0$, $E$所对应证据的出现使$H$为真。此时，$MB(H|E)=0, MD(H|E)=1$</li>
<li>当$CF(H|E)=0$时，有$MB(H|E)=0, MD(H|E)=0$, $E$所对应证据的出现不证实$H$,也不否认$H$.</li>
</ol>
<p>CF(H | E) = MB(H | E) - MD(H | E)</p>
<p>实际应用中，P(H)和P(H|E)的值难以获得，因此CF(H|E)的值要 求由领域专家直接给出。</p>
<ol>
<li>
<p>否定证据不确定性的计算： $CF(\neg E) = - CF(E)$</p>
</li>
<li>
<p>组合证据不确定性的计算：</p>
<ol>
<li>合取：当规则前提(组合证据)是多个单一证据的组合，即$E = E_1 \land &hellip; \land E_n$时，若已知$CF(E_1),CF(E_2),&hellip;,CF(E_n)$ , 则$CF(E) = \min {CF(E_1,&hellip;,CF(E_n))}$</li>
<li>析取：当规则前提(组合证据)是多个单一证据的析取，即$E = E_1 \lor &hellip; \lor E_n$时，若已知$CF(E_1),CF(E_2),&hellip;,CF(E_n)$ , 则$CF(E) = \max {CF(E_1,&hellip;,CF(E_n))}$</li>
</ol>
</li>
</ol>
<p>不确定性的更新公式： $CF(H) = CF(H,E) \times \max{0,CF(E)}$</p>
<ol>
<li>若$CF(E)&lt;0$,则$CF(H)=0$,即该模型没考略$E$为假对$H$的影响</li>
<li>若$CF(E)=1$,则$CF(H) = CF(H,E)$, 即规则强度$CF(H,E)$实际上是在$E$为真时，$H$的确信度。</li>
</ol>
<h4 id="结论不确定性的合成">结论不确定性的合成<a href="#结论不确定性的合成" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>原理:多条知识支持同一个结论，且这些知识的前提相互独立， 结论的确信度不相同时，可利用不确定性的合成算法求出结论 的综合确信度。</p>
<p>设有知识: If E1 then H (CF(H|E1)), If E2 then H (CF(H|E2))</p>
<p>我们先计算每个CF(H): CF1(H) = CF(H|E1) * max{0,CF(E1)}, CF2(H) = CF(H|E2) * max{0,CF(E2)}, 然后用如下公式求E1与E2对H的综合确信度</p>
<p>$CF(H) = \begin{cases} CF1(H)+CF2(H)-CF1(H)*CF2(H) &amp; \text{若} CF1(H) \ge 0 \text{且} CF2(H) \ge 0 \  CF1(H)+CF2(H)+CF1(H)*CF2(H) &amp; \text{若} CF1(H) &lt; 0 \text{且} CF2(H) &lt; 0 \ \frac{CF1(H)+CF2(H)}{1- \min{|CF1(H)|, |CF2(H)|}} &amp; \text{若} CF1(H)\text{与} CF2(H)异号 \end{cases}$</p>
<p>合并计算公式所含特性：</p>
<ul>
<li>计算出来的CF值保证在1和-1之间</li>
<li>在合并相反符号的CF时，它们能够相互削弱</li>
<li>合并后的CF是一个单调函数</li>
</ul>
<h3 id="证据理论">证据理论<a href="#证据理论" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>原理:基于收集到的证据数量，将概率论中的单点赋值扩展为集合赋值，
处理由“不知道”所引起的不确定性。</p>
<p>形式定义:考虑命题集，赋给区间值[belief, plausibility]，每个命题的可信度(belief
measure)必须在这个区间内。</p>
<ol>
<li>从相关问题的主观概念得到其可信度的思想</li>
<li>基于相互独立的证据时，合并可信度的规则</li>
</ol>
<h4 id="信任函数">信任函数<a href="#信任函数" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>Bel: $ 2^{\Omega} \rightarrow [0,1]$,  $Bel(A) = \sum\limits_{B \subseteq A} m(B)$, 其中 $A \subseteq \Omega$.</p>
<p>Bel为下限函数，Bel(A)表示对$A$的总信任度</p>
<h4 id="似然函数">似然函数：<a href="#似然函数" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>Pl: $2^{\Omega} \rightarrow [0,1]$, $PI(A) = 1- Bel(\neg A)$, 其中$A \subseteq \Omega$, $\neg A = \Omega -A$</p>
<p>$PI$为上限函数，$Bel(\neg A)$表示对$\neg A$的总信任度， 即$A$为假的信任度，因此$PI(A)$ 表示对$A$为非假的信任度。</p>
<h4 id="信任函数与似然函数">信任函数与似然函数<a href="#信任函数与似然函数" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>$PI(A) \ge Bel(A)$</p>
<p>称$Bel(A)$ 和 $PI(A)$为对A信任程度的下限和上限，记为：$A[Bel(A),PI(A)]$</p>
<p>$PI(A) - Bel(A)$:描述&quot;不知道&quot;的情况</p>
<h4 id="dempster证据合并规则">Dempster证据合并规则<a href="#dempster证据合并规则" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>对于$\forall A \subseteq \Omega, \Omega$上的两个$m$函数$m_1$, $m_2$,其Dempster合成规则为: $m_1 \oplus m_2 (A) = \frac{1}{K} \sum\limits_{B \cap C =A} m_1(B) \times m_2(C)$.  $K= \sum\limits_{B \cap C \not= \emptyset} m_1(B) \times m_2(C) = 1- \sum\limits_{B \cap C = \emptyset} m_1(B) \times m_2(C)$</p>
<ul>
<li>$K$为冲突因子，反应证据的冲突程度</li>
<li>$\frac{1}{K}$为归一化因子，相当于在组合中将空集(冲突)等比例分配给各个集合</li>
<li>前提：证据是相互独立的。</li>
</ul>
<h2 id="贝叶斯网络">贝叶斯网络<a href="#贝叶斯网络" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>先验概率 vs 后验概率</p>
<ul>
<li>
<p>先验概率：在得到任何新证据之前，统计的事件概率。即非条件概率，P(事件)</p>
</li>
<li>
<p>后验概率：给定新证据之后，统计的事件概率。即条件概率，P(事件|证据)。</p>
</li>
</ul>
<p>演绎推理 vs 归纳推理</p>
<ul>
<li>演绎推理：不要求前件是真实的</li>
<li>归纳推理：要求前件必须为真，结论未必为真(从特殊到一般)</li>
<li>贝叶斯决策(贝叶斯归纳推理)：
<ul>
<li>已知先验概率和类条件概率表达式;</li>
<li>转换成后验概率;</li>
<li>根据后验概率大小进行决策/推理。</li>
</ul>
</li>
</ul>
<p>贝叶斯定理： 通过先验概率和类条件概率表达式，计算后验概率</p>
<h3 id="贝叶斯信念网络">贝叶斯信念网络<a href="#贝叶斯信念网络" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>贝叶斯网络</p>
<ul>
<li>是一个有向无环图</li>
<li>节点代表随机变量</li>
<li>边代表节点间的关系(因果关系)，用条件概率表达关系的强
度。</li>
<li>没有父节点的用先验概率表达信息。</li>
</ul>
<p>贝叶斯网络中的独立性：</p>
<ul>
<li>顺序连接
<ul>
<li>$Z \rightarrow Y \rightarrow X$</li>
<li>给定$Y$的知识，那么$X$和$Z$独立。如果$Y$未知，则$X$和$Z$不独立。</li>
</ul>
</li>
<li>分支连接
<ul>
<li>$Y \rightarrow X, Y \rightarrow Z$</li>
<li>给定$Y$的知识，那么$X$和$Z$独立。如果$Y$未知，则$X$和$Z$不独立。</li>
</ul>
</li>
<li>汇合连接
<ul>
<li>$X \rightarrow Y, Z \rightarrow Y$</li>
<li>$Y$ 未知时，$X$和$Z$独立，但给定$Y$, $X$和$Z$不独立</li>
</ul>
</li>
<li>分支和汇合
<ul>
<li>$Z \rightarrow U, Z \rightarrow V$, $U \rightarrow X, V \rightarrow X$</li>
<li>仅给定$U$, $Z$和$X$不独立。当且仅当给定$U$和$V$时，$Z$和$X$独立。</li>
</ul>
</li>
</ul>
<p>d-可分</p>
<ul>
<li>
<p>判断贝叶斯网络中任意两个节点之间是否独立</p>
</li>
<li>
<p>定义：$A$和$B$被一组随机变量E d-可分，当且仅当他们之间的所有路径都是堵塞的。</p>
</li>
<li>
<p>堵塞：如果$A$和$B$上有这样的一个中间节点$V$,那么路径是堵塞的。$V$满足以下两个属性之一：</p>
<ol>
<li>
<p>连接是顺序的或者分支的，$V$在$E$中</p>
</li>
<li>
<p>连接是汇合的，则$V$和它的子节点都不在$E$中</p>
</li>
</ol>
</li>
</ul>
<p>网络结构确定：</p>
<ul>
<li>选择一组刻画问题的随机变量${ X_1, X_2,&hellip;,X_n}$</li>
<li>确定一个变量顺序$a = &lt; X_1, X_2,&hellip;,X_n&gt;$</li>
<li>参数学习从一个空图出发，按照顺序$a$ 逐个将变量加入$\zeta$中</li>
<li>假设当前需要加入的是变量$X_i$,此时$\zeta$中已经包含变量$X_1,X_2,&hellip;,X_{i-1}$
<ul>
<li>在$X_1,X_2,&hellip;,X_{i-1}$选择一个尽可能小的子集$\pi(X_i)$, 使得假设&quot;给定$\pi(X_i)$, $X_i$ 与$\zeta$ 中的其他变量条件独立&quot;合理</li>
<li>从$\pi(X_i)$ 中的每一个节点添加一条指向$X_i$的有向边</li>
</ul>
</li>
</ul>
<p>$a$的顺序会影响网络的结构。</p>
<p>贝叶斯信念网络推理</p>
<ul>
<li>因果推理(自顶向下的推理)
<ul>
<li>由原因推出结论，即根据一定的原因，推理出在该原因情况下结果发生的概率。</li>
</ul>
</li>
<li>诊断推理(自底向上的推理)
<ul>
<li>由结论推出原因，即根据产生的结果，利用贝叶斯网推理算法，得出导致该结果的原因的概率</li>
</ul>
</li>
<li>支持推理
<ul>
<li>对所发生的现象提供解释，目的是分析原因之间的相互影响。</li>
</ul>
</li>
</ul>
<h2 id="马尔科夫逻辑网络">马尔科夫逻辑网络<a href="#马尔科夫逻辑网络" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<h3 id="markov链">Markov链<a href="#markov链" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>考虑一个$N$(有限)状态${s_1,s_2,&hellip;,s_n}$的系统：在离散的时间序列中${t_1,t_2,&hellip;}$, 其在时间$t$的状态记为$X_t$.</p>
<p>系统在时间$t$处在状态$s_j(1 \le j \le n)$ 的概率取决于其在时间${1,2,..,t-1}$的状态： $P(X_t = s_k | X_1,X_2,&hellip;,X_{t-1})$</p>
<p>一阶马尔科夫链：$P(X_t = s_k | X_1,X_2,&hellip;,X_{t-1}) = P(X_t = s_k | X_{t-1})$</p>
<h3 id="markov网">Markov网<a href="#markov网" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>有向图+概率分布：Bayesian Network</p>
<p>无向图+概率分布：Markov Network(Markov Random Field, MRF), $G=(V,E)$</p>
<p>顶点：随机变量$V$</p>
<p>边：变量间的依赖关系$E$</p>
<p>团(Clique):各边所在的最大全联通子图(必须全连接)</p>
<p>势函数：为非负函数，表示团的一个状态</p>
<p>联合分布函数</p>
<ul>
<li>吉布斯测度：已知一种分配方案$x$,求MLN刚好为该情况的联合分布概率
<ul>
<li>$P(X=x) = \frac{1}{Z} \prod\limits_{k} f_k(X_{{k}})  $</li>
</ul>
</li>
<li>配分函数：所有分配方案的测度总和
<ul>
<li>$Z = \sum\limits_{x \in \mathcal{X}} \prod\limits_{k} f_k(x_{{k}})$</li>
</ul>
</li>
</ul>
<p>对数线性模型：</p>
<ul>
<li>对数线性模型：马尔可夫网络常表示为该模型，通过引入特征函数$\phi_k$
<ul>
<li>$f_k = \exp(w_k^T \phi_k(x_{{k}}))$</li>
<li>$P(X=x) = \frac{1}{Z} \exp(\sum\limits_k w_k^T \phi)k(x_{{k}})$</li>
</ul>
</li>
<li>配分函数：
<ul>
<li>$Z= \sum\limits_{x \in \mathcal{X}} \exp(w_k^T \phi_k(x_{{k}}))$</li>
</ul>
</li>
<li>将每个团的势函数表示为指数函数，指数项为对应团的加权特征量</li>
</ul>
<p>在马尔可夫网络中，我们可以使用类似的直觉，但因为其中没有有方向的边（箭头），所以其条件独立陈述相对简单——如果节点 A 和 B 之间没有路径能使得该路径上的所有节点都被观察到，那么 A 和 B 就是相互独立的。换种说法：如果在 A 和 B 之间至少有一条路径上的所有中间节点都未被观察到，那么 A 和 B 就不是相互独立的。</p>
<h3 id="markov逻辑网的独立性">Markov逻辑网的独立性<a href="#markov逻辑网的独立性" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<ul>
<li>Pairwise Markov Property: 给定所有其他变量，任意两个不相邻变量条
件独立。
<ul>
<li>$X_u \parallel X_v | X_{V \backslash {u,v} } $ If ${ u,v } \notin E$</li>
</ul>
</li>
<li>Local Markov Property:一个变量如果给定所有邻居变量后与所有其他
变量条件独立。
<ul>
<li>$X_v \parallel X_{V \backslash cl(v)} | X_{ne}(v)$</li>
</ul>
</li>
<li>Global Markov Property:A、B两个子集间任何一条路径都经过子集S，
则给定S后，A、B两个子集相互条件独立。
<ul>
<li>$X_A \parallel X_B | X_S$</li>
</ul>
</li>
</ul>
<p>一个无向图$G=(V,E)$,是马尔科夫网络的充分必要条件是：当且仅当其满足以上三条独立性质</p>
<h3 id="构建马尔科夫网络">构建马尔科夫网络<a href="#构建马尔科夫网络" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<ul>
<li>方法一：基于Pairwise Markov Property
<ul>
<li>如果满足下面条件，则在$X$和$Y$之间加边：
<ul>
<li>$P \not\models (X \perp Y | \mathcal{X} - {X,Y})$.</li>
</ul>
</li>
</ul>
</li>
<li>方法二：基于Local Markov Property
<ul>
<li>集合$U$是$X$的马尔科夫毯(Markov blanket, $X$的邻居节点集合)，给定$U$, $X$独立于余下的变量；
<ul>
<li>$(X \perp \mathcal{X} - {X} -U | U) \in \mathcal{I}(P)$</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="马尔科夫逻辑网">马尔科夫逻辑网<a href="#马尔科夫逻辑网" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>一个可能世界(A Possible World):为每个可能的闭谓词指定真值。</p>
<p>可满足:一个一阶公式是可满足的，当且仅当该公式至少在一个世界中为真。</p>
<p>一阶逻辑的推理:判断一个知识库中是否包含公式F，即F是否在 所有满足知识库的世界中为真。</p>
<p>Markov逻辑网(Markov Logic Networks, MLNs): Markov网+一阶逻辑，其本质是公式附加权值的一阶逻辑知识库</p>
<p>基本思想：将一阶逻辑的限制放松，即一个可能世界违反公式越多，其发生的概率越小，但未必为0。</p>
<p>公式权重：表示公式限制强度的大小。权值越大，满足该公式世界的发生概率与不满足该公式世界的发生概率之间的差越大。</p>
<h4 id="markov逻辑网的定义">Markov逻辑网的定义<a href="#markov逻辑网的定义" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>马尔科夫逻辑网$L$:是$(F_i,w_i)$对的集合，其中$F_i$代表一阶逻辑规则，$w_i$是用一个实数表示权重；有限的常数集为$C= {c_1,c_2,&hellip;,c_n}$</p>
<p>马尔科夫逻辑网$M_{L,C}$:</p>
<ul>
<li>L中的任意闭原子(ground atom)都对应了$M_{L,C}$中的一个二值节点。若此闭原子为真，则对应的二值节点取值为1;若为假，则取值为0。</li>
<li>L中的任意闭规则(ground formula)都对应着一个特征值。若此闭规则为真，则对应的特征值为1;若为假，则特征值为0。并且这个特征值$F_i$ 的权重为二元项中该规则对应的权重$w_i$</li>
</ul>
<h4 id="mln特例一阶逻辑">MLN特例：一阶逻辑<a href="#mln特例一阶逻辑" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<ul>
<li>只有一条规则
<ul>
<li>$\forall x \ R(x) \rightarrow S(x)$, 权重为$w$,常数集$C= {A}$</li>
</ul>
</li>
<li>只有4个事件
<ul>
<li>${\neg R(A), \neg S(A) }$, ${\neg R(A),  S(A) }$, ${R(A), \neg S(A) }$, ${R(A), S(A) }$</li>
</ul>
</li>
</ul>
<p>$\Pr({ { R(A), \neg S(A) } }) = 1/(3e^w + 1)$, 其他均为$e^w/(3e^w+1)$</p>
<h3 id="mln推理">MLN推理<a href="#mln推理" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<ul>
<li>条件概率查询(Conditional Probability Query)
<ul>
<li>证据：$\vec{E} = \vec{e}$</li>
<li>查询：变量子集$\vec{Y}$</li>
<li>计算：$P(\vec{Y}| \vec{E} =\vec{e})$</li>
</ul>
</li>
<li>最大化后验(Maximum a Posterior, MAP)
<ul>
<li>证据：$\vec{E} = \vec{e}$</li>
<li>查询：所有其他变量$\vec{Y} (\vec{Y} = {X_1,X_2,&hellip;X_n} - \vec{E})$</li>
<li>计算：$MAP(\vec{Y} | \vec{E} = \vec{e}) = \arg \max_{\vec{y}}P(\vec{Y}=\vec{y} | \vec{E} = \vec{e})$</li>
</ul>
</li>
</ul>
<p>贝叶斯公式：$P(A,B) = P(A) P(B|A)$</p>
<p>边缘概率求取公式$P(A) = \sum_B P(A,B)$</p>
<p>BN中的和积(Sum-Product)</p>
<ul>
<li>我们可以根据任意一个贝叶斯网络写出所有节点对应的随机变量的联合概率分布为：$p(\vec{x}) = \prod\limits_{k=1}^K p(x_k | pa_k)$ , 其中$pa_k$为节点$x_k$的所有父节点构成的集合。</li>
</ul>
<p>MN中的和积</p>
<h3 id="变量消除算法">变量消除算法<a href="#变量消除算法" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<ul>
<li>精确算法
<ul>
<li>变量消除(Variable elimination)</li>
</ul>
</li>
<li>近似算法
<ul>
<li>信念传播(Belief propagation)</li>
<li>随机采样(Random sampling)
<ul>
<li>Markov chain</li>
<li>Gibbs sampling</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="符号学习">符号学习<a href="#符号学习" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<h3 id="概念学习concept-learning">概念学习(Concept Learning)<a href="#概念学习concept-learning" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>定义：给定样例集合，以及每个样例是否属于某个概念，自动地推断出该概念的一般定义。</p>
<p>实例集合$X$: 如PPT中用六个属性表示</p>
<p>目标概念$c$: 定义在实例集上的布尔函数：$c: X \rightarrow {0,1}$</p>
<p>训练样例：正例$(c(x)=1)$, 反例$(c(x)=0)$</p>
<p>假设集$H$:每个假设$h$表示$X$上定义的布尔函数$h: X \rightarrow {0,1}$</p>
<p>概念学习：寻找一个假设$h$, 使对于$X$中的所有$x$, $h(x)=c(x)$</p>
<h4 id="实例空间和假设数">实例空间和假设数<a href="#实例空间和假设数" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>最一般的假设:</p>
<p>最特殊的假设：</p>
<p>实例空间：</p>
<p>假设空间：</p>
<p>归纳学习假设：任一假设如果在足够大的训练样例集合中能很好的逼近目标概念函数，它也能在未见实例中很好的逼近目标概念。</p>
<h4 id="假设的一般到特殊序">假设的一般到特殊序<a href="#假设的一般到特殊序" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>$h1=&lt;Sunny,?,?,Strong,?,?&gt;$, $h2=&lt;Sunny,?,?,?,?,?&gt;$,</p>
<p>$h2$包含的实例数多于$h_1$</p>
<p><strong>更泛化</strong>(more general greater than or equal to): 令$h_j$和$h_k$是定义在$X$上的布尔函数，若$h_j \ge_g h_k$ 当且仅当，$(\forall x \in X)[h_k(x)=1 \rightarrow h_j(x)=1]$</p>
<p><strong>严格泛化</strong>： $h_j &gt;_g h_k $</p>
<p><strong>更特化</strong>： $h_j \ge_s h_k$</p>
<h4 id="find-s寻找极大特殊假设">Find-S:寻找极大特殊假设<a href="#find-s寻找极大特殊假设" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<ol>
<li>将$h$初始化为$H$中最特殊的假设</li>
<li>对每个正例$x$
<ul>
<li>对$h$的每个属性约束$a_i$，如果$x$满足$a_i$ 那么不做任何处理，否则将$h$中$a_i$替换为$x$满足的另一个最一般的约束</li>
</ul>
</li>
<li>输出假设$h$</li>
</ol>
<h3 id="变型空间">变型空间<a href="#变型空间" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<ul>
<li>
<p>一致(Consistent): 一个假设$h$与训练样例集合$D$一致 当且仅当，$Consistent(h,D) \equiv (\forall &lt;x,c(x)&gt; \in D) h(x)=c(x)$</p>
</li>
<li>
<p>变型空间(version space):关于假设空间$H$和训练样例集合$D$的变型空间，是$H$中与训练样例$D$一致的所有假设构成的子集： $VS_{H,D} = { h\in H | Consistent(h,D) }$</p>
</li>
</ul>
<h4 id="列表消除算法list-then-eliminate">列表消除算法：List-Then-Eliminate<a href="#列表消除算法list-then-eliminate" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<ol>
<li>变型空间VersionSpace,包含$H$中所有假设的列表</li>
<li>对每个样例$&lt;x,c(x)&gt;$: 从变型空间中移除$h(x) \not=c(x)$的假设$h$</li>
<li>输出VersionSpace中的假设列表</li>
</ol>
<p>缺点：要列出所有假设，在实际中往往不可能</p>
<p>极大泛化(maximally general): $H$中与训练样例集合$D$一致的极大一般成员的集合。 $G={g\in H | Consistent(g,D)\wedge (\neg \exists g&rsquo; \in H [ (g&rsquo; &gt;_g g) \wedge Consitent(g&rsquo;,D)]  ) }$</p>
<p>极大特化(maximally specific):$H$中与训练样例集合$D$一致的极大特殊成员的集合：$S \equiv { s\in H | Consistent(s,D) \wedge (\neg \exists s&rsquo; \in H [(s &gt;_s s&rsquo;) \wedge Consitent(s&rsquo;,D) ]) }$</p>
<h4 id="变型空间表示定理">变型空间表示定理<a href="#变型空间表示定理" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>表示定理：令$X$为任意的实例集合，$H$为$X$上定义的布尔函数集合。令$c: X \rightarrow [0,1]$为$X$上定义的任一目标概念，并令$D$为任意训练样例的集合${&lt;x,c(x)&gt; }$. 对所有的$X,H,c,D$以及良好定义的$S$和$G$: $VS_{H,D} \equiv { h\in H | (\exists s \in S)(\exists g \in G) [g &gt;_g h &gt;_s s]  }$</p>
<p>正例和反例的作用</p>
<ul>
<li>正例用于泛化，搜索$S$集合</li>
<li>反例用于特化，缩小$G$集合</li>
</ul>
<h4 id="候选消除算法candidate-eliminate">候选消除算法：Candidate-Eliminate<a href="#候选消除算法candidate-eliminate" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<ul>
<li>如果$d$是正例
<ul>
<li>从$G$中移去所有和$d$不一致的假设</li>
<li>对$S$中每一个与$d$不一致的假设$s$
<ul>
<li>从$S$中移除$s$</li>
<li>把$s$的所有极小泛化假设$h$加入到$S$中， 其中$h$满足与$D$ 一致，而且$G$中的某个成员比$h$更一般</li>
<li>从$S$中移去这样的假设，它比$S$中另一假设更一般</li>
</ul>
</li>
</ul>
</li>
<li>如果$d$是反例
<ul>
<li>从$S$中移去所有和$d$不一致的假设</li>
<li>对$G$中每一个与$d$不一致的假设$g$
<ul>
<li>从$G$中移除$g$</li>
<li>把$g$的所有极小特化假设$h$加入到$G$中，其中$h$满足与$D$一致，而且$S$中的某个成员比$h$更特殊</li>
<li>从$G$中移去这样的假设，它比$G$中另一假设更特殊</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="归纳偏置">归纳偏置<a href="#归纳偏置" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<h3 id="决策树学习">决策树学习<a href="#决策树学习" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>决策树学习：</p>
<ul>
<li>实例：&ldquo;属性-值&quot;对表示，应用最广的归纳推理算法之一</li>
<li>目标函数具有离散的输出值</li>
<li>很好的健壮性(样例可以包含错误，也可以处理缺少属性值的实例)</li>
<li>能够学习析取表达式</li>
</ul>
<p>算法：</p>
<ul>
<li>ID3，Assistant,C4.5</li>
<li>搜索一个完整表示的假设空间，表示为多个If-then规则</li>
</ul>
<p>归纳偏置</p>
<ul>
<li>优先选择较小的树</li>
</ul>
<p>信息增益： $Entropy(S) = \sum\limits_{i=1}^c -p_i \log_2{p_1}$</p>
<h2 id="神经网络">神经网络<a href="#神经网络" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>激活函数</p>
<p>A saturating activation function squeezes the input.</p>
<p>$f$ is non-saturating iff ($|\lim\limits_{z \rightarrow - \infty} f(z)| = + \infty$) $\lor (|\lim\limits_{z \rightarrow + \infty } f(z)| = + \infty) $</p>
<ul>
<li>饱和型激励函数：tanh,Sigmoid
<ul>
<li>缺点：
<ol>
<li>梯度消失</li>
<li>非以0为中心</li>
<li>指数计算代价大</li>
</ol>
</li>
</ul>
</li>
<li>非饱和型激励函数：ReLU,ELU,&hellip;</li>
</ul>
<p>感知机的学习方法：</p>
<ul>
<li>$c$是常数，表示学习率</li>
<li>$d$是期望的输出，取值为1或-1</li>
<li>$sign$是感知机的输出，取值为1或-1
<ul>
<li>$\Delta W_i = c(d-sign(\sum w_i * x_i)) X_i$</li>
<li>期望输出和实际输出相同，不改变权值</li>
<li>实际输出为-1,期望输出为+1, 则增加$2cX_i$</li>
<li>实际输出为+1,期望输出为-1, 则减少$2cX_i$</li>
</ul>
</li>
</ul>
<p>感知机学习缺点：感知机模型属于单层神经网络，它不能解决一类非线性可分的问题。典型的例子就是异或。</p>
<p>二层神经网络可以表达所有的布尔函数</p>
<h3 id="delta规则">Delta规则<a href="#delta规则" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>Delta规则是基于错误(误差)平面的，错误(误差)平面是神经 网络所表示的函数在数据集上的累积误差。每一个神经网络 权值向量都对应误差平面中的一个点。</p>
<p>应用delta规则时，激励函数必须是连续的和可微分的。</p>
<p>$\Delta W_k = c(d_i - O_i) f&rsquo;(net_i) * X_k$</p>
<p>Delta规则分析</p>
<ul>
<li>学习常数c对delta规则的性能有很重要的影响，c决定了在一 步学习过程中权值变化的快慢，c越大，权值朝最优值移动 的速度越快。然而，c过大会越过最优值或在最优值附近震 荡。</li>
<li>尽管delta规则本身不能克服单层神经网络的局限，但是它的 一般形式是反传算法(BP)的核心，反传算法是多层神经网络 中的学习算法。</li>
<li>梯度下降(gradient descent)
<ul>
<li>搜索无限假设空间的有效策略</li>
<li>无限假设空间：连续的参数/可微</li>
<li>缺点：收敛速度慢/局部极小</li>
</ul>
</li>
<li>随机梯度下降(stochastic gradient descent)
<ul>
<li>每次随机选择样本更新权重</li>
<li>不需要计算总误差，快/可以有效避免局部极小</li>
</ul>
</li>
</ul>
<h3 id="多层神经网络">多层神经网络<a href="#多层神经网络" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>隐藏层神经元实际为特征检测算子 (feature detector)，在多层神经网络 的学习过程中，隐藏层神经元开始 逐步“发现”刻画训练数据的突出 特征。</p>
<h3 id="反向传播算法back-propagation">反向传播算法(Back Propagation)<a href="#反向传播算法back-propagation" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<ul>
<li>前向阶段：网络突触的权值固定，输入信号在网络中正向一层一层传播，直到到达输出端，获得网络的输出。</li>
<li>反向阶段：通过比较网络的输出与期望输出，产生一个误差信号。误差信号通过网络反向一层一层传播，在传播过程中对网络突触的权值进行修正。</li>
</ul>
<p>BP神经网络：</p>
<ul>
<li>三层或三层以上结构</li>
<li>无反馈</li>
<li>层内无互连</li>
<li>输入层+输出层+隐含层</li>
<li>采用误差反向传播学习算法</li>
</ul>
<h2 id="遗传算法">遗传算法<a href="#遗传算法" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>遗传算法GA:受生物进化启发的学习算法：</p>
<ul>
<li>通过对当前最好的假设重组来产生后续假设</li>
<li>生成并测试(generate-and-test)的柱状搜索(beam-search)</li>
</ul>
<p>假设的表示：可以用01位串表示</p>
<p>适应函数(fitness)</p>
<p>染色体的选择：</p>
<ul>
<li>基于适应度函数的选择
<ul>
<li>轮盘赌选择(roulette wheel selection)
<ul>
<li>与适应度成比例选择</li>
</ul>
</li>
<li>锦标赛选择(tournament selection)
<ul>
<li>按预定义概率$p$选择较大适应度的假设</li>
<li>按概率1-p选择其他假设</li>
</ul>
</li>
<li>排序选择(rank selection)
<ul>
<li>根据序而不是适应度进行选择</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>遗传算子(GA operator): 对从当前群体中选择的染色体进行重组，以产生后代</p>
<p>交叉： 选择两个候选个体，分解每一个个体，然后交换分量形成两个新的候选个体</p>
<p>变异：选择一个候选个体，随机的选择一位，然后取反</p>
<p>遗传算法的优势：</p>
<ul>
<li>无需理解问题内部的相关性和因果性</li>
<li>以一个随机的群体开始，以适应度作为某种”启发式</li>
<li>”进化论”保证整个种群的演化</li>
</ul>
<p>未解决的问题：</p>
<ul>
<li>表示的问题:编码不规范及编码存在表示的不准确性</li>
<li>约束的问题:单一的遗传算法编码不能全面地将优化问题的约束表 示出来。考虑约束的一个方法就是对不可行解采用阈值，这样，计 算的时间必然增加</li>
<li>搜索效率的问题:遗传算法通常的效率比其他传统的优化方法低; 遗传算法容易出现过早收敛</li>
<li>理论保证的问题:遗传算法对算法的精度、可行度、计算复杂性等 方面，还没有有效的定量分析方法</li>
</ul>
<h3 id="模式定理">模式定理<a href="#模式定理" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>Short schemata with large fitness will increase their representation in the
population during the evolution</p>
<p>模式H的阶，o(H):模式H中确定位置的个数</p>
<p>模式H的长度，d(H):模式H中第一个确定的位置到最后一个确定位置的距离</p>
<h4 id="模式的进化">模式的进化<a href="#模式的进化" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>$m(s,t)$ 表示在第$t$代种群$p_t$中模式$s$的实例数量</p>
<p>模式理论：</p>
<ul>
<li>根据GA的原理，去推断$m(s,t+1)$的期望值</li>
<li>$f(h)$: 染色体$h$的适应度</li>
<li>$\bar{f}(t)$:第$t$代种群染色体的平均适应度</li>
<li>$n$:种群中个体的总数量</li>
<li>$h \in s \cap p_t$: 染色体$h$属于模式$s$,又是$p_t$的成员</li>
<li>$\hat{u}(s,t):$ 第$t$代中模式$s$的染色体的平均适应度</li>
</ul>
<p>轮盘赌选择：$\Pr(h) = \frac{f(h)}{\sum\limits_{i=1}^n f(h_i)} = \frac{f(h)}{n\bar{f}(t)}$</p>
<p>选择的假设是模式$s$的实例的概率：$\Pr(h \in s) = \sum\limits_{h \in s \cap p_t}\frac{f(h)}{n\bar{f}(t)} = \frac{\hat{u}(s,t)}{n \bar{f}(t)} m(s,t)$</p>
<p>如果选择$n$次，得到$s$的实例的期望值是$\mathbb{E}[m(s,t+1)] = \frac{\hat{u}(s,t)}{\bar{f}(t)} m(s,t)$</p>
<ul>
<li>单点交叉的概率$p_c$</li>
<li>任意染色体任意位变异的概率$p_m$</li>
<li>模式$s$的阶(确定位数的个数) o(s)</li>
<li>模式$s$的长度(从最左确定位到最右确定位的距离)$d(s)$</li>
<li>染色体的长度$l$</li>
</ul>
<p>模式定理：$E[m(s,t+1)] \ge \frac{\hat{u}(s,t)}{\bar{f}(t)} m(s,t) (1 - p_c \frac{d(s)}{l-1}) (1-p_m)^{o(s)}$</p>
<ul>
<li>适应度越高的模式影响力越大</li>
<li>包含较少确定位的模式(也就是有较多#)影响力越大</li>
<li>确定位彼此靠近的模式影响力越大</li>
</ul>
<h2 id="强化学习">强化学习<a href="#强化学习" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>强化学习的本质：奖惩和试错(Trial and Error)</p>
<h3 id="markov-decision-processmdp">Markov Decision Process(MDP)<a href="#markov-decision-processmdp" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<ul>
<li>S- set of states, 状态集合</li>
<li>A- set of actions, 动作集合</li>
<li>$\delta$- transition probability, 状态转移概率</li>
<li>$R$- immediate reward function, 即时奖赏函数</li>
</ul>
<p>MDP模型-返回函数</p>
<ul>
<li>有限函数(Finite Horizon):
<ul>
<li>return= $\sum\limits_{1 \le i \le H} R(s_i,a_i)$</li>
</ul>
</li>
<li>无穷窗口(Infinite Horizon)
<ul>
<li>有折扣： return = $\sum\limits_{i=0}^{\infty} \gamma^i R(s_i,a_i)$</li>
<li>无折扣：return= $ \frac{1}{N}\sum\limits_{i=0}^{N-1} R(s_i,a_i), N \rightarrow \infty$</li>
</ul>
</li>
<li>通常返回函数是即时奖赏值的线性组合</li>
</ul>
<p>MDP模型-动作选择：</p>
<ul>
<li>目标
<ul>
<li>最大化期望返回(Return)</li>
</ul>
</li>
<li>策略
<ul>
<li>状态到动作的映射($\pi : S \rightarrow A$)</li>
</ul>
</li>
<li>最优策略
<ul>
<li>如果$\pi$是最优策略，则其从任一状态出发，均是最优的策略</li>
</ul>
</li>
<li>定理：必然存在着一个确定性的最优策略</li>
</ul>
<p>监督学习 VS 强化学习</p>
<ul>
<li>监督学习
<ul>
<li>(正/反例)在样本上的分布是确定的。</li>
</ul>
</li>
<li>强化学习
<ul>
<li>(状态/奖赏)的分布是策略依赖的(Policy Dependent!!!)</li>
<li>策略上小的变换都会导致返回值的巨大改变</li>
</ul>
</li>
</ul>
<h3 id="动态规划">动态规划<a href="#动态规划" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>给定一个完全已知的MDP模型</p>
<ul>
<li>策略评估(Policy Evaluation)
<ul>
<li>给定一个策略$\pi$, 评估其返回值</li>
</ul>
</li>
<li>最优控制(Optimal Control)
<ul>
<li>寻找一个最优策略$\pi^*$(从任一状态出发，其返回值都为最大)</li>
</ul>
</li>
</ul>
<p>$V^{\pi} (s):$ 从s状态出发，采用$\pi$策略，所获得的期望返回值</p>
<p>$Q^{\pi} (s,a):$ 从$s$状态出发，采用$a$动作，继而采用$\pi$策略，所获得的期望返回值</p>
<p>最优值函数($V^*(s)$ 和 $Q^*(s,a)$): 采用最优策略$\pi^*$所获得的期望返回值</p>
<p>定理：策略$\pi$为最优策略当且仅当，在每一个状态s, $V^*(s) = \max_{\pi} V^{\pi} (s)$, $V^{\pi}(s) = \max_a Q^{\pi}(s,a)$</p>
<p>最优策略： $\pi^* =\arg \max \limits_{\pi} V^{\pi}(s), (\forall s) $</p>
<p>Bellman等式(有折扣无限窗口)：</p>
<ul>
<li>$V^{\pi}(s) = E_{s&rsquo; ~ \pi(s) } [R(s,\pi(s)) + \gamma V^{\pi} (s&rsquo;)]$</li>
<li>重写之后：</li>
<li>$V^{\pi}(s) = E[R(s,\pi(s))] + \gamma \sum_{s&rsquo;} \delta (s, \pi(s),s&rsquo;) V^{\pi} (s&rsquo;) $</li>
</ul>
<p>动态规划-最优控制</p>
<ul>
<li>贪心策略
<ul>
<li>$\pi(s) = \arg \max_a Q^{\pi} (s,a)$</li>
</ul>
</li>
<li>$\varepsilon-$贪心策略
<ul>
<li>以$1-\varepsilon$概率选择， $\pi(s) = \arg \max_a Q^{\pi} (s,a)$</li>
<li>以$\varepsilon$概率选择其他动作</li>
</ul>
</li>
</ul>
<h3 id="monte-carlo策略">Monte Carlo策略<a href="#monte-carlo策略" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>策略评价：</p>
<ul>
<li>
<p>目标：学习$V^{\pi}(s)$</p>
</li>
<li>
<p>给定：在访问状态$s$, 采用策略$\pi$下，获得的若干经验</p>
</li>
<li>
<p>在访问状态$s$后，对所获得的返回，进行平均</p>
</li>
<li>
<p>Every-Visit MC: 在一次经验中，对每次访问到的$s$进行平均</p>
</li>
<li>
<p>First-Visit MC: 在一次经验中，只对首次访问到的$s$ 进行平均</p>
</li>
</ul>
<p>策略优化：$V(s_t) \leftarrow V(s_t) + \alpha(R_t - V(s_t))$</p>
<p>最优控制：</p>
<ul>
<li>MC策略迭代：使用MC方法对策略进行评估，计算值函数</li>
<li>MC策略修正：根据值函数(或者状态-动作对值函数)，采用贪心策略进行策略修正。</li>
</ul>
<h3 id="时差学习temporal-difference-learning">时差学习(Temporal-Difference Learning)<a href="#时差学习temporal-difference-learning" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>蒙特卡洛的方法可以看做是最大步数的时差学习</p>
<p>单步时差方法：$V(s_t) = V(s_t) + \alpha[r_t + \gamma V(s_{t+1}） - V(s_t)]$</p>
<p>$R_t^{(2)} = r_t + \gamma V(s_{t+1})$</p>
<p>N步时差方法：$R_t^{(n)} = \sum\limits_{i=0}^{n-1} \gamma^i r_{t+i} + \gamma^n V(s_{t+n})$</p>
<p>N步回退方法：$R_t $</p>
<h4 id="bootstaps和sampling">Bootstaps和Sampling<a href="#bootstaps和sampling" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>Bootstraps</p>
<ul>
<li>通过一个估计值进行更新</li>
<li>动态规划/时差学习中采用</li>
<li>蒙特卡洛方法不采用</li>
</ul>
<p>采样</p>
<ul>
<li>不通过估计值进行更新，而根据经验进行更新</li>
<li>蒙特卡洛方法/时差学习中采用</li>
<li>动态规划中不采用</li>
</ul>
<h2 id="博弈">博弈<a href="#博弈" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>囚徒困境</p>
<p>布雷斯悖论：它是指在一个交通网络上增加一条路段反而使网络上的旅行时间增加；这一附加路段不但没有减少交通延滞，反而降低了整个交通网络的服务水准。这种出力不讨好且与人们直观感受相背的交通网络现象主要源于纳什均衡点并不一定使社会最优化。</p>
<p>社会福利(Social Welfare):最大化所有参与者的受益和</p>
<p>帕里托优(Pareto Efficiency)</p>
<p>纳什均衡(Nash Equilibrium)</p>
<p>优超(Dominant):不依赖其他参与者</p>
<h3 id="帕里托优">帕里托优<a href="#帕里托优" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>一个方案$x$是帕里脱最优，当且仅当不存在另一个方案$x'$满足</p>
<ul>
<li>$\exists agent \ ag: ut_{ag}(x&rsquo;) &gt; ut_{ag}(x)$</li>
<li>$\forall agent \ ag&rsquo;: ut_{ag&rsquo;}(x&rsquo;) \ge ut_{ag&rsquo;} (x)$</li>
</ul>
<p>帕里托最优：不考虑跨Agent效益比较的情况下满足一个全局最优</p>
<p>帕里托改善：在不减少一方利益的同时，通过改变现有的资源配置而提高另一方的利益</p>
<p>社会福利是帕利脱最优的一个子集：一个agent要想提高自己的利益，必然存在其他agent的利益受损</p>
<h3 id="纳什均衡">纳什均衡<a href="#纳什均衡" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>Agent的策略依赖于其他agent</p>
<p>如果$S_A^* = &lt;S_1^*,S_2^*,&hellip;,S_{|A|^*}&gt;$ 为纳什均衡策略，当且仅当对agent $i$:$S_i^*$ 对于agent $i$ 是最优策略当其他agent选择以下策略时$&lt;S_1^*,S_2^*,&hellip;,S_{i-1}^*,S_{i+1}^*,&hellip;,S_{|A|}^*&gt;$</p>
<p>没有参与者可以独自行动而增加受益</p>
<p>问题:</p>
<ul>
<li>无纯Nash均衡解</li>
<li>多个Nash均衡解</li>
</ul>
<p>不同准则下的最优策略</p>
<ul>
<li>社会福利：&lt;抗拒，抗拒&gt;</li>
<li>帕里托优：除了&lt;坦白,坦白&gt;之外的其他情况</li>
<li>纳什均衡：&lt;坦白,坦白&gt;</li>
<li>优超：&lt;坦白，坦白&gt;</li>
</ul>
<p>分布式决策下的博弈??</p>
<h3 id="协商">协商<a href="#协商" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<h4 id="投票">投票<a href="#投票" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>投票机制：</p>
<ul>
<li>Agents给予一个投票机输入，投票机结果作为Agents的解决方案</li>
<li>设$A$为所有Agents的集合，$O$为所有投票结果的集合</li>
<li>一个agent $i$的投票结果可以被描述为$\succ_i \subseteq O \times O $</li>
</ul>
<p>投票机制的六原则</p>
<ul>
<li>对所有可能的输入组合，都存在一个社会偏序$\succ^*$</li>
<li>$\succ^*$对任意候选人的二元组$o,o&rsquo; \in O$都有定义</li>
<li>$\succ^*$在$O$上是非对称且传递的</li>
<li>结果满足帕里脱最优，即$\forall i \in A, o \succ_i o'$, 则$o \succ^* o'$</li>
<li>投票方案对不相关的候选人是独立的</li>
<li>没有Agent可以是独裁的</li>
</ul>
<p>不同的投票机制：</p>
<ul>
<li>多数投票
<ul>
<li>机制
<ul>
<li>所有候选人同时进行比较，得票最高者获胜</li>
</ul>
</li>
<li>分析
<ul>
<li>不满足无关方案独立原则</li>
</ul>
</li>
</ul>
</li>
<li>二叉投票
<ul>
<li>机制
<ul>
<li>候选人成对PK</li>
<li>胜者和其他候选人继续PK</li>
<li>败者淘汰</li>
</ul>
</li>
<li>分析
<ul>
<li>不满足无关方案独立原则</li>
<li>投票的结果依赖于比较的次序</li>
</ul>
</li>
</ul>
</li>
<li>计分投票
<ul>
<li>机制
<ul>
<li>设置一个分值$|O|$</li>
<li>排名第一的得$|O|$分，排名第二的得$|O|-1$分，依次类推</li>
<li>累加所有候选人的得分</li>
</ul>
</li>
<li>分析
<ul>
<li>不满足无关方案独立原则！</li>
<li>投票的结果依赖于分值！</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="拍卖">拍卖<a href="#拍卖" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<ul>
<li>
<p>投票机制的设计，其目的是使结果帕里脱优</p>
</li>
<li>
<p>拍卖机制的设计，其目的是使拍卖者增加自己的利益</p>
</li>
<li>
<p>拍卖者尽可能高价卖出物品</p>
</li>
<li>
<p>竞拍者尽可能使自己以低价获得物品</p>
</li>
</ul>
<p>拍卖机制：</p>
<ul>
<li>英格兰拍卖：first-price open-cry</li>
<li>密封拍卖 first-price sealed-bid</li>
<li>荷兰式拍卖
<ul>
<li>减价式拍卖</li>
</ul>
</li>
<li>Vickery拍卖second-price sealed-bid：
<ul>
<li>最好的策略是诚实</li>
<li>可以达到帕里脱最优</li>
</ul>
</li>
</ul>
<h4 id="谈判">谈判<a href="#谈判" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>谈判机制：</p>
<ul>
<li>公理谈判机制
<ul>
<li>不变形、对称性、无关性、帕里脱优</li>
</ul>
</li>
<li>策略谈判机制
<ul>
<li>物品的折扣因素，谈判的代价因素</li>
</ul>
</li>
</ul>

		</div>
	</main>

	<footer id="site-footer" class="section-inner thin animated fadeIn faster">
		<p>&copy; 2020 <a href="https://ricky-ting.github.io">Ricky Ting</a> &#183; <a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0</a></p>
		<p>
			Made with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> &#183; Theme <a href="https://github.com/Track3/hermit" target="_blank" rel="noopener">Hermit</a> &#183; <a href="https://ricky-ting.github.io/posts/index.xml" target="_blank" title="rss"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg></a>
		</p>
	</footer>



	<script src="https://ricky-ting.github.io/js/bundle.min.4a9a0ac3d2217822c7865b4161e6c2a71de1d70492264337755427898dd718f6.js" integrity="sha256-SpoKw9IheCLHhltBYebCpx3h1wSSJkM3dVQniY3XGPY=" crossorigin="anonymous"></script>
	

</body>

</html>
