<!DOCTYPE html>
<html lang="zh-CN">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<meta name="theme-color" content="#494f5c">
	<meta name="msapplication-TileColor" content="#494f5c">
<meta itemprop="name" content="机器学习(周志华)笔记">
<meta itemprop="description" content="机器学习笔记(学习中 进度堪忧) 第1章 绪论 1.1 引言 通过对经验的利用，就能对新情况做出有效的决策。计算机在这方面可以帮忙。 机器学习致力于研究如何通">
<meta itemprop="datePublished" content="2018-02-13T11:38:41&#43;08:00" />
<meta itemprop="dateModified" content="2018-02-13T11:38:41&#43;08:00" />
<meta itemprop="wordCount" content="7438">



<meta itemprop="keywords" content="untagged," /><meta property="og:title" content="机器学习(周志华)笔记" />
<meta property="og:description" content="机器学习笔记(学习中 进度堪忧) 第1章 绪论 1.1 引言 通过对经验的利用，就能对新情况做出有效的决策。计算机在这方面可以帮忙。 机器学习致力于研究如何通" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://ricky-ting.github.io/notes/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%91%A8%E5%BF%97%E5%8D%8E-%E7%AC%94%E8%AE%B0/" />
<meta property="article:published_time" content="2018-02-13T11:38:41+08:00" />
<meta property="article:modified_time" content="2018-02-13T11:38:41+08:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="机器学习(周志华)笔记"/>
<meta name="twitter:description" content="机器学习笔记(学习中 进度堪忧) 第1章 绪论 1.1 引言 通过对经验的利用，就能对新情况做出有效的决策。计算机在这方面可以帮忙。 机器学习致力于研究如何通"/>

	<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
	<link rel="manifest" href="/site.webmanifest">
	<link rel="mask-icon" href="/safari-pinned-tab.svg" color="">
	<link rel="shortcut icon" href="/favicon.ico">

	<title>机器学习(周志华)笔记</title>
	<link rel="stylesheet" href="https://ricky-ting.github.io/css/style.min.657bcb7af31123e4156b1a3d2ff60a636717e54ead74f882136b5114cf72b55e.css" integrity="sha256-ZXvLevMRI+QVaxo9L/YKY2cX5U6tdPiCE2tRFM9ytV4=" crossorigin="anonymous">
	
</head>

<body id="page">
	
	<header id="site-header" class="animated slideInUp faster">
		<div class="hdr-wrapper section-inner">
			<div class="hdr-left">
				<div class="site-branding">
					<a href="https://ricky-ting.github.io">Ricky Ting&#39;s Blog</a>
				</div>
				<nav class="site-nav hide-in-mobile">
					
				<a href="https://ricky-ting.github.io/posts/">Posts</a>
				<a href="https://ricky-ting.github.io/notes/">Notes</a>
				<a href="https://ricky-ting.github.io/slides/">Slides</a>
				<a href="https://ricky-ting.github.io/about-hugo/">About</a>
				<a href="https://ricky-ting.github.io/links/">Links</a>

				</nav>
			</div>
			<div class="hdr-right hdr-icons">
				<button id="toc-btn" class="hdr-btn desktop-only-ib" title=""><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-list"><line x1="8" y1="6" x2="21" y2="6"></line><line x1="8" y1="12" x2="21" y2="12"></line><line x1="8" y1="18" x2="21" y2="18"></line><line x1="3" y1="6" x2="3" y2="6"></line><line x1="3" y1="12" x2="3" y2="12"></line><line x1="3" y1="18" x2="3" y2="18"></line></svg></button><span class="hdr-social hide-in-mobile"><a href="https://github.com/Ricky-Ting/" target="_blank" rel="noopener me" title="Github"><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path></svg></a></span><button id="menu-btn" class="hdr-btn" title=""><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></button>
			</div>
		</div>
	</header>
	<div id="mobile-menu" class="animated fast">
		<ul>
			<li><a href="https://ricky-ting.github.io/posts/">Posts</a></li>
			<li><a href="https://ricky-ting.github.io/notes/">Notes</a></li>
			<li><a href="https://ricky-ting.github.io/slides/">Slides</a></li>
			<li><a href="https://ricky-ting.github.io/about-hugo/">About</a></li>
			<li><a href="https://ricky-ting.github.io/links/">Links</a></li>
		</ul>
	</div>


	<main class="site-main section-inner thin animated fadeIn faster">
		<h1>机器学习(周志华)笔记</h1>
		<div class="content">
			<h1 id="机器学习笔记学习中-进度堪忧">机器学习笔记(学习中 进度堪忧)<a href="#机器学习笔记学习中-进度堪忧" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h1>
<h2 id="第1章-绪论">第1章 绪论<a href="#第1章-绪论" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<h3 id="11-引言">1.1 引言<a href="#11-引言" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>通过对经验的利用，就能对新情况做出有效的决策。计算机在这方面可以帮忙。</p>
<p>机器学习致力于研究如何通过计算的手段，利用经验来改善系统自身的性能。机器学习所研究的主要内容，是关于在计算机上从数据中产生“模型”(model)的算法，即&quot;学习算法&rdquo;(learning algorithm).</p>
<!-- raw HTML omitted -->
<h3 id="12-基本术语">1.2 基本术语<a href="#12-基本术语" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>一组记录的集合称为一个“数据集”(data set),其中每条记录是关于一个事件或对象的描述，称为一个“示例”(instance)或&quot;样本&rdquo;(sample)</p>
<p>反映事件或对象在某方面的表现或性质的事项称为&quot;属性&rdquo;(attribute)或&quot;特征&rdquo;(feature).属性上的取值称为&quot;属性值&rdquo;(attribute value).属性张成的空间称为&quot;属性空间&rdquo;(attribute space)、&ldquo;样本空间&rdquo;(sample space)或&quot;输入空间&rdquo;.我们也把一个示例称为一个&quot;特征向量&rdquo;(feature vector).</p>
<p>每个示例由d个属性描述,d称为样本的&quot;维数&rdquo;(dimensionality).</p>
<p>从数据中学得模型的过程称为&quot;学习&rdquo;(learning)或&quot;训练&rdquo;(training)</p>
<p>训练中使用的数据称为&quot;训练数据&rdquo;(training data),其中每个样本称为一个&quot;训练样本&rdquo;(training sample),训练样本组成的集合称为&quot;训练集&rdquo;(training set)</p>
<p>学得模型对应了关于数据的某种潜在的规律，因此亦称&quot;假设&rdquo;(hypothesis);这种潜在规律自身，则称为&quot;真相&quot;或&quot;真实&rdquo;(ground-truth).有时将模型称为&quot;学习器&rdquo;(learner),可以看作学习算法在给定数据和参数空间上的实例化.</p>
<p>标记(label);拥有了标记信息的示例,则称为&quot;样例&rdquo;(example).所有标记的集合称为&quot;标记空间&rdquo;(label space)或&quot;输出空间&rdquo;.</p>
<p>(<strong>x</strong>i,yi)表示第i个样例,<strong>x</strong>i是d维向量.</p>
<p>若欲预测的是离散值，此类学习任务称为&quot;分类&rdquo;(classification);若欲预测的是连续值,此类学习任务称为&quot;回归&rdquo;(regression).</p>
<p>对于只涉及两个类别的“二分类”(binary classification)任务，通常称其中一个类为&quot;正类&rdquo;(positive class),另一个类为&quot;反类&rdquo;(negative class)；涉及多个类别时,则称为“多分类”(multi-class classification)任务。</p>
<p>学得模型后，使用其进行预测的过程称为“测试”(testing),被预测的样本称为&quot;测试样本&rdquo;(testing sample) .</p>
<p>聚类(clustering),即将训练中的示例分成若干组，每组称为一个&quot;簇&rdquo;(cluster);这些自动形成的簇可能对应一些潜在的概念划分.这样的学习过程有助于我们了解数据内在的规律，能为更深入地分析数据建立基础.</p>
<p>根据训练数据是否拥有标记信息，学习任务可大致划分为两大类:&ldquo;监督学习&rdquo;(supervised learning)和&quot;无监督学习&rdquo;(unsupervised learning),分类和回归是前者的代表,而聚类则是后者的代表.</p>
<p>机器学习的目标是使学得的模型能更好地适用于&quot;新样本&rdquo;，而不是仅仅在训练样本上工作得好.学得模型适用于新样本的能力,称为&quot;泛化&rdquo;(generalization)能力.</p>
<p>通常假设样本空间中全体样本服从一个未知&quot;分布&rdquo;(distribution)<em>D</em>,我们获得的每个样本都是独立地从这个分布上采样获得的,即&quot;独立同分布&rdquo;(independent and identically distributed,简称<em>i.i.d</em>)</p>
<h3 id="13-假设空间">1.3 假设空间<a href="#13-假设空间" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p><em>归纳(induction)和演绎(deduction)科学推理的两大基本手段</em></p>
<p>归纳学习(inductive learning).狭义的归纳学习要求从训练数据中学得概念(concept),亦称为&quot;概念学习&quot;或&quot;概念形成&rdquo;.概念学习技术目前研究、应用都比较少，因为要学得泛化性能好且语义明确的概念实在太困难了,现实常用的技术大多是产生&quot;黑箱&quot;模型。</p>
<p>概念学习中最基本的是布尔概念学习.</p>
<p>&ldquo;记住&quot;训练样本，就是所谓的&quot;机械学习&rdquo;.</p>
<p>我们可以把学习过程看作一个在所有假设(hypothesis)组成的空间中进行搜索的过程,搜索目标是找到与训练集&quot;匹配&rdquo;(fit)的假设.现实问题中我们常面临很大的假设空间,但学习过程是基于有限样本训练集进行的,因此，可能有多个假设与训练集一致,即存在着一个与训练集一致的&quot;假设集合&rdquo;,我们称之为&quot;版本空间&rdquo;(version space)</p>
<h3 id="14-归纳偏好">1.4 归纳偏好<a href="#14-归纳偏好" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>当有多个模型(假设)时，应该采纳哪一个.这时,学习算法本身的&quot;偏好&quot;就会起到关键的作用.</p>
<p>机器学习算法在学习过程中对某种类型假设的偏好,称为&quot;归纳偏好&rdquo;(inductive bias),或简称为&quot;偏好&rdquo;.</p>
<p>任何一个有效的机器学习算法必有其归纳偏好.</p>
<p>归纳偏好可看作学习算法自身在一个很庞大的假设空间中对假设进行选择的启发式或&quot;价值观&rdquo;.“奥卡姆剃刀”(Occam&rsquo;s razor)是一种常用的、自然科学研究中最基本的原则，即“若有多个假设与观察一致，则选最简单的那个”</p>
<p>算法的归纳偏好是否与问题本身匹配，大多数时候直接决定了算法能否取得好的性能.</p>
<p>对于一个学习算法A,若它在某些问题上比学习算法B好,则必然存在另一些问题,在那里B比A好.这个结论对任何算法均成立.<strong>证明待看</strong></p>
<p>NFL定理(No Free Lunch Theorem)[Wolpert,1996;Wolpert and Macready,1995]</p>
<p>NFL的最重要寓意，是让我们清楚地认识到,脱离具体问题,空泛地谈论&quot;什么学习算法更好&quot;毫无意义。学习算法自身的归纳偏好与问题是否相配,往往会起到决定性的作用.</p>
<h3 id="15-发展历程">1.5 发展历程<a href="#15-发展历程" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>二十世纪五十年代到七十年代初,人工智能研究处于&quot;推理期&rdquo;,那时认为人们只要能赋予机器逻辑推理能力，机器就能具有智能.人们逐渐认识到,仅具有逻辑推理能力是远远实现不了人工智能的.后来认为，要使机器具有智能，就必须设法使机器拥有知识.从二十世纪七十年代中期开始,人工智能研究进入了&quot;知识期&rdquo;。大量专家系统问世。但逐渐的专家系统面临&quot;知识工程瓶颈&rdquo;，简单地说，就是由人来把知识总结出来再教给计算机是相当困难的.</p>
<p>二十世纪五十年代初已有机器学习的相关研究,五十年代中后期，基于神经网络的&quot;连接主义&rdquo;(connectionism)学习开始出现。在六七十年代，基于逻辑表示的“符号主义”(symbolism)学习技术蓬勃发展,以决策理论为基础的学习技术以及强化学习技术等也得到发展。</p>
<p>总的来看，二十世纪八十年代是机器学习成为一个独立学科领域、各种机器学习技术百花初绽的时期。</p>
<p>在二十世纪八十年代，“从样例中学习”的一大主流是符号主义学习，其代表包括决策树(decision tree)和基于逻辑的学习.典型的决策树学习以信息论为基础，以信息熵的最小化为目标，直接模拟了人类对概念进行判定的树形流程.决策树学习技术由于简单易用,到今天仍是最常用的机器学习技术之一.</p>
<p>BP一直是被应用得最广泛的机器学习算法之一.连接主义学习的最大局限是其&quot;试错性&rdquo;</p>
<p>二十世纪九十年代中期,&ldquo;统计学习&rdquo;(statistical learning)闪亮登场并迅速占据主流舞台,代表性技术是支持向量机(Support Vector Machine,简称SVM)以及更一般的“核方法”(kernel methods).在支持向量机被普遍接受后,核技巧被人们用到了机器学习的几乎每一个角落，核方法(kernel trick)也逐渐成为机器学习的基本内容之一.</p>
<p>二十一世纪初,连接主义又卷土重来,掀起了以&quot;深度学习&quot;为名的热潮.所谓深度学习，狭义地说就是&quot;很多层&quot;的神经网络.</p>
<h3 id="16-应用现状">1.6 应用现状<a href="#16-应用现状" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<h2 id="第二章-模型评估与选择">第二章 模型评估与选择<a href="#第二章-模型评估与选择" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<h3 id="21-经验误差与过拟合">2.1 经验误差与过拟合<a href="#21-经验误差与过拟合" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>&ldquo;错误率&rdquo;(error rate)：分类错误的样本数占样本总数的比例.</p>
<p>“精度”(accuracy)：精度 = 1-错误率</p>
<p>&ldquo;误差&rdquo;(error)：学习器的实际预测输出与样本的真实输出之间的差异</p>
<p>&ldquo;训练误差&rdquo;(training error)或&quot;经验误差&rdquo;(empirical error):学习器在训练集上的误差</p>
<p>&ldquo;泛化误差&rdquo;(generalization error)：学习器在新样本上的误差</p>
<p>我们希望得到泛化误差小的学习器.然而，我们事先并不知道新样本是什么样的,实际能做的是努力使经验误差最小化.</p>
<p>&ldquo;过拟合&rdquo;(overfitting):当学习器把训练样本学得&quot;太好&quot;了的时候,很可能已经把训练样本本身的一些特点当做了所有潜在样本都会具有的一般性质,这样就会导致泛化性能下降.</p>
<p>&ldquo;欠拟合&rdquo;(underfitting):指对训练样本的一般性质尚未学好。</p>
<p>欠拟合比较容易克服,例如在决策树学习中扩展分支、在神经网络学习中增加训练轮数等</p>
<p>过拟合是机器学习面临的关键障碍,过拟合是无法彻底避免的,我们所能做的只是&quot;缓解&rdquo;.只要相信P $\not=$ NP,过拟合就不可避免.</p>
<p>机器学习中的&quot;模型选择&rdquo;(model selection)问题,如何进行模型评估与选择呢？</p>
<p><strong>疑惑：这里的评估是对学习算法在这特定问题上表现的评估吧？</strong></p>
<h3 id="22-评估方法">2.2 评估方法<a href="#22-评估方法" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>通常，我们可通过实验测试来对学习器的泛化误差进行评估并进而做出选择.为此，需使用一个“测试集”(testing set)来测试学习器对新样本的判别能力,然后以测试集上的“测试误差&rdquo;(testing error)作为泛化误差的近似.测试集应该尽可能与训练集互斥.</p>
<p>有限的数据集,如何产生训练集<em>S</em>和测试集<em>T</em>.下面是几种常见的做法</p>
<h4 id="221-留出法hold-out">2.2.1 留出法(hold-out)<a href="#221-留出法hold-out" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>直接将数据集<em>D</em>划分为两个互斥的集合。</p>
<p>训练/测试集的划分要尽可能保持数据分布的一致性,避免因数据划分过程中中引入额外的偏差而对最终结果产生影响.&ldquo;分层采样&rdquo;(stratified sampling).</p>
<p>单次使用留出法得到的估计结果往往不够稳定可靠,在使用留出法时,一般要采用若干次随机划分、重复进行试验评估后取平均值作为留出法的评估结果.</p>
<p>保真性(fidelity),划分比例过大或过小导致的问题没有完美的解决方案,常见做法是将大约2/3~4/5的样本用于训练，剩余样本用于测试.</p>
<h4 id="222-交叉验证法cross-validation">2.2.2 交叉验证法(cross validation)<a href="#222-交叉验证法cross-validation" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>将数据集<em>D</em>划分为k个子集,保证每个子集数据分布的一致性(可以通过分层采样).每次用k-1个子集训练，剩下的一个做测试集。这样可以得到k组.最后返回k个测试结果的均值.</p>
<p>这种方法的稳定性和保真性在很大程度上取决于k的取值，通常把这种方法称为&quot;k折交叉验证&rdquo;(<em>k</em>-fold cross validation).通常k取10</p>
<p>把数据集D划分为k个子集存在多种方式,所以为了减小划分不同引入的误差,通常要随机使用不同的划分重复p次,最终的评估结果是这p次k折交叉验证结果的均值.</p>
<p>假定数据集D中包含m个样本,若令k=m，则得到了交叉验证法的一个特例:留一法(Leave-One-Out,简称LOO)。显然，留一法不受随机样本划分方式的影响.留一法的评估结果往往被认为比较准确.留一法也有缺陷:在数据集比较大时，训练m个模型的计算开销可能是难以忍受的.而且这还是在未考虑算法调参的情况下.留一法的估计结果也未必永远比其他评估方法准确.</p>
<p>&ldquo;没有免费午餐&quot;定理对实验评估方法同样适用。</p>
<h4 id="223-自助法bootstrapping可重复采样">2.2.3 自助法(bootstrapping)=可重复采样<a href="#223-自助法bootstrapping可重复采样" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>有没有什么办法可以减少训练样本规模不同造成的影响,同时还能比较高效地进行实验估计呢？</p>
<p>”自助法“是一个比较好的解决方案,它直接以自助采样法(bootstrap sampling)为基础.就是相当于摸小球放回知道摸的次数与小球数相等。</p>
<p>样本在m次采样中始终不被采到的概率是 $(1-\frac{1}{m})^m$，取极限为 $\frac{1}{e} \approx 0.368$ ,将未被抽中的作为测试集。这样的测试结果，亦称&quot;包外估计&rdquo;(out-of-bag estimate).</p>
<p>自助法在数据集较小、难以有效划分训练/测试集时很有用；此时，自助法能从初始数据集中产生多个不同训练集,这对集成学习等学习方法有很大的好处。然而，自助法产生的数据集改变了初始数据集的分布，会引入估计偏差.因此在初始数据量足够时，留出法和交叉验证法更常用一些.</p>
<h4 id="224-调参parameter-tuning与最终模型">2.2.4 调参(parameter tuning)与最终模型<a href="#224-调参parameter-tuning与最终模型" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>参数可能在实数范围内取值，有着极大的调参工作量,以至于在不少应用任务中,参数调的好不好往往对最终模型性能有关键性影响。</p>
<p>模型选择完成后，学习算法和参数配置已选定,此时应该用数据集<em>D</em>重新训练模型.这才是我们最终提交给用户的模型.</p>
<p>验证集(validation set)存疑</p>
<h3 id="23-性能度量">2.3 性能度量<a href="#23-性能度量" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>需要有衡量模型泛化能力的评价标准,这就是性能度量(performance measure).面对不同的任务需求，选用不同的性能度量。</p>
<p>回归任务最常用的性能度量是&quot;均方误差&rdquo;(mean squared error) <strong>公式待补</strong></p>
<p>下面主要介绍分类任务中常用的性能度量.</p>
<h4 id="231-错误率与精度">2.3.1 错误率与精度<a href="#231-错误率与精度" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>这是分类任务中最常用的两种性能度量，既适用于二分类任务，也适用于多分类任务 <strong>公式待补</strong></p>
<h4 id="232-查准率precision查全率recall与f1">2.3.2 查准率(precision)、查全率(recall)与F1<a href="#232-查准率precision查全率recall与f1" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>对于二分类问题,可将样例根据其真实类别与学习器预测类别的组合划分为真正例(true positive,TP)、假正例(false positive,FP)、真反例(true negative,TN)、假反例(false negative,FN)四种情形。
分类结果的&quot;混淆矩阵&rdquo;(confusion matrix)</p>
<table>
<thead>
<tr>
<th>真实情况</th>
<th>预测结果</th>
<th>预测结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>真实情况</td>
<td>正例</td>
<td>反例</td>
</tr>
<tr>
<td>正例</td>
<td>TP(真正例)</td>
<td>FN(假反例)</td>
</tr>
<tr>
<td>反例</td>
<td>FP(假正例)</td>
<td>TN(真反例)</td>
</tr>
</tbody>
</table>
<p>查准率P与查全率R分别定义为:
$$ P=\frac{TP}{TP+FP} $$</p>
<p>$$R=\frac{TP}{TP+FN}$$</p>
<p>查准率和查全率是一对矛盾的度量.一般来说，查准率高时，查全率往往偏低;反之类似.</p>
<p>查准率-查全率曲线,简称”P-R曲线“，显示该曲线的图称为”P-R图“.</p>
<p>若一个学习器的P-R曲线被另一个学习器的曲线完全&quot;包住&rdquo;，则可断言后者的性能优于前者.</p>
<p>若两个学习器的P-R曲线发生了交叉,则一般难以一般性地断言两者孰优孰劣,只能在具体的查准率或查全率条件下进行比较.仍希望比个高低,这时一个比较合理的判据是比较P-R曲线下面积的大小。</p>
<p>人们设计了一些综合考察查准率、查全率的性能度量.</p>
<p>”平衡点“(Break-Even Point,简称BEP)就是这样一个度量,它是”查准率=查全率“时的取值</p>
<p>但BEP还是过于简化了些，更常用的是F1度量:</p>
<p>$$F1=\frac{2 \times P \times R}{P+R} = \frac{2 \times TP}{样例总数+TP-TN}$$</p>
<p>F1是基于查准率与查全率的调和平均(harmonic mean)定义的</p>
<p>F1的一般形式是$F_{\beta}$，能让我们表达出对查准率/查全率的不同偏好,$F_{\beta}$是加权调和平均.</p>
<p>$$F_{\beta} = \frac{1+\beta^2 \times P \times R}{(\beta^2 \times P) + R}$$</p>
<p>其中$\beta &gt;0$度量了查全率对查准率的相对重要性.$\beta = 1$时退化为标准的F1;$\beta &gt;1$时查全率有更大影响；$\beta &lt;1$时查准率有更大影响</p>
<p>我们希望在n个二分类混淆矩阵上综合考察查准率和查全率.</p>
<p>一种直接的做法是先在各混淆矩阵上分别计算出查准率和查全率，然后计算平均值,这样就得到&quot;宏查准率&rdquo;(macro-P)、&ldquo;宏查全率&rdquo;(macro-R),以及相应的&quot;宏F1&rdquo;(macro-F1):</p>
<p>还有一种:先将各混淆矩阵的对应的元素进行平均,再基于这些平均值计算出&quot;微查准率&rdquo;(micro-P)、&ldquo;微查全率&rdquo;(micro-R)和&quot;微F1&rdquo;(micro-F1)</p>
<h4 id="233-roc与auc">2.3.3 ROC与AUC<a href="#233-roc与auc" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>分类阈值(threshold) 截断点(cut point)</p>
<p>排序本身的质量好坏,体现了综合考虑学习器在不同任务下的&quot;期望泛化性能&quot;的好坏，或者说，”一般情况下“泛化性能的好坏，ROC曲线则是从这个角度出发来研究学习器泛化性能的有力工具.</p>
<p>ROC全称是”受试者工作特征“(Receiver Operating Characteristic)曲线</p>
<p>ROC曲线的纵轴是”真正例率“(True Positive Rate,简称&quot;TPR&rdquo;),横轴是&quot;假正例率&rdquo;(False Positive Rate,简称FPR)</p>
<p>$$TPR = \frac{TP}{TP+FN}$$</p>
<p>$$FPR = \frac{FP}{TN+FP}$$</p>
<p>两条ROC曲线的比较类似于P-R曲线类似. ROC曲线下的面积,即AUC(Area Under ROC Curve)</p>
<p><strong>公式待补</strong></p>
<p>排序&quot;损失&rdquo;(loss)的定义为: <strong>公式待补</strong></p>
<p>$l_{rank}$对应的是ROC曲线之上的面积,AUC = 1-$l_{rank}$</p>
<h4 id="234-代价敏感错误率与代价曲线">2.3.4 代价敏感错误率与代价曲线<a href="#234-代价敏感错误率与代价曲线" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>为权衡不同类型错误所造成的不同损失，可为错误赋予&quot;非均等代价&rdquo;(unequal cost).</p>

		</div>
	</main>

	<footer id="site-footer" class="section-inner thin animated fadeIn faster">
		<p>&copy; 2020 <a href="https://ricky-ting.github.io">Ricky Ting</a> &#183; <a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0</a></p>
		<p>
			Made with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> &#183; Theme <a href="https://github.com/Track3/hermit" target="_blank" rel="noopener">Hermit</a> &#183; <a href="https://ricky-ting.github.io/posts/index.xml" target="_blank" title="rss"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg></a>
		</p>
	</footer>



	<script src="https://ricky-ting.github.io/js/bundle.min.4a9a0ac3d2217822c7865b4161e6c2a71de1d70492264337755427898dd718f6.js" integrity="sha256-SpoKw9IheCLHhltBYebCpx3h1wSSJkM3dVQniY3XGPY=" crossorigin="anonymous"></script>
	

</body>

</html>
