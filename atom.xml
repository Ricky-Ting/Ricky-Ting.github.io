<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ricky Ting&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/5c8eecd06d08187c73ea49421008f04d</icon>
  <subtitle>当时只道是寻常</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-08-03T08:11:46.047Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Ricky-Ting</name>
    <email>1770048119@qq.com dbr1770048119@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2018 Spring Problem Solving 2</title>
    <link href="http://yoursite.com/2018/07/08/2018-Spring-Problem-Solving-2/"/>
    <id>http://yoursite.com/2018/07/08/2018-Spring-Problem-Solving-2/</id>
    <published>2018-07-08T01:12:08.000Z</published>
    <updated>2018-08-03T08:11:46.047Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2018春问题求解笔记"><a href="#2018春问题求解笔记" class="headerlink" title="2018春问题求解笔记"></a>2018春问题求解笔记</h1><h2 id="2-1-算法正确性-2018-3-7"><a href="#2-1-算法正确性-2018-3-7" class="headerlink" title="2-1 算法正确性(2018.3.7)"></a>2-1 算法正确性(2018.3.7)</h2><p>程序和算法不等同</p><p>算法正确性是基础</p> <a id="more"></a><p>“Program testing can be used to show the presence of bugs, but never to show their absence!”</p><p>封闭环境内同一个输入会产生同样的错误，但网络环境以及并行下不一定。错误的难重现</p><p>部分正确性(if terminates)和完全正确性(indeed terminates)</p><p>循环不变式</p><p>show converge</p><p>assertion和checkpoint：我们可以在算法的任意位置，设置assertion，这个“位置”就是check point</p><p>证明就是断言的序列</p><p>一条链</p><p>递归：数学归纳法</p><p>证明多个变量的数学归纳法：$\forall$ m, 对n做归纳</p><h3 id="习题讲解-2018-3-12"><a href="#习题讲解-2018-3-12" class="headerlink" title="习题讲解(2018.3.12)"></a>习题讲解(2018.3.12)</h3><p>totalwork = workdone + worktodo</p><p>(1)-&gt;(2)-&gt;(2’)-&gt;(3)-&gt;(4)</p><h3 id="open-topic"><a href="#open-topic" class="headerlink" title="open topic"></a>open topic</h3><h4 id="1-证明插入排序的完全正确性"><a href="#1-证明插入排序的完全正确性" class="headerlink" title="1.证明插入排序的完全正确性"></a>1.证明插入排序的完全正确性</h4><p>两层循环 内层 外层</p><h4 id="2-证明旋转汉诺塔的完全正确性"><a href="#2-证明旋转汉诺塔的完全正确性" class="headerlink" title="2.证明旋转汉诺塔的完全正确性"></a>2.证明旋转汉诺塔的完全正确性</h4><p>状态数 操作数：操作数&gt;状态数，则非最优解</p><h2 id="2-2-算法的效率"><a href="#2-2-算法的效率" class="headerlink" title="2-2 算法的效率"></a>2-2 算法的效率</h2><h3 id="open-topic-1"><a href="#open-topic-1" class="headerlink" title="open topic"></a>open topic</h3><h4 id="Algorithmic-Gap"><a href="#Algorithmic-Gap" class="headerlink" title="Algorithmic Gap"></a>Algorithmic Gap</h4><p>Decision Tree</p><p>Adversary Argument</p><h2 id="2-3-组合与计数"><a href="#2-3-组合与计数" class="headerlink" title="2-3 组合与计数"></a>2-3 组合与计数</h2><p>计数在算法分析中很重要</p><p>抽象</p><p>加法原理 乘法原理</p><p>kth falling factorial power of n</p><p>Pascal’s triangle</p><p>Pascal relationship</p><p>multiset：放入k个后取</p><p>等价关系用于计数 等价类 商集</p><h2 id="2-4-分治法与递归"><a href="#2-4-分治法与递归" class="headerlink" title="2-4 分治法与递归"></a>2-4 分治法与递归</h2><p>Divide-and-Conquer: 3steps(Divid -&gt; Conquer -&gt; Combine)</p><p>递归中subproblem出现的两种case:recursive case, base case</p><h3 id="three-methods-for-solving-recurrences"><a href="#three-methods-for-solving-recurrences" class="headerlink" title="three methods for solving recurrences:"></a>three methods for solving recurrences:</h3><ul><li>substitution method</li><li>recursion-tree method</li><li>master method</li></ul><h3 id="maximum-subarray-problem"><a href="#maximum-subarray-problem" class="headerlink" title="maximum-subarray problem"></a>maximum-subarray problem</h3><p>consider the daily change in price</p><p>divide-and-conquer解法: 把序列一分为二，然后最长的有三种情况，全在左边一半，全在右边一半，横跨中点。然后重点如何处理第三种情况，在中点向两边分别找，然后合并。复杂度为O(nlogn).</p><p>有O(n)算法 类似于DP</p><h3 id="Strassen’s-algorithm-for-matrix-multiplication"><a href="#Strassen’s-algorithm-for-matrix-multiplication" class="headerlink" title="Strassen’s algorithm for matrix multiplication"></a>Strassen’s algorithm for matrix multiplication</h3><p>$O(n^3) -&gt; O(n^{2.81})[O(n^{lg7})]$</p><h3 id="substituition-method"><a href="#substituition-method" class="headerlink" title="substituition method"></a>substituition method</h3><p>Guess and then prove. Mathematical Induction.</p><ol><li>Guess the form of the solution.</li><li>Use mathemarical induction to find the constants and show that the solution works.</li></ol><p>一些证明中的小技巧:改变起始项，更换变量</p><h3 id="Recursion-tree-method"><a href="#Recursion-tree-method" class="headerlink" title="Recursion-tree method"></a>Recursion-tree method</h3><p>A recursion-tree is best used to generate a good guess.</p><p>Analyse and then sum.</p><h3 id="master-method"><a href="#master-method" class="headerlink" title="master method"></a>master method</h3><p>prove</p><p>为什么分治法能降低时间复杂度？</p><h2 id="2-5-递归及其数学基础"><a href="#2-5-递归及其数学基础" class="headerlink" title="2-5 递归及其数学基础"></a>2-5 递归及其数学基础</h2><p>求解精确解</p><h3 id="Mathematical-Induction"><a href="#Mathematical-Induction" class="headerlink" title="Mathematical Induction"></a>Mathematical Induction</h3><ul><li>base case  </li><li>inductive hypothesis</li><li>inductive step</li><li>inductive conclusion</li></ul><p>The terms weak and strong arise from what is assumed in the inductive hypothesis. Adding more restrictions strengthens an assertion, while removing restrictions weakens the assertion</p><p>recursion和mathematical induction有密切联系<br>一个自上而下(分解问题) 一个自下而上(组合问题)</p><p>structural induction</p><p>triangulated polygon<br>Ear Lemma</p><p>等比数列</p><p>ﬁrst-order linear recurrence ：T(n) = f (n)T(n − 1) + g(n)</p><p>巧用微积分知识</p><p>解一阶线性：直接展开</p><p>解线性齐次：解特征方程</p><h2 id="2-6-算法方法"><a href="#2-6-算法方法" class="headerlink" title="2-6 算法方法"></a>2-6 算法方法</h2><p>问题求解：压缩解空间</p><p>Maximal Polygon Distance问题</p><p>Minimal Spanning Tree</p><p>Greedy DP(本质上还是穷竭搜索 但空间换时间)</p><p>DFS BFS</p><p>Bin packing NPC问题</p><h2 id="2-7-离散概率"><a href="#2-7-离散概率" class="headerlink" title="2-7 离散概率"></a>2-7 离散概率</h2><p>Complementary Probabilities</p><p>The Uniform Probability Distribution</p><p>(Principle of Inclusion and Exclusion for Probability)<br>Proof1: 算P(x)的系数 用二项式定理 Proof2:待理解</p><p>Conditional probability: P(E|F)=P(E \cap F) / P(F) [P(E|F)=P(E) when P(F)=0]</p><p>We say E is independent of F if P(E|F) = P(E). 我认为P(E|F)不是由公式导出的。存疑</p><p><strong>Bayes’ Theorem</strong>：P(E|F)P(F) = P(F|E)P(E).</p><p>product principle for independent probabilities: P(E \cap F) = P(E)P(F)</p><p>independent trials process</p><p>our model of hashing is an independent trials process.</p><p>probability tree</p><p>A random variable for an experiment with a sample space S is a function that assigns a number to each element of S.</p><p>Bernoulli trials process</p><p>expected value</p><p>indicator random variable</p><p>The Number of Trials until the First Success</p><p>指示器随机变量提供了一个便利的工具实现事件A发生的概率和期望之间的转换：求某个随机变量的期望往往可以简化为若干个和该随机变量相关的事件的概率之和</p><h2 id="2-8-概率分析与随机化算法"><a href="#2-8-概率分析与随机化算法" class="headerlink" title="2-8 概率分析与随机化算法"></a>2-8 概率分析与随机化算法</h2><p>conditional expected value</p><p>Randomized Algorithms</p><p>Quicksort分析</p><p>normal curve</p><p>variance</p><p>Central limit theorem.</p><p>normal distribution</p><h2 id="2-9-排序与选择"><a href="#2-9-排序与选择" class="headerlink" title="2-9 排序与选择"></a>2-9 排序与选择</h2><p>The Coupon Collector’s Problem</p><p>$n log n + (m-1)nloglogn + nC_m + o(n), n \rightarrow \infty, m fixed$</p><p>Tony Hoare: Quicksort, Hoare Logic: {P}S{Q}, null pointer “I call it my billion-dollar mistake”.</p><p>证明下界：1. decision tree 2. adversary strategy</p><p>Adversary Argument：证下界</p><p>检测01、同时找最大最小、找第二小，k=3 is still open， 找中间值</p><h2 id="2-10-基本数据结构"><a href="#2-10-基本数据结构" class="headerlink" title="2-10 基本数据结构"></a>2-10 基本数据结构</h2><p>tail指向最后一个元素的后一个 为什么</p><p>Why Numbering Should Start at Zero(EWD831)</p><h2 id="2-11-堆与堆排序"><a href="#2-11-堆与堆排序" class="headerlink" title="2-11 堆与堆排序"></a>2-11 堆与堆排序</h2><h2 id="2-12-Hashing方法"><a href="#2-12-Hashing方法" class="headerlink" title="2-12 Hashing方法"></a>2-12 Hashing方法</h2><h2 id="2-13-搜索树"><a href="#2-13-搜索树" class="headerlink" title="2-13 搜索树"></a>2-13 搜索树</h2><p>A tree is a recursive abstract data type</p><h3 id="Binary-Search-Tree"><a href="#Binary-Search-Tree" class="headerlink" title="Binary Search Tree"></a>Binary Search Tree</h3><p>Operations: Search(用while), Minimum(当子节点不为nil一直下去), Maximum, Predecessor(分两种情况:有右子树 无右子树), Successor, Insert and Delete(分三种情况).  Transplant(不管子节点)</p><p>The expected height of a randomly built binary search tree is $O(\lg{n})$.</p><p>B-trees are particularly good for maintaining databases on secondary(disk) storage</p><h4 id="Binary-search-tree-property"><a href="#Binary-search-tree-property" class="headerlink" title="Binary-search-tree property"></a>Binary-search-tree property</h4><p> If y is a node of left subtree of x, then $y.key \le x.key$.</p><p> If x is a node of right subtree of x, then $y.key \ge x.key$</p><h4 id="tree-walk"><a href="#tree-walk" class="headerlink" title="tree walk"></a>tree walk</h4><p>inorder tree walk   Inorder-tree-walk(T.root)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">INORDER-TREE-WALK(x)</span><br><span class="line">if x!=NIL</span><br><span class="line">INORDER-TREE-WALK(x.left)</span><br><span class="line">print x.key</span><br><span class="line">INORDER-TREE-WALK(x.right)</span><br></pre></td></tr></table></figure><p>如何证明其正确性<br>效率$\Theta(n) 用master直观 用替代法证明$</p><p>preorder tree walk</p><p>postorder tree walk.</p><h4 id="Tree-Search-and-Tree-Insert"><a href="#Tree-Search-and-Tree-Insert" class="headerlink" title="Tree-Search and Tree-Insert"></a>Tree-Search and Tree-Insert</h4><h4 id="Minimum-and-maximum"><a href="#Minimum-and-maximum" class="headerlink" title="Minimum and maximum"></a>Minimum and maximum</h4><h4 id="Successor-and-Predecessor"><a href="#Successor-and-Predecessor" class="headerlink" title="Successor and Predecessor"></a>Successor and Predecessor</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Tree-Successor(x)</span><br><span class="line">if x.right!=NIL</span><br><span class="line">return Tree-Minimum(x.right)</span><br><span class="line">y=x.p</span><br><span class="line">while y!=NIL &amp;&amp; x=y.right</span><br><span class="line">x=y</span><br><span class="line">y=x.p</span><br><span class="line">return y</span><br></pre></td></tr></table></figure><h4 id="Insertion-and-Deletion"><a href="#Insertion-and-Deletion" class="headerlink" title="Insertion and Deletion"></a>Insertion and Deletion</h4><p>插入找空位就可</p><p>删除分三种情况：没有孩子(直接删除)、有一个孩子(直接登基)、有两个孩子(找后继)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Transplant(T,u,v)</span><br><span class="line">if u.p==NIL</span><br><span class="line">T.root=v</span><br><span class="line">elseif u==u.p.left</span><br><span class="line">u.p.left=v</span><br><span class="line">else</span><br><span class="line">u.p.right=v</span><br><span class="line">if v!=NIL</span><br><span class="line">v.p=u.p</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Tree-Delete(T,z)</span><br><span class="line">if z.left==NIL</span><br><span class="line">Transplant(T,z,z.right)</span><br><span class="line">elseif z.right==NIL</span><br><span class="line">Transplant(T,z,z.left)</span><br><span class="line">else</span><br><span class="line">y=Tree-Minimum(z.right)</span><br><span class="line">if y.p!=z</span><br><span class="line">Transplant(T,y,y.right)</span><br><span class="line">y.right=z.right</span><br><span class="line">y.right.p=y</span><br><span class="line">Transplant(T,z,y)</span><br><span class="line">y.left=z.left</span><br><span class="line">y.left.p=y</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### Red Black Tree</span><br><span class="line"></span><br><span class="line">something</span><br><span class="line"></span><br><span class="line">#### red-black properties</span><br><span class="line"></span><br><span class="line">1. Every node is either red or black</span><br><span class="line">2. The root is black</span><br><span class="line">3. Every leaf(NIL) is black</span><br><span class="line">4. If a node is red, then both its children are black.</span><br><span class="line">5. For each node, all simple paths from the node to descendant leaves contain the same number of black nodes.</span><br><span class="line"></span><br><span class="line">A red-black tree with n internal nodes has height at most $2\lg&#123;n+1&#125;$</span><br><span class="line"></span><br><span class="line">#### Rotations</span><br></pre></td></tr></table></figure><p>Left-Rotate(T,x)<br>y=x.right<br>x.right=y.left<br>if y.left!=T.nil<br>    y.left.p=x<br>y.p=x.p<br>if x.p==T.nil<br>    T.root=y<br>elseif x==x.p.left<br>    x.p.left=y<br>else<br>    x.p.right=y<br>y.left=x<br>x.p=y<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">In every n-node binary search tree, there are exactly n-1 possible rotations.</span><br><span class="line"></span><br><span class="line">#### Insertion</span><br></pre></td></tr></table></figure></p><p>RB-INSERT(T,z)<br>y=T.nil<br>x=T.root<br>while x!=T.nil<br>    y=x<br>    if z.key&lt;x.key<br>        x=x.left<br>    else x=x.right<br>z.p=y<br>if y==T.nil<br>    T.root=z<br>elseif z.key&lt;y.key<br>    y.left=z<br>else y.right=z<br>z.left=T.nil<br>z.right=T.nil<br>z.color = RED<br>RB-INSERT-FIXUP(T,z)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>RB-INSERT-FIXUP(T,z)<br>while z.p.color==RED<br>    if z.p==z.p.p.left<br>        y=z.p.p.right<br>        if y.color==RED<br>            z.p.color=BLACK                //case1<br>            y.color=BLACK                    //case1<br>            z.p.p.color=RED                //case1<br>            z=z.p.p                        //case1<br>        else if z==z.p.right<br>                z=z.p                        //case2<br>                LEFT-ROTATE(T,z)            //case2<br>            z.p.color=BLACK                //case3<br>            z.p.p.color=RED                //case3<br>            RIGHT-ROTATE(T,z.p.p)        //case3<br>        else (same as then clause with “right” and “left” exchanged)<br>T.root.color=BLACK<br>```</p><h2 id="2-14-B树"><a href="#2-14-B树" class="headerlink" title="2-14 B树"></a>2-14 B树</h2><h2 id="Appendix-C"><a href="#Appendix-C" class="headerlink" title="Appendix C"></a>Appendix C</h2><p>Binomial bounds: C_n^k &gt;= (n/k)^k</p><p>对于自然数集N: <code>E[X]=\sum_{i=0}^{\infty} i*Pr{X=i} =\sum_{i=0}^{\infty} i*(Pr{X&gt;=i}-Pr{X&gt;=i+1}) = \sum_{i=1}^{\infty} Pr{X&gt;=i}</code></p><p>Var[X]=E[X^2]-E^2[X]</p><p>Var[aX]=a^2Var[X]</p><p>Var[X+Y]=Var[X]+Var[Y]</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;2018春问题求解笔记&quot;&gt;&lt;a href=&quot;#2018春问题求解笔记&quot; class=&quot;headerlink&quot; title=&quot;2018春问题求解笔记&quot;&gt;&lt;/a&gt;2018春问题求解笔记&lt;/h1&gt;&lt;h2 id=&quot;2-1-算法正确性-2018-3-7&quot;&gt;&lt;a href=&quot;#2-1-算法正确性-2018-3-7&quot; class=&quot;headerlink&quot; title=&quot;2-1 算法正确性(2018.3.7)&quot;&gt;&lt;/a&gt;2-1 算法正确性(2018.3.7)&lt;/h2&gt;&lt;p&gt;程序和算法不等同&lt;/p&gt;
&lt;p&gt;算法正确性是基础&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>数字逻辑电路笔记</title>
    <link href="http://yoursite.com/2018/07/01/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/07/01/数字逻辑电路笔记/</id>
    <published>2018-07-01T04:55:38.000Z</published>
    <updated>2018-07-01T04:57:25.983Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数字逻辑电路笔记"><a href="#数字逻辑电路笔记" class="headerlink" title="数字逻辑电路笔记"></a>数字逻辑电路笔记</h1><p>给定输入 给出输出 用布尔逻辑实现</p><p>晶体管的开关特性是数字电路研究的重点。</p><p>数字逻辑中考虑电路模拟的特性，如时延问题。</p><p>数字设计中一些层次问题</p> <a id="more"></a><p>数字电路特性：</p><ul><li>稳定性好</li><li>速度快</li><li>集成度高且成本低</li><li>设计容易、功能灵活</li><li>可编程性</li></ul><p>模数转换：取样、量化 数模转换：合成</p><p>传输门？？？</p><p>摩尔定律即电子定律：集成电路的集成度每18个月翻一番（1965年）</p><p>超摩尔定律即光子定律：光纤传输的数据总量每9个月翻一番；</p><p>迈特卡夫Metcalfe定律：网络的价值与联网设备数（用户数）的平方关系成正比</p><p>时序逻辑 组合逻辑</p><h2 id="数制与编码"><a href="#数制与编码" class="headerlink" title="数制与编码"></a>数制与编码</h2><p>按位计数制(positional number system):加权</p><p>二进制八进制互转，二进制十六进制互转。</p><p>十进制转任意进制，任意进制转十进制。</p><p>除以基数去余法：倒序。 乘基数取整法：正序(到fraction为0，或达到最大有效位数)</p><h3 id="通用转换过程："><a href="#通用转换过程：" class="headerlink" title="通用转换过程："></a>通用转换过程：</h3><h4 id="算法1："><a href="#算法1：" class="headerlink" title="算法1："></a>算法1：</h4><p>A进制数N转换成B进制数。</p><ul><li>(a) 用B进制数取代展开序列中的数字，并计算结果，或</li><li>(b) 基于A进制运算，计算B基数的乘除法。</li></ul><h4 id="算法2："><a href="#算法2：" class="headerlink" title="算法2："></a>算法2：</h4><p>A进制数N转换成B进制数。</p><ul><li>(a) 用序列替代法将A进制数转换成10进制。</li><li>(b) 用基数乘除法，将10进制数转换成B进制数。</li></ul><p>各种数制之间的表达能力不一样，是否存在最强表达能力的数制？</p><p>符号位+数值的表示法，正数和负数个数相同，0有两个表示，但电路设计复杂。但一旦做了加法器，减法器就不用再做了。</p><p><strong>补码等于反码加1的证明</strong>：写成 反码=补码-1</p><p>补码 两次取补仍为原数 减去或取反加1 最高位权为负 符号扩展：将符号位扩展(如果是0，全补0，如果是1，全补1) 如果减小位数 从左边减，丢弃的位要与符号位相同。正数表示。</p><p>补码下： -2-(-8) 还是成立的  会不会判溢出？？？？</p><p>反码 ：    取反。对称和易于求反。</p><p>余码: 除符号位相反，对任何数，补码和余码两种表示法中的其他位都是一样的(仅适用于偏离为$2^{m-1}$的情况)。余码表示常用在浮点数系统中。余码表示用在浮点数系统中指数的表示。</p><h3 id="二进制补码的加法与减法"><a href="#二进制补码的加法与减法" class="headerlink" title="二进制补码的加法与减法"></a>二进制补码的加法与减法</h3><h4 id="加法："><a href="#加法：" class="headerlink" title="加法："></a>加法：</h4><p>忽略超过MSB的进位，只要不超过计数系统的范围，该结果就总是正确的和。</p><p>加法中有简便的规则判断溢出：如果加数的符号相同，而和的符号与加数的符号不同，则有加法的溢出。 不同符号的加数不会溢出</p><h4 id="减法："><a href="#减法：" class="headerlink" title="减法："></a>减法：</h4><p>减数取反，初始进位为1</p><h3 id="二进制反码的加法和减法"><a href="#二进制反码的加法和减法" class="headerlink" title="二进制反码的加法和减法"></a>二进制反码的加法和减法</h3><p>计数经过$1111_2$时要额外多加一个1. 循环进位(end-around carry).即符号位有进位则+1</p><p>溢出判断：异号相加不溢出，同号相加结果异号则溢出。或进位和符号位不一致。</p><h3 id="二进制补码的乘法"><a href="#二进制补码的乘法" class="headerlink" title="二进制补码的乘法"></a>二进制补码的乘法</h3><p>要在每一步做符号位扩展，最高位的权为负</p><h3 id="二进制补码的除法？？？"><a href="#二进制补码的除法？？？" class="headerlink" title="二进制补码的除法？？？"></a>二进制补码的除法？？？</h3><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><p>{对象集，码字集，编码方案}</p><h3 id="十进制数的二进制编码"><a href="#十进制数的二进制编码" class="headerlink" title="十进制数的二进制编码"></a>十进制数的二进制编码</h3><p>BCD编码又称8421码</p><p>加法需要修正：超过1001需要修正 要加6</p><p>2421码，是自反码。</p><p>余3码，也是自反码：BCD码+0011</p><p>二五混合码(biquinary code)</p><p>10中取1码(1-out-of-10 code)</p><h3 id="格雷码-Gray-code"><a href="#格雷码-Gray-code" class="headerlink" title="格雷码(Gray code)"></a>格雷码(Gray code)</h3><p>1) 镜像法: 1位格雷码有2个码字：0  1,<br>N+1位格雷码中的前$2^N$个码字是N位格雷码顺序排列，且前面加0。<br>N+1位格雷码中的后$2^N$个码字是N位格雷码逆序排列，且前面加1</p><p>2）相邻异或法: N位二进制数字从右向左，从0到n-1编号；<br>如果第i位和第i+1位相同，则对应格雷码的第i位为0，否则为1。</p><p>编码:{对象集，码字集，编码方案}</p><h3 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h3><p>ASCII</p><h3 id="动作、条件和状态的编码"><a href="#动作、条件和状态的编码" class="headerlink" title="动作、条件和状态的编码"></a>动作、条件和状态的编码</h3><p>n中取1码，n中取m码</p><h3 id="n维体与距离"><a href="#n维体与距离" class="headerlink" title="n维体与距离"></a>n维体与距离</h3><p>寻找Gray code即寻找一条遍历所有点的路径。</p><p>汉明距离(Hamming distance)</p><p>n维体的m维子集(m-subcube)</p><h3 id="检错码和纠错码"><a href="#检错码和纠错码" class="headerlink" title="检错码和纠错码"></a>检错码和纠错码</h3><p>差错模式(error model) 独立差错模式(independent error model):单一物理故障只影响单一的数据位。</p><h4 id="检错码-error-detecting-code"><a href="#检错码-error-detecting-code" class="headerlink" title="检错码(error-detecting code)"></a>检错码(error-detecting code)</h4><p>最小汉明距离$ge$2</p><p>奇偶校验位(parity bit)</p><h4 id="纠错码与多重检错码"><a href="#纠错码与多重检错码" class="headerlink" title="纠错码与多重检错码"></a>纠错码与多重检错码</h4><p>待看课件 不理解 ？？？<br>纠错准则？</p><h4 id="汉明码"><a href="#汉明码" class="headerlink" title="汉明码"></a>汉明码</h4><p>纠1位错 判两位错</p><p>位置是2的幂的那些位都是校验位，其余为信息位。校验矩阵(parity-check matrix) </p><p>偶校验</p><p>最小距离为3的编码</p><p>对于任意i值，可产生2^i-1位的编码，其中包含i个校验位，2^i-i-1个信息位。</p><p>信息位长度D增加时，检验位长度P增长缓慢: 2^P &gt;= P+D+1</p><h4 id="循环冗余校验码-cyclic-redundancy-check-CRC"><a href="#循环冗余校验码-cyclic-redundancy-check-CRC" class="headerlink" title="循环冗余校验码(cyclic-redundancy-check,CRC)"></a>循环冗余校验码(cyclic-redundancy-check,CRC)</h4><p>两个重要的应用是磁盘驱动器和数据网络</p><h4 id="二维码-two-dimensional-code"><a href="#二维码-two-dimensional-code" class="headerlink" title="二维码(two-dimensional code)"></a>二维码(two-dimensional code)</h4><p>一个重要的应用是用在RAID储存系统中。RAID表示(redundant array of inexpensive disks)</p><p>BCD加法减法</p><p>每个位元出现在传输线上的实际信号格式取决于线路码（line code）。</p><h4 id="校验和码"><a href="#校验和码" class="headerlink" title="校验和码"></a>校验和码</h4><h3 id="补充：变长编码-待拓展？？？"><a href="#补充：变长编码-待拓展？？？" class="headerlink" title="补充：变长编码 待拓展？？？"></a>补充：变长编码 待拓展？？？</h3><p>原理：基于概率分布特性,采用可变字长编码.</p><p>Huffman编码：</p><ul><li>每个编码均非其它码的前缀，因此唯一可译</li><li>简单,易实现</li><li>编码效率较高(但还不是最高的，参考JPEG)</li></ul><h2 id="组合逻辑设计原理"><a href="#组合逻辑设计原理" class="headerlink" title="组合逻辑设计原理"></a>组合逻辑设计原理</h2><h3 id="布尔代数"><a href="#布尔代数" class="headerlink" title="布尔代数"></a>布尔代数</h3><p>一致律(冗余项): XY+X’Z+YZ=XY+X’Z  (X+Y)(X’+Z)(Y+Z)=(X+Y)(X’+Z)</p><p>1.代入定理：所谓代入定理，是指在逻辑等式中任何一个变量A，都可以用任意逻辑表达式代入，则等式仍然成立。</p><p>2.反演定理：所谓反演定理，是指对于任意一个逻辑式Y，若将其中所有的“·”与“+”互换，“0”和“1”互换，原变量与反变量互换，则得到的结果就是原函数的反函数  Y’  。</p><p>3.对偶定理： 若两逻辑式相等，则它们的对偶式也相等，这就是对偶定理。所谓对偶式，即：对于任何一个逻辑式Y，若将其中的“·”与“+”互换，“0”和“1”互换，则得到Y的对偶式YD，或者Y与YD互为对偶式。？？？？？？</p><p>逻辑函数化简基本方法：</p><ul><li>并项法: AB+A’B=B</li><li>吸收法: AB+B=B</li><li>消去法: A+A’B=A+B</li><li>配项法: AB+A’C+BC=AB+A’C</li><li>摩根定理</li></ul><h3 id="组合逻辑"><a href="#组合逻辑" class="headerlink" title="组合逻辑"></a>组合逻辑</h3><p>逻辑电路分为两大类：“组合的”和“时序的”. 组合逻辑电路(combinational logic circuit) 和 时序逻辑电路(sequential logic circuit)。</p><p>电路的分析和设计</p><p>正逻辑和负逻辑</p><p>完备归纳法(perfect induction)</p><p>一致性定理有两个重要的应用:在组合逻辑电路中，它可以用来去掉某些定时冒险;也是用于寻找主蕴涵项的迭代一致法的基础。</p><p>与非=非或,可以用CMOS直接实现</p><p>对偶性原理：可以运用对偶性原理证明广义德摩根定理。（待加深 P135）</p><p>逻辑函数的标准表示法：</p><ul><li>文字(literal): 一个自变量或反变量</li><li>乘积项(product term):单个文字或2个以上文字的逻辑积</li><li>“积之和”表达式(sum-of-products expression):是乘积项的逻辑和</li><li>求和项(sum term):单个文字或2个以上文字的逻辑和</li><li>“和之积”表达式(product-of-sum expression):求和项的逻辑积</li><li>标准项(normal term):是一个乘积项或求和项，每个变量当且仅当只出现一次</li><li>n变量最小项(minterm):是具有n个文字的标准乘积项</li><li>n变量最大项(maxterm):是具有n个文字的标准求和项</li><li>主蕴含项</li><li>质主蕴含项</li><li>奇异1：只被单一主蕴含项覆盖的输入组合</li></ul><p>和之积表达式？？？？</p><p>相同变量相同编号的最小项和最大项互为反函数。</p><p>时延问题</p><p>多类门技术中，类似与非门和或非门那样的带取反的门比不取反的门要快。</p><p>证明反演定理，曾考过？？？？ 反演定理是否是对偶定理的一个推论</p><p>ASIC设计和PLD设计中，化简都很重要</p><p>考试可能栽在配项法</p><p>电路分析最后一步：通常情况下描述电路的功能：投票电路，校验电路，加法器</p><p>设计：一般</p><h4 id="卡诺图化简："><a href="#卡诺图化简：" class="headerlink" title="卡诺图化简："></a>卡诺图化简：</h4><ul><li>如何化简逻辑函数——最小化： (主蕴涵项)定理：最简“积之和”是主蕴涵项之和(为什么不是质主蕴含项的和)</li><li>蕴涵项： 任何积项都称为蕴涵项，与卡诺图中的圈对应</li><li>主蕴含项：定义若逻辑函数的积项P再也不能同其它积项合并以组成变量个数更少的积项，则称P为主蕴涵项，对应卡诺图中最大的圈</li><li>质主蕴涵项： 定义：不能被其它蕴涵项代替的主蕴涵项；至少包含一个不能被其它任何主蕴涵项所覆盖的最小项</li><li>覆盖：若逻辑函数的所有最小项被1组蕴涵项所包含，则该组蕴涵项称为函数的1个覆盖</li><li>最小覆盖： 是1个包含最少主蕴涵项和最少符号数的覆盖</li></ul><p>奎因——穆克鲁斯基算法(Quine-McCluskey algorithm)</p><h3 id="定时冒险"><a href="#定时冒险" class="headerlink" title="定时冒险"></a>定时冒险</h3><p>一个信号，以两种形式出现在输出端，因传输时间不同，使二者某段时间不具有相应逻辑关系，造成错误输出，称为冒险或险象（ Hazard ）</p><p>竞争：门电路的两个输入端同时向相反的逻辑电平跳变。</p><h4 id="静态冒险"><a href="#静态冒险" class="headerlink" title="静态冒险"></a>静态冒险</h4><p>静态冒险(Static hazard) ：一个周期内，输出只出现一次瞬时改变。</p><p>静态-1型冒险：在输出1的过程中，出现0尖峰。通常产生于最小项生成电路中</p><p>静态-0型冒险：通常产生于最大项生成电路中</p><p>利用卡诺图发现静态冒险：卡诺图检测：在卡诺图中存在两个质主蕴涵项相切，当从一个质主蕴涵项向另一个转换时，一旦有传递延迟，则产生险态。</p><p>消除冒险：添加一致项consensus:增加新的质蕴涵项，覆盖相切的两个质蕴涵。</p><p>动态冒险：一个输入转变一次而引起输出变化多次。由于多个不同的延迟路径所产生。</p><p>2、3、4变量的卡诺图：不断翻折    </p><h3 id="无关项处理"><a href="#无关项处理" class="headerlink" title="无关项处理"></a>无关项处理</h3><p>禁止态检测电路通常是必须的, 若不影响电路运行,此时可不必刻意区分禁止态和其它状态，可以处理成0，也可以处理成1，按照化简的需要酌情确定。</p><h3 id="QM算法"><a href="#QM算法" class="headerlink" title="QM算法"></a>QM算法</h3><h2 id="组合逻辑设计实践"><a href="#组合逻辑设计实践" class="headerlink" title="组合逻辑设计实践"></a>组合逻辑设计实践</h2><p>有时要求输入变量只能用原变量形式，可作相应的变换</p><h3 id="设计文档"><a href="#设计文档" class="headerlink" title="设计文档"></a>设计文档</h3><p>设计文档是项目设计正确、可维护的重要基础。</p><p>设计文档可以是综合性的单文档描述，也可以是分列的多文档描述形态。</p><ul><li>规格说明书：准确描述电路或系统的输入、输出及功能。主要是外部特性的描述。</li><li>方框图：系统主要功能模块及其基本互连的非正式图示描述。展示系统的输入、输出，功能模块、内部数据通路和重要的控制信号</li><li>原理图：系统的电气元件、元件间互连和构建系统所需的全部细节的正式说明，包括IC类型、参考标志符和引脚编号。（和常说的逻辑图不同）能够生成生产用的材料清单。</li><li>定时图：说明各种逻辑信号的值随时间的变化情况。关键信号之间的因果延迟。</li><li>结构化逻辑器件描述：描述PLD、FPGA或者ASIC的内部功能设计。通常用HDL描述；也可以用逻辑表达式、状态表、状态图等形式。</li><li>电路描述：电路功能设计的描述性文本，和其它文档一起解释电路的工作原理。应该包括设计的假设、限制等。</li></ul><p>方框图：</p><ul><li>能展示最重要的系统元素以及工作原理。</li><li>每个方框图不要超过1页。</li><li>大型系统可以另附页描述子系统。</li><li>重要的控制信号和总线要命名。</li><li>明确表明控制流和数据流。</li><li>不要包含细节。</li></ul><p>圏到圈逻辑设计(目的：使用包含有效电平标识的逻辑符号或信号命名方式使得逻辑电路更容易理解。)</p><h3 id="可编程逻辑器件"><a href="#可编程逻辑器件" class="headerlink" title="可编程逻辑器件"></a>可编程逻辑器件</h3><p>PLA:</p><p>PAL:或门阵列固定、与门阵列可编程、双向输入/输出引脚。</p><p>GAL通用阵列逻辑：GAL16V8是一个时序逻辑器件，但可以编程设置为组合逻辑器件。此时，其结构和PAL16L8类似。多了一个输出极性控制的异或门。</p><p>CPLD复杂可编程逻辑器件：是将多个PLD集成到单个芯片上，并提供可编程的互连和输入/输出结构。可以把CPLD的基本结构看成由可编程逻辑阵列（LAB）、可编程I/O控制模块和可编程内部连线（PIA）等三部分组成。</p><h3 id="译码器"><a href="#译码器" class="headerlink" title="译码器"></a>译码器</h3><p>译码器的输出编码通常比其输入编码位数多</p><p>真值表</p><p>逻辑图</p><p>上低下高</p><p>2-4译码器 3-8译码器 级联二进制译码器：4-16译码器 5-32译码器</p><p>译码器的级联</p><p>七段显示译码器</p><p>半导体显示：LED 液晶显示：LCD</p><h3 id="编码器"><a href="#编码器" class="headerlink" title="编码器"></a>编码器</h3><p>器件的输出编码比其输入编码位数少</p><p>8-3编码器</p><p>3位二进制优先编码器：允许几个信号同时输入，但只对优先级别最高<br>的进行编码</p><h3 id="三态器件"><a href="#三态器件" class="headerlink" title="三态器件"></a>三态器件</h3><p>三态缓冲器</p><p>三态器件允许多个信号源共享单个线路</p><h4 id="三态缓冲器"><a href="#三态缓冲器" class="headerlink" title="三态缓冲器"></a>三态缓冲器</h4><p>三态门进入和离开高阻态的延迟时间不同，会造成输出线路上值的混乱，造成同时驱动的冲突现象。解决的方法：设计控制逻辑，保证一段截止时间（dead time），这段时间不应该有任何器件驱动同线。</p><h3 id="数据选择器-多路选择器"><a href="#数据选择器-多路选择器" class="headerlink" title="数据选择器(多路选择器)"></a>数据选择器(多路选择器)</h3><p>一种多路输入，单路输出的逻辑构件。</p><p>2-1 multiplexer</p><p>n个输入变量 需要m=log n 个控制信号</p><p>多路选择器除完成对多路数据进行选择的基本功能外，在逻辑设计中主要用来实现各种逻辑函数功能。用多路选择器实现分时多路转换电路。(将并行输入的数据转换成串行输出)。</p><p>方法I：用具有n个选择变量的MUX实现n个变量的函数。</p><p>方法Ⅱ：用具有n-1个选择控制变量的MUX实现n个变量函数功能：即从函数的n个变量中任n-1个作为MUX的选择控制变量，并根据所选定的选择控制变量将函数变换成F=∑miDi的形式，以确定各数据输入Di。假定剩余变量为X，则Di的取值只可能是0、1、X或X’四者之一。</p><p>把并行处理的数据放在Di端上。在地址端上，周期性的循环加载 00-&gt;01-&gt;10-&gt;11  如此，在输出端上，顺序地送出原先并行的数据。</p><h3 id="数据分配器-Demultiplexers"><a href="#数据分配器-Demultiplexers" class="headerlink" title="数据分配器(Demultiplexers)"></a>数据分配器(Demultiplexers)</h3><p>其功能和多路数据选择器相反。是一种单路输入，多路输出的逻辑构件。从哪一端输出依赖于当时的地址控制端输入。</p><p>【例】利用DMUX和MUX设计一个实现8路数据传输的逻辑电路。 </p><p>多路分配器常与多路选择器联用，以实现多通道数据分时传送。通常在发送端由MUX将各路数据分时送上公共传输线(总线)，接收端再由DEMUX将公共线上的数据适时分配到相应的输出端。</p><p>大扇出处理：每个输出端增加一个三态缓冲</p><p>扇入系数大会有什么影响？</p><h3 id="校验电路"><a href="#校验电路" class="headerlink" title="校验电路"></a>校验电路</h3><p>异或门和异或非门 用与或非三个门或者用与非门实现</p><p>奇偶校验电路</p><p>奇偶校验器件74x280:9个输入 2个输出</p><p>chapter6-3 ppt 第七张重点</p><p>奇偶校验应用：7位海明码纠错电路。</p><h3 id="比较器"><a href="#比较器" class="headerlink" title="比较器"></a>比较器</h3><p>两种类型：比较器  大小比较器</p><p>大小比较器</p><p>内部电路图</p><p>级联</p><p>74x682 只有相等和大于输出  扩展判断输出</p><h3 id="加法器、减法器和ALU"><a href="#加法器、减法器和ALU" class="headerlink" title="加法器、减法器和ALU"></a>加法器、减法器和ALU</h3><p>ALU:可以根据操作码完成加法、减法等运算功能的电路。</p><p>行波进位加法器 属于迭代电路 延迟： t add = t XYCout + (n-2) tCinCout +tCinS</p><p>用加法器实现减法器</p><p>chapter6-3 第33张ppt存疑</p><p>chapter6-3 第35张ppt存疑 如何化简</p><p>74x283(4位先行进位加法器) ’283的进位信号c0到c4的延迟很短相当于2个反相门，可以级联扩展计算位数，组间串行进位加法器</p><p>74x181 4位ALU</p><p>组间先行进位：不同于组间串行进位，先行进位信号直接由输入的操作数决定，没有组间串行的进位信号。</p><h3 id="组合乘法器"><a href="#组合乘法器" class="headerlink" title="组合乘法器"></a>组合乘法器</h3><p>移位-累加算法的电路实现：最坏20级延迟 延迟估计  进位保留加法(14级延迟)？？？？</p><h2 id="时序逻辑"><a href="#时序逻辑" class="headerlink" title="时序逻辑"></a>时序逻辑</h2><p>时序电路的输出不仅取决于当前的输入，而且取决于过去的输入序列（状态）。</p><p>状态：是一个状态变量集合。包含了在当前输入的基础上预测当前输出的所有的历史信息。</p><p>时序电路的状态个数有限：有限状态机</p><p>有效电平：通常在时钟的触发沿内状态发生改变。</p><p>时钟周期tper、时钟频率、时钟触发沿、占空比</p><h3 id="时序电路的类型"><a href="#时序电路的类型" class="headerlink" title="时序电路的类型"></a>时序电路的类型</h3><ul><li>反馈时序电路：采用普通门电路和反馈回路来实现逻辑电路中的记忆能力，由此构成时序逻辑电路</li><li>时钟同步时序电路：也采用逻辑构件来构建电路，但输入由统一的时钟信号控制。</li><li>其它类型：通用基本型、多脉冲型等</li></ul><h3 id="双稳态器件"><a href="#双稳态器件" class="headerlink" title="双稳态器件"></a>双稳态器件</h3><p>所谓的双稳态元件（或者电路），是指电路有两个稳定的状态，即置位状态和复位状态。Q为1的状态称为置位状态，而Q为0的状态称为复位状态。</p><p>双稳态电路的内在特性(inherent)</p><ul><li>2 稳定点（stable points）</li><li>1亚稳定点（metastable point）</li></ul><p>亚稳态，非有效的逻辑信号，但满足回路方程</p><p>任何时序电路都存在亚稳态现象</p><ul><li>开机：存在亚稳态</li><li>工作：外部激励必须满足最短时间要求, 才能生效, 否则…</li></ul><h3 id="单稳态"><a href="#单稳态" class="headerlink" title="单稳态"></a>单稳态</h3><p>to be or not to be</p><h3 id="锁存器与触发器"><a href="#锁存器与触发器" class="headerlink" title="锁存器与触发器"></a>锁存器与触发器</h3><ul><li>时序电路的基本构件。</li><li>都是双稳态元件。</li><li>锁存器(Latch)：连续地监测其输入，并且独立于时钟信号而在任何时候都可以改变输出</li><li>触发器(Flip-Flop)：连续地监测输入信号，并只在时钟信号所确定的时刻改变其输出</li></ul><h4 id="RS锁存器"><a href="#RS锁存器" class="headerlink" title="RS锁存器"></a>RS锁存器</h4><p>S置位 R 复位  S=R=1时,Q=QN=0   S=R=0时,Q=last Q, QN=last QN  R和S不能同时取消，否则会导致震荡状态或亚稳态</p><p>输入信号宽度必须大于最小脉冲宽度</p><h4 id="R’-S’锁存器"><a href="#R’-S’锁存器" class="headerlink" title="R’-S’锁存器"></a>R’-S’锁存器</h4><p>R非S非锁存器：低态有效的置位和复位，可以用与非门实现。</p><h4 id="具有使能端的RS锁存器"><a href="#具有使能端的RS锁存器" class="headerlink" title="具有使能端的RS锁存器"></a>具有使能端的RS锁存器</h4><p>S-R Latch with Enable, 带使能端的RS锁存器(RS闩锁)<br>受使能信号控制，C为写入条件或指令</p><h4 id="D锁存器"><a href="#D锁存器" class="headerlink" title="D锁存器"></a>D锁存器</h4><p>数据经非门产生一对互补信号，D型锁存器(D Latch)</p><p>建立时间(Set-up time) 保持时间(Hold time)</p><h4 id="如何实现边沿触发"><a href="#如何实现边沿触发" class="headerlink" title="如何实现边沿触发"></a>如何实现边沿触发</h4><p>用 to be or not to be 电路</p><h4 id="边沿触发式-Edge-Triggered-触发器"><a href="#边沿触发式-Edge-Triggered-触发器" class="headerlink" title="边沿触发式(Edge Triggered)触发器"></a>边沿触发式(Edge Triggered)触发器</h4><p>只在时钟信号的上升沿或者下降沿改变状态</p><h4 id="主从D触发器-存疑"><a href="#主从D触发器-存疑" class="headerlink" title="主从D触发器  存疑"></a>主从D触发器  存疑</h4><p>第1个锁存器称为主(master)锁存器，第2个称为从(slave)锁存器。</p><p>传播延迟 (from CLK) 建立时间 (D before CLK) 保持时间 (D after CLK)</p><p>具有预置和清零端的正边沿D触发器</p><p>具有使能端的边沿触发式D触发器</p><h4 id="扫描触发器"><a href="#扫描触发器" class="headerlink" title="扫描触发器"></a>扫描触发器</h4><p>扫描触发器除了D输入端以外，还有两个输入端。</p><p>TI即Test Input，用来输入测试序列（测试向量）。</p><p>TE即Test Enable，用来控制触发器工作状态。</p><h4 id="主从式触发器"><a href="#主从式触发器" class="headerlink" title="主从式触发器"></a>主从式触发器</h4><ul><li>在时钟脉冲信号高电平期间数据进入触发器，在下降沿输出反映输入的变化</li><li>主从式触发器也称为脉冲触发型触发器(Pulse Triggered Flip-flops)</li><li>为了使得输出能正确地反映输入的变化，要求在时钟脉冲信号为高期间，输入不发生变化。</li><li>其特点是数据在第一个边沿锁入触发器，第二个边沿后数据出现在输出端。</li><li>主从式触发器基本上已经被边沿触发式触发器所取代。</li></ul><h4 id="主从式JK触发器"><a href="#主从式JK触发器" class="headerlink" title="主从式JK触发器"></a>主从式JK触发器</h4><p>同时有效则翻转</p><p>在触发脉冲的后沿，JK输入的状态变化可能无效。 使用中，尽量保持JK稳定</p><p>0钳位 1钳位????</p><h4 id="边沿触发式JK触发器"><a href="#边沿触发式JK触发器" class="headerlink" title="边沿触发式JK触发器"></a>边沿触发式JK触发器</h4><p>解决主从JK触发器中1和0钳位的问题。</p><p>在上升沿时采样输入信号。</p><h4 id="T触发器"><a href="#T触发器" class="headerlink" title="T触发器"></a>T触发器</h4><ul><li>T触发器：在每一个时钟脉冲的有效边沿都会改变状态。</li><li>常用在计数器和分频器。</li><li>具有使能端的T触发器</li></ul><h4 id="维持-阻塞D触发器"><a href="#维持-阻塞D触发器" class="headerlink" title="维持-阻塞D触发器"></a>维持-阻塞D触发器</h4><h4 id="锁存器和触发器的描述"><a href="#锁存器和触发器的描述" class="headerlink" title="锁存器和触发器的描述"></a>锁存器和触发器的描述</h4><h5 id="特征方程"><a href="#特征方程" class="headerlink" title="特征方程"></a>特征方程</h5><p>SR锁存器： Q* = S + R’Q</p><p>JK触发器： Q* = JQ’ + K’Q</p><p>T触发器： Q* = Q’</p><p>D触发器： Q* = D</p><h3 id="状态转移图"><a href="#状态转移图" class="headerlink" title="状态转移图"></a>状态转移图</h3><ul><li>用来描述电路状态，也可以对现实世界中任何有状态的事物进行建模</li><li>列举出该事物所有可能的状态，每个状态用一个圈表示</li><li>状态之间可以相互转换。状态转换用带箭头的弧线表示。</li><li>在弧线上标明状态发生变化的条件（即系统的输入）。也可以标明该状态转移导致的结果（输出）。</li></ul><h3 id="时钟控制时序逻辑电路分析"><a href="#时钟控制时序逻辑电路分析" class="headerlink" title="时钟控制时序逻辑电路分析"></a>时钟控制时序逻辑电路分析</h3><p>Sequential-Circuit：组合逻辑+记忆电路</p><ul><li>同步时序电路（Synchronous Sequential Logic）</li><li>异步时序电路（Asynchronous Sequential Logic）</li></ul><p>Synchronous Sequential Logic</p><ul><li>统一时钟驱动，触发时刻更新记忆电路状态</li><li>状态转移图描述</li><li>设计方法、工具相对规范成熟</li></ul><p>Asynchronous Sequential Logic</p><ul><li>状态变化时刻不一致</li><li>状态转移图描述</li><li>异步电路多用在接口电路设计方面</li></ul><h4 id="同步时序电路的类型"><a href="#同步时序电路的类型" class="headerlink" title="同步时序电路的类型"></a>同步时序电路的类型</h4><p>按照输出方程的不同，分为：</p><ul><li>Mealy型电路(Mealy State Machine)： 某时刻输出是该电路当前时刻输入和当前状态的函数</li><li>Moore型电路(Moore State Machine)：某时刻输出仅是该电路当前状态的函数，与当前时刻的输入无关，如某些计数器</li></ul><h4 id="状态机分析的步骤"><a href="#状态机分析的步骤" class="headerlink" title="状态机分析的步骤"></a>状态机分析的步骤</h4><ol><li>确定下一状态函数F和输出函数G</li><li>用F和G构造状态/输出表(state/output table)，列出所有当前状态和输入的组合，指定电路的下一状态和输出</li><li>画出状态图（state diagram）。</li><li>描述电路的功能。</li></ol><h4 id="状态图"><a href="#状态图" class="headerlink" title="状态图"></a>状态图</h4><p>State Diagram(状态图)中，离开某个特定状态的所有转移条件，满足:</p><ul><li>Mutually Exclusive(互斥性)，每种输入组合都有唯一的下一状态。否则相同输入组合对应不同的下一状态(二义性)</li><li>All Inclusion(完备性)，所有输入组合都有确定的下一状态(有时需要根据设计需求，在不违背题意的前提下作出合理安排)</li><li>称为完全确定的时序电路</li></ul><h4 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h4><ul><li>利用转移、状态和输出表，可构造定时图</li><li>定时图：表示出状态机在任何期望的起始状态和输入序列的作用下所产生的行为。</li></ul><h4 id="同步时序电路的分析步骤"><a href="#同步时序电路的分析步骤" class="headerlink" title="同步时序电路的分析步骤"></a>同步时序电路的分析步骤</h4><ol><li>写出各触发器的激励方程。</li><li>把得到的激励方程代入到触发器的特征方程，得到转移方程/次态方程。</li><li>确定输出方程。</li><li>根据转移方程构造转移表，在转移表中对每一种状态/输入组合添加输出值，构成状态/输出表</li><li>利用状态名得到时序电路的状态图。</li><li>画出时序图。</li></ol><h3 id="时钟同步状态机设计"><a href="#时钟同步状态机设计" class="headerlink" title="时钟同步状态机设计"></a>时钟同步状态机设计</h3><ol><li>根据文字描述，构造状态/输出表</li><li>（可选）将状态/输出表中的状态数目最小化</li><li>状态赋值，选择一组状态变量编码组合赋给状态</li><li>将状态变量组合代入状态/输出表，建立转移/输出表。</li><li>选择一种触发器作为状态存储器</li><li>构造激励表</li><li>由激励表推导出激励方程</li><li>由转移/输出表推导出输出方程</li><li>画出逻辑电路图。</li></ol><h4 id="状态化简"><a href="#状态化简" class="headerlink" title="状态化简"></a>状态化简</h4><p>等价状态：设状态S1和S2是完全确定状态表中的两个状态,如果对于所有可能的输入序列，分别从状态S1    和状态S2出发，所得到的输出响应序列完全相同，    则状态S1和S2是等价的，记作(S1, S2) .    或说，状态S1和S2是等价对。等价状态可以合并。</p><p>等价状态具有传递性 </p><p>等价类：彼此等价的状态集合</p><p>状态简化的任务是要在原始状态表中找出全部最大等价类(最大等价类集合)，并将每一个最大等价类用一个状态来表示。</p><p>假定状态S1和S2是完全确定原始状态表中的两个现态，那么S1和S2等价的条件可归纳为在输入的各种取值组合下：</p><ul><li>第一、它们的输出完全相同；</li><li>第二、它们的次态满足下列条件之一，即：(1) 次态相同；(2) 次态交错 (3) 次态循环 (4) 次态对等价</li></ul><p>隐含表法化简</p><h5 id="不完全确定状态表的简化"><a href="#不完全确定状态表的简化" class="headerlink" title="不完全确定状态表的简化"></a>不完全确定状态表的简化</h5><p>不完全确定状态表： 状态表中存在不确定的次态或输出，这些不确定的次态或输出将有利于状态简化。</p><p> 相容状态：设状态S1和S2是不完全确定状态表中    的两个状态，如果对于所有的有效输入序列，分别从状态S1和S2出发，所得到的输出响应序列(除不确定的那些位之外)是完全相同的，那么状态S1和S2是相容的，或者说状    态S1和S2是相容对，记作(S1,S2)。相容状态可以合并。</p><p> 状态相容无传递性</p><p> 相容类：彼此相容的状态集合  最大相容类：不被其他相容类所包含的相容类</p><p>作最小化状态表: 最小化状态表(又称最小闭覆盖) 应满足下列三个条件：</p><ul><li>覆盖性－－所选相容类集合应包含原始状态表中    的全部状态。</li><li>最小性－－所选相容类集合中相容类的个数应最    少。</li><li>闭合性－－所选相容类集合中的任一相容类，在    原始状态表中任一输入条件下产生的次态应    该属于该集合中的某一个相容类。</li></ul><h4 id="状态赋值-状态编码"><a href="#状态赋值-状态编码" class="headerlink" title="状态赋值(状态编码)"></a>状态赋值(状态编码)</h4><ul><li>确定表示状态表的状态需要多少位二进制变量，并且对每一个已命名的状态赋予一个特定的组合（编码）。</li><li>状态编码(coded state)：赋给一个特定状态的二进制数的组合。</li></ul><p>状态分配方案的种数：排列数计算</p><p>如果两种状态分配在实现逻辑时产生相同的结果，则认为它们是等价的。状态编码分配互补，或状态编码左右互换，都是等价的。</p><p>独立状态数: N=(2^K - 1)! / ((2^K-n)!K!)</p><p>在同步时序电路中状态分配目的在于：在逻辑化简时，生成尽可能大的必要质蕴含。状态分配的标准就是使得质蕴含达到最大程度。寻找较好的结果。</p><p>状态编码：从2^n种可能组合中选择S种编码</p><p>遗憾的是：至今没有找到普遍有效的算法实现最佳状态分配，唯一途径是将所有分配方案都试个遍</p><p>次佳状态分配方案：相邻状态分配法，建立通用方程法，减少相关性</p><h5 id="次佳状态分配方案"><a href="#次佳状态分配方案" class="headerlink" title="次佳状态分配方案"></a>次佳状态分配方案</h5><p>相邻状态分配法</p><ul><li>次态相同，现态相邻: 使下一个状态较少依赖于当前状态变量</li><li>同一现态，次态相邻：使下一状态较少依赖于输入变量</li><li>输出相同，现态相邻：使输出较少依赖于当前状态变量</li></ul><h5 id="处理未用状态方法"><a href="#处理未用状态方法" class="headerlink" title="处理未用状态方法"></a>处理未用状态方法</h5><p>最小风险法 最小成本法</p><h4 id="反馈时序电路"><a href="#反馈时序电路" class="headerlink" title="反馈时序电路"></a>反馈时序电路</h4><p>异步时序电路特征：状态变化不受“统一时钟信号控制”</p><p>依电路结构和输入信号形式不同，异步时序电路分类：</p><ul><li>脉冲型Pulsed Asynchronous Circuit(脉冲信号):记忆电路为“触发器”</li><li>电平型Level Asynchronous Circuit(电平信号)：记忆电路为“反馈加延时”</li></ul><p>双稳态电路、锁存器和触发器等都是反馈时序电路。反馈回路是记忆元件，存储0或1。</p><p>基本模式电路，对输入信号的约束：</p><ul><li>不允许两个或两个以上输入同时变化(每时刻仅允许1个输入发生变化)</li><li>仅当电路处于稳态时，允许输入信号发生变化</li></ul><h5 id="反馈时序电路的分析步骤"><a href="#反馈时序电路的分析步骤" class="headerlink" title="反馈时序电路的分析步骤"></a>反馈时序电路的分析步骤</h5><ul><li>切断反馈路径，写出激励函数和输出函数</li><li>列出状态转移表</li><li>作出状态图和时序(间)图</li><li>说明电路的逻辑功能</li></ul><h5 id="反馈时序电路的分析"><a href="#反馈时序电路的分析" class="headerlink" title="反馈时序电路的分析"></a>反馈时序电路的分析</h5><ul><li>现态和次态只是在时间上有延迟，经过一段时间后，现态和次态的值趋于一致。</li><li>总态Total State：用来描述异步时序机的行为。包括输入状态I和次态S，并记为(I，S)。</li><li>稳定状态：如某一现态y在输入x发生变化时，若次态Y和现态y的值相同，则称次态Y为稳定状态；若次态Y和现态y的值不等，则称进入的次态Y为不稳定状态。不稳定状态是不能保持不变，经过一段延迟时间后，现态和次态趋于一致，进入稳定状态，则称为状态迁移。</li><li>状态表：状态命名，且将稳定的总状态用圆圈圈住。</li><li>总态可以是稳定的也可以是不稳定的，不稳定的总态要发生状态迁移，而达到一个稳定的状态或循环不稳态。稳定的总态，如果输入不改变，则始终保存稳定状态，不会发生状态迁移。</li><li>异步电路的基本工作方式是保证电路稳定工作，使电路状态的转移是可以预测的。</li><li>输入状态的改变仅能引起次态在状态表作相邻方格的水平移动。</li><li>二次状态的改变则引起次态在状态表中作垂直方向的移动。</li></ul><p>多反馈回路中，必须断开所有的反馈，设置虚构的缓冲器和状态变量。</p><p>最小割集(cut set)：断点数最少的集合</p><h5 id="竞争"><a href="#竞争" class="headerlink" title="竞争"></a>竞争</h5><p>一个输入信号的变化，引起多个内部状态变量改变，称之为发生了竞争</p><ul><li>非临界竞争(Noncritical race)，最终状态与状态变量变化顺序无关，结果可预测。</li><li>临界竞争(Critical race)，最终状态取决于状态变量变化顺序和速度，结果不可预测。</li></ul><p>对于竞争的处理</p><ul><li>允许非临界竞争</li><li>避免临界竞争</li></ul><h5 id="状态表与流程表"><a href="#状态表与流程表" class="headerlink" title="状态表与流程表"></a>状态表与流程表</h5><ul><li>状态表：状态命名，且将稳定的总状态用圆圈圈住。</li><li>跳程hop：单个输入变量变化时，电路达到新的稳定总状态时所发生的不稳定的状态。</li><li>流程表Flow table：由现态和在不同输入条件下的次态及输出组成。删除状态表中的跳程，只表示出每次转移过程的最终目标，去除未用内部状态的那些行，去掉那些稳定的总状态在单个输入变化时从不会到达的下一状态项。</li></ul><h4 id="反馈时序电路设计"><a href="#反馈时序电路设计" class="headerlink" title="反馈时序电路设计"></a>反馈时序电路设计</h4><ol><li>根据逻辑要求，建立原始流程表</li><li>将原始状态表简化，得到最简流程表</li><li>对最简流程表进行状态分配</li><li>建立激励表和输出表</li><li>列出激励函数和输出函数表达式</li><li>画出逻辑电路图</li></ol><p>原始流程表:每一行含有一个稳态 每个状态决定于上一个状态和输入</p><h5 id="本质冒险"><a href="#本质冒险" class="headerlink" title="本质冒险"></a>本质冒险</h5><p>本质冒险：当输入信号变化时，电路进入错误状态的可能性。：如果最终状态变量的变化被传回到激励电路输入端之前，输入的变化未被所有的激励电路接收到，就会发生错误。</p><p>通俗定义：如果从状态S出发，X的一次变化和三次变化的最终结果状态不一致，就存在本质冒险。</p><p>本质冒险是电路中固有的问题，可通过增加延迟解决问题。</p><h3 id="时序逻辑设计实践"><a href="#时序逻辑设计实践" class="headerlink" title="时序逻辑设计实践"></a>时序逻辑设计实践</h3><p>定时图： </p><p>建立时间容限=tclk-tffpd(max)-tcomb(max)-tsetup&gt;0</p><p>保持时间容限=tffpd(min)+tcomb(min)-thold&gt;0</p><h4 id="开关消颤"><a href="#开关消颤" class="headerlink" title="开关消颤"></a>开关消颤</h4><p>双稳态电路消颤</p><p>锁存器和上拉电阻消颤</p><h4 id="S’-R’锁存器消除击键抖动"><a href="#S’-R’锁存器消除击键抖动" class="headerlink" title="S’-R’锁存器消除击键抖动"></a>S’-R’锁存器消除击键抖动</h4><h4 id="总线保持电路"><a href="#总线保持电路" class="headerlink" title="总线保持电路"></a>总线保持电路</h4><p>在三态总线中，悬空总线的处理方法</p><ul><li>上拉电阻：价格贵、占用印刷电路的面积 大小选择比较困难，过大，转换慢；过小，则消耗过多的电流</li><li>有源总线保持电路：带电阻反馈回路的双稳态电路</li></ul><p>为什么要？？？？</p><h4 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h4><p>共用一个时钟信号的2个或2个以上的D触发器组合在一起，称为寄存器，通常用来存储一组相关的二进制数。</p><p>锁存器和触发器的区别:</p><ul><li>前者是电位信号控制，后者是同步时钟边沿信号控制。</li><li>使用的场合不同：取决于控制方式、控制信号和数据之间的时间关系。：数据有效滞后于控制信息时，使用锁存器。反之，可使用寄存器。</li></ul><h4 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h4><p>计数器：在状态图中包含一个循环的时序电路。</p><p>1.功能：对时钟脉冲 CLK 计数。<br>2.应用：分频、定时、产生节拍脉冲和脉冲序列、进行数字运算等。</p><p>按数制分：二进制计数器 十进制计数器 N进制(任意进制)计数器</p><p>按计数方式分： 加法计数器 减法计数器 可逆计数（Up-Down Counter）</p><h5 id="行波计数器：进位信息像波浪一样由低位向高位，每次传送一次。"><a href="#行波计数器：进位信息像波浪一样由低位向高位，每次传送一次。" class="headerlink" title="行波计数器：进位信息像波浪一样由低位向高位，每次传送一次。"></a>行波计数器：进位信息像波浪一样由低位向高位，每次传送一次。</h5><p>延迟时间很长</p><h5 id="同步计数器"><a href="#同步计数器" class="headerlink" title="同步计数器"></a>同步计数器</h5><p>同步计数器：所有的触发器共用一个CLK信号 使用带有使能端的T触发器</p><p>串行同步4位二进制计数器 并行同步4位二进制计数器(最快的二进制计数器)</p><p>一次状态转移中有2个以上的计数位同时变化，在译码端可能产生尖峰脉冲(glitch)。 属于功能性冒险</p><p>无冒险译码输出：输出延迟一个时钟周期 可使用环形计数器实现</p><p>可逆同步计数器169</p><p>N进制计数器：用触发器和门电路设计或用集成计数器构成。</p><p>十进制异步计数器</p><p>提高归零可靠性？</p><h5 id="移位寄存器"><a href="#移位寄存器" class="headerlink" title="移位寄存器"></a>移位寄存器</h5><p>移位寄存器shift register：是一个n位寄存器，在每一个时钟触发沿到来时就将所存储的数据移一位。</p><ul><li>处理串行数据</li><li>用于rs232,modem通信、以太网连接等</li><li>串入串出</li></ul><p>也可以串入并出、并入串出、并入并出</p><h6 id="移位寄存器的应用"><a href="#移位寄存器的应用" class="headerlink" title="移位寄存器的应用"></a>移位寄存器的应用</h6><ul><li>串并转换是移位寄存器的“数据应用”。</li><li>与组合电路构成具有循环状态图的状态机，“非数据应用”，称为移位寄存器计数器shift-register counter。</li><li>计数顺序既不是升序也不是降序。</li></ul><h5 id="环形计数器"><a href="#环形计数器" class="headerlink" title="环形计数器"></a>环形计数器</h5><h5 id="自校正环形计数器"><a href="#自校正环形计数器" class="headerlink" title="自校正环形计数器"></a>自校正环形计数器</h5><h5 id="Johnson计数器"><a href="#Johnson计数器" class="headerlink" title="Johnson计数器"></a>Johnson计数器</h5><p>扭环计数器，把n位移位寄存器的串行输出取反，得到具有2n种状态的计数器。 有2n-2n个非正常状态，存在健壮性问题。</p><h5 id="线性反馈移位寄存器计数器"><a href="#线性反馈移位寄存器计数器" class="headerlink" title="线性反馈移位寄存器计数器"></a>线性反馈移位寄存器计数器</h5><ul><li>n位线性反馈移位寄存器计数器(n-bit linear feedback shift-register counter,LFSR)有2n-1种有效状态，通常称为最大长度序列发生器(maximum-length sequence generator)。</li><li>基于有限域理论（finite field），对于任意值n，至少可以找到一种反馈方程，使得计数器的计数循环包含所有2n-1种非零状态。</li><li>最大长度序列。</li><li>n大于3，有多个反馈方程可实现最大长度序列。</li><li>用于伪随机数生成器、检错码、纠错码，加扰和解扰通信数据等。</li></ul><h4 id="计数器的应用"><a href="#计数器的应用" class="headerlink" title="计数器的应用"></a>计数器的应用</h4><p>序列信号发生器</p><h4 id="迭代电路与时序电路"><a href="#迭代电路与时序电路" class="headerlink" title="迭代电路与时序电路"></a>迭代电路与时序电路</h4><ul><li>一个由n个模块构成的迭代电路，其功能可以用一个模块加暂存机制构成的时序电路来完成，需经过n个时钟周期才能得到结果。</li><li>数字设计中的空间/时间折中。</li></ul><h2 id="存储器、CPLD和FPGA"><a href="#存储器、CPLD和FPGA" class="headerlink" title="存储器、CPLD和FPGA"></a>存储器、CPLD和FPGA</h2><h3 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h3><h4 id="ROM"><a href="#ROM" class="headerlink" title="ROM"></a>ROM</h4><ul><li>只读存储器简称ROM (read-only memory)：是一种具有n个输入b个输出的组合逻辑电路。</li><li>包含地址输入（地址译码）、数据输出（输出缓冲）和存储矩阵三部分。</li><li>与真正存储器的区别：非易失性存储器(non volatile memory)。即使电源断电，ROM中存储的数据不会丢失。</li><li>ROM = 最小项译码器+ 可编程或矩阵</li><li>ROM = 存真值表的存储器</li></ul><h4 id="ROM的应用"><a href="#ROM的应用" class="headerlink" title="ROM的应用"></a>ROM的应用</h4><ul><li>字符发生器：实现字符发生器的基本原理是:将字符的点阵预先存储在ROM中，然后顺序给出地址码，从存储矩阵中逐行读出字符的点阵，并送入显示器即可显示出字符。</li><li>数学函数表：实现计算机中的运算有两种方法，一种是编写运算程序，存入ROM中，通过计算机执行运算程序。另一种方法是把因变量和自变量的函数关系存在ROM中，好像查函数表一样。</li></ul><h4 id="RAM"><a href="#RAM" class="headerlink" title="RAM"></a>RAM</h4><ul><li>读/写存储器(Read/Write Memory RWM)是指可以在任何时候存储和检索信息的存储器阵列</li><li>现在数字系统中的读写存储器大多数是随机存取存储器（Random-access Memory, RAM），意思说读或写存储器的1个位所花费的时间与该位在RAM中的位置无关。</li><li>静态存储器Static RAM,SRAM：一旦在某个存储位置写入数据，只要电源不被切断，其存储内容保持不变，除非重新写入新内容。</li><li>动态存储器Dynamic RAM,DRAM：必须对存储数据进行周期性读出和写入刷新，否则存储器中的数据将会消失。</li></ul><p>存储器的容量扩展：位扩展 字扩展  字位同时扩展</p><h4 id="CPLD"><a href="#CPLD" class="headerlink" title="CPLD"></a>CPLD</h4><p>基本结构：大多由内部PLD、输入输出块和可编程内部连线组成。</p><h4 id="FPGA"><a href="#FPGA" class="headerlink" title="FPGA"></a>FPGA</h4><ul><li>与CPLD相比，具有更高的集成度、更强的逻辑功能和更大的灵活性</li><li>FPGA属于阵列型PLD</li><li>有三个可编程电路块和一个用于存放编程数据的SRAM组成：可编程逻辑块（CLB）  输入/输出模块（IOB）  可编程互连线（PI）</li></ul><h4 id="FPGA和CPLD的区别"><a href="#FPGA和CPLD的区别" class="headerlink" title="FPGA和CPLD的区别"></a>FPGA和CPLD的区别</h4><ul><li>编程技术与数据易失性：通常FPGA采用SRAM进行功能配置，可以重复编程，但系统掉电后，SRAM中的数据丢失。因此，需在FPGA外加EPROM，将配置数据写入其中，系统每次上电自动将数据引入SRAM中。而一般CPLD器件采用EEPROM存储技术，可重复编程，且系统掉电后，EEPROM中的数据不会丢失，适于数据的保密。</li><li>触发器资源：FPGA器件由于含有丰富的触发器资源，容易实现时序逻辑，若要求实现比较复杂的组合电路则需要几个CLB结合起来实现。CPLD的与或阵列结构，使它更适合于实现大规模的组合逻辑功能，而它的触发器资源相对比较少。</li><li>芯片利用率：FPGA多为细粒度结构。FPGA内部有丰富连线资源，CLB分块比较小，芯片利用率比较高。CPLD多为粗粒度结构。 CPLD宏单元的与或阵列较大，通常不能完全被应用，而且宏单元之间主要通过高速数据通道连接，容量有限，限制了器件的灵活布线，因此CPLD利用率比FPGA低。</li><li>布线结构与延时预测性：FPGA为非连续式布线。FPGA器件在每次编程时实现的逻辑功能一样，但走的路线不同，因此延时难以预测，要求开发软件允许工程师对关键的路线给予限制。CPLD为连续式布线。CPLD每次布线路径一样，其连续式互连结构利用具有同样长度的一些金属线实现逻辑单元之间的互连，消除了分段式互连结构在定时上的差异，并且在逻辑单元之间提供快速而且具有固定延时的通路。另外，CPLD的延时比较小。</li></ul><h2 id="数字系统"><a href="#数字系统" class="headerlink" title="数字系统"></a>数字系统</h2><p>数字系统的基本模型：由输入部件、输出部件及逻辑系统组成。逻辑系统包括存储部件、处理部件、控制部件三大子系统。</p><p>基本子系统：是指构成数字系统时最基本的逻辑功能部件。这些逻辑功能部件有：算术逻辑运算单元ALU、寄存器、RAM、数据总线、控制器。</p><p>ALU：是数字系统中对数据进行加工处理的功能部件。</p><p>寄存器：加法器和ALU均由门电路组成，它们没有记忆功能，因此运算的结果需要寄存器保存起来。而参与运算的两个数也要取自寄存器。寄存器是数字系统中必不可少的逻辑子系统。  寄存器的分类：通用寄存器 、专用寄存器。</p><p>存储器RAM：当存储大量数据时，从经济和成本上考虑，只能使用随机读写的RAM存储器。</p><p>总线的概念 ：在数字系统中，总线是多个逻辑子系统的联系纽带。所谓总线，就是多个信息源分时传送数据到多个目的地的传送通路。单向总线 双向总线</p><p>给不给器件的原理图 ？？？</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数字逻辑电路笔记&quot;&gt;&lt;a href=&quot;#数字逻辑电路笔记&quot; class=&quot;headerlink&quot; title=&quot;数字逻辑电路笔记&quot;&gt;&lt;/a&gt;数字逻辑电路笔记&lt;/h1&gt;&lt;p&gt;给定输入 给出输出 用布尔逻辑实现&lt;/p&gt;
&lt;p&gt;晶体管的开关特性是数字电路研究的重点。&lt;/p&gt;
&lt;p&gt;数字逻辑中考虑电路模拟的特性，如时延问题。&lt;/p&gt;
&lt;p&gt;数字设计中一些层次问题&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>BST</title>
    <link href="http://yoursite.com/2018/06/07/BST/"/>
    <id>http://yoursite.com/2018/06/07/BST/</id>
    <published>2018-06-07T07:09:17.000Z</published>
    <updated>2018-06-07T07:11:04.225Z</updated>
    
    <content type="html"><![CDATA[<p>下面是基于C++的BST类实现</p> <a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">//  main.cpp</span><br><span class="line">//  debugger</span><br><span class="line">//</span><br><span class="line">//  Created by 丁保荣 on 2018/6/6.</span><br><span class="line">//  Copyright © 2018 丁保荣. All rights reserved.</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">    node * p;</span><br><span class="line">    node * l;</span><br><span class="line">    node * r;</span><br><span class="line">    int key;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class BST</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    node * root;</span><br><span class="line">    node mynil;</span><br><span class="line">    void Initial()</span><br><span class="line">    &#123;</span><br><span class="line">        root=&amp;mynil;</span><br><span class="line">    &#125;</span><br><span class="line">    void Inorder_tree_walk(node * x);</span><br><span class="line">    void Preorder_tree_walk(node * x);</span><br><span class="line">    void Postorder_tree_walk(node * x);</span><br><span class="line">    node * Search(node * x, int k);</span><br><span class="line">    node * Minimum(node * z);</span><br><span class="line">    node * Maximum(node * z);</span><br><span class="line">    node * Successor(node * x);</span><br><span class="line">    node * Predecessor(node * x);</span><br><span class="line">    void Insert(node * z);</span><br><span class="line">    void Transplant(node * u, node * v);</span><br><span class="line">    void Delete(node * z);</span><br><span class="line">    </span><br><span class="line">private:</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void BST::Inorder_tree_walk(node * x)</span><br><span class="line">&#123;</span><br><span class="line">    if(x!=&amp;mynil)</span><br><span class="line">    &#123;</span><br><span class="line">        BST::Inorder_tree_walk((*x).l);</span><br><span class="line">        cout&lt;&lt;(*x).key;</span><br><span class="line">        BST::Inorder_tree_walk((*x).r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void BST::Preorder_tree_walk(node * x)</span><br><span class="line">&#123;</span><br><span class="line">    if(x!=&amp;mynil)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;(*x).key;</span><br><span class="line">        BST::Preorder_tree_walk((*x).l);</span><br><span class="line">        BST::Preorder_tree_walk((*x).r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void BST::Postorder_tree_walk(node * x)</span><br><span class="line">&#123;</span><br><span class="line">    if(x!=&amp;mynil)</span><br><span class="line">    &#123;</span><br><span class="line">        BST::Postorder_tree_walk((*x).l);</span><br><span class="line">        BST::Postorder_tree_walk((*x).r);</span><br><span class="line">        cout&lt;&lt;(*x).key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">node * BST::Search(node * x,int k)</span><br><span class="line">&#123;</span><br><span class="line">    if(x==&amp;mynil || k==(*x).key)</span><br><span class="line">        return x;</span><br><span class="line">    if(k&lt;(*x).key)</span><br><span class="line">        return BST::Search((*x).l,k);</span><br><span class="line">    else</span><br><span class="line">        return BST::Search((*x).r,k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">node * BST::Minimum(node * z)</span><br><span class="line">&#123;</span><br><span class="line">    while((*z).l!=&amp;mynil)</span><br><span class="line">        z=(*z).l;</span><br><span class="line">    return z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">node * BST::Maximum(node * z)</span><br><span class="line">&#123;</span><br><span class="line">    while((*z).r!=&amp;mynil)</span><br><span class="line">        z=(*z).r;</span><br><span class="line">    return z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">node * BST::Successor(node * x)</span><br><span class="line">&#123;</span><br><span class="line">    if((*x).r!=&amp;mynil)</span><br><span class="line">        return BST::Minimum((*x).r);</span><br><span class="line">    node * y=(*x).p;</span><br><span class="line">    while(y!=&amp;mynil &amp;&amp; x==(*y).r)</span><br><span class="line">    &#123;</span><br><span class="line">        x=y;</span><br><span class="line">        y=(*y).p;</span><br><span class="line">    &#125;</span><br><span class="line">    return y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">node * BST::Predecessor(node * x)</span><br><span class="line">&#123;</span><br><span class="line">    if((*x).l!=&amp;mynil)</span><br><span class="line">        return BST::Maximum((*x).l);</span><br><span class="line">    node * y=(*x).p;</span><br><span class="line">    while(y!=&amp;mynil &amp;&amp; x==(*y).l)</span><br><span class="line">    &#123;</span><br><span class="line">        x=y;</span><br><span class="line">        y=(*y).p;</span><br><span class="line">    &#125;</span><br><span class="line">    return y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void BST::Insert(node * z)</span><br><span class="line">&#123;</span><br><span class="line">    node * y=&amp;mynil;</span><br><span class="line">    node * x=root;</span><br><span class="line">    while(x!=&amp;mynil)</span><br><span class="line">    &#123;</span><br><span class="line">        y=x;</span><br><span class="line">        if((*z).key&lt;(*x).key)</span><br><span class="line">            x=(*x).l;</span><br><span class="line">        else</span><br><span class="line">            x=(*x).r;</span><br><span class="line">    &#125;</span><br><span class="line">    (*z).p=y;</span><br><span class="line">    if(y==&amp;mynil)</span><br><span class="line">        root=z;</span><br><span class="line">    else if((*z).key&lt;(*y).key)</span><br><span class="line">        (*y).l=z;</span><br><span class="line">    else</span><br><span class="line">        (*y).r=z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void BST::Transplant(node * u, node * v)</span><br><span class="line">&#123;</span><br><span class="line">    if((*u).p==&amp;mynil)</span><br><span class="line">        root=v;</span><br><span class="line">    else if(u==(*(*u).p).l)</span><br><span class="line">        (*(*u).p).l=v;</span><br><span class="line">    else</span><br><span class="line">        (*(*u).p).r=v;</span><br><span class="line">    if(v!=&amp;mynil)</span><br><span class="line">        (*v).p=(*u).p;</span><br><span class="line">&#125;</span><br><span class="line">void BST::Delete(node * z)</span><br><span class="line">&#123;</span><br><span class="line">    node * y;</span><br><span class="line">    if((*z).l==&amp;mynil)</span><br><span class="line">        BST::Transplant(z,(*z).r);</span><br><span class="line">    else if((*z).r==&amp;mynil)</span><br><span class="line">        BST::Transplant(z,(*z).l);</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        y=BST::Minimum((*z).r);</span><br><span class="line">        if((*y).p!=z)</span><br><span class="line">        &#123;</span><br><span class="line">            BST::Transplant(y,(*y).r);</span><br><span class="line">            (*y).r=(*z).r;</span><br><span class="line">            (*(*y).r).p=y;</span><br><span class="line">        &#125;</span><br><span class="line">        BST::Transplant(z,y);</span><br><span class="line">        (*y).l=(*z).l;</span><br><span class="line">        (*(*y).l).p=y;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BST T;</span><br><span class="line"></span><br><span class="line">void myinsert(int key)</span><br><span class="line">&#123;</span><br><span class="line">    node * p=new node;</span><br><span class="line">    (*p).key=key;</span><br><span class="line">    p-&gt;l=&amp;T.mynil;</span><br><span class="line">    p-&gt;r=&amp;T.mynil;</span><br><span class="line">    T.Insert(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void mydelete(int key)</span><br><span class="line">&#123;</span><br><span class="line">    node * p = T.Search(T.root,key);</span><br><span class="line">    T.Delete(p);</span><br><span class="line">    delete(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是基于C++的RB-Tree类实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">//  main.cpp</span><br><span class="line">//  debugger</span><br><span class="line">//</span><br><span class="line">//  Created by 丁保荣 on 2018/6/6.</span><br><span class="line">//  Copyright © 2018 丁保荣. All rights reserved.</span><br><span class="line">//</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int counter=0;</span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">    bool c; // true is black and false is red.</span><br><span class="line">    int key;</span><br><span class="line">    node * p;</span><br><span class="line">    node * l;</span><br><span class="line">    node * r;</span><br><span class="line">&#125;;</span><br><span class="line">class myRB_Tree</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    node mynil;</span><br><span class="line">    node * root;</span><br><span class="line">    void Initial()</span><br><span class="line">    &#123;</span><br><span class="line">        mynil.c=true;</span><br><span class="line">        mynil.p=mynil.l=mynil.r=NULL;</span><br><span class="line">        mynil.key=-1;</span><br><span class="line">        root=&amp;mynil;</span><br><span class="line">    &#125;</span><br><span class="line">    void Insert(node * z);</span><br><span class="line">    void Delete(node * z);</span><br><span class="line">    node * Search(node * x, int k);</span><br><span class="line">    node * Minimum(node * z);</span><br><span class="line">    void Preorder_tree_walk(node * x);</span><br><span class="line">    </span><br><span class="line">private:</span><br><span class="line">    void Insert_Fixup(node * z);</span><br><span class="line">    void Transplant(node * u, node * v);</span><br><span class="line">    void Left_Rotate(node * x);</span><br><span class="line">    void Right_Rotate(node * x);</span><br><span class="line">    void Delete_Fixup(node * x);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void myRB_Tree::Preorder_tree_walk(node * x)</span><br><span class="line">&#123;</span><br><span class="line">    if(x!=&amp;mynil)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;(*x).key&lt;&lt;&quot;:&quot;&lt;&lt;((*x).c?&quot;black&quot;:&quot;red&quot;)&lt;&lt;endl;</span><br><span class="line">        myRB_Tree::Preorder_tree_walk((*x).l);</span><br><span class="line">        myRB_Tree::Preorder_tree_walk((*x).r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void myRB_Tree::Insert(node * z)</span><br><span class="line">&#123;</span><br><span class="line">    node * y=&amp;mynil;</span><br><span class="line">    node * x=root;</span><br><span class="line">    while(x!=&amp;mynil)</span><br><span class="line">    &#123;</span><br><span class="line">        y=x;</span><br><span class="line">        if((*z).key&lt;(*x).key)</span><br><span class="line">            x=(*x).l;</span><br><span class="line">        else</span><br><span class="line">            x=(*x).r;</span><br><span class="line">    &#125;</span><br><span class="line">    (*z).p=y;</span><br><span class="line">    if(y==&amp;mynil)</span><br><span class="line">        root=z;</span><br><span class="line">    else if((*z).key&lt;(*y).key)</span><br><span class="line">        (*y).l=z;</span><br><span class="line">    else</span><br><span class="line">        (*y).r=z;</span><br><span class="line">    (*z).l=&amp;mynil;</span><br><span class="line">    (*z).r=&amp;mynil;</span><br><span class="line">    (*z).c=0;</span><br><span class="line">    myRB_Tree::Insert_Fixup(z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void myRB_Tree::Insert_Fixup(node * z)</span><br><span class="line">&#123;</span><br><span class="line">    while((*(*z).p).c==false)</span><br><span class="line">    &#123;</span><br><span class="line">        if((*z).p==(*(*(*z).p).p).l)</span><br><span class="line">        &#123;</span><br><span class="line">            node * y=(*(*(*z).p).p).r;</span><br><span class="line">            if((*y).c==false)</span><br><span class="line">            &#123;</span><br><span class="line">                (*(*z).p).c=true;</span><br><span class="line">                (*y).c=true;</span><br><span class="line">                (*(*(*z).p).p).c=false;</span><br><span class="line">                z=(*(*z).p).p;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                if(z==(*(*z).p).r)</span><br><span class="line">                &#123;</span><br><span class="line">                    z=(*z).p;</span><br><span class="line">                    myRB_Tree::Left_Rotate(z);</span><br><span class="line">                &#125;</span><br><span class="line">                (*(*z).p).c=true;</span><br><span class="line">                (*(*(*z).p).p).c=false;</span><br><span class="line">                myRB_Tree::Right_Rotate((*(*z).p).p);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            node * y=(*(*(*z).p).p).l;</span><br><span class="line">            if((*y).c==false)</span><br><span class="line">            &#123;</span><br><span class="line">                (*(*z).p).c=true;</span><br><span class="line">                (*y).c=true;</span><br><span class="line">                (*(*(*z).p).p).c=false;</span><br><span class="line">                z=(*(*z).p).p;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                if(z==(*(*z).p).l)</span><br><span class="line">                &#123;</span><br><span class="line">                    z=(*z).p;</span><br><span class="line">                    myRB_Tree::Right_Rotate(z);</span><br><span class="line">                &#125;</span><br><span class="line">                (*(*z).p).c=true;</span><br><span class="line">                (*(*(*z).p).p).c=false;</span><br><span class="line">                myRB_Tree::Left_Rotate((*(*z).p).p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    (*root).c=true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void myRB_Tree::Left_Rotate(node * x)</span><br><span class="line">&#123;</span><br><span class="line">    node * y= (*x).r;</span><br><span class="line">    (*x).r=(*y).l;</span><br><span class="line">    if((*y).l!=&amp;mynil)</span><br><span class="line">        (*(*y).l).p=x;</span><br><span class="line">    (*y).p=(*x).p;</span><br><span class="line">    if((*x).p==&amp;mynil)</span><br><span class="line">        root=y;</span><br><span class="line">    else if(x==(*(*x).p).l)</span><br><span class="line">        (*(*x).p).l=y;</span><br><span class="line">    else</span><br><span class="line">        (*(*x).p).r=y;</span><br><span class="line">    (*y).l=x;</span><br><span class="line">    (*x).p=y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void myRB_Tree::Right_Rotate(node * x)</span><br><span class="line">&#123;</span><br><span class="line">    node * y= (*x).l;</span><br><span class="line">    (*x).l=(*y).r;</span><br><span class="line">    if((*y).r!=&amp;mynil)</span><br><span class="line">        (*(*y).r).p=x;</span><br><span class="line">    (*y).p=(*x).p;</span><br><span class="line">    if((*x).p==&amp;mynil)</span><br><span class="line">        root=y;</span><br><span class="line">    else if(x==(*(*x).p).r)</span><br><span class="line">        (*(*x).p).r=y;</span><br><span class="line">    else</span><br><span class="line">        (*(*x).p).l=y;</span><br><span class="line">    (*y).r=x;</span><br><span class="line">    (*x).p=y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void myRB_Tree::Transplant(node * u, node * v)</span><br><span class="line">&#123;</span><br><span class="line">    if((*u).p==&amp;mynil)</span><br><span class="line">        root=v;</span><br><span class="line">    else if(u==(*(*u).p).l)</span><br><span class="line">        (*(*u).p).l=v;</span><br><span class="line">    else</span><br><span class="line">        (*(*u).p).r=v;</span><br><span class="line">    (*v).p=(*u).p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void myRB_Tree::Delete(node * z)</span><br><span class="line">&#123;</span><br><span class="line">    node * y=z;</span><br><span class="line">    node * x;</span><br><span class="line">    bool y_original_color=(*y).c;</span><br><span class="line">    if((*z).l==&amp;mynil)</span><br><span class="line">    &#123;</span><br><span class="line">        x=(*z).r;</span><br><span class="line">        myRB_Tree::Transplant(z,(*z).r);</span><br><span class="line">    &#125;</span><br><span class="line">    else if((*z).r==&amp;mynil)</span><br><span class="line">    &#123;</span><br><span class="line">        x=(*z).l;</span><br><span class="line">        myRB_Tree::Transplant(z,(*z).l);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        y=myRB_Tree::Minimum((*z).r);</span><br><span class="line">        y_original_color=(*y).c;</span><br><span class="line">        x=(*y).r;</span><br><span class="line">        if((*y).p==z)</span><br><span class="line">            (*x).p=y;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            myRB_Tree::Transplant(y,(*y).r);</span><br><span class="line">            (*y).r=(*z).r;</span><br><span class="line">            (*(*y).r).p=y;</span><br><span class="line">        &#125;</span><br><span class="line">        myRB_Tree::Transplant(z,y);</span><br><span class="line">        (*y).l=(*z).l;</span><br><span class="line">        (*(*y).l).p=y;</span><br><span class="line">        (*y).c=(*z).c;</span><br><span class="line">    &#125;</span><br><span class="line">    if(y_original_color==true)</span><br><span class="line">        myRB_Tree::Delete_Fixup(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void myRB_Tree::Delete_Fixup(node * x)</span><br><span class="line">&#123;</span><br><span class="line">    node * w;</span><br><span class="line">    while(x!=root and (*x).c==true)</span><br><span class="line">    &#123;</span><br><span class="line">        if(x==(*(*x).p).l)</span><br><span class="line">        &#123;</span><br><span class="line">            w=(*(*x).p).r;</span><br><span class="line">            if((*w).c==false)</span><br><span class="line">            &#123;</span><br><span class="line">                (*w).c=true;</span><br><span class="line">                (*(*x).p).c=false;</span><br><span class="line">                myRB_Tree::Right_Rotate((*x).p);</span><br><span class="line">                w=(*(*x).p).r;</span><br><span class="line">            &#125;</span><br><span class="line">            if((*(*w).l).c==true &amp;&amp; (*(*w).r).c==true)</span><br><span class="line">            &#123;</span><br><span class="line">                (*w).c=false;</span><br><span class="line">                x=(*x).p;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                if((*(*w).r).c==true)</span><br><span class="line">                &#123;</span><br><span class="line">                    (*(*w).l).c=true;</span><br><span class="line">                    (*w).c=false;</span><br><span class="line">                    myRB_Tree::Left_Rotate(w);</span><br><span class="line">                    w=(*(*x).p).r;</span><br><span class="line">                &#125;</span><br><span class="line">                (*w).c=(*(*x).p).c;</span><br><span class="line">                (*(*x).p).c=true;</span><br><span class="line">                (*(*w).r).c=true;</span><br><span class="line">                myRB_Tree::Right_Rotate((*x).p);</span><br><span class="line">                x=root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            w=(*(*x).p).l;</span><br><span class="line">            if((*w).c==false)</span><br><span class="line">            &#123;</span><br><span class="line">                (*w).c=true;</span><br><span class="line">                (*(*x).p).c=false;</span><br><span class="line">                myRB_Tree::Right_Rotate((*x).p);</span><br><span class="line">                w=(*(*x).p).l;</span><br><span class="line">            &#125;</span><br><span class="line">            if((*(*w).r).c==true &amp;&amp; (*(*w).l).c==true)</span><br><span class="line">            &#123;</span><br><span class="line">                (*w).c=false;</span><br><span class="line">                x=(*x).p;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                if((*(*w).l).c==true)</span><br><span class="line">                &#123;</span><br><span class="line">                    (*(*w).r).c=true;</span><br><span class="line">                    (*w).c=false;</span><br><span class="line">                    myRB_Tree::Left_Rotate(w);</span><br><span class="line">                    w=(*(*x).p).l;</span><br><span class="line">                &#125;</span><br><span class="line">                (*w).c=(*(*x).p).c;</span><br><span class="line">                (*(*x).p).c=true;</span><br><span class="line">                (*(*w).l).c=true;</span><br><span class="line">                myRB_Tree::Right_Rotate((*x).p);</span><br><span class="line">                x=root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">node * myRB_Tree::Minimum(node * z)</span><br><span class="line">&#123;</span><br><span class="line">    while((*z).l!=&amp;mynil)</span><br><span class="line">        z=(*z).l;</span><br><span class="line">    return z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">node * myRB_Tree::Search(node * x,int k)</span><br><span class="line">&#123;</span><br><span class="line">    if(x==&amp;mynil || k==(*x).key)</span><br><span class="line">        return x;</span><br><span class="line">    if(k&lt;(*x).key)</span><br><span class="line">    &#123;</span><br><span class="line">        counter++;</span><br><span class="line">        return myRB_Tree::Search((*x).l,k);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        counter++;</span><br><span class="line">        return myRB_Tree::Search((*x).r,k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">myRB_Tree T;</span><br><span class="line">void myinsert(int key)</span><br><span class="line">&#123;</span><br><span class="line">    node * p=new node;</span><br><span class="line">    (*p).key=key;</span><br><span class="line">    p-&gt;l=&amp;T.mynil;</span><br><span class="line">    p-&gt;r=&amp;T.mynil;</span><br><span class="line">    T.Insert(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void mydelete(int key)</span><br><span class="line">&#123;</span><br><span class="line">    node * p = T.Search(T.root,key);</span><br><span class="line">    T.Delete(p);</span><br><span class="line">    delete(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;下面是基于C++的BST类实现&lt;/p&gt;
    
    </summary>
    
    
      <category term="algorithm" scheme="http://yoursite.com/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>微积分五讲</title>
    <link href="http://yoursite.com/2018/05/14/%E5%BE%AE%E7%A7%AF%E5%88%86%E4%BA%94%E8%AE%B2/"/>
    <id>http://yoursite.com/2018/05/14/微积分五讲/</id>
    <published>2018-05-14T12:47:58.000Z</published>
    <updated>2018-05-14T12:49:56.146Z</updated>
    
    <content type="html"><![CDATA[<h1 id="微积分五讲-笔记"><a href="#微积分五讲-笔记" class="headerlink" title="微积分五讲 笔记"></a>微积分五讲 笔记</h1><p>希尔伯特的演讲：数学中每一步真正的发展都与更有力的工具和更简单的方法的发现密切联系着，这些工具和方法同时会有助于理解已有的理论并把陈旧的、复杂的东西抛到一边。数学科学发展的这种特点是根深蒂固。</p><a id="more"></a><p>黎曼几何  爱因斯坦的相对论正是以“Riemann几何”作为其数学工具的</p><p>学习数学实际上就是一个以”高级“替代“低级”的过程，否则靠死记硬背，最后将会忘掉一切。</p><p>一元微积分的微积分基本定理的建立标志着微积分的诞生；分析算术化的胜利标志着微积分严格化的完成；外微分形式的产生，建立了多元微积分的微积分基本定理，标志着微积分的完成，并从古典走向近代。</p><p>非标准分析</p><p>分析算术化不是微积分严格化的唯一途径。</p><p>可微一定可积吗？ 不一定 导函数可能无界</p><p>扩展微积分：Lebesgue积分理论，现在称为实变函数或实分析</p><p>形象表述：先按钞票面值的大小分类，然后计算每一类的面额总值，再相加，这就是我的积分思想。如不按面值大小分类，而是按从钱袋中摸出的先后次序来计算总是，那就是Riemann积分的思想</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;微积分五讲-笔记&quot;&gt;&lt;a href=&quot;#微积分五讲-笔记&quot; class=&quot;headerlink&quot; title=&quot;微积分五讲 笔记&quot;&gt;&lt;/a&gt;微积分五讲 笔记&lt;/h1&gt;&lt;p&gt;希尔伯特的演讲：数学中每一步真正的发展都与更有力的工具和更简单的方法的发现密切联系着，这些工具和方法同时会有助于理解已有的理论并把陈旧的、复杂的东西抛到一边。数学科学发展的这种特点是根深蒂固。&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>git笔记</title>
    <link href="http://yoursite.com/2018/04/15/git%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/04/15/git笔记/</id>
    <published>2018-04-15T07:11:08.000Z</published>
    <updated>2018-04-15T07:12:18.627Z</updated>
    
    <content type="html"><![CDATA[<h1 id="git笔记"><a href="#git笔记" class="headerlink" title="git笔记"></a>git笔记</h1><p><code>git init</code> 初始化</p> <a id="more"></a><p>单独执行”git”指令会显示辅助说明;执行”git help -a”则显示完整的指令列表;执行 “git 指令 -help”(例如 “git init -help”) 则会显示该指令的网页说明文件。</p><p><code>git add filename</code></p><p><code>git commit -m &quot;description&quot; --author=&quot;name &lt;email&gt;&quot;</code>        </p><p><code>git commit --amend -m &#39;new description&#39; --author=&quot;name &lt;email&gt;&quot;</code></p><p><code>exit</code></p><p><code>.gitignore</code>忽略特定文件</p><p>Git有三个不同级别的配置文件,它们有不同的优先权.</p><ol><li>文件夹”.git”子文件夹内的config文件(只对它所在的文档库有效)</li><li>登陆账号的home directory中的.gitconfig文件(只对此账号登陆的用户有效)</li><li>Git程序的安装文件夹中的etc\gitconfig文件(对所有登陆账号和所有Git文档库都有效)</li></ol><p><code>git congif -l</code> 显示当前git的设置值。会显示三个配置文件中所有的设置项，顺序是先显示优先权最低的设置</p><p><code>git config --system -l</code><br><code>git config --global -l</code></p><p><code>git config user.name &quot;name&quot;</code><br><code>git config user.email &quot;email&quot;</code></p><p><code>git config --unset user.name</code></p><p><code>git config alias.指令别名 &#39;正式的指令和选项&#39;</code> 别名    </p><p><code>git commit</code> 启动文本编辑器来输入commit</p><p><code>git diff</code>    </p><p>Git 会将文件和文件夹分成以下三类:</p><ol><li>被追踪的(tracked);</li><li>忽略的(ignored);</li><li>不被追踪的(untracked);</li></ol><p><code>touch .gitignore</code></p><p><code>git rm --cached 文件名</code> add之后删除 这个文件将从tracked状态变成untracked状态</p><p><code>git reset HEAD 文件名</code> commit之后</p><p>取出文件:<code>git checkout commit 节点标识符或标签 文件1 文件2 ...</code>文件夹中的文件会被取出的文件覆盖</p><p><code>git grep</code></p><p><code>git blame</code></p><p><code>git mb 原文件名 新文件名</code> </p><p><code>git gc</code> 清理文档库</p><p><code>git log</code></p><p><code>git branch</code></p><p>一般情况下在切换分支之前，会先把最新的文件内容存入文档库</p><p><code>git branch -d 要删除的分支名称</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;git笔记&quot;&gt;&lt;a href=&quot;#git笔记&quot; class=&quot;headerlink&quot; title=&quot;git笔记&quot;&gt;&lt;/a&gt;git笔记&lt;/h1&gt;&lt;p&gt;&lt;code&gt;git init&lt;/code&gt; 初始化&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>OJ笔记#1</title>
    <link href="http://yoursite.com/2018/03/26/OJ%E7%AC%94%E8%AE%B0-1/"/>
    <id>http://yoursite.com/2018/03/26/OJ笔记-1/</id>
    <published>2018-03-26T03:08:21.000Z</published>
    <updated>2018-03-26T03:11:58.432Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OJ笔记-1"><a href="#OJ笔记-1" class="headerlink" title="OJ笔记#1"></a>OJ笔记#1</h1><h2 id="Non-negative-Partial-Sums"><a href="#Non-negative-Partial-Sums" class="headerlink" title="Non-negative Partial Sums"></a>Non-negative Partial Sums</h2><h3 id="My-soultion"><a href="#My-soultion" class="headerlink" title="My soultion"></a>My soultion</h3><p>不断减小序列的长度，最后两个负数间至少有一个整数，最后序列的第一个元素(正常情况下)为正数，最后一个元素可正可负</p> <a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">ios::sync_with_stdio(false);</span><br><span class="line">int n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">while(n!=0)</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;int&gt; a;</span><br><span class="line">bool b[1000000]=&#123;true&#125;;</span><br><span class="line">for(int i=0;i&lt;=n-1;i++)</span><br><span class="line">&#123;</span><br><span class="line">int in;</span><br><span class="line">cin&gt;&gt;in;</span><br><span class="line">a.push_back(in);</span><br><span class="line">if(i&gt;=1)</span><br><span class="line">&#123;</span><br><span class="line">if(a[a.size()-1]&lt;0)</span><br><span class="line">&#123;</span><br><span class="line">while(a.size()&gt;=2 &amp;&amp; a[a.size()-1]+a[a.size()-2]&lt;0)</span><br><span class="line">&#123;</span><br><span class="line">a[a.size()-2]+=a[a.size()-1];</span><br><span class="line">a.pop_back();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">if(a.size()&gt;1 &amp;&amp; a[0]&lt;0)</span><br><span class="line">&#123;</span><br><span class="line">a.push_back(a[0]);</span><br><span class="line">a.erase(a.begin());</span><br><span class="line">&#125;</span><br><span class="line">while(a.size()&gt;=2 &amp;&amp; a[a.size()-1]+a[a.size()-2]&lt;0)</span><br><span class="line">&#123;</span><br><span class="line">a[a.size()-2]+=a[a.size()-1];</span><br><span class="line">a.pop_back();</span><br><span class="line">&#125;</span><br><span class="line">int counter=0;</span><br><span class="line">for(int i=0;i&lt;a.size();i++)</span><br><span class="line">if(a[i]&gt;=0)</span><br><span class="line">counter++;</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;counter&lt;&lt;endl;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提高cin cout效率</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;OJ笔记-1&quot;&gt;&lt;a href=&quot;#OJ笔记-1&quot; class=&quot;headerlink&quot; title=&quot;OJ笔记#1&quot;&gt;&lt;/a&gt;OJ笔记#1&lt;/h1&gt;&lt;h2 id=&quot;Non-negative-Partial-Sums&quot;&gt;&lt;a href=&quot;#Non-negative-Partial-Sums&quot; class=&quot;headerlink&quot; title=&quot;Non-negative Partial Sums&quot;&gt;&lt;/a&gt;Non-negative Partial Sums&lt;/h2&gt;&lt;h3 id=&quot;My-soultion&quot;&gt;&lt;a href=&quot;#My-soultion&quot; class=&quot;headerlink&quot; title=&quot;My soultion&quot;&gt;&lt;/a&gt;My soultion&lt;/h3&gt;&lt;p&gt;不断减小序列的长度，最后两个负数间至少有一个整数，最后序列的第一个元素(正常情况下)为正数，最后一个元素可正可负&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="OJ" scheme="http://yoursite.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>无法接触的方程</title>
    <link href="http://yoursite.com/2018/02/25/%E6%97%A0%E6%B3%95%E8%A7%A3%E5%87%BA%E7%9A%84%E6%96%B9%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/02/25/无法解出的方程/</id>
    <published>2018-02-25T05:02:36.000Z</published>
    <updated>2018-02-25T05:04:30.483Z</updated>
    
    <content type="html"><![CDATA[<h1 id="无法解出的方程"><a href="#无法解出的方程" class="headerlink" title="无法解出的方程"></a>无法解出的方程</h1><p>平移对称 旋转对称 反射对称 滑移反射对称 置换 </p><a id="more"></a><p>量子力学是以概率的语言表述的</p><p>立体视觉,两只眼睛看到的像是不同的</p><p>这样一个问题:在我们周围的环境中，可以进行什么操作而让描述所有观察到的现象的规律不变？</p><p>棋盘是世界，棋子是宇宙中的诸现象，游戏规则是我们所称的自然规律。当代物理学家希望自然规律不仅代表游戏规则，而且可以解释棋盘和棋子本身的存在与特点！</p><p>有关宇宙唯一可以确定的是各种结果的概率，而非结果本身。上帝确实在掷骰子。</p><p>对称性是破解大自然设计奥秘的一种最重要的工具。</p><p>定义一个群的特点是：</p><ol><li>封闭性</li><li>结合律</li><li>单位元</li><li>逆元素</li></ol><p>由这个简单的定义可以产生一种包含和统一了世界上所有对称性的理论，这个事实一直令数学家吃惊。</p><p>群论被称为“数学抽象地顶尖艺术”</p><p>任何系统的所有对称变换集总是形成一个群。</p><p>爱因斯坦在”科学与幸福”的演讲中谈到:”对于人类自身及其命运的关注组成了所有技术努力的主要目标”</p><p>丢番图方程:如<code>29x+4=8y</code>(整数解).历史上最著名的丢番图方程是被称为费马大定理的那个方程<code>x^n + y^n = z^n</code>对于<code>n&gt;2</code>没有整数解。</p><p>阿贝尔和伽罗瓦</p><p>置换是伽罗瓦证明中的精华</p><p>魔方谜题的解答完全可以用群论的语言来说明</p><p>对置换性质的分析使我们可以自信地预测最终的结果，而不必实际进行试验。这也是伽罗瓦理论背后的基本哲学。</p><p>一个群中元素的数量叫做群的阶。例如，三个对象的置换群$S_3$的阶是6.</p><p>任何对象的对称集合构成一个群。</p><p>每一个群都映射在具有相同的模的置换群上。(同构)</p><p>子群。母群的阶除以子群的阶等于指数，指数总为整数。有限子群的阶总是等分其有限母群的阶。</p><p>正规子群</p><p>伽罗瓦证明，一个方程要有公式解，方程必须具有一种特定类型的伽罗瓦群特别地，如果由后代最大正规子群产生的每一个单独的指数是一个素数，那么伽罗瓦称这个群是可解的。一个方程存在公式解的条件是其伽罗瓦群可解。</p><p>伽罗瓦对五次方程解的寻找产生了“数学抽象地顶尖艺术”——群论。</p><p>一种相同的群结构可以描述似乎全然不同的概念</p><p>公式语言在计算机科学和复杂性理论(涉及计算任务内在的复杂性)方面起着重要作用。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;无法解出的方程&quot;&gt;&lt;a href=&quot;#无法解出的方程&quot; class=&quot;headerlink&quot; title=&quot;无法解出的方程&quot;&gt;&lt;/a&gt;无法解出的方程&lt;/h1&gt;&lt;p&gt;平移对称 旋转对称 反射对称 滑移反射对称 置换 &lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="读书" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>读的书与想读的书(除计算机)</title>
    <link href="http://yoursite.com/2018/02/23/%E8%AF%BB%E7%9A%84%E4%B9%A6%E4%B8%8E%E6%83%B3%E8%AF%BB%E7%9A%84%E4%B9%A6-%E9%99%A4%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    <id>http://yoursite.com/2018/02/23/读的书与想读的书-除计算机/</id>
    <published>2018-02-23T04:14:49.000Z</published>
    <updated>2018-05-20T12:26:26.106Z</updated>
    
    <content type="html"><![CDATA[<h1 id="读的书与想读的书-除计算机"><a href="#读的书与想读的书-除计算机" class="headerlink" title="读的书与想读的书(除计算机)"></a>读的书与想读的书(除计算机)</h1><p>斜体为未读，粗体为在读</p> <a id="more"></a><h2 id="文史哲"><a href="#文史哲" class="headerlink" title="文史哲"></a>文史哲</h2><ul><li><em>中国文学欣赏举隅</em></li><li>吾国吾民</li><li>罗生门</li><li>中国哲学简史</li></ul><h2 id="科普类"><a href="#科普类" class="headerlink" title="科普类"></a>科普类</h2><ul><li>无法解出的方程</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;读的书与想读的书-除计算机&quot;&gt;&lt;a href=&quot;#读的书与想读的书-除计算机&quot; class=&quot;headerlink&quot; title=&quot;读的书与想读的书(除计算机)&quot;&gt;&lt;/a&gt;读的书与想读的书(除计算机)&lt;/h1&gt;&lt;p&gt;斜体为未读，粗体为在读&lt;/p&gt;
    
    </summary>
    
    
      <category term="计划" scheme="http://yoursite.com/tags/%E8%AE%A1%E5%88%92/"/>
    
      <category term="记录" scheme="http://yoursite.com/tags/%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>读的书与想读的书(计算机)</title>
    <link href="http://yoursite.com/2018/02/23/%E8%AF%BB%E7%9A%84%E4%B9%A6%E4%B8%8E%E6%83%B3%E8%AF%BB%E7%9A%84%E4%B9%A6-%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    <id>http://yoursite.com/2018/02/23/读的书与想读的书-计算机/</id>
    <published>2018-02-23T04:14:26.000Z</published>
    <updated>2018-02-23T04:16:14.977Z</updated>
    
    <content type="html"><![CDATA[<h1 id="读的书与想读的书-计算机方面"><a href="#读的书与想读的书-计算机方面" class="headerlink" title="读的书与想读的书(计算机方面)"></a>读的书与想读的书(计算机方面)</h1><p>斜体为未读，粗体为在读</p> <a id="more"></a><h2 id="程序语言方面"><a href="#程序语言方面" class="headerlink" title="程序语言方面:"></a>程序语言方面:</h2><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><ul><li><em>C++ Primer</em></li></ul><h2 id="算法方面："><a href="#算法方面：" class="headerlink" title="算法方面："></a>算法方面：</h2><ul><li><em>算法导论</em></li></ul><h2 id="数学方面"><a href="#数学方面" class="headerlink" title="数学方面"></a>数学方面</h2><ul><li><strong>离散数学及其应用</strong></li><li><em>具体数学</em></li></ul><h2 id="Linux-Unix-Mac-OS-X-方面"><a href="#Linux-Unix-Mac-OS-X-方面" class="headerlink" title="Linux/Unix/Mac OS X 方面"></a>Linux/Unix/Mac OS X 方面</h2><h2 id="体系结构方面"><a href="#体系结构方面" class="headerlink" title="体系结构方面"></a>体系结构方面</h2><ul><li><em>深入理解计算机系统</em></li></ul><h2 id="科普类"><a href="#科普类" class="headerlink" title="科普类"></a>科普类</h2><ul><li><em>编码：隐匿在计算机软硬件背后的语言</em></li><li><em>黑客与画家</em></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;读的书与想读的书-计算机方面&quot;&gt;&lt;a href=&quot;#读的书与想读的书-计算机方面&quot; class=&quot;headerlink&quot; title=&quot;读的书与想读的书(计算机方面)&quot;&gt;&lt;/a&gt;读的书与想读的书(计算机方面)&lt;/h1&gt;&lt;p&gt;斜体为未读，粗体为在读&lt;/p&gt;
    
    </summary>
    
    
      <category term="计划" scheme="http://yoursite.com/tags/%E8%AE%A1%E5%88%92/"/>
    
      <category term="记录" scheme="http://yoursite.com/tags/%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Unix Programming Tools</title>
    <link href="http://yoursite.com/2018/02/15/Unix-Programming-Tools/"/>
    <id>http://yoursite.com/2018/02/15/Unix-Programming-Tools/</id>
    <published>2018-02-15T04:43:11.000Z</published>
    <updated>2018-02-16T06:38:57.802Z</updated>
    
    <content type="html"><![CDATA[<p><strong>已弃坑 待更</strong></p><h1 id="gcc"><a href="#gcc" class="headerlink" title="gcc"></a>gcc</h1><p>Gcc can compile C,C++(maybe g++),and objective-C. It is both a compiler and linker.</p><a id="more"></a><p>一步到位：<code>gcc main.c module1.c module2.c -o program</code></p><p>分开：<code>gcc -c main.c</code> <code>gcc -c module1.c</code> <code>gcc -c module2.c</code> <code>gcc main.o module1.o module2.o -o program</code></p><h2 id="command-line-options"><a href="#command-line-options" class="headerlink" title="command-line options"></a>command-line options</h2><p>-c <em>files</em> : Direct gcc to compile the source files into an object files without going through the linking stage. Makefiles (below) use this option to compile files one at a time.</p><p>-o <em>file</em> : Specifies that gcc’s output should be named file. If this option is not specified, then the default name used depends on the context…(a) if compiling a source .c file, the output object file will be named with the same name but with a .o extension. Alternately, (b) if linking to create an executable, the output file will be named a.out. Most often, the -o option is used to specify the output filename when linking an executable, while for compiling, people just let the default .c/.o naming take over.It’s a memorable error if your -o option gets switched around in the command line so it accidentally comes before a source file like “…-o foo.c program” – this can overwrite your source file – bye bye source file!</p><p>-g : Directs the compiler to include extra debugging information in its output. We recommend that you always compile your source with this option set, since we encourage you to gain proficiency using the debugger such as gdb (below).</p><p>-Wall : Give warnings about possible errors in the source code. </p><p>-I<em>dir</em> : Adds the directory dir to the list of directories searched for #include files.</p><p>-l<em>mylib</em> : (lower case ‘L’) Search the library named mylib for unresolved symbols (functions, global variables) when linking. The actual name of the file will be libmylib.a, and must be found in either the default locations for libraries or in a directory added with the -L flag (below).</p><p>-L<em>dir</em> </p><h1 id="make"><a href="#make" class="headerlink" title="make"></a>make</h1><p>The “make” utility automates the process of compiling and linking.</p><p>run make with no arguments in the project directory.and it will search for a file called <code>Makefile</code> or <code>makefile</code> for its build instructions.</p><h2 id="Makefiles"><a href="#Makefiles" class="headerlink" title="Makefiles"></a>Makefiles</h2><p>variable: for example <code>CC=gcc</code></p><p>standard variable names: </p><p>CC: The name of the C compiler, this will default to cc or gcc in most versions of make.</p><p>CFLAGS: A list of options to pass on to the C compiler for all of your source files. This is commonly used to set the include path to include non- standard directories (-I) or build debugging versions (-g).</p><p>LDFLAGS: A list of options to pass on to the linker. This is most commonly used to include application specific library files (-l) and set the library search path (-L).</p><p>To refer to the value of a variable, put a dollar sign ($) followed by the name in parenthesis or curly braces…</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CFLAGS = -g -I/usr/class/cs107/include</span><br><span class="line">$(CC) $(CFLAGS) -c binky.c</span><br></pre></td></tr></table></figure><p>The second major component of a makefile is the dependency/build rule.</p><p>A rule generally consists of two lines: a dependency line followed by a command line.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">binky.o : binky.c binky.h akbar.h </span><br><span class="line">tab$(CC) $(CFLAGS) -c binky.c</span><br></pre></td></tr></table></figure><h1 id="Unix-Shell"><a href="#Unix-Shell" class="headerlink" title="Unix Shell"></a>Unix Shell</h1><h2 id="Directory-Commands"><a href="#Directory-Commands" class="headerlink" title="Directory Commands"></a>Directory Commands</h2><p>cd <em>directory</em>: change directory</p><p>pwd : print working(current) directory</p><p>rm <em>file</em>: delete a file</p><p>mv <em>old</em> <em>new</em> : Rename a file(also works for moving things between directories).If exists, overwritten.</p><p>mkdir <em>name</em> : Create a directory</p><p>rmdir name : Delete a directory(must be empty)</p><h2 id="Shorthand-Notations-amp-Wildcards"><a href="#Shorthand-Notations-amp-Wildcards" class="headerlink" title="Shorthand Notations &amp; Wildcards"></a>Shorthand Notations &amp; Wildcards</h2><p>. : Current Directory</p><p>.. : Parent Directory</p><p>~ : Your home directory</p><p>~/cs107 : The cs107 directory in your home directory</p><p>~<em>user</em> : Home directory of <em>user</em></p><p> 通配符 : Any number of characters(not ‘.’)</p><p>? : Any single character(not ‘.’)</p><h2 id="Miscellaneous-Commands"><a href="#Miscellaneous-Commands" class="headerlink" title="Miscellaneous Commands"></a>Miscellaneous Commands</h2><p>cat <em>file</em> : Print the contents of <em>file</em> to standard output </p><p>more <em>file</em> : Same as <em>cat</em>,but only a page at a time.</p><p>less <em>file</em> : Same as <em>more</em>,but with navigability.</p><p>w : Find out who is on the system and what they are doing.</p><p>ps : List all your processed(use the process id’s in <strong>kill</strong> below)</p><p>jobs : Show jobs that have been suspended(use with fg)</p><p><em>program</em>&amp; : Runs <em>program</em> in the background.</p><p>ctrl-z : Suspend the current program.</p><p>% : Continue last job suspended, or use <strong>fg</strong>(foreground)</p><p>%<em>number</em> : Continue a particular job(the number comes from the <em>jobs</em> list)</p><p>kill <em>process-id</em> : Kill a process</p><p>kill -9 <em>process</em> : Kill a process with extreme prejudice </p><p>grep <em>exp</em> <em>files</em> : Search for an expression in a set of files.</p><p>wc <em>files</em> : Count words,lines and characters in a file</p><p>script : Start saving everything that happens in a file. Type <strong>exit</strong> when done</p><p>lpr <em>file</em> : Print <em>file</em> to the default printer</p><p>lpr -Pinky <em>file</em> : Print <em>file</em> to the printer named <em>inky</em></p><p>diff <em>file1</em> <em>file2</em> Show the differences between two files.</p><p>telnet <em>hostname</em> : Log on to another machine</p><p>source <em>file</em> : Execute the lines in the given file as if they were typed to the shell</p><h2 id="Getting-Help"><a href="#Getting-Help" class="headerlink" title="Getting Help"></a>Getting Help</h2><p>man <em>subject</em> : Read the manual entry on a particular subject</p><p>man -k keyword : Show all the manual pages for a particular keyword</p><h2 id="History"><a href="#History" class="headerlink" title="History"></a>History</h2><p>history : Show the most recent commands executed</p><p>!! : Re-execute the last command (or type up-arrow with modern shells)</p><p>!number : Re-execute a particular command by number</p><p>!<em>string</em> : Re-execute the last command beginning with string </p><p>^wrong^right^ : Re-execute the last command, substituting right for wrong</p><p>ctrl-P : Scroll backwards through previous commands</p><h2 id="Pipes"><a href="#Pipes" class="headerlink" title="Pipes"></a>Pipes</h2><p>a &gt; b : Redirect a’s standard output to overwrite file b</p><p>a &gt;&gt; b : Redirect a’s standard output to append to the file b</p><p>a &gt;&amp; b : Redirect a’s error output to overwrite file b</p><p>a &lt; b : Redirect a’s standard input to read from the file b</p><p>a | b : Redirect a’s standard output to b’s standard input</p><p>参考:<a href="http://cslibrary.stanford.edu/107/UnixProgrammingTools.pdf" target="_blank" rel="noopener">Unix Programming Tools from Standford Univer</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;已弃坑 待更&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;gcc&quot;&gt;&lt;a href=&quot;#gcc&quot; class=&quot;headerlink&quot; title=&quot;gcc&quot;&gt;&lt;/a&gt;gcc&lt;/h1&gt;&lt;p&gt;Gcc can compile C,C++(maybe g++),and objective-C. It is both a compiler and linker.&lt;/p&gt;
    
    </summary>
    
    
      <category term="Unix" scheme="http://yoursite.com/tags/Unix/"/>
    
      <category term="Tools" scheme="http://yoursite.com/tags/Tools/"/>
    
      <category term="Programming" scheme="http://yoursite.com/tags/Programming/"/>
    
  </entry>
  
  <entry>
    <title>2017秋寒假待学习内容(这是一篇flag) 2018.2</title>
    <link href="http://yoursite.com/2018/02/13/2017%E7%A7%8B%E5%AF%92%E5%81%87%E5%BE%85%E5%AD%A6%E4%B9%A0%E5%86%85%E5%AE%B9-%E8%BF%99%E6%98%AF%E4%B8%80%E7%AF%87flag-2018-2/"/>
    <id>http://yoursite.com/2018/02/13/2017秋寒假待学习内容-这是一篇flag-2018-2/</id>
    <published>2018-02-13T05:14:08.000Z</published>
    <updated>2018-07-08T01:13:43.931Z</updated>
    
    <content type="html"><![CDATA[<ul><li>机器学习</li><li>编写可读代码的艺术</li><li>离散数学及其应用</li><li>配置软件</li><li>github学习</li><li>git学习</li><li>…</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;机器学习&lt;/li&gt;
&lt;li&gt;编写可读代码的艺术&lt;/li&gt;
&lt;li&gt;离散数学及其应用&lt;/li&gt;
&lt;li&gt;配置软件&lt;/li&gt;
&lt;li&gt;github学习&lt;/li&gt;
&lt;li&gt;git学习&lt;/li&gt;
&lt;li&gt;…&lt;/li&gt;
&lt;/ul&gt;

      
    
    </summary>
    
    
      <category term="flag" scheme="http://yoursite.com/tags/flag/"/>
    
      <category term="计划" scheme="http://yoursite.com/tags/%E8%AE%A1%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>机器学习(周志华)笔记</title>
    <link href="http://yoursite.com/2018/02/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%91%A8%E5%BF%97%E5%8D%8E-%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/02/13/机器学习-周志华-笔记/</id>
    <published>2018-02-13T03:38:41.000Z</published>
    <updated>2018-02-14T04:55:59.093Z</updated>
    
    <content type="html"><![CDATA[<h1 id="机器学习笔记-学习中-进度堪忧"><a href="#机器学习笔记-学习中-进度堪忧" class="headerlink" title="机器学习笔记(学习中 进度堪忧)"></a>机器学习笔记(学习中 进度堪忧)</h1><h2 id="第1章-绪论"><a href="#第1章-绪论" class="headerlink" title="第1章 绪论"></a>第1章 绪论</h2><h3 id="1-1-引言"><a href="#1-1-引言" class="headerlink" title="1.1 引言"></a>1.1 引言</h3><p>通过对经验的利用，就能对新情况做出有效的决策。计算机在这方面可以帮忙。</p><p>机器学习致力于研究如何通过计算的手段，利用经验来改善系统自身的性能。机器学习所研究的主要内容，是关于在计算机上从数据中产生“模型”(model)的算法，即”学习算法”(learning algorithm).</p> <a id="more"></a><h3 id="1-2-基本术语"><a href="#1-2-基本术语" class="headerlink" title="1.2 基本术语"></a>1.2 基本术语</h3><p>一组记录的集合称为一个“数据集”(data set),其中每条记录是关于一个事件或对象的描述，称为一个“示例”(instance)或”样本”(sample)</p><p>反映事件或对象在某方面的表现或性质的事项称为”属性”(attribute)或”特征”(feature).属性上的取值称为”属性值”(attribute value).属性张成的空间称为”属性空间”(attribute space)、”样本空间”(sample space)或”输入空间”.我们也把一个示例称为一个”特征向量”(feature vector).</p><p>每个示例由d个属性描述,d称为样本的”维数”(dimensionality).</p><p>从数据中学得模型的过程称为”学习”(learning)或”训练”(training)</p><p>训练中使用的数据称为”训练数据”(training data),其中每个样本称为一个”训练样本”(training sample),训练样本组成的集合称为”训练集”(training set)</p><p>学得模型对应了关于数据的某种潜在的规律，因此亦称”假设”(hypothesis);这种潜在规律自身，则称为”真相”或”真实”(ground-truth).有时将模型称为”学习器”(learner),可以看作学习算法在给定数据和参数空间上的实例化.</p><p>标记(label);拥有了标记信息的示例,则称为”样例”(example).所有标记的集合称为”标记空间”(label space)或”输出空间”.</p><p>(<strong>x</strong>i,yi)表示第i个样例,<strong>x</strong>i是d维向量.</p><p>若欲预测的是离散值，此类学习任务称为”分类”(classification);若欲预测的是连续值,此类学习任务称为”回归”(regression).</p><p>对于只涉及两个类别的“二分类”(binary classification)任务，通常称其中一个类为”正类”(positive class),另一个类为”反类”(negative class)；涉及多个类别时,则称为“多分类”(multi-class classification)任务。</p><p>学得模型后，使用其进行预测的过程称为“测试”(testing),被预测的样本称为”测试样本”(testing sample) .</p><p>聚类(clustering),即将训练中的示例分成若干组，每组称为一个”簇”(cluster);这些自动形成的簇可能对应一些潜在的概念划分.这样的学习过程有助于我们了解数据内在的规律，能为更深入地分析数据建立基础.</p><p>根据训练数据是否拥有标记信息，学习任务可大致划分为两大类:”监督学习”(supervised learning)和”无监督学习”(unsupervised learning),分类和回归是前者的代表,而聚类则是后者的代表.</p><p>机器学习的目标是使学得的模型能更好地适用于”新样本”，而不是仅仅在训练样本上工作得好.学得模型适用于新样本的能力,称为”泛化”(generalization)能力.</p><p>通常假设样本空间中全体样本服从一个未知”分布”(distribution)<em>D</em>,我们获得的每个样本都是独立地从这个分布上采样获得的,即”独立同分布”(independent and identically distributed,简称<em>i.i.d</em>)</p><h3 id="1-3-假设空间"><a href="#1-3-假设空间" class="headerlink" title="1.3 假设空间"></a>1.3 假设空间</h3><p><em>归纳(induction)和演绎(deduction)科学推理的两大基本手段</em></p><p>归纳学习(inductive learning).狭义的归纳学习要求从训练数据中学得概念(concept),亦称为”概念学习”或”概念形成”.概念学习技术目前研究、应用都比较少，因为要学得泛化性能好且语义明确的概念实在太困难了,现实常用的技术大多是产生”黑箱”模型。</p><p>概念学习中最基本的是布尔概念学习.</p><p>“记住”训练样本，就是所谓的”机械学习”.</p><p>我们可以把学习过程看作一个在所有假设(hypothesis)组成的空间中进行搜索的过程,搜索目标是找到与训练集”匹配”(fit)的假设.现实问题中我们常面临很大的假设空间,但学习过程是基于有限样本训练集进行的,因此，可能有多个假设与训练集一致,即存在着一个与训练集一致的”假设集合”,我们称之为”版本空间”(version space)</p><h3 id="1-4-归纳偏好"><a href="#1-4-归纳偏好" class="headerlink" title="1.4 归纳偏好"></a>1.4 归纳偏好</h3><p>当有多个模型(假设)时，应该采纳哪一个.这时,学习算法本身的”偏好”就会起到关键的作用.</p><p>机器学习算法在学习过程中对某种类型假设的偏好,称为”归纳偏好”(inductive bias),或简称为”偏好”.</p><p>任何一个有效的机器学习算法必有其归纳偏好.</p><p>归纳偏好可看作学习算法自身在一个很庞大的假设空间中对假设进行选择的启发式或”价值观”.“奥卡姆剃刀”(Occam’s razor)是一种常用的、自然科学研究中最基本的原则，即“若有多个假设与观察一致，则选最简单的那个”</p><p>算法的归纳偏好是否与问题本身匹配，大多数时候直接决定了算法能否取得好的性能.</p><p>对于一个学习算法A,若它在某些问题上比学习算法B好,则必然存在另一些问题,在那里B比A好.这个结论对任何算法均成立.<strong>证明待看</strong></p><p>NFL定理(No Free Lunch Theorem)[Wolpert,1996;Wolpert and Macready,1995]</p><p>NFL的最重要寓意，是让我们清楚地认识到,脱离具体问题,空泛地谈论”什么学习算法更好”毫无意义。学习算法自身的归纳偏好与问题是否相配,往往会起到决定性的作用.</p><h3 id="1-5-发展历程"><a href="#1-5-发展历程" class="headerlink" title="1.5 发展历程"></a>1.5 发展历程</h3><p>二十世纪五十年代到七十年代初,人工智能研究处于”推理期”,那时认为人们只要能赋予机器逻辑推理能力，机器就能具有智能.人们逐渐认识到,仅具有逻辑推理能力是远远实现不了人工智能的.后来认为，要使机器具有智能，就必须设法使机器拥有知识.从二十世纪七十年代中期开始,人工智能研究进入了”知识期”。大量专家系统问世。但逐渐的专家系统面临”知识工程瓶颈”，简单地说，就是由人来把知识总结出来再教给计算机是相当困难的.</p><p>二十世纪五十年代初已有机器学习的相关研究,五十年代中后期，基于神经网络的”连接主义”(connectionism)学习开始出现。在六七十年代，基于逻辑表示的“符号主义”(symbolism)学习技术蓬勃发展,以决策理论为基础的学习技术以及强化学习技术等也得到发展。</p><p>总的来看，二十世纪八十年代是机器学习成为一个独立学科领域、各种机器学习技术百花初绽的时期。</p><p>在二十世纪八十年代，“从样例中学习”的一大主流是符号主义学习，其代表包括决策树(decision tree)和基于逻辑的学习.典型的决策树学习以信息论为基础，以信息熵的最小化为目标，直接模拟了人类对概念进行判定的树形流程.决策树学习技术由于简单易用,到今天仍是最常用的机器学习技术之一.</p><p>BP一直是被应用得最广泛的机器学习算法之一.连接主义学习的最大局限是其”试错性”</p><p>二十世纪九十年代中期,”统计学习”(statistical learning)闪亮登场并迅速占据主流舞台,代表性技术是支持向量机(Support Vector Machine,简称SVM)以及更一般的“核方法”(kernel methods).在支持向量机被普遍接受后,核技巧被人们用到了机器学习的几乎每一个角落，核方法(kernel trick)也逐渐成为机器学习的基本内容之一.</p><p>二十一世纪初,连接主义又卷土重来,掀起了以”深度学习”为名的热潮.所谓深度学习，狭义地说就是”很多层”的神经网络.</p><h3 id="1-6-应用现状"><a href="#1-6-应用现状" class="headerlink" title="1.6 应用现状"></a>1.6 应用现状</h3><h2 id="第二章-模型评估与选择"><a href="#第二章-模型评估与选择" class="headerlink" title="第二章 模型评估与选择"></a>第二章 模型评估与选择</h2><h3 id="2-1-经验误差与过拟合"><a href="#2-1-经验误差与过拟合" class="headerlink" title="2.1 经验误差与过拟合"></a>2.1 经验误差与过拟合</h3><p>“错误率”(error rate)：分类错误的样本数占样本总数的比例.</p><p>“精度”(accuracy)：精度 = 1-错误率</p><p>“误差”(error)：学习器的实际预测输出与样本的真实输出之间的差异</p><p>“训练误差”(training error)或”经验误差”(empirical error):学习器在训练集上的误差</p><p>“泛化误差”(generalization error)：学习器在新样本上的误差</p><p>我们希望得到泛化误差小的学习器.然而，我们事先并不知道新样本是什么样的,实际能做的是努力使经验误差最小化.</p><p>“过拟合”(overfitting):当学习器把训练样本学得”太好”了的时候,很可能已经把训练样本本身的一些特点当做了所有潜在样本都会具有的一般性质,这样就会导致泛化性能下降.</p><p>“欠拟合”(underfitting):指对训练样本的一般性质尚未学好。</p><p>欠拟合比较容易克服,例如在决策树学习中扩展分支、在神经网络学习中增加训练轮数等</p><p>过拟合是机器学习面临的关键障碍,过拟合是无法彻底避免的,我们所能做的只是”缓解”.只要相信P $\not=$ NP,过拟合就不可避免.</p><p>机器学习中的”模型选择”(model selection)问题,如何进行模型评估与选择呢？</p><p><strong>疑惑：这里的评估是对学习算法在这特定问题上表现的评估吧？</strong></p><h3 id="2-2-评估方法"><a href="#2-2-评估方法" class="headerlink" title="2.2 评估方法"></a>2.2 评估方法</h3><p>通常，我们可通过实验测试来对学习器的泛化误差进行评估并进而做出选择.为此，需使用一个“测试集”(testing set)来测试学习器对新样本的判别能力,然后以测试集上的“测试误差”(testing error)作为泛化误差的近似.测试集应该尽可能与训练集互斥.</p><p>有限的数据集,如何产生训练集<em>S</em>和测试集<em>T</em>.下面是几种常见的做法</p><h4 id="2-2-1-留出法-hold-out"><a href="#2-2-1-留出法-hold-out" class="headerlink" title="2.2.1 留出法(hold-out)"></a>2.2.1 留出法(hold-out)</h4><p>直接将数据集<em>D</em>划分为两个互斥的集合。</p><p>训练/测试集的划分要尽可能保持数据分布的一致性,避免因数据划分过程中中引入额外的偏差而对最终结果产生影响.”分层采样”(stratified sampling).</p><p>单次使用留出法得到的估计结果往往不够稳定可靠,在使用留出法时,一般要采用若干次随机划分、重复进行试验评估后取平均值作为留出法的评估结果.</p><p>保真性(fidelity),划分比例过大或过小导致的问题没有完美的解决方案,常见做法是将大约2/3~4/5的样本用于训练，剩余样本用于测试.</p><h4 id="2-2-2-交叉验证法-cross-validation"><a href="#2-2-2-交叉验证法-cross-validation" class="headerlink" title="2.2.2 交叉验证法(cross validation)"></a>2.2.2 交叉验证法(cross validation)</h4><p>将数据集<em>D</em>划分为k个子集,保证每个子集数据分布的一致性(可以通过分层采样).每次用k-1个子集训练，剩下的一个做测试集。这样可以得到k组.最后返回k个测试结果的均值.</p><p>这种方法的稳定性和保真性在很大程度上取决于k的取值，通常把这种方法称为”k折交叉验证”(<em>k</em>-fold cross validation).通常k取10</p><p>把数据集D划分为k个子集存在多种方式,所以为了减小划分不同引入的误差,通常要随机使用不同的划分重复p次,最终的评估结果是这p次k折交叉验证结果的均值.</p><p>假定数据集D中包含m个样本,若令k=m，则得到了交叉验证法的一个特例:留一法(Leave-One-Out,简称LOO)。显然，留一法不受随机样本划分方式的影响.留一法的评估结果往往被认为比较准确.留一法也有缺陷:在数据集比较大时，训练m个模型的计算开销可能是难以忍受的.而且这还是在未考虑算法调参的情况下.留一法的估计结果也未必永远比其他评估方法准确.</p><p>“没有免费午餐”定理对实验评估方法同样适用。</p><h4 id="2-2-3-自助法-bootstrapping-可重复采样"><a href="#2-2-3-自助法-bootstrapping-可重复采样" class="headerlink" title="2.2.3 自助法(bootstrapping)=可重复采样"></a>2.2.3 自助法(bootstrapping)=可重复采样</h4><p>有没有什么办法可以减少训练样本规模不同造成的影响,同时还能比较高效地进行实验估计呢？</p><p>”自助法“是一个比较好的解决方案,它直接以自助采样法(bootstrap sampling)为基础.就是相当于摸小球放回知道摸的次数与小球数相等。</p><p>样本在m次采样中始终不被采到的概率是 $(1-\frac{1}{m})^m$，取极限为 $\frac{1}{e} \approx 0.368$ ,将未被抽中的作为测试集。这样的测试结果，亦称”包外估计”(out-of-bag estimate).</p><p>自助法在数据集较小、难以有效划分训练/测试集时很有用；此时，自助法能从初始数据集中产生多个不同训练集,这对集成学习等学习方法有很大的好处。然而，自助法产生的数据集改变了初始数据集的分布，会引入估计偏差.因此在初始数据量足够时，留出法和交叉验证法更常用一些.</p><h4 id="2-2-4-调参-parameter-tuning-与最终模型"><a href="#2-2-4-调参-parameter-tuning-与最终模型" class="headerlink" title="2.2.4 调参(parameter tuning)与最终模型"></a>2.2.4 调参(parameter tuning)与最终模型</h4><p>参数可能在实数范围内取值，有着极大的调参工作量,以至于在不少应用任务中,参数调的好不好往往对最终模型性能有关键性影响。</p><p>模型选择完成后，学习算法和参数配置已选定,此时应该用数据集<em>D</em>重新训练模型.这才是我们最终提交给用户的模型.</p><p>验证集(validation set)存疑</p><h3 id="2-3-性能度量"><a href="#2-3-性能度量" class="headerlink" title="2.3 性能度量"></a>2.3 性能度量</h3><p>需要有衡量模型泛化能力的评价标准,这就是性能度量(performance measure).面对不同的任务需求，选用不同的性能度量。</p><p>回归任务最常用的性能度量是”均方误差”(mean squared error) <strong>公式待补</strong></p><p>下面主要介绍分类任务中常用的性能度量.</p><h4 id="2-3-1-错误率与精度"><a href="#2-3-1-错误率与精度" class="headerlink" title="2.3.1 错误率与精度"></a>2.3.1 错误率与精度</h4><p>这是分类任务中最常用的两种性能度量，既适用于二分类任务，也适用于多分类任务 <strong>公式待补</strong></p><h4 id="2-3-2-查准率-precision-、查全率-recall-与F1"><a href="#2-3-2-查准率-precision-、查全率-recall-与F1" class="headerlink" title="2.3.2 查准率(precision)、查全率(recall)与F1"></a>2.3.2 查准率(precision)、查全率(recall)与F1</h4><p>对于二分类问题,可将样例根据其真实类别与学习器预测类别的组合划分为真正例(true positive,TP)、假正例(false positive,FP)、真反例(true negative,TN)、假反例(false negative,FN)四种情形。<br>分类结果的”混淆矩阵”(confusion matrix)</p><table><thead><tr><th>真实情况</th><th>预测结果</th><th>预测结果 </th></tr></thead><tbody><tr><td>真实情况</td><td>正例</td><td>反例</td></tr><tr><td>正例</td><td>TP(真正例)</td><td>FN(假反例)</td></tr><tr><td>反例</td><td>FP(假正例)</td><td>TN(真反例)</td></tr></tbody></table><p>查准率P与查全率R分别定义为:<br>$$ P=\frac{TP}{TP+FP} $$</p><p>$$R=\frac{TP}{TP+FN}$$</p><p>查准率和查全率是一对矛盾的度量.一般来说，查准率高时，查全率往往偏低;反之类似.</p><p>查准率-查全率曲线,简称”P-R曲线“，显示该曲线的图称为”P-R图“.</p><p>若一个学习器的P-R曲线被另一个学习器的曲线完全”包住”，则可断言后者的性能优于前者.</p><p>若两个学习器的P-R曲线发生了交叉,则一般难以一般性地断言两者孰优孰劣,只能在具体的查准率或查全率条件下进行比较.仍希望比个高低,这时一个比较合理的判据是比较P-R曲线下面积的大小。</p><p>人们设计了一些综合考察查准率、查全率的性能度量.</p><p>”平衡点“(Break-Even Point,简称BEP)就是这样一个度量,它是”查准率=查全率“时的取值</p><p>但BEP还是过于简化了些，更常用的是F1度量:</p><p>$$F1=\frac{2 \times P \times R}{P+R} = \frac{2 \times TP}{样例总数+TP-TN}$$</p><p>F1是基于查准率与查全率的调和平均(harmonic mean)定义的</p><p>F1的一般形式是$F<em>{\beta}$，能让我们表达出对查准率/查全率的不同偏好,$F</em>{\beta}$是加权调和平均.</p><p>$$F_{\beta} = \frac{1+\beta^2 \times P \times R}{(\beta^2 \times P) + R}$$</p><p>其中$\beta &gt;0$度量了查全率对查准率的相对重要性.$\beta = 1$时退化为标准的F1;$\beta &gt;1$时查全率有更大影响；$\beta &lt;1$时查准率有更大影响</p><p>我们希望在n个二分类混淆矩阵上综合考察查准率和查全率.</p><p>一种直接的做法是先在各混淆矩阵上分别计算出查准率和查全率，然后计算平均值,这样就得到”宏查准率”(macro-P)、”宏查全率”(macro-R),以及相应的”宏F1”(macro-F1):</p><p>还有一种:先将各混淆矩阵的对应的元素进行平均,再基于这些平均值计算出”微查准率”(micro-P)、”微查全率”(micro-R)和”微F1”(micro-F1)</p><h4 id="2-3-3-ROC与AUC"><a href="#2-3-3-ROC与AUC" class="headerlink" title="2.3.3 ROC与AUC"></a>2.3.3 ROC与AUC</h4><p>分类阈值(threshold) 截断点(cut point)</p><p>排序本身的质量好坏,体现了综合考虑学习器在不同任务下的”期望泛化性能”的好坏，或者说，”一般情况下“泛化性能的好坏，ROC曲线则是从这个角度出发来研究学习器泛化性能的有力工具.</p><p>ROC全称是”受试者工作特征“(Receiver Operating Characteristic)曲线</p><p>ROC曲线的纵轴是”真正例率“(True Positive Rate,简称”TPR”),横轴是”假正例率”(False Positive Rate,简称FPR)</p><p>$$TPR = \frac{TP}{TP+FN}$$</p><p>$$FPR = \frac{FP}{TN+FP}$$</p><p>两条ROC曲线的比较类似于P-R曲线类似. ROC曲线下的面积,即AUC(Area Under ROC Curve)</p><p><strong>公式待补</strong></p><p>排序”损失”(loss)的定义为: <strong>公式待补</strong></p><p>$l<em>{rank}$对应的是ROC曲线之上的面积,AUC = 1-$l</em>{rank}$</p><h4 id="2-3-4-代价敏感错误率与代价曲线"><a href="#2-3-4-代价敏感错误率与代价曲线" class="headerlink" title="2.3.4 代价敏感错误率与代价曲线"></a>2.3.4 代价敏感错误率与代价曲线</h4><p>为权衡不同类型错误所造成的不同损失，可为错误赋予”非均等代价”(unequal cost).</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;机器学习笔记-学习中-进度堪忧&quot;&gt;&lt;a href=&quot;#机器学习笔记-学习中-进度堪忧&quot; class=&quot;headerlink&quot; title=&quot;机器学习笔记(学习中 进度堪忧)&quot;&gt;&lt;/a&gt;机器学习笔记(学习中 进度堪忧)&lt;/h1&gt;&lt;h2 id=&quot;第1章-绪论&quot;&gt;&lt;a href=&quot;#第1章-绪论&quot; class=&quot;headerlink&quot; title=&quot;第1章 绪论&quot;&gt;&lt;/a&gt;第1章 绪论&lt;/h2&gt;&lt;h3 id=&quot;1-1-引言&quot;&gt;&lt;a href=&quot;#1-1-引言&quot; class=&quot;headerlink&quot; title=&quot;1.1 引言&quot;&gt;&lt;/a&gt;1.1 引言&lt;/h3&gt;&lt;p&gt;通过对经验的利用，就能对新情况做出有效的决策。计算机在这方面可以帮忙。&lt;/p&gt;
&lt;p&gt;机器学习致力于研究如何通过计算的手段，利用经验来改善系统自身的性能。机器学习所研究的主要内容，是关于在计算机上从数据中产生“模型”(model)的算法，即”学习算法”(learning algorithm).&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>mac已装软件目录</title>
    <link href="http://yoursite.com/2018/02/10/mac%E5%B7%B2%E8%A3%85%E8%BD%AF%E4%BB%B6%E7%9B%AE%E5%BD%95/"/>
    <id>http://yoursite.com/2018/02/10/mac已装软件目录/</id>
    <published>2018-02-10T07:34:43.000Z</published>
    <updated>2018-05-14T12:45:47.315Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mac已装软件目录-更新至2018-5-14"><a href="#Mac已装软件目录-更新至2018-5-14" class="headerlink" title="Mac已装软件目录(更新至2018.5.14)"></a>Mac已装软件目录(更新至2018.5.14)</h1><h2 id="Develop"><a href="#Develop" class="headerlink" title="Develop"></a>Develop</h2><ul><li>Xcode</li><li>PyCharm Edu : for python</li><li>MATLAB_R2016b</li><li>Sublime Text</li><li>Mathematic</li><li>iTerm</li><li>Dash</li><li>ScriptFlow</li><li>IconKit<a id="more"></a></li></ul><h2 id="Design"><a href="#Design" class="headerlink" title="Design"></a>Design</h2><ul><li>Adobe Photoshop CC</li><li>Adobe Premiere Pro CC</li><li>Adobe Audition CC</li><li>Total Video Converter Lite</li><li>Sketch</li><li>xScope</li></ul><h2 id="Text"><a href="#Text" class="headerlink" title="Text"></a>Text</h2><ul><li>MacDown</li><li>Evernote</li><li>Texshop</li><li>Pages Keynote Numbers</li><li>VS Code</li></ul><h2 id="Tools"><a href="#Tools" class="headerlink" title="Tools"></a>Tools</h2><ul><li>Chrome</li><li>Firefox</li><li>Parallels Desktop</li><li>EuDic</li><li>iStat Menus</li><li>Baidu Netdisk</li><li>Reeder</li><li>iText</li><li>uTorrent</li><li>WonderPen</li><li>The Unarchiver</li><li>每日英语听力</li><li>XMind</li><li>Reflector 2</li><li>Qlpmsg</li><li>Focusky</li><li>DjView</li><li>CAJCloudViewer</li><li>Blackmagic Disk Speed Test</li><li>1Checker</li><li>1Keyboard</li><li>Disk Graph</li><li>PDF Expert</li><li>WiFi Explorer Pro</li><li>UltraEdit</li><li>WebTorrent</li><li>RescueTime</li><li>OmniGraffle</li><li>Xee</li><li>Workspaces</li></ul><h2 id="Entertainment"><a href="#Entertainment" class="headerlink" title="Entertainment"></a>Entertainment</h2><ul><li>youku</li><li>mpv</li><li>aiqiyi</li><li>QQ Music</li><li>Netease Music</li><li>Steam</li><li>Lep’s World 2</li><li>IINA</li></ul><h2 id="Social-Networking"><a href="#Social-Networking" class="headerlink" title="Social Networking"></a>Social Networking</h2><ul><li>WeChat</li><li>QQ</li></ul><h2 id="Plugins"><a href="#Plugins" class="headerlink" title="Plugins"></a>Plugins</h2><ul><li>Snap</li><li>ShadowsocksX-R</li><li>Irvue</li><li>Alfred 3</li><li>Kap : for screen capturing</li><li>Homebrew</li><li>zsh</li><li>pandoc : File converting</li><li>Bartender 3</li></ul><h2 id="Virtual-Machine"><a href="#Virtual-Machine" class="headerlink" title="Virtual Machine"></a>Virtual Machine</h2><ul><li>Windows 10</li><li>Ubuntu</li><li>Kali Linux </li></ul><h2 id="待装"><a href="#待装" class="headerlink" title="待装"></a>待装</h2><ul><li>SPSS</li><li>Dash</li><li>UltraEdit</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Mac已装软件目录-更新至2018-5-14&quot;&gt;&lt;a href=&quot;#Mac已装软件目录-更新至2018-5-14&quot; class=&quot;headerlink&quot; title=&quot;Mac已装软件目录(更新至2018.5.14)&quot;&gt;&lt;/a&gt;Mac已装软件目录(更新至2018.5.14)&lt;/h1&gt;&lt;h2 id=&quot;Develop&quot;&gt;&lt;a href=&quot;#Develop&quot; class=&quot;headerlink&quot; title=&quot;Develop&quot;&gt;&lt;/a&gt;Develop&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Xcode&lt;/li&gt;
&lt;li&gt;PyCharm Edu : for python&lt;/li&gt;
&lt;li&gt;MATLAB_R2016b&lt;/li&gt;
&lt;li&gt;Sublime Text&lt;/li&gt;
&lt;li&gt;Mathematic&lt;/li&gt;
&lt;li&gt;iTerm&lt;/li&gt;
&lt;li&gt;Dash&lt;/li&gt;
&lt;li&gt;ScriptFlow&lt;/li&gt;
&lt;li&gt;IconKit
    
    </summary>
    
    
      <category term="Mac" scheme="http://yoursite.com/tags/Mac/"/>
    
      <category term="软件" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="记录" scheme="http://yoursite.com/tags/%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Python笔记</title>
    <link href="http://yoursite.com/2018/02/09/Python%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/02/09/Python笔记/</id>
    <published>2018-02-09T12:42:21.000Z</published>
    <updated>2018-02-09T12:44:06.714Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python笔记-未完待续"><a href="#Python笔记-未完待续" class="headerlink" title="Python笔记(未完待续)"></a>Python笔记(未完待续)</h1><h2 id="Python特点"><a href="#Python特点" class="headerlink" title="Python特点"></a>Python特点</h2><ul><li>简单</li><li>解释型</li><li>交互式</li><li>可移植</li><li>面向对象</li></ul><h2 id="Python特性"><a href="#Python特性" class="headerlink" title="Python特性"></a>Python特性</h2><ul><li>动态类型</li><li>自动内存管理</li><li>大型程序支持</li><li>内置对象类型</li></ul><h2 id="Python彩蛋"><a href="#Python彩蛋" class="headerlink" title="Python彩蛋"></a>Python彩蛋</h2><p>在交互解释器里输入<code>import this</code></p> <a id="more"></a><h2 id="Python解释器"><a href="#Python解释器" class="headerlink" title="Python解释器"></a>Python解释器</h2><p>有很多种，最常用的是CPython。 </p><p>解释器是输入一行就执行一行</p><p>输入<code>exit()</code>来退出解释器。</p><p>在终端里输入<code>python3 Filename.py</code>来执行python文件</p><p>在Mac和Linux上可以直接运行<code>.py</code>文件，方法是在<code>.py</code>文件的第一行加上一个特殊的注释:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br></pre></td></tr></table></figure><p>然后通过命令给<code>hello.py</code>以执行权限:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ chmod a+x hello.py</span><br></pre></td></tr></table></figure><p>以下一行注释是为了告诉Python解释器，按照UTF-8编码读取源代码，否则可能中文会有乱码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br></pre></td></tr></table></figure><h2 id="Python语法"><a href="#Python语法" class="headerlink" title="Python语法"></a>Python语法</h2><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p><code>print()</code>用<code>,</code>隔开多个输出。<strong>遇到逗号会输出一个空格</strong></p><h4 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h4><h5 id="print-方法"><a href="#print-方法" class="headerlink" title="print()方法"></a>print()方法</h5><table><thead><tr><th>占位符</th><th>替换内容 </th></tr></thead><tbody><tr><td>%d</td><td>整数  </td></tr><tr><td>%f</td><td>浮点数  </td></tr><tr><td>%s</td><td>字符串  </td></tr><tr><td>%x</td><td>十六进制整数</td></tr></tbody></table><h5 id="format-方法"><a href="#format-方法" class="headerlink" title="format()方法"></a>format()方法</h5><p>另一种格式化字符串的方法是使用字符串的format()方法，它会用传入的参数依次替换字符串内的占位符{0}、{1}……，不过这种方式写起来比%要麻烦得多：</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p><code>input()</code>。如:<code>name = input()</code>。又如<code>name = input(&#39;please enter your name&#39;)</code></p><p><code>input()</code>返回的是<code>str</code>类型，要进行转换，如<code>int()</code></p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>以<code>#</code>开头</p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="整数-int"><a href="#整数-int" class="headerlink" title="整数(int)"></a>整数(int)</h4><h4 id="浮点数-float"><a href="#浮点数-float" class="headerlink" title="浮点数(float)"></a>浮点数(float)</h4><h4 id="字符串-str"><a href="#字符串-str" class="headerlink" title="字符串(str)"></a>字符串(str)</h4><p>(<code>&#39;</code>和<code>&quot;</code>都可以) 可以用<code>r&#39;&#39;</code>表示<code>&#39;&#39;</code>里的字符串默认不转义 </p><p><code>ord()</code>获取字符的整数表示，<code>chr()</code>将编码转换为对应的字符 </p><p><code>encode()</code>和<code>decode()</code>方法 </p><p><code>len()</code>函数计算的是<code>str</code>的字符数,如果换成<code>bytes</code>,则计算字节数</p><h4 id="布尔值-bool"><a href="#布尔值-bool" class="headerlink" title="布尔值(bool)"></a>布尔值(bool)</h4><p>(<code>True</code>和<code>False</code>, <code>and</code>、<code>or</code>和<code>not</code>运算)</p><h4 id="空值"><a href="#空值" class="headerlink" title="空值"></a>空值</h4><p>用<code>None</code>表示</p><h4 id="列表-list"><a href="#列表-list" class="headerlink" title="列表(list)"></a>列表(list)</h4><p><code>classmates = [&#39;Michael&#39;, &#39;Bob&#39;, &#39;Tracy&#39;]</code> </p><p>可以用len()函数获取list的元素个数，</p><p>运用索引访问，从0开始，用-1做索引可以直接获取最后一个元素，一次类推，可以获取倒数第2个、倒数第3个···。</p><p>list有序可变：<code>append(element)</code>方法追加至末尾,<code>insert(position,element)</code>方法追插入至指定位置，删除末尾用<code>pop()</code>,删除指定位置的用<code>pop(i)</code>。</p><p>list里的元素可以不同类型，且可嵌套。</p><p>list有<code>sort()</code>方法</p><h4 id="元组-tuple"><a href="#元组-tuple" class="headerlink" title="元组(tuple)"></a>元组(tuple)</h4><p><code>classmates = (&#39;Michael&#39;, &#39;Bob&#39;, &#39;Tracy&#39;)</code></p><p>tuple与list类似，但是tuple一旦初始化就不能修改,即tuple没有append(),insert()方法。</p><p>定义一个只有1个元素的tuple得这样定义:<code>t=(1,)</code>。 </p><p>tuple里嵌套的list可变</p><h4 id="字典-dict"><a href="#字典-dict" class="headerlink" title="字典(dict)"></a>字典(dict)</h4><p>(<code>d = {&#39;Michael&#39;: 95, &#39;Bob&#39;: 75, &#39;Tracy&#39;: 85}</code>)</p><p>在其他语言中也称为map，使用键-值(key-value)储存。</p><p>一个key只能对应一个value，多次放入会把前面的值冲掉。</p><p>用<code>in</code>判断key是否存在如<code>&gt;&gt;&gt; &#39;Thomas&#39; in d</code>。<code>get()</code>方法，</p><p>如果key不存在就返回<code>None</code>,或者自己指定的value，如<code>d.get(&#39;Thomas,-1&#39;)</code></p><p>要删除一个key，用pop(key),对应的value也会从dict中删除。</p><p>dict的key必须是不可变对象，所以list不能作为key</p><p><code>dict</code>的<code>items()</code>可以同时迭代key和value:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for k,v in d.items():</span><br><span class="line">print(k,&apos;=&apos;,v)</span><br></pre></td></tr></table></figure><p>list特点：</p><ol><li>查找和插入的时间随着元素的增加而增加；</li><li>占用空间小，浪费内存很少。</li></ol><p>dict特点：</p><ol><li>找和插入的速度极快，不会随着key的增加而变慢；</li><li>需要占用大量的内存，内存浪费多。</li></ol><h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><p>set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key,重复元素在set中自动被过滤。</p><p>要创建一个set，需要提供一个list作为输入集合：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = set([1, 2, 3])</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">&#123;1, 2, 3&#125;</span><br></pre></td></tr></table></figure><p><code>add(key)</code>方法来添加key，<code>remove(key)</code>方法可以删除元素</p><p><code>s1 &amp; s2</code>：集合交， <code>s1 | s2</code>集合并</p><h4 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h4><p><code>int()</code> <code>float()</code> <code>str()</code> <code>bool()</code></p><p><em>变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言</em><br><em>返回<code>None</code>的时候Python的交互环境不显示结果</em><br><em>常量名常用大写表示，如<code>PI</code></em></p><p><em>Python中有两种除法,<code>/</code>的结果是浮点数，’//‘的结果是整数</em></p><p><em>取余为<code>%</code></em></p><p><em>UTF-8为可变长编码，把一个Unicode字符根据不同的数字大小编码成1-6个字节</em></p><h3 id="程序结构"><a href="#程序结构" class="headerlink" title="程序结构"></a>程序结构</h3><h4 id="分支语句"><a href="#分支语句" class="headerlink" title="分支语句"></a>分支语句</h4><h5 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if &lt;条件判断1&gt;:</span><br><span class="line">    &lt;执行1&gt;</span><br><span class="line">elif &lt;条件判断2&gt;:</span><br><span class="line">    &lt;执行2&gt;</span><br><span class="line">elif &lt;条件判断3&gt;:</span><br><span class="line">    &lt;执行3&gt;</span><br><span class="line">else:</span><br><span class="line">    &lt;执行4&gt;</span><br></pre></td></tr></table></figure><p>判断条件还可以简写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if x:</span><br><span class="line">    print(&apos;True&apos;)</span><br></pre></td></tr></table></figure><p>只要<code>x</code>是非零数值、非空字符串、非空list等，就判断为<code>True</code>，否则为<code>False</code>。</p><h4 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h4><h5 id="for"><a href="#for" class="headerlink" title="for"></a>for</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">names = [&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;]</span><br><span class="line">for name in names:</span><br><span class="line">    print(name)</span><br></pre></td></tr></table></figure><p><em><code>range()</code>函数可以生成一个整数序列，比如<code>range(5)</code>生成的序列是从0开始小于5的整数</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sum = 0</span><br><span class="line">for x in range(101):</span><br><span class="line">    sum = sum + x</span><br><span class="line">print(sum)</span><br></pre></td></tr></table></figure><h5 id="while"><a href="#while" class="headerlink" title="while"></a>while</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sum = 0</span><br><span class="line">n = 99</span><br><span class="line">while n &gt; 0:</span><br><span class="line">    sum = sum + n</span><br><span class="line">    n = n - 2</span><br><span class="line">print(sum)</span><br></pre></td></tr></table></figure><p><em><code>break</code>和<code>continue</code>与C++中类似。</em></p><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”：<code>a = abs</code></p><h5 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def my_abs(x):</span><br><span class="line">    if x &gt;= 0:</span><br><span class="line">        return x</span><br><span class="line">    else:</span><br><span class="line">        return -x</span><br></pre></td></tr></table></figure><p><code>return None</code>可以简写为<code>return</code></p><h6 id="空函数"><a href="#空函数" class="headerlink" title="空函数"></a>空函数</h6><p>可以用<code>pass</code>语句，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def nop():</span><br><span class="line">pass</span><br></pre></td></tr></table></figure><p><code>pass</code>也可以放在其他语句里,如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if condition:</span><br><span class="line">pass</span><br></pre></td></tr></table></figure><h6 id="参数检查"><a href="#参数检查" class="headerlink" title="参数检查"></a>参数检查</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def my_abs(x):</span><br><span class="line">    if not isinstance(x, (int, float)):</span><br><span class="line">        raise TypeError(&apos;bad operand type&apos;)</span><br><span class="line">    if x &gt;= 0:</span><br><span class="line">        return x</span><br><span class="line">    else:</span><br><span class="line">        return -x</span><br></pre></td></tr></table></figure><p>函数可以返回多个值(实质上是tuple)，并可按位置赋给相应的变量</p><h6 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h6><p><code>def power(x,n=2):</code></p><p><em>必选参数在前，默认参数在后。</em><br><em>不按默认顺序提供参数是，需要把参数名写上。</em><br><em>定义默认参数要牢记一点：默认参数必须指向不变对象！不然不同次的调用会出现不同的结果。</em></p><h6 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h6><p><code>def calc(*numbers):</code>相当于传入一个tuple</p><p>若已有list和tuple 可这样调用<code>calc(*nums)</code></p><h6 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h6><p><code>def person(name, age, **kw):</code>:会组建一个dict</p><p>和可变参数类似，也可以先组装出一个dict，然后，把该dict转换为关键字参数传进去：</p><h6 id="命名关键字参数"><a href="#命名关键字参数" class="headerlink" title="命名关键字参数"></a>命名关键字参数</h6><p>如果要限制关键字参数的名字，就可以用命名关键字参数，例如，只接收city和job作为关键字参数。这种方式定义的函数如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def person(name, age, *, city, job):</span><br><span class="line">    print(name, age, city, job)</span><br></pre></td></tr></table></figure><p>和关键字参数<code>**kw</code>不同，命名关键字参数需要一个特殊分隔符<code>*</code>，<code>*</code>后面的参数被视为命名关键字参数。</p><p>如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符*了：</p><p>命名关键字参数必须传入参数名，这和位置参数不同。如果没有传入参数名，调用将报错：</p><p>命名关键字参数可以有缺省值，从而简化调用：</p><h6 id="参数组合"><a href="#参数组合" class="headerlink" title="参数组合"></a>参数组合</h6><p>在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。</p><h5 id="函数递归"><a href="#函数递归" class="headerlink" title="函数递归"></a>函数递归</h5><p><em>尾递归可以进行优化，但大多数编译器和解释器没有进行优化</em></p><h4 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h4><p>可以对list,tuple,str操作，相当于截取，如:<code>l[1:3]</code>取索引为1和2的元素组成一个list，还可以设置间隔如：<code>l[0:100;5]</code>每五个取一个</p><h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><p>for…in 可以迭代任何可迭代的对象(如dict)</p><p>如何判断是否可以迭代：通过collections模块的Iterable类型判断。<br><code>isinstance(&#39;abc&#39;, Iterable)</code></p><p>Python内置的<code>enumerate</code>函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for i,value in enumerate([&apos;A&apos;,&apos;B&apos;,&apos;C&apos;]):</span><br><span class="line">print(i,value)</span><br></pre></td></tr></table></figure><h4 id="列表生成式-List-Comprehension"><a href="#列表生成式-List-Comprehension" class="headerlink" title="列表生成式(List Comprehension)"></a>列表生成式(List Comprehension)</h4><p><code>list(range(1,11))</code>生成<code>[1,2,3,4,5,6,7,8,9,10]</code></p><p><code>[x * x for x in range(1,11)]</code>生成 <code>[1,4,9,16,25,36,49,64,81,100]</code></p><p><code>[x * x for x in range(1,11) if x % 2 == 0]</code>生成<code>[4,16,36,64,100]</code></p><p><code>[m+n for m in &#39;ABC&#39; for n in &#39;XYZ&#39;]</code>生成<code>[&#39;AX&#39;, &#39;AY&#39;, &#39;AZ&#39;, &#39;BX&#39;, &#39;BY&#39;, &#39;BZ&#39;, &#39;CX&#39;, &#39;CY&#39;, &#39;CZ&#39;]</code></p><h4 id="生成器-generator"><a href="#生成器-generator" class="headerlink" title="生成器(generator)"></a>生成器(generator)</h4><p>边循环边计算，把<code>[]</code>变为<code>()</code>就可以了</p><p>可以通过<code>next()</code>打印generator的下一个返回值 </p><p>还可以用for循环迭代</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">g = (x*x for x in range(10))</span><br><span class="line">for n in g:</span><br><span class="line">print(n)</span><br></pre></td></tr></table></figure><p>如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator。generator和函数的执行流程不一样。函数是顺序执行，遇到return语句或者最后一行函数语句就返回。而变成generator的函数，在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行。</p><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>凡是可作用于<code>for</code>循环的对象都是<code>Iterable</code>类型；</p><p>凡是可作用于<code>next()</code>函数的对象都是<code>Iterator</code>类型，它们表示一个惰性计算的序列；</p><p>可以使用<code>isinstance()</code>判断一个对象是否是<code>Iterator</code>对象：</p><p>集合数据类型如<code>list</code>、<code>dict</code>、<code>str</code>等是<code>Iterable</code>但不是<code>Iterator</code>，不过可以通过<code>iter()</code>函数获得一个<code>Iterator</code>对象。</p><p>Python的<code>for</code>循环本质上就是通过不断调用<code>next()</code>函数实现的</p><h4 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h4><h5 id="高阶函数（Higher-order-function）"><a href="#高阶函数（Higher-order-function）" class="headerlink" title="高阶函数（Higher-order-function）"></a>高阶函数（Higher-order-function）</h5><p>函数可以赋值给变量，函数名也是变量</p><p>一个函数接受另一个函数作为参数，这种函数被称为高阶函数。</p><h6 id="map-和reduce-函数"><a href="#map-和reduce-函数" class="headerlink" title="map()和reduce()函数"></a><code>map()</code>和<code>reduce()</code>函数</h6><p><code>map()</code>函数接受两个参数，一个是函数，一个是<code>Iterable</code>,<code>map</code>将传入的函数依次作用到序列的每个元素，并把结果作为新的<code>Iterator</code>返回</p><p><code>reduce()</code>把一个函数作用在一个序列<code>[x1,x2,x3,...]</code>上。<code>reduce</code>把结果继续和序列的下一个元素做累积计算</p><p><code>reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)</code></p><h6 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h6><p>Python内建的<code>filter()</code>函数用于过滤序列。</p><p><code>filter()</code>把传入的函数依次作用于每个元素，然后根据返回值是<code>True</code>还是<code>False</code>决定保留还是丢弃该元素。</p><p><code>filter()</code>函数返回的是一个<code>Iterator</code>，也就是一个惰性序列，所以要强迫<code>filter()</code>完成计算结果，需要用<code>list()</code>函数获得所有结果并返回list。</p><h6 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h6><p><code>sorted()</code>函数也是一个高阶函数，它还可以接收一个<code>key</code>函数来实现自定义的排序,如：</p><p><code>sorted([36, 5, -12, 9, -21], key=abs)</code></p><p>默认情况下，对字符串排序，是按照ASCII的大小比较的，</p><p>要进行反向排序，不必改动key函数，可以传入第三个参数<code>reverse=True</code></p><h5 id="返回函数"><a href="#返回函数" class="headerlink" title="返回函数"></a>返回函数</h5><p>函数作为返回值</p><p>闭包：返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。如果一定要引用循环变量怎么办？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变：</p><p>返回一个函数时，牢记该函数并未执行，返回函数中不要引用任何可能会变化的变量。</p><h5 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h5><p>当我们在传入函数时，有些时候，不需要显式地定义函数，直接传入匿名函数更方便。<code>list(map(lambda x: x * x, [1, 2, 3, 4, 5, 6, 7, 8, 9]))</code></p><p><code>lambda x: x * x</code>实际上就是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def f(x):</span><br><span class="line">return x * x</span><br></pre></td></tr></table></figure><p>关键字<code>lambda</code>表示匿名函数，冒号前面的x表示函数参数。</p><p>匿名函数有个限制，就是只能有一个表达式，不用写<code>return</code>，返回值就是该表达式的结果。</p><h5 id="装饰器-Decorator-在代码运行期间动态增加功能的方式"><a href="#装饰器-Decorator-在代码运行期间动态增加功能的方式" class="headerlink" title="装饰器(Decorator)(在代码运行期间动态增加功能的方式)"></a>装饰器(Decorator)(在代码运行期间动态增加功能的方式)</h5><p>本质上，decorator就是一个返回函数的高阶函数。</p><p><strong>函数也是个对象</strong>，可以通过<code>__name__</code>属性拿到函数的名字</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def log(func):</span><br><span class="line">    def wrapper(*args, **kw):</span><br><span class="line">        print(&apos;call %s():&apos; % func.__name__)</span><br><span class="line">        return func(*args, **kw)</span><br><span class="line">    return wrapper</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@log</span><br><span class="line">def now():</span><br><span class="line">    print(&apos;2018-2-9&apos;)</span><br></pre></td></tr></table></figure><p>三层嵌套的decorator</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def log(text):</span><br><span class="line">    def decorator(func):</span><br><span class="line">        def wrapper(*args, **kw):</span><br><span class="line">            print(&apos;%s %s():&apos; % (text, func.__name__))</span><br><span class="line">            return func(*args, **kw)</span><br><span class="line">        return wrapper</span><br><span class="line">    return decorator</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@log(&apos;execute&apos;)</span><br><span class="line">def now():</span><br><span class="line">    print(&apos;2018-2-9&apos;)</span><br></pre></td></tr></table></figure><p>但此时函数名会出现错误，所以完整写法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import functools</span><br><span class="line"></span><br><span class="line">def log(func):</span><br><span class="line">    @functools.wraps(func)</span><br><span class="line">    def wrapper(*args, **kw):</span><br><span class="line">        print(&apos;call %s():&apos; % func.__name__)</span><br><span class="line">        return func(*args, **kw)</span><br><span class="line">    return wrapper</span><br></pre></td></tr></table></figure><h5 id="偏函数-Partial-function"><a href="#偏函数-Partial-function" class="headerlink" title="偏函数(Partial function)"></a>偏函数(Partial function)</h5><p>与数学意义上的偏函数不一样</p><p>所以，简单总结<code>functools.partial</code>的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单。</p><p><code>functools.partial</code>就是帮助我们创建一个偏函数的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import functools </span><br><span class="line">int2 = functools.partial(int, base=2)</span><br></pre></td></tr></table></figure><p>创建偏函数时，实际上可以接收函数对象、<code>*args</code>和<code>**kw</code>这3个参数</p><h4 id="模块-Module"><a href="#模块-Module" class="headerlink" title="模块(Module)"></a>模块(Module)</h4><p>在Python中，一个.py文件就称之为一个模块（Module）</p><p>为了避免模块名冲突，Python又引入了按目录来组织模块的方法，称为包（Package）。</p><p>方法是选择一个顶层包名，比如<code>mycompany</code>。引入了包以后，只要顶层的包名不与别人冲突，那所有模块都不会与别人冲突。现在，<code>abc.py</code>模块的名字就变成了<code>mycompany.abc</code>，类似的，<code>xyz.py</code>的模块名变成了<code>mycompany.xyz</code>。</p><p>请注意，每一个包目录下面都会有一个<code>__init__.py</code>的文件，这个文件是必须存在的，否则，Python就把这个目录当成普通目录，而不是一个包。<code>__init__.py</code>可以是空文件，也可以有Python代码，因为<code>__init__.py</code>本身就是一个模块，而它的模块名就是<code>mycompany</code>。</p><p>类似的，可以有多级目录，组成多级层次的包结构。</p><h5 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h5><p>正常的函数和变量名是公开的（public），可以被直接引用</p><p>类似<code>__xxx__</code>这样的变量是特殊变量，可以被直接引用，但是有特殊用途</p><p>类似<code>_xxx</code>和<code>__xxx</code>这样的函数或变量就是非公开的（private），不应该被直接引用</p><p>之所以我们说，private函数和变量“不应该”被直接引用，而不是“不能”被直接引用，是因为Python并没有一种方法可以完全限制访问private函数或变量，但是，从编程习惯上不应该引用private函数或变量。</p><h5 id="安装第三方模块"><a href="#安装第三方模块" class="headerlink" title="安装第三方模块"></a>安装第三方模块</h5><p>在Python中，安装第三方模块，是通过包管理工具pip完成的。</p><h4 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h4><p>数据封装、继承和多态是面向对象的三大特点</p><h5 id="类和实例-Class-and-Instance"><a href="#类和实例-Class-and-Instance" class="headerlink" title="类和实例(Class and Instance)"></a>类和实例(Class and Instance)</h5><p>在Python中，定义类是通过<code>class</code>关键字：class后面紧接着是类名，即Student，类名通常是大写开头的单词，紧接着是<code>(object)</code>，表示该类是从哪个类继承下来的,如果没有合适的继承类，就使用object类，这是所有类最终都会继承的类。</p><p>定义好了<code>Student</code>类，就可以根据<code>Student</code>类创建出Student的实例，创建实例是通过类名+()实现的。如:<code>bart = Student()</code></p><p>由于类可以起到模板的作用，因此，可以在创建实例的时候，把一些我们认为必须绑定的属性强制填写进去。通过定义一个特殊的<code>__init__</code>方法，在创建实例的时候，就把<code>name</code>，<code>score</code>等属性绑上去：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self, name, score):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.score = score</span><br></pre></td></tr></table></figure><p>和普通的函数相比，在类中定义的函数只有一点不同，就是第一个参数永远是实例变量self，并且，调用时，不用传递该参数。除此之外，类的方法和普通函数没有什么区别，所以，你仍然可以用默认参数、可变参数、关键字参数和命名关键字参数。</p><h6 id="数据封装"><a href="#数据封装" class="headerlink" title="数据封装"></a>数据封装</h6><p>和静态语言不同，Python允许对实例变量绑定任何数据，也就是说，对于两个实例变量，虽然它们都是同一个类的不同实例，但拥有的变量名称都可能不同：</p><h5 id="访问限制"><a href="#访问限制" class="headerlink" title="访问限制"></a>访问限制</h5><p>如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线<code>__</code>，在Python中，实例的变量名如果以<code>__</code>开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问</p><p>需要注意的是，在Python中，变量名类似<code>__xxx__</code>的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是private变量，所以，不能用<code>__name__</code>、<code>__score__</code>这样的变量名。</p><p>双下划线开头的实例变量是不是一定不能从外部访问呢？其实也不是。不能直接访问<code>__name</code>是因为Python解释器对外把<code>__name</code>变量改成了<code>_Student__name</code>，所以，仍然可以通过<code>_Student__name</code>来访问<code>__name</code>变量：</p><h5 id="继承和多态"><a href="#继承和多态" class="headerlink" title="继承和多态"></a>继承和多态</h5><p>在OOP程序设计中，当我们定义一个class的时候，可以从某个现有的class继承，新的class称为子类（Subclass），而被继承的class称为基类、父类或超类（Base class、Super class）。</p><p>继承有什么好处？最大的好处是子类获得了父类的全部功能。由于<code>Animial</code>实现了<code>run()</code>方法，因此，<code>Dog</code>和<code>Cat</code>作为它的子类，什么事也没干，就自动拥有了<code>run()</code>方法：</p><p>当子类和父类都存在相同的<code>run()</code>方法时，我们说，子类的<code>run()</code>覆盖了父类的<code>run()</code>，在代码运行的时候，总是会调用子类的<code>run()</code>。这样，我们就获得了继承的另一个好处：多态。</p><p>所以，在继承关系中，如果一个实例的数据类型是某个子类，那它的数据类型也可以被看做是父类。但是，反过来就不行</p><h6 id="静态语言-vs-动态语言"><a href="#静态语言-vs-动态语言" class="headerlink" title="静态语言 vs 动态语言"></a>静态语言 vs 动态语言</h6><p>对于静态语言（例如Java）来说，如果需要传入<code>Animal</code>类型，则传入的对象必须是<code>Animal</code>类型或者它的子类，否则，将无法调用<code>run()</code>方法。</p><p>对于Python这样的动态语言来说，则不一定需要传入<code>Animal</code>类型。我们只需要保证传入的对象有一个<code>run()</code>方法就可以了</p><p>这就是动态语言的“鸭子类型”，它并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。</p><p>Python的“file-like object“就是一种鸭子类型。对真正的文件对象，它有一个<code>read()</code>方法，返回其内容。但是，许多对象，只要有<code>read()</code>方法，都被视为“file-like object“。许多函数接收的参数就是“file-like object“，你不一定要传入真正的文件对象，完全可以传入任何实现了<code>read()</code>方法的对象。</p><h5 id="获取对象信息"><a href="#获取对象信息" class="headerlink" title="获取对象信息"></a>获取对象信息</h5><h6 id="使用type"><a href="#使用type" class="headerlink" title="使用type()"></a>使用type()</h6><p>判断对象类型</p><h6 id="使用isinstance"><a href="#使用isinstance" class="headerlink" title="使用isinstance()"></a>使用isinstance()</h6><h6 id="使用dir"><a href="#使用dir" class="headerlink" title="使用dir()"></a>使用dir()</h6><p>如果要获得一个对象的所有属性和方法，可以使用<code>dir()</code>函数，它返回一个包含字符串的list</p><h5 id="实例属性和类属性"><a href="#实例属性和类属性" class="headerlink" title="实例属性和类属性"></a>实例属性和类属性</h5><p>疑惑：<br>python的动态类型是否是用指针实现的</p><p>参考:</p><ol><li><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/00143186738532805c392f2cc09446caf3236c34e3f980f000" target="_blank" rel="noopener">Python教程</a></li><li>《Python学习手册》 by Mark Lutz(O’REILLY Press,2011)</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python笔记-未完待续&quot;&gt;&lt;a href=&quot;#Python笔记-未完待续&quot; class=&quot;headerlink&quot; title=&quot;Python笔记(未完待续)&quot;&gt;&lt;/a&gt;Python笔记(未完待续)&lt;/h1&gt;&lt;h2 id=&quot;Python特点&quot;&gt;&lt;a href=&quot;#Python特点&quot; class=&quot;headerlink&quot; title=&quot;Python特点&quot;&gt;&lt;/a&gt;Python特点&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;简单&lt;/li&gt;
&lt;li&gt;解释型&lt;/li&gt;
&lt;li&gt;交互式&lt;/li&gt;
&lt;li&gt;可移植&lt;/li&gt;
&lt;li&gt;面向对象&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Python特性&quot;&gt;&lt;a href=&quot;#Python特性&quot; class=&quot;headerlink&quot; title=&quot;Python特性&quot;&gt;&lt;/a&gt;Python特性&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;动态类型&lt;/li&gt;
&lt;li&gt;自动内存管理&lt;/li&gt;
&lt;li&gt;大型程序支持&lt;/li&gt;
&lt;li&gt;内置对象类型&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Python彩蛋&quot;&gt;&lt;a href=&quot;#Python彩蛋&quot; class=&quot;headerlink&quot; title=&quot;Python彩蛋&quot;&gt;&lt;/a&gt;Python彩蛋&lt;/h2&gt;&lt;p&gt;在交互解释器里输入&lt;code&gt;import this&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>LaTex笔记(不定期更新)</title>
    <link href="http://yoursite.com/2018/02/06/LaTex%E7%AC%94%E8%AE%B0-%E4%B8%8D%E5%AE%9A%E6%9C%9F%E6%9B%B4%E6%96%B0/"/>
    <id>http://yoursite.com/2018/02/06/LaTex笔记-不定期更新/</id>
    <published>2018-02-06T06:46:11.000Z</published>
    <updated>2018-06-04T11:22:59.280Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Latex-笔记（不定期更新）"><a href="#Latex-笔记（不定期更新）" class="headerlink" title="Latex 笔记（不定期更新）"></a>Latex 笔记（不定期更新）</h1><h2 id="标题，章和节"><a href="#标题，章和节" class="headerlink" title="标题，章和节"></a>标题，章和节</h2><table><thead><tr><th>命令</th><th>效果</th><th>命令</th><th>效果</th></tr></thead><tbody><tr><td>\title</td><td>标题</td><td>\author</td><td>作者</td></tr><tr><td>\date</td><td>日期</td><td>\maketitle</td><td>生成标题</td></tr><tr><td>\section</td><td>节标题</td><td>\subsection</td><td>小节标题</td></tr><tr><td>\subsubsection</td><td>次小节标题</td><td>\paragraph</td><td>段标题</td></tr><tr><td>\subparagraph</td><td>小段标题</td><td>\part</td><td>部分标题</td></tr><tr><td>\appendix</td><td>附录标题</td><td>\tableofcontents</td><td>生成目录</td></tr><tr><td>\listoffigures</td><td>插图目录</td><td>\listoftables</td><td>表格目录</td></tr></tbody></table> <a id="more"></a><h2 id="插入项目符号和编号"><a href="#插入项目符号和编号" class="headerlink" title="插入项目符号和编号"></a>插入项目符号和编号</h2><h3 id="不带序号"><a href="#不带序号" class="headerlink" title="不带序号"></a>不带序号</h3><p>关于{itemize}里序号的形式：latex默认生成的简单列表，默认为一个小圆点，而我们在写文章时可能想要一些不一样的列表符号，比如 -， * 之类的. 我们可以这样写</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;itemize&#125; </span><br><span class="line">\item[-] something</span><br><span class="line">\item[-] something</span><br><span class="line">\end&#123;itemize&#125;</span><br></pre></td></tr></table></figure><h3 id="带序号"><a href="#带序号" class="headerlink" title="带序号"></a>带序号</h3><p> 关于{enumerate}，这是用于带序号的列表。 默认生成 1，2，3。如果想要其他修饰，如(1) (2)….或step-1，step2，需要加载 \usepackage{enumerate}，然后如下使用</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;enumerate&#125;[step 1]</span><br><span class="line">\item something</span><br><span class="line">\item something</span><br><span class="line">\end&#123;enumerate&#125;</span><br></pre></td></tr></table></figure><h2 id="引入参考文献"><a href="#引入参考文献" class="headerlink" title="引入参考文献"></a>引入参考文献</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;thebibliography&#125;&#123;99&#125;</span><br><span class="line">\bibitem&#123;a&#125; something</span><br><span class="line">\bibitem&#123;b&#125; something</span><br><span class="line">\end&#123;thebibliography&#125;</span><br></pre></td></tr></table></figure><h2 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\usepackage&#123;graphicx&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\includegraphics[width=1.77in,height=1.75in]&#123;pic.jpg&#125;</span><br></pre></td></tr></table></figure><h2 id="插入代码"><a href="#插入代码" class="headerlink" title="插入代码"></a>插入代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">\usepackage&#123;listings&#125;</span><br><span class="line">\lstset&#123;language=C++&#125;%这条命令可以让LaTeX排版时将C++键字突出显示</span><br><span class="line"></span><br><span class="line">\lstset&#123;breaklines&#125;%这条命令可以让LaTeX自动将长的代码行换行排版</span><br><span class="line"></span><br><span class="line">\lstset&#123;extendedchars=false&#125;%这一条命令可以解决代码跨页时，章节标题，页眉等汉字不显示的问题</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;lstlisting&#125;</span><br><span class="line"></span><br><span class="line">\end&#123;lstlisting&#125;</span><br></pre></td></tr></table></figure><h2 id="插入表格"><a href="#插入表格" class="headerlink" title="插入表格"></a>插入表格</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;tabular&#125;&#123;|c|c|&#125; %通过添加 | 来表示是否需要绘制竖线</span><br><span class="line">\hline  % 在表格最上方绘制横线</span><br><span class="line">sth &amp; sth\\</span><br><span class="line">\hline  %在第一行和第二行之间绘制横线</span><br><span class="line">...\\</span><br><span class="line">\hline</span><br><span class="line">\end&#123;tabular&#125;</span><br></pre></td></tr></table></figure><p>如果要添加斜线<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\usepackage&#123;diagbox&#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">\diagbox&#123;&#125;&#123;&#125;&#123;&#125;...</span><br></pre></td></tr></table></figure></p><h2 id="大括号"><a href="#大括号" class="headerlink" title="大括号"></a>大括号</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$$T(n)=</span><br><span class="line">\begin&#123;cases&#125;</span><br><span class="line">0    &amp;  \text&#123;n=0&#125;\\</span><br><span class="line">2T(n-1) &amp; n \ge 1</span><br><span class="line">\end&#123;cases&#125;$$</span><br></pre></td></tr></table></figure><h2 id="插入伪代码"><a href="#插入伪代码" class="headerlink" title="插入伪代码"></a>插入伪代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">\usepackage&#123;algorithm&#125;</span><br><span class="line">\usepackage&#123;algpseudocode&#125;</span><br><span class="line"></span><br><span class="line">\begin&#123;algorithm&#125;[H]</span><br><span class="line">\caption&#123;$\textsc&#123;SomeAlgorithm&#125;$&#125;</span><br><span class="line">\begin&#123;algorithmic&#125;</span><br><span class="line">\If&#123;$condition$&#125;</span><br><span class="line">\State $something$</span><br><span class="line">\ElsIf&#123;$condition2$&#125;</span><br><span class="line">\State $sth$</span><br><span class="line">\Else</span><br><span class="line">\State $something else$</span><br><span class="line">\EndIf</span><br><span class="line"></span><br><span class="line">\For&#123;$i=1$ to $n$&#125;</span><br><span class="line">\State $something$</span><br><span class="line">\State $something else$</span><br><span class="line">\EndFor</span><br><span class="line"></span><br><span class="line">\While&#123;$condition$&#125;</span><br><span class="line">\State $something$</span><br><span class="line">\EndWhile</span><br><span class="line"></span><br><span class="line">\Repeat</span><br><span class="line">\State $something$</span><br><span class="line">\Until&#123;$condition$&#125;</span><br><span class="line">\end&#123;algorithmic&#125;</span><br><span class="line">\end&#123;algorithm&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Latex-笔记（不定期更新）&quot;&gt;&lt;a href=&quot;#Latex-笔记（不定期更新）&quot; class=&quot;headerlink&quot; title=&quot;Latex 笔记（不定期更新）&quot;&gt;&lt;/a&gt;Latex 笔记（不定期更新）&lt;/h1&gt;&lt;h2 id=&quot;标题，章和节&quot;&gt;&lt;a href=&quot;#标题，章和节&quot; class=&quot;headerlink&quot; title=&quot;标题，章和节&quot;&gt;&lt;/a&gt;标题，章和节&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;效果&lt;/th&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;效果&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;\title&lt;/td&gt;
&lt;td&gt;标题&lt;/td&gt;
&lt;td&gt;\author&lt;/td&gt;
&lt;td&gt;作者&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\date&lt;/td&gt;
&lt;td&gt;日期&lt;/td&gt;
&lt;td&gt;\maketitle&lt;/td&gt;
&lt;td&gt;生成标题&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\section&lt;/td&gt;
&lt;td&gt;节标题&lt;/td&gt;
&lt;td&gt;\subsection&lt;/td&gt;
&lt;td&gt;小节标题&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\subsubsection&lt;/td&gt;
&lt;td&gt;次小节标题&lt;/td&gt;
&lt;td&gt;\paragraph&lt;/td&gt;
&lt;td&gt;段标题&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\subparagraph&lt;/td&gt;
&lt;td&gt;小段标题&lt;/td&gt;
&lt;td&gt;\part&lt;/td&gt;
&lt;td&gt;部分标题&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\appendix&lt;/td&gt;
&lt;td&gt;附录标题&lt;/td&gt;
&lt;td&gt;\tableofcontents&lt;/td&gt;
&lt;td&gt;生成目录&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\listoffigures&lt;/td&gt;
&lt;td&gt;插图目录&lt;/td&gt;
&lt;td&gt;\listoftables&lt;/td&gt;
&lt;td&gt;表格目录&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="LaTex" scheme="http://yoursite.com/tags/LaTex/"/>
    
  </entry>
  
  <entry>
    <title>Markdown简明语法</title>
    <link href="http://yoursite.com/2018/02/04/Markdown%E7%AE%80%E6%98%8E%E8%AF%AD%E6%B3%95/"/>
    <id>http://yoursite.com/2018/02/04/Markdown简明语法/</id>
    <published>2018-02-04T05:16:50.000Z</published>
    <updated>2018-02-12T04:20:22.615Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Markdown简明语法"><a href="#Markdown简明语法" class="headerlink" title="Markdown简明语法"></a>Markdown简明语法</h1><h2 id="Markdown优点"><a href="#Markdown优点" class="headerlink" title="Markdown优点"></a>Markdown优点</h2><ul><li>纯文本，兼容性强</li><li>语法简单，有较强的可读性</li><li>转换方便 <a id="more"></a></li></ul><h2 id="Markdown语法"><a href="#Markdown语法" class="headerlink" title="Markdown语法"></a>Markdown语法</h2><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><h4 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表:"></a>无序列表:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 文本1</span><br><span class="line">- 文本2</span><br><span class="line">- 文本3</span><br></pre></td></tr></table></figure><p>显示效果为：</p><ul><li>文本1</li><li>文本2</li><li>文本3</li></ul><h4 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表:"></a>有序列表:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 文本1</span><br><span class="line">2. 文本2</span><br><span class="line">3. 文本3</span><br></pre></td></tr></table></figure><p>显示效果为：</p><ol><li>文本1</li><li>文本2</li><li>文本3</li></ol><h3 id="链接和图片"><a href="#链接和图片" class="headerlink" title="链接和图片"></a>链接和图片</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[显示文本](链接地址)</span><br><span class="line">![](图片链接地址)</span><br></pre></td></tr></table></figure><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>在希望引用的文件前面加<code>&gt;</code>就可以 </p><p><code>&gt;</code> 和文本之间要保留一个字符的空格。</p><h3 id="粗体和斜体"><a href="#粗体和斜体" class="headerlink" title="粗体和斜体"></a>粗体和斜体</h3><p>用两个 <code>*</code> 包含一段文本就是粗体的语法，用一个 <code>*</code> 包含一段文本就是斜体的语法</p><h3 id="代码引用"><a href="#代码引用" class="headerlink" title="代码引用"></a>代码引用</h3><p>一行代码用 包住 </p><p>若代码为多行，则用两行(每行三个)包住</p><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| Tables        | Are           | Cool  |</span><br><span class="line">| ------------- |:-------------:| -----:|</span><br><span class="line">| col 3 is      | right-aligned | $1600 |</span><br><span class="line">| col 2 is      | centered      |   $12 |</span><br><span class="line">| zebra stripes | are neat      |    $1 |</span><br></pre></td></tr></table></figure><p>显示效果为:</p><table><thead><tr><th>Tables</th><th style="text-align:center">Are</th><th style="text-align:right">Cool</th></tr></thead><tbody><tr><td>col 3 is</td><td style="text-align:center">right-aligned</td><td style="text-align:right">$1600</td></tr><tr><td>col 2 is</td><td style="text-align:center">centered</td><td style="text-align:right">$12</td></tr><tr><td>zebra stripes</td><td style="text-align:center">are neat</td><td style="text-align:right">$1</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dog | bird | cat</span><br><span class="line">----|------|----</span><br><span class="line">foo | foo  | foo</span><br><span class="line">bar | bar  | bar</span><br><span class="line">baz | baz  | baz</span><br></pre></td></tr></table></figure><p>显示效果为:</p><table><thead><tr><th>dog</th><th>bird</th><th>cat</th></tr></thead><tbody><tr><td>foo</td><td>foo</td><td>foo</td></tr><tr><td>bar</td><td>bar</td><td>bar</td></tr><tr><td>baz</td><td>baz</td><td>baz</td></tr></tbody></table><h3 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h3><p>行内公式: <code>$数学公式$</code></p><p>行间公式: <code>$$数学公式$$</code></p><p>用LaTex语法</p><p>参考：<a href="https://www.jianshu.com/p/q81RER" target="_blank" rel="noopener">献给写作者的 Markdown 新手指南</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Markdown简明语法&quot;&gt;&lt;a href=&quot;#Markdown简明语法&quot; class=&quot;headerlink&quot; title=&quot;Markdown简明语法&quot;&gt;&lt;/a&gt;Markdown简明语法&lt;/h1&gt;&lt;h2 id=&quot;Markdown优点&quot;&gt;&lt;a href=&quot;#Markdown优点&quot; class=&quot;headerlink&quot; title=&quot;Markdown优点&quot;&gt;&lt;/a&gt;Markdown优点&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;纯文本，兼容性强&lt;/li&gt;
&lt;li&gt;语法简单，有较强的可读性&lt;/li&gt;
&lt;li&gt;转换方便
    
    </summary>
    
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="markdown" scheme="http://yoursite.com/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2018/02/02/hello-world/"/>
    <id>http://yoursite.com/2018/02/02/hello-world/</id>
    <published>2018-02-02T05:02:57.299Z</published>
    <updated>2018-02-02T05:02:57.299Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
