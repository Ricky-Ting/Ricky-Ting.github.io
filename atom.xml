<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ricky Ting&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/4492b8f6628f8336b7f13bd4cb84b846</icon>
  <subtitle>当时只道是寻常</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ricky-ting.github.io/"/>
  <updated>2019-11-14T06:22:45.569Z</updated>
  <id>https://ricky-ting.github.io/</id>
  
  <author>
    <name>Ricky-Ting</name>
    <email>Ricky.Ting@outlook.com Ricky.B.Ting@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SQL学习</title>
    <link href="https://ricky-ting.github.io/2019/11/14/SQL%E5%AD%A6%E4%B9%A0/"/>
    <id>https://ricky-ting.github.io/2019/11/14/SQL学习/</id>
    <published>2019-11-14T06:22:19.000Z</published>
    <updated>2019-11-14T06:22:45.569Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SQL学习"><a href="#SQL学习" class="headerlink" title="SQL学习"></a>SQL学习</h1><h2 id="MySQL相关使用"><a href="#MySQL相关使用" class="headerlink" title="MySQL相关使用"></a>MySQL相关使用</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">databases</span>; <span class="comment">--展示所有数据库</span></span><br><span class="line"><span class="keyword">use</span> db1; <span class="comment">--使用db1数据库</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">tables</span>; <span class="comment">--展示当前数据库里所有的表</span></span><br><span class="line"><span class="keyword">describe</span> tb1; <span class="comment">--展示tb1的相关信息</span></span><br><span class="line"><span class="comment">/*这是多行注释*/</span></span><br><span class="line"><span class="comment">--这是单行注释</span></span><br></pre></td></tr></table></figure><h2 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">databases</span> db1;</span><br><span class="line"><span class="keyword">use</span> db1;</span><br></pre></td></tr></table></figure><h2 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> tb1 </span><br><span class="line">(</span><br><span class="line">col1_name <span class="built_in">char</span>(<span class="number">40</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">col2_name <span class="built_in">char</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">col3_name <span class="built_in">real</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">describe</span> tb1;</span><br></pre></td></tr></table></figure><h2 id="向表中插入数据"><a href="#向表中插入数据" class="headerlink" title="向表中插入数据"></a>向表中插入数据</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name</span><br><span class="line"><span class="keyword">VALUES</span> (value1,value2,value3,...); </span><br><span class="line"><span class="comment">--或者</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name (column1,column2,column3,...)</span><br><span class="line"><span class="keyword">VALUES</span> (value1,value2,value3,...);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SQL学习&quot;&gt;&lt;a href=&quot;#SQL学习&quot; class=&quot;headerlink&quot; title=&quot;SQL学习&quot;&gt;&lt;/a&gt;SQL学习&lt;/h1&gt;&lt;h2 id=&quot;MySQL相关使用&quot;&gt;&lt;a href=&quot;#MySQL相关使用&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>由边缘计算综述引出的一些知识点</title>
    <link href="https://ricky-ting.github.io/2019/11/06/%E7%94%B1%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97%E7%BB%BC%E8%BF%B0%E5%BC%95%E5%87%BA%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>https://ricky-ting.github.io/2019/11/06/由边缘计算综述引出的一些知识点/</id>
    <published>2019-11-06T11:57:44.000Z</published>
    <updated>2019-11-06T12:18:11.089Z</updated>
    
    <content type="html"><![CDATA[<h1 id="由边缘计算综述引出的一些知识点"><a href="#由边缘计算综述引出的一些知识点" class="headerlink" title="由边缘计算综述引出的一些知识点"></a>由边缘计算综述引出的一些知识点</h1><h2 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h2><p><em>Insight and Perspectives for Content Delivery Network, 2006</em> </p><p>CDN的思想很简单，把内容缓存在离用户较近的服务器上。但在实际的实施过程中，有很多问题需要解决。</p><p>如：</p><ol><li>代理服务器的选址。</li><li>缓存内容的选择：把所有内容都缓存很不经济，在很多情况下也不现实。如何选择的缓存内容，(个人认为有两种方式：一种是手动的推送，由人来预判，然后推送到代理服务器，还有一种是自动地靠算法来选择，可以模仿cpu里的cache算法，也可以根据这一地区用户看的比较多的内容，预测他们的偏好(可以用一些数据挖掘和机器学习)，缓存一些他们偏好的内容。还有根据内容相关性，如同一url下的内容更有可能被同时访问到。)</li><li>访问机制：<ol><li>cooperative push-based: 代理服务器有去代理服务器，否则去中心服务器。代理服务器之间协作来减少备份的数量</li><li>uncooperative pull-based: 去最近的代理服务器，如果没有，由代理服务器向中心服务器请求。但代理服务器之间不协作</li><li>Cooperative pull-based:与上一个的区别是：代理服务器之间是协作的。</li></ol></li><li>定价问题</li></ol><h2 id="移动边缘计算"><a href="#移动边缘计算" class="headerlink" title="移动边缘计算"></a>移动边缘计算</h2><p><em>The case for VM-based cloudlets in mobile computing. 2009</em></p><p>这应该是工业界的一份报告，内容有点长，粗略浏览了一下：主要关注了一下它提出的应用场景。</p><ol><li>增强现实，如在博物馆中，可以根据用户的站立方向和眼神来给用户全方位地展示内容，因此在边缘需要一些AR的计算设备，但云也不可少，因为需要一些AR的内容，但边缘服务器也有一些缓存。我个人觉得也可以这样理解：博物馆很大，它有一个中心服务器，存放了很多内容，用户所在的是很多边缘，边缘识别和计算并缓存内容。边缘还可以为中心服务器提供数据，分析用户的偏好等等。</li><li>智能视频加速，因为无线链路的不稳定性，所以网速可能会出现很大的波动，而TCP不能很好地应对，所以我们在边缘部署无线信道分析程序来分析、预测可能的信道速率并告诉视频服务器，这样视频服务器能做出调整。</li><li>联网汽车，可以部署边缘设备，收集汽车上报的信息，来衡量这附近的路况等等，并能够返回信息给车辆，让它们做好准备。</li></ol><h2 id="NDN和SDN-待了解"><a href="#NDN和SDN-待了解" class="headerlink" title="NDN和SDN(待了解)"></a>NDN和SDN(待了解)</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;由边缘计算综述引出的一些知识点&quot;&gt;&lt;a href=&quot;#由边缘计算综述引出的一些知识点&quot; class=&quot;headerlink&quot; title=&quot;由边缘计算综述引出的一些知识点&quot;&gt;&lt;/a&gt;由边缘计算综述引出的一些知识点&lt;/h1&gt;&lt;h2 id=&quot;CDN&quot;&gt;&lt;a href=
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>边缘计算：现状与展望</title>
    <link href="https://ricky-ting.github.io/2019/11/06/%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97%EF%BC%9A%E7%8E%B0%E7%8A%B6%E4%B8%8E%E5%B1%95%E6%9C%9B/"/>
    <id>https://ricky-ting.github.io/2019/11/06/边缘计算：现状与展望/</id>
    <published>2019-11-06T08:30:22.000Z</published>
    <updated>2019-11-06T08:35:25.523Z</updated>
    
    <content type="html"><![CDATA[<h1 id="边缘计算：现状与展望"><a href="#边缘计算：现状与展望" class="headerlink" title="边缘计算：现状与展望"></a>边缘计算：现状与展望</h1><h2 id="云计算模型的不足："><a href="#云计算模型的不足：" class="headerlink" title="云计算模型的不足："></a>云计算模型的不足：</h2><ol><li>实时性不够，网络延迟（云计算模型更适合批处理）</li><li>带宽不足，边缘设备产生的数据很多，但广域网的带宽不足。</li><li>能耗较大，（这点存疑）虽然数据中心消耗了很多能源，但也提供了很强的计算能力，如果把这些计算能力分布到边缘，是不是总的能耗会更高呢？？ </li><li>不利于数据安全和隐私。如家庭摄像头等隐私数据</li></ol><h2 id="边缘计算的概念"><a href="#边缘计算的概念" class="headerlink" title="边缘计算的概念"></a>边缘计算的概念</h2><p>边缘计算并不是不需要云了，否则边缘设备之间就孤立了，它需要云。边缘指的是从数据源到云计算中心路径之间的任意计算和网络资源，是一个连续统。</p><p>边缘计算的一些优点：</p><ul><li>减轻了网络带宽和数据中心能耗的压力</li><li>减少了系统的延迟</li><li>保护了隐私</li></ul><a id="more"></a><h2 id="边缘计算的发展历程"><a href="#边缘计算的发展历程" class="headerlink" title="边缘计算的发展历程"></a>边缘计算的发展历程</h2><p>作者将其大致划分为三个阶段：</p><ol><li>2015年以前——原始技术积累阶段</li><li>2015-2017年——飞速发展阶段</li><li>2018年及以后——稳健发展阶段</li></ol><h3 id="技术储备期"><a href="#技术储备期" class="headerlink" title="技术储备期"></a>技术储备期</h3><p>最早追溯到1998年CDN的提出。但CDN主要强调的是内容(即数据)的缓存，而边缘计算强调的是功能缓存(function cache).</p><p>2005年，施巍松教授团队已提出功能缓存的概念，并将其应用在个性化的邮箱管理服务中，以节省延迟和带宽。</p><p>2009年，Satyanarayanan等人提出了Cloudlet的概念，Cloudlet是一个可信且自愿丰富的主机，部署在网络边缘，可以为用户提供服务，也被称作“小朵云”，这里强调下行，把云服务器的功能下移至边缘服务器。</p><p>至于上行，则在靠近数据生产者的边缘增加数据处理的功能，代表性的是移动边缘计算、雾计算和海云计算。</p><p>移动边缘计算：位于无线接入网内，在云计算中心和边缘计算设备之间建立边缘服务器，在边缘服务器上完成计算，但移动边缘设备不认为具有计算能力。而在边缘计算中，终端设备具有较强的计算能力。</p><p>雾计算：由思科在2012年提出，定义为迁移云计算中心任务到网络边缘设备执行的一种高度虚拟化计算平台。雾计算关注基础设施之间分布式资源共享问题。</p><p>海云计算：由中科院在2012年提出，强调“云计算”系统和“海计算”系统之间的系统和集成，“海”指的是物理世界的一些设备。</p><h3 id="快速增长期"><a href="#快速增长期" class="headerlink" title="快速增长期"></a>快速增长期</h3><p>2016年，NSF将边缘计算列为突出领域，标志着边缘计算的发展已经在美国政府层面上引起了重视。</p><p>2016年，施巍松教授团队给出了边缘计算的一个正式定义：</p><p>学术界….</p><p>工业界…..</p><h3 id="稳健发展期"><a href="#稳健发展期" class="headerlink" title="稳健发展期"></a>稳健发展期</h3><p>很多活动</p><h2 id="支持边缘计算的核心技术"><a href="#支持边缘计算的核心技术" class="headerlink" title="支持边缘计算的核心技术"></a>支持边缘计算的核心技术</h2><p>7项核心技术：网络、隔离技术、体系结构、边缘操作系统、算法执行框架、数据处理平台以及安全和隐私。</p><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><ol><li>服务发现：计算服务请求者会动态变化，请求者如何发现周围的服务，DNS服务发现机制需要一定时间来同步，会造成一定的网络抖动</li><li>快速配置：计算设备可能会被用户频繁开关，服务往往要随之迁移，会导致大量的突发网络流量。因此，如何从设备层支持服务的快速配置，是边缘计算中的一个核心问题。</li><li>负载均衡：如何动态调度任务。</li></ol><p>命名数据网络(named data networking, NDN)是一种将数据和服务进行命名和寻址，以P2P和中心化方式相结合进行自组织的一种数据网络，可以很好地解决服务发现问题。</p><p>软件定义网络(SDN)是一种控制面和数据面分离的可编程网络，以及简单网络管理。可以较为快速地进行路由器和交换机的配置，减少网络抖动性，以支持快速的流量迁移。</p><h3 id="隔离技术"><a href="#隔离技术" class="headerlink" title="隔离技术"></a>隔离技术</h3><p>两大隔离：计算资源的隔离和数据的隔离</p><p>现在云计算中主要使用的有VM虚拟机和Docker技术。</p><p>Li等人建立了一个基于Docker迁移的有效服务切换系统。</p><p>Ha等人提出了一种VM切换技术。</p><h3 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h3><p>异构硬件</p><p>ShiDianNao首次提出将人工智能处理器放置在靠近图像传感器的位置，处理器直接从传感器读取数据，避免内存存取开销，将模型放置在SRAM中，避免了权值数据在DRAM中的存取开销。</p><p>Phi-Stack提出了针对边缘计算的一整套技术栈，其中针对物联网设备设计的PhiPU，使用异构多核的结构并行处理深度学习任务和普通的计算任务(实时操作系统).</p><p>还有一些工作探索了FPGA在边缘计算场景中的应用</p><p>针对边缘计算的计算系统结构设计仍然具有很多挑战。</p><h3 id="边缘操作系统"><a href="#边缘操作系统" class="headerlink" title="边缘操作系统"></a>边缘操作系统</h3><p>边缘操作系统向下需要管理异构的计算资源，向上需要处理大量的异构数据以及多用的应用负载，需要负责将复杂的计算任务在边缘计算节点上部署、调度及迁移，从而保证计算任务的可靠性以及资源的最大化利用。</p><p>ROS, ROS2.0, EdgeOS$_H$ , PhiOS</p><h3 id="算法执行框架"><a href="#算法执行框架" class="headerlink" title="算法执行框架"></a>算法执行框架</h3><p>边缘设备更多地是执行预测任务，需要关注算法执行框架预测时的速度、内存占用量和能效。</p><p>TensorFlow Lite, Caffe2, PyTorch, MXNet</p><h3 id="数据处理平台"><a href="#数据处理平台" class="headerlink" title="数据处理平台"></a>数据处理平台</h3><p>边缘设备的数据的来源和类型具有多样化的特征，大多具有时空属性，构建一个针对边缘数据进行管理、分析和共享的平台十分重要。</p><h3 id="安全和隐私"><a href="#安全和隐私" class="headerlink" title="安全和隐私"></a>安全和隐私</h3><p>通过基于密码学的方案来进行信息保护、通过访问控制策略来对越权访问等进行防护。</p><p>也有一些新兴的安全技术，如硬件协助的可信执行环境，使用机器学习来增强系统的安全防护。</p><p>可信执行环境(TEE)：Intel软件防护扩展、Intel管理引擎、x86系统管理模式、AMD内存加密技术、AMD平台安全处理器和ARM TrustZone技术</p><h2 id="边缘计算的典型应用"><a href="#边缘计算的典型应用" class="headerlink" title="边缘计算的典型应用"></a>边缘计算的典型应用</h2><p>6个成功典型应用</p><h3 id="公共安全中实时数据处理"><a href="#公共安全中实时数据处理" class="headerlink" title="公共安全中实时数据处理"></a>公共安全中实时数据处理</h3><p>武汉的“雪亮工程”建设</p><p>网约车的视频、音频保障安全</p><p>安柏报警助手：对绑匪车辆实时追踪</p><p>用于消防系统的边缘计算系统：实时获得消防员位置信息和周边情况。</p><h3 id="智能网联车和自动驾驶"><a href="#智能网联车和自动驾驶" class="headerlink" title="智能网联车和自动驾驶"></a>智能网联车和自动驾驶</h3><h3 id="虚拟现实"><a href="#虚拟现实" class="headerlink" title="虚拟现实"></a>虚拟现实</h3><p>将VA/AR的计算任务卸载到边缘服务器。</p><p>Furion</p><h3 id="工业物联网"><a href="#工业物联网" class="headerlink" title="工业物联网"></a>工业物联网</h3><h3 id="智能家居"><a href="#智能家居" class="headerlink" title="智能家居"></a>智能家居</h3><p>工业界的Echo、SmartThings、Google Home。 Home OS和Home Kit.</p><p>学术界：EdgeOS$_H$ </p><h3 id="智慧城市"><a href="#智慧城市" class="headerlink" title="智慧城市"></a>智慧城市</h3><h2 id="边缘计算面临的紧迫问题"><a href="#边缘计算面临的紧迫问题" class="headerlink" title="边缘计算面临的紧迫问题"></a>边缘计算面临的紧迫问题</h2><p>6个方向是未来几年迫切需要解决的问题：编程模型、软硬件选型、基准程序与标准、动态调度、与垂直行业的紧密结合以及边缘节点的落地</p><h3 id="编程模型"><a href="#编程模型" class="headerlink" title="编程模型"></a>编程模型</h3><p>边缘计算模型与云计算模型存在较大的区别。边缘计算具有弹性管理、协同执行和环境异构的特点。</p><p>应用程序/服务功能可分割，数据可分布、资源可分布</p><h3 id="软硬件选型"><a href="#软硬件选型" class="headerlink" title="软硬件选型"></a>软硬件选型</h3><p>设计并实现一套能够帮助用户对边缘计算平台进行性能、功耗分析并提供软硬件选型参考的工具十分重要。</p><h3 id="基准程序和标准"><a href="#基准程序和标准" class="headerlink" title="基准程序和标准"></a>基准程序和标准</h3><h3 id="动态调度"><a href="#动态调度" class="headerlink" title="动态调度"></a>动态调度</h3><p>云计算中心和边缘设备之间的调度，边缘设备和云计算中心之间的调度。</p><p>降低传输带宽，减少任务完成时间，减少响应时间，还需要考虑能耗</p><h3 id="和垂直行业紧密合作"><a href="#和垂直行业紧密合作" class="headerlink" title="和垂直行业紧密合作"></a>和垂直行业紧密合作</h3><ol><li>减少与行业标准间的隔阂</li><li>完善数据保护和访问机制</li><li>提高互操作性</li></ol><h3 id="边缘节点落地问题"><a href="#边缘节点落地问题" class="headerlink" title="边缘节点落地问题"></a>边缘节点落地问题</h3><ol><li>新型的商业模式</li><li>边缘节点的选择</li><li>边缘数据的选择</li><li>边缘节点的可靠性</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;边缘计算：现状与展望&quot;&gt;&lt;a href=&quot;#边缘计算：现状与展望&quot; class=&quot;headerlink&quot; title=&quot;边缘计算：现状与展望&quot;&gt;&lt;/a&gt;边缘计算：现状与展望&lt;/h1&gt;&lt;h2 id=&quot;云计算模型的不足：&quot;&gt;&lt;a href=&quot;#云计算模型的不足：&quot; class=&quot;headerlink&quot; title=&quot;云计算模型的不足：&quot;&gt;&lt;/a&gt;云计算模型的不足：&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;实时性不够，网络延迟（云计算模型更适合批处理）&lt;/li&gt;
&lt;li&gt;带宽不足，边缘设备产生的数据很多，但广域网的带宽不足。&lt;/li&gt;
&lt;li&gt;能耗较大，（这点存疑）虽然数据中心消耗了很多能源，但也提供了很强的计算能力，如果把这些计算能力分布到边缘，是不是总的能耗会更高呢？？ &lt;/li&gt;
&lt;li&gt;不利于数据安全和隐私。如家庭摄像头等隐私数据&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;边缘计算的概念&quot;&gt;&lt;a href=&quot;#边缘计算的概念&quot; class=&quot;headerlink&quot; title=&quot;边缘计算的概念&quot;&gt;&lt;/a&gt;边缘计算的概念&lt;/h2&gt;&lt;p&gt;边缘计算并不是不需要云了，否则边缘设备之间就孤立了，它需要云。边缘指的是从数据源到云计算中心路径之间的任意计算和网络资源，是一个连续统。&lt;/p&gt;
&lt;p&gt;边缘计算的一些优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;减轻了网络带宽和数据中心能耗的压力&lt;/li&gt;
&lt;li&gt;减少了系统的延迟&lt;/li&gt;
&lt;li&gt;保护了隐私&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数据通信期中复习</title>
    <link href="https://ricky-ting.github.io/2019/04/29/%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0/"/>
    <id>https://ricky-ting.github.io/2019/04/29/数据通信期中复习/</id>
    <published>2019-04-29T14:24:02.000Z</published>
    <updated>2019-09-07T13:42:23.322Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据通信期中复习"><a href="#数据通信期中复习" class="headerlink" title="数据通信期中复习"></a>数据通信期中复习</h1><p>通信模型： 源点-&gt;发送器-&gt;传输系统-&gt;接收器-&gt;终点</p><p>单工、半双工、双工。</p><p>数字通信系统:利用数字信号来传递信息的通信系统</p><p>模拟通信系统: 利用模拟信号来传递信息的通信系统</p><p>混成系统</p><p>TCP/IP 5层模型</p><ul><li><p>应用层：用于支持各种不同应用程序的逻辑 (SMTP,FTP,SSH,HTTP)</p></li><li><p>运输层：提供端到端的传输服务 (TCP,UDP)</p></li><li><p>网际层：提供多个网络的路由选择功能，能够让数据跨越多个互联的网路 (IPv4,Ipv6))</p></li><li><p>数据链路层：为与同一个网络相连的两个系统提供网络接入 (以太网,WiFi,ATM,帧中继)</p></li><li><p>物理层：负责数据传输设备与传输媒体的物理接口 (双绞线,光纤,卫星,地面微波)</p></li></ul><a id="more"></a><p>网络体系结构分层的好处：</p><ul><li><p>为应用提供一个抽象，对应用设计者<strong>隐藏网络的复杂性</strong></p></li><li><p>促进<strong>标准化</strong></p></li><li><p>各层互相独立，技术升级和扩展<strong>灵活性好</strong></p></li><li><p>便于方案设计和<strong>维护</strong></p></li></ul><p>信源编码与译码的目的：</p><ul><li><p>提高信息传输的有效性</p></li><li><p>完成模/数转换</p></li></ul><p>信道编码与译码的目的：</p><ul><li>增强抗干扰能力</li></ul><p>加密与解密的目的：</p><ul><li>保证所传信息的安全</li></ul><p>数字调制与解调的目的：</p><ul><li>形成适合在信道中传输的带通信号</li></ul><p>数字通信的特点</p><ul><li><p>优点：</p><ul><li><p>抗干扰能力强，且噪声不积累</p></li><li><p>传输差错可控</p></li><li><p>便于处理、变换、存储</p></li><li><p>便于将来自不同信源的信号综合到一起传输</p></li><li><p>易于集成，使通信设备微型化，重量轻</p></li><li><p>易于加密处理，且保密性好</p></li></ul></li><li><p>缺点：</p><ul><li><p>需要较大的传输带宽</p></li><li><p>对同步要求高</p></li></ul></li></ul><p>套接字：</p><ul><li><p>流套接字(TCP)： 面向连接的可靠数据传输，并保证按发送时的顺序到达</p></li><li><p>数据报套接字(UDP): 快速，交付没有保证，也不一定会保留初始顺序</p></li><li><p>原始套接字：直接访问底层协议。</p></li></ul><h2 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h2><p>成功的数据传输依赖于两个因素：</p><ul><li><p>传输信号的质量</p></li><li><p>传输媒体的特性</p></li></ul><p>传输媒体：</p><ul><li><p>导向媒体：电磁波在导线引导下 沿某一物理路径前进， 双绞线，光纤，同轴电缆</p></li><li><p>非导向媒体：无线传输，提供传输电磁波方式，但不引导传输方向，空气，真空，海水</p></li></ul><p>傅里叶变换</p><p>方波信号：$s(t) = A \times \frac{4}{\pi} \sum_{k=1,k \ is \ odd}^{\infty} \frac{sin(2\pi kft)}{k}$</p><p>频谱：信号所包含的频率范围</p><p>绝对带宽：信号的频谱宽度</p><p>有效带宽：包含信号绝大多数能量的窄带</p><p>直流分量：信号中频率为零的成份</p><p>$R_b = 2f$</p><p>信号的能量与功率：</p><p>能量：$E<em>x = \int</em>{-\infty} ^{\infty} |x(t)|^2 dt$</p><p>功率：$P_x = \frac{1}{t_2-t<em>1} \int</em>{t_1}^{t_2} |x(t)|^2 dt$.</p><p>一个周期的平均功率为$P= \frac{1}{T} \int_{0}^{T} |x(t)|^2 dt$</p><p>模拟信号：用连续变化电磁波来表示数据</p><p>数字信号：用电压脉冲序列来表示数据</p><p>3dB带宽：即$P<em>{\text{半功}} = 0.5 P</em>{\text{峰值}}$， 也就是说该区间边界的功率值比峰值功率值低3dB.</p><p>数字信号传输：</p><ul><li><p>比传输模拟信号便宜</p></li><li><p>不易受噪声干扰</p></li><li><p>比传输模拟信号更容易受衰减影响</p></li></ul><p>目前普遍采用数字技术的原因：</p><ul><li><p>大规模集成电路在体积和价格上都不断降低</p></li><li><p>数据完整性：不使用放大器而使用转发器，噪声和其他损伤的影响不会被累积</p></li><li><p>容量利用率：实现复用，数字技术(时分)比模拟技术(频分)更容易也更便宜</p></li><li><p>安全与保密：数字数据可以直接加密，而模拟数据还得数字化之后才能加密</p></li><li><p>综合性：所有信号具有相同的格式并且处理方法也相同。经济方便</p></li></ul><p>主要考虑的损伤：</p><ul><li><p>衰减：解决方法：放大器和转发器</p></li><li><p>失真： 时延失真，码间串扰</p></li><li><p>噪声：包括热噪声、互调噪声、串扰、冲激噪声</p></li></ul><p>信噪比：$SNR_{dB} = 10 lg \frac{S}{N}$.</p><p>热噪声：由电子的热运动造成的。 热噪声均匀地分布在通信系统常用的频率范围内，因此通常称为白噪声。$N_0 = kT(W/Hz)$</p><p>互调噪声：当不同频率的信号共享同一传输媒体时，可能会产生互调噪声。互调噪声的产生是由于在发送器、接收器中存在非线性因素，或者是传输系统受到干扰。 额外的信号，频率是两个原频率之和或差。</p><p>串扰：载有多路信号的相邻双绞线之间发生电耦合，有时在同轴电缆之间也会发生。 双绞线的扭绞结构是为了减少相邻导线 间的串扰和消除外界干扰。</p><p>以上噪声都是可预测的，并有着比较固定的强度。</p><p>冲激噪声：是非连续的，由不规则的脉冲或持续时间短而振幅大的噪声尖峰组成。它的产生有多种原因，包括外部电磁波干扰以及通信通信系统本身的故障和缺陷。</p><p>信道容量：给定条件下，某一通信信道上所能达到的最大数据传输速率。</p><p>奈奎斯特带宽： $C = 2B log_2M$</p><p>波特率$R_B$与比特率$R_b$</p><p>$R_b = R_B log_2 M$ </p><p>香农公式: $C = B log_2 (1+SNR)$</p><p>$E_b$为每比特信号的能量, $N_0$ 为每赫兹噪声功率密度</p><p>$\frac{E_b}{N_0} = \frac{S/R}{N_0} = \frac{S}{kTR}$</p><h2 id="传输媒体"><a href="#传输媒体" class="headerlink" title="传输媒体"></a>传输媒体</h2><p>双绞线：</p><ul><li><p>廉价</p></li><li><p>方便</p></li><li><p>数据率低</p></li><li><p>传输距离短</p></li></ul><p>插入损耗，近端串扰</p><p>同轴电缆可以被用于长距离传输和更多的复用</p><p>光纤的特点：</p><ul><li><p>容量更大</p></li><li><p>体积更小、质量更轻</p></li><li><p>衰减更小</p></li><li><p>隔绝电磁场 (可以提高安全性)</p></li><li><p>转发器的间隔更远</p></li></ul><p>分类：</p><ul><li><p>多模突变传播：有多个角度可以发生反射。存在多条传播路径</p></li><li><p>单模传播：</p></li><li><p>多模渐变</p></li></ul><p>天线增益：$G_{dB} = 10 lg(P_2/p_1)$ </p><p>天线增益和有效面积的关系：$G = \frac{4 \pi A_e}{\lambda^2} = \frac{4 \pi f^2 A_e}{c^2}$  $A_e = 0.56 A$</p><p>无线传播:</p><ul><li><p>地波： f&lt;2MHz, AM</p></li><li><p>天波： BBC</p></li><li><p>视距： f&gt;30MHz.  $d = 3.57 (\sqrt{Kh_1} + \sqrt{Kh_2})$ </p></li></ul><p>自由空间损耗：$\frac{P_t}{P_r} = \frac{(4 \pi d)^2}{\lambda^2} = \frac{(4\pi f d)^2}{c^2}$  </p><h2 id="信号编码技术"><a href="#信号编码技术" class="headerlink" title="信号编码技术"></a>信号编码技术</h2><p>极性</p><ul><li><p>单极性：正电平和零电平对应二进制码1和0。 有直流分量，不适用有交流耦合的远距离传输。</p></li><li><p>双极性：正电平和负电平对应1和0. 1和0等概率出现时无直流分量</p></li></ul><p>归零:</p><ul><li><p>归零：电脉冲宽度小于码元宽度，即信号电压在一个码元终止时刻前总要回到零电平 (易于提取同步信息)</p></li><li><p>不归零：占空比100%</p></li></ul><p>占空比：电脉冲宽度/码元宽度</p><p>双相位：’0’用’01’两个相位表示, ‘1’用’10’两个相位表示</p><p>差分波形：利用相邻码元的电平跳变和不变来表示消息代码</p><p>数字信号编码：</p><ul><li><p>不归零电平(NRZ-L)</p><ul><li><p>0=高电平</p></li><li><p>1=低电平</p></li></ul></li><li><p>不归零1制(NRZI)</p><ul><li><p>0=在间隔的起始位置没有跳变</p></li><li><p>1=在间隔的起始位置跳变</p></li></ul></li><li><p>双极性AMI</p><ul><li><p>0=没有线路信号</p></li><li><p>1=正电平或负电平，如果是连续的比特1，则在正负电平之间不断交替</p></li></ul></li><li><p>伪三进制码</p><ul><li><p>0= 正电平或负电平，如果是连续的比特0，则在正负电平之间不断交替</p></li><li><p>1=没有线路信号</p></li></ul></li><li><p>曼彻斯特编码</p><ul><li><p>0=在间隔的中间位置从高向低跳变</p></li><li><p>1=在间隔的中间位置从低向高跳变</p></li></ul></li><li><p>差分曼彻斯特编码：在间隔的中间位置总是有一个跳变</p><ul><li><p>0 = 在间隔的起始位置跳变</p></li><li><p>1 = 在间隔的起始位置没有跳变</p></li></ul></li><li><p>8零替换(B8ZS)</p><ul><li>与双极性AMI类似，除了连续的8个零的比特串被另一个比特串所取代，这个比特串中有两个码是违反编码规则的</li></ul></li><li><p>高密度双极性3零码(HDB3)</p><ul><li>与双极性AMI类似，除了连续的4个零的比特串被另一个比特串所取代，这个比特串中有一个码是违反编码规则的</li></ul></li></ul><p>NRZ特点：</p><ul><li><p>简单</p></li><li><p>有效利用带宽</p></li><li><p>具有直流成份</p></li><li><p>缺乏同步能力</p></li></ul><p>扰码技术：使用扰码替代产生恒定电压的序列</p><p>填充序列</p><ul><li><p>必须产生足够的跳变以利于同步</p></li><li><p>必须被接收器识别并以原始序列替换回来</p></li><li><p>和原始序列长度相同</p></li></ul><p>设计目标：</p><ul><li><p>不含直流</p></li><li><p>含有丰富的定时信息</p></li><li><p>不会降低数据率</p></li><li><p>可提供差错检测</p></li><li><p>易于检测，不会被接收端误判</p></li></ul><p>三角公式</p><p>正交调幅： QAM : $s(t) = d_1(t)cos 2\pi f_c t + d_2(t) sin 2\pi f_c t$.</p><p>在同样的载波频率上发送两个不同的信号：</p><ul><li><p>使用两个载波，具备90偏移</p></li><li><p>每个载波通过ASK调制</p></li><li><p>在同样的传输媒体发送两个独立的信号</p></li></ul><p>脉码调制</p><p>压扩函数</p><p>AM: $S_{AM}(t) = (A_0+m(t)) cos \omega_c t$</p><p>PM: $S(t) = Acos[w_ct + n_p m(t)]$</p><p>FM: $S(t) = Acos[w_c t + n_f \int m(\tau) d \tau]$ </p><h2 id="数据链路控制协议"><a href="#数据链路控制协议" class="headerlink" title="数据链路控制协议"></a>数据链路控制协议</h2><p>性能指标</p><ul><li><p>传输时延: 数据量/数据率</p></li><li><p>传播时延: 从一端到另一端</p></li><li><p>处理时延</p></li><li><p>排队时延</p></li></ul><h3 id="流量控制-确保发送的数据不会超出接收实体接收数据能力的技术"><a href="#流量控制-确保发送的数据不会超出接收实体接收数据能力的技术" class="headerlink" title="流量控制: 确保发送的数据不会超出接收实体接收数据能力的技术"></a>流量控制: 确保发送的数据不会超出接收实体接收数据能力的技术</h3><h4 id="停止等待流量控制"><a href="#停止等待流量控制" class="headerlink" title="停止等待流量控制"></a>停止等待流量控制</h4><p>流程:</p><ol><li><p>源点发送帧</p></li><li><p>终点接收帧并返回ACK</p></li><li><p>源点收到ACK后发送下一帧</p></li><li><p>终点可以通过不发送ACK来终止流</p></li></ol><p>停止等待流量控制对于少量但比较长的帧是比较有效的，但对于多量但比较短的帧不是很高效。</p><p>但把数据分割成较小的数据块更为常见，原因如下:</p><ol><li><p>接收方缓存有限</p></li><li><p>大数据块容易发生错误，出现错误时，重传的数据量也比较小。</p></li><li><p>避免一个站点长时间占用传输媒体</p></li></ol><p>一些计算:</p><ul><li><p>链路的比特长度: $B = R \times \frac{d}{v}$ , $R$ 是数据率(bps), $d$ 是链路长度$m$, $V$ 是传播速度$m/s$.</p></li><li><p>传播时延/时间(归一化值) : $a  = \frac{t<em>{prop}}{t</em>{frame}} = \frac{d/V}{L/R} = \frac{B}{L}$   , $L$ 是一个帧中的比特数</p></li><li><p>链路利用率: $U = \frac{t<em>{frame}}{t</em>{all}} = \frac{t<em>{frame}}{2t</em>{prop} + t_{frame}} = \frac{1}{2a+1}$   </p></li></ul><h4 id="滑动窗口流量控制"><a href="#滑动窗口流量控制" class="headerlink" title="滑动窗口流量控制"></a>滑动窗口流量控制</h4><p>流程:</p><ul><li><p>接收端缓存大小W</p></li><li><p>发送端在没有收到ACK前可以发送W个帧</p></li><li><p>每个帧通过序号来标识</p><ul><li><p>序号大小受字段长度限制(k bits)</p></li><li><p>帧以$2^k$ 为模编号($0 … 2^k - 1$) </p></li></ul></li><li><p>ACK 包含下一个期望收到的帧编号</p></li></ul><p>协议优化</p><ul><li><p>接收端允许发送RNR,切断对方的帧流</p></li><li><p>之后，接收端必须通过一个正常的确认帧来重启滑窗</p></li><li><p>如果是双向链路,可以使用捎带“piggybacking”</p><ul><li><p>一个帧包含发送数据和ACK</p></li><li><p>如果没有数据发送，发送独立的确认帧</p></li><li><p>如果需要发送数据，但是没有新的确认，则重新发送上一次已经发送过的确认</p></li></ul></li></ul><p>计算:</p><ul><li><p>链路利用率: $W$ 为窗口宽度</p><ul><li><p>$U = 1$, $W \ge 2a+1$ </p></li><li><p>$U = \frac{W}{2a+1}$, $W&lt; 2a+1$ </p></li></ul></li></ul><h3 id="差错控制-用于检测和纠正帧传输过程中出-现差错的机制"><a href="#差错控制-用于检测和纠正帧传输过程中出-现差错的机制" class="headerlink" title="差错控制: 用于检测和纠正帧传输过程中出 现差错的机制"></a>差错控制: 用于检测和纠正帧传输过程中出 现差错的机制</h3><p>针对以下两种类型的差错:</p><ul><li><p>帧丢失: 帧没有到达另一方</p></li><li><p>帧损伤: 帧到达，但是有一些比特有差错</p></li></ul><p>数据链路层差错控制采用自动请求重传(automatic repeat request)机制</p><p>ARQ使得一个不可靠的数据链路变为可靠链路：</p><ul><li><p>差错检测</p></li><li><p>肯定确认</p></li><li><p>超时重传</p></li><li><p>否认与重传</p></li></ul><p>三种ARQ标准:</p><ul><li><p>停止等待ARQ(stop-and-wait ARQ)</p></li><li><p>返回N ARQ(go-back-N ARQ)</p></li><li><p>选择拒绝ARQ(selective-reject ARQ)</p></li></ul><p>停止等待ARQ</p><ul><li><p>基于停止等待流量控制</p></li><li><p>要保存一个发送帧的拷贝, 在终点确认返回前，源点不发送其他帧</p></li><li><p>帧损伤:</p><ul><li><p>接收端检测到差错，丢弃该帧</p></li><li><p>发送端超时重传</p></li></ul></li><li><p>ACK损伤:</p><ul><li><p>发送端超时重传</p></li><li><p>接收端收到用两份相同编号的帧</p></li><li><p>使用 ACK0 / ACK1 来确认希望接收的帧</p><ul><li>ACKi means“I am ready to receive frame i”</li></ul></li></ul></li></ul><p>返回N ARQ</p><ul><li><p>最常用的差错控制协议</p></li><li><p>基于滑动窗口流控机制,没有收到确认的帧的最大数目取决于窗口大小</p></li><li><p>如果没有差错，使用ACK确认接收就绪</p></li><li><p>如果错误发生，为错误帧发送rejection(negativeACK)</p><ul><li><p>接收端丢弃该帧和所有后来收到的帧，直到错误帧被正确接收</p></li><li><p>发送端必须重传有差错的帧和差错帧后所有已 经传输过的帧</p></li></ul></li><li><p>窗口大小最大为$2^k -1$ </p></li><li><p>Go-back-N 接收不允许乱序? </p></li></ul><p>选择拒绝ARQ</p><ul><li><p>仅重传拒绝帧或超时帧，也叫做选择重传ARQ</p></li><li><p>后续帧被接收端接收并缓存起来</p></li><li><p>最小化重传帧的数量</p></li><li><p>接收端需要维护足够大的缓存</p></li><li><p>发送端和接收端逻辑更为复杂</p><ul><li><p>能够按照正确的顺序重组帧</p></li><li><p>判断并仅发送失序帧</p></li></ul></li><li><p>用于传播时延长的卫星链路</p></li><li><p>窗口大小最大为$2^{k-1}$</p></li></ul><h3 id="HDLC"><a href="#HDLC" class="headerlink" title="HDLC"></a>HDLC</h3><ul><li><p>站点类型:</p><ul><li><p>主站:负责控制链路操作. 由主站发出的帧称为命令</p></li><li><p>从站: 在主站的控制下操作。由从站发出的帧称为响应。主站为链路上的每个从站维护一条独立的逻辑链路。</p></li><li><p>混合站: 结合了主站和从站的特点。混合站发出的帧既可能是命令，也可能是响应。</p></li></ul></li><li><p>链路设置:</p><ul><li><p>非平衡设置 – 1个主站、 多个从站， 可支持全双工或半双工传输。</p></li><li><p>平衡设置 – 2个混合站组成， 可支持全双工或半双工传输。</p></li></ul></li><li><p>数据传送方式:</p><ul><li><p>正常响应方式(NRM)</p><ul><li><p>非平衡设置</p></li><li><p>主站能够发起到从站的数据传送</p></li><li><p>从站只有在接收到主站的命令式才传输数据</p></li></ul></li><li><p>异步平衡方式(ABM)</p><ul><li><p>平衡设置</p></li><li><p>两个混合站都能够发起数据传输，不需要对方混合站 的许可</p></li><li><p>使用最广泛</p></li></ul></li></ul></li><li><p>帧结构: </p><ul><li><p>使用同步传输</p></li><li><p>传输以帧的形式进行</p></li><li><p>一个帧格式满足所有数据和控制交换</p></li></ul></li></ul><h2 id="复用"><a href="#复用" class="headerlink" title="复用"></a>复用</h2><h3 id="FDM-频分复用"><a href="#FDM-频分复用" class="headerlink" title="FDM 频分复用"></a>FDM 频分复用</h3><ul><li><p>概念: 将多个信号调制到不同的载波频率上，且有足够间隙防止其带宽重叠，以同时运载</p></li><li><p>信道: 每个信号以各自载波频率为中心的一定的带宽。</p></li><li><p>防护频带: 在载波频率中，信道之间未被占用的部分</p></li><li><p>流程: </p><ul><li>信号$m_i(t)$  —副载波调制器$f_i$–&gt;  副载波$s_i(t)$ —叠加$\Sigma$ —&gt; 复合基带调制信号$m_b(t)$ —–发送器$f_c$ —&gt; FDM信号$s(t)$  —-接收器—&gt; 复合基带信号$m_b(t)$  —– 带通滤波器$f_i$ ——&gt; 副载波$s_i(t)$ —–解调器$f_i$ —-&gt; 信号$m_i(t)$. </li></ul></li><li><p>波分复用:</p><ul><li><p>波分复用是光纤通信中使用的一种复用方式</p></li><li><p>不同波长的光信号通过同一根光纤传输</p></li><li><p>在概念上与频分复用相同</p></li><li><p>采用不同源的窄带光组成一个宽带光</p><ul><li>棱镜用作波分复用及其多路分解</li></ul></li></ul></li></ul><h3 id="Synchronous-TDM-同步时分复用"><a href="#Synchronous-TDM-同步时分复用" class="headerlink" title="Synchronous TDM  同步时分复用"></a>Synchronous TDM  同步时分复用</h3><p>概念</p><ul><li><p>可以用于数字信号或模拟信号传输数字数据</p></li><li><p>数据被组织成“帧”:每帧包含一组循环使用的时隙;每个数据源可以被分配一个或多个时隙</p></li><li><p>间隔可以是比特级，也可以是字符级或更大的粒度</p></li><li><p>同步时分复用中同步是指时隙被提前分配给数据源且是固定的</p></li></ul><p>流程:</p><ul><li>数据$m_i(t)$ —-缓存—&gt; 数据$m_i(t)$  —–扫描操作—-&gt; TDM流$m_c(t)$ ——调制调节器—–&gt; 经调制的TDM流$s(t)$  ——-调制解调器—–&gt;  TDM流$m_c(t)$  —–扫描操作—–&gt; 数据$m_i(t)$  —–缓存—–&gt; 数据$m_i(t)$</li></ul><p>链路控制:</p><ul><li><p>数据流不存在头部和尾部,不需要数据链路控制</p></li><li><p>数据率是固定的，如果没有信息将发送空时隙</p></li><li><p>差错控制: 基于单信道的差错控制</p></li></ul><p>组帧:</p><ul><li><p>不需要flag或SYNC字符为TDM帧定界</p></li><li><p>仍然需要提供源和宿端的同步(clock)机制</p></li><li><p>增加数字组帧技术</p><ul><li><p>每个TDM帧附加一个控制比特</p></li><li><p>可识别的比特模式</p></li><li><p>一个典型的交替比特模式 101010……</p></li><li><p>同步搜索模式:接收器将接收到的帧中的比特位与预 期的模式相比较，直到这个模式在多个帧里持续传输， 建立帧同步</p></li></ul></li></ul><p>数字载波系统:</p><ul><li><p>E体系: PCM30/32路数字载波系统, </p><ul><li><p>以2.048Mbps作为基群速率(E1速率) 的数字系列</p></li><li><p>欧洲、中国采用，并用于国际间传输</p></li></ul></li><li><p>T体系 PCM24路数字载波系统</p><ul><li><p>– 以1.544Mbps作为基群速率(T1速率) 的数字系列</p></li><li><p>用于北美、日本</p></li></ul></li></ul><h3 id="Statistical-TDM-统计时分复用"><a href="#Statistical-TDM-统计时分复用" class="headerlink" title="Statistical TDM 统计时分复用"></a>Statistical TDM 统计时分复用</h3><ul><li><p>概念</p><ul><li><p>每个源有一缓存，填满时作为一帧发送</p></li><li><p>根据需求分配时隙，解决空时隙和浪费问题</p></li></ul></li><li><p>电缆调制解调器</p><ul><li>让用户通过有线电视网访问Internet</li></ul></li></ul><h3 id="ADSL-非对称用户数字线路"><a href="#ADSL-非对称用户数字线路" class="headerlink" title="ADSL 非对称用户数字线路"></a>ADSL 非对称用户数字线路</h3><ul><li><p>用户和广域网络之间的线路(最后一公里)</p></li><li><p>使用已安装好的双绞线(电话线)</p></li><li><p>非对称 – 下行流容量高于上行流</p></li><li><p>使用频分复用uses Frequency Division Multiplexing</p><ul><li><p>最低的 25kHz用于话音业务 (POTS)</p></li><li><p>使用回声抵消(echo cancellation)或者FDM提供双向传 输</p></li></ul></li><li><p>距离范围可达5.5km</p></li></ul><h2 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h2><h3 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h3><ul><li><p>用于公众电话网 PSTN， 为处理话音通信量(voice traffic)而开发，但 也能处理数字数据</p></li><li><p>在两个站点之间建立固定通路</p></li><li><p>通信期间在网络内部保留交换与传输资源</p></li><li><p>一旦电路建立，网络连接是透明的</p></li><li><p>流程: 建立通路，通信，断开通路</p></li></ul><h3 id="空分交换"><a href="#空分交换" class="headerlink" title="空分交换"></a>空分交换</h3><ul><li><p>Cross Switch: 两两交叉，$n$ 入$n$ 出, 有$n^2$个交叉点，至多用$n$ 个交叉点。 非阻塞</p></li><li><p>3-Stage Space Division Switching: </p><ul><li><p>第一级: $\frac{N}{n}$ 个 $N \times m$ 单元</p></li><li><p>第二级: $m$ 个$n \times n$ 单元</p></li><li><p>第三极: $\frac{N}{n}$ 个 $N \times m$ 单元</p></li><li><p>$m \ge 2n-1$ 时非阻塞， 否则阻塞。</p></li></ul></li><li><p>Banyan Switch: 利用输入端的二进制编码来构建空分交换, </p></li></ul><h3 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h3><ul><li><p>概念: </p><ul><li><p>数据交换,大数据段分为较小的数据包，包括用户数据和控制信息</p></li><li><p>途径多个节点，可被缓存</p></li></ul></li></ul><p>数据包交换:</p><ul><li><p>每个数据包都被当做单独的数据包对待</p></li><li><p>无建立时间，灵活，可靠</p></li></ul><p>虚电路交换:</p><ul><li><p>先建立(虚拟)路径，此后数据包都按此路径发送</p></li><li><p>可提供排序和错误控制,可以按序发送，传送速度更快(无需选择路由)，较不可靠。</p></li></ul><h3 id="异步传输模式-ATM"><a href="#异步传输模式-ATM" class="headerlink" title="异步传输模式 ATM"></a>异步传输模式 ATM</h3><p>概念:</p><ul><li><p>信元: 小的，固定长度的分组，减小时延</p></li><li><p>面向连接的分组交换技术，提供类似电路交换网络的性能，同时又提供分组交换的灵活性和效率</p></li><li><p>数据率:高</p></li><li><p>支持数据，语音，视频</p></li><li><p>传输: 基于优先级和QoS，用户可选择服务等级</p></li></ul><p>ATM逻辑连接:</p><ul><li><p>虚通路: VCC,类似虚电路,速率可变，全双工，定长信元流</p></li><li><p>虚通道连接: VPC, 一群具有相同端点的虚通路</p></li></ul><h2 id="蜂窝无线网络"><a href="#蜂窝无线网络" class="headerlink" title="蜂窝无线网络"></a>蜂窝无线网络</h2><p>概念:</p><ul><li><p>区域被分成蜂窝</p></li><li><p>使用低功率发送器，100W以下，控制功率防止频率逃逸</p></li><li><p>每个蜂窝一个基站: 发送器，接收器和控制单元。</p></li><li><p>相邻蜂窝频率不同:防止干扰</p></li><li><p>蜂窝形状为六边形: 蜂窝半径为R,则相邻蜂窝中心距离$\sqrt{3} R$ </p></li></ul><p>频率重用:</p><ul><li><p>$D$: 使用相同频率的蜂窝中心之间的距离</p></li><li><p>$R$: 蜂窝半径</p></li><li><p>$d$: 相邻蜂窝中心之间的距离</p></li><li><p>$N$: 重复模式中的蜂窝数量，重用系数，其可能值仅有这些: $N = I^2 + J^2 + I \times J$, $I,J = 0,1,2,3,…$</p></li><li><p>$D/R = \sqrt{3N}$ </p></li></ul><p>增大容量:</p><ul><li><p>添加新信道</p></li><li><p>频率借用</p></li><li><p>蜂窝分裂</p></li><li><p>蜂窝扇区化</p></li><li><p>微蜂窝</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数据通信期中复习&quot;&gt;&lt;a href=&quot;#数据通信期中复习&quot; class=&quot;headerlink&quot; title=&quot;数据通信期中复习&quot;&gt;&lt;/a&gt;数据通信期中复习&lt;/h1&gt;&lt;p&gt;通信模型： 源点-&amp;gt;发送器-&amp;gt;传输系统-&amp;gt;接收器-&amp;gt;终点&lt;/p&gt;
&lt;p&gt;单工、半双工、双工。&lt;/p&gt;
&lt;p&gt;数字通信系统:利用数字信号来传递信息的通信系统&lt;/p&gt;
&lt;p&gt;模拟通信系统: 利用模拟信号来传递信息的通信系统&lt;/p&gt;
&lt;p&gt;混成系统&lt;/p&gt;
&lt;p&gt;TCP/IP 5层模型&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;应用层：用于支持各种不同应用程序的逻辑 (SMTP,FTP,SSH,HTTP)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;运输层：提供端到端的传输服务 (TCP,UDP)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;网际层：提供多个网络的路由选择功能，能够让数据跨越多个互联的网路 (IPv4,Ipv6))&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;数据链路层：为与同一个网络相连的两个系统提供网络接入 (以太网,WiFi,ATM,帧中继)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;物理层：负责数据传输设备与传输媒体的物理接口 (双绞线,光纤,卫星,地面微波)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android Studio Installation</title>
    <link href="https://ricky-ting.github.io/2019/04/03/Android-Studio-Installation/"/>
    <id>https://ricky-ting.github.io/2019/04/03/Android-Studio-Installation/</id>
    <published>2019-04-03T03:07:18.000Z</published>
    <updated>2019-04-03T03:11:38.845Z</updated>
    
    <content type="html"><![CDATA[<p>出现错误的话，把<code>~/.gradle</code>删除, 并把代理全部关掉，重新打开build。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;出现错误的话，把&lt;code&gt;~/.gradle&lt;/code&gt;删除, 并把代理全部关掉，重新打开build。&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>proxy for bash</title>
    <link href="https://ricky-ting.github.io/2019/04/01/proxy-for-bash/"/>
    <id>https://ricky-ting.github.io/2019/04/01/proxy-for-bash/</id>
    <published>2019-04-01T03:04:55.000Z</published>
    <updated>2019-04-01T03:06:15.893Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export ALL_PROXY=socks5://127.0.0.1:1086</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数据通信笔记</title>
    <link href="https://ricky-ting.github.io/2019/03/12/%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%E7%AC%94%E8%AE%B0/"/>
    <id>https://ricky-ting.github.io/2019/03/12/数据通信笔记/</id>
    <published>2019-03-12T06:02:49.000Z</published>
    <updated>2019-03-12T07:51:10.247Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据通信笔记"><a href="#数据通信笔记" class="headerlink" title="数据通信笔记"></a>数据通信笔记</h1><h2 id="课程介绍"><a href="#课程介绍" class="headerlink" title="课程介绍"></a>课程介绍</h2><p>课程主页：<a href="http://cs.nju.edu.cn/yafeng/" target="_blank" rel="noopener">http://cs.nju.edu.cn/yafeng/</a> </p><p>考核形式：</p><ul><li><p>课程习题：考试重点(6-8次)</p></li><li><p>课外作业：文档阅读，完成报告(&gt;=6页)</p></li><li><p>期中小测验+期末考试</p></li><li><p>成绩：期末(70%)+期中(10%)+课程习题(10%)+课外作业(10%)</p></li></ul><a id="more"></a><h2 id="数据通信综述"><a href="#数据通信综述" class="headerlink" title="数据通信综述"></a>数据通信综述</h2><p><strong>数字通信系统：</strong>利用数字信号来传递信息的通信系统</p><p><strong>模拟通信系统:</strong>   利用模拟信号来传递信息的通信系统</p><p><strong>混成系统：</strong> 同一系统中包含模拟通信和数字通信</p><p>网络术语：</p><ul><li><p>节点(node): 网络中通信线路连接的计算机和交换机</p></li><li><p>线路(line): 节点间通信的物理连接</p></li><li><p>链路(link): 建立在相邻节点物理连接上的逻辑信道</p></li><li><p>电路(circuit): 源站点与目的站点之间建立的传输通路</p></li><li><p>交换(switching): 交换节点建立、保持和改变数据传输通路的过程</p></li><li><p>路由选择(routing): 交换技术中选择传输路径的功能</p></li><li><p>传输中继/传输网</p></li><li><p>接入线/接入网</p></li></ul><p>网络拓扑：</p><ul><li><p>星型</p></li><li><p>树型</p></li><li><p>环型</p></li><li><p>总线型</p></li></ul><h2 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h2><p>成功的数据传输依赖于两个因素：</p><ul><li><p>传输信号的质量 Quality of the Signal</p></li><li><p>传输媒体的特性</p></li></ul><p>导向媒体(点对点、多点)， 非导向媒体</p><p>噪声:通信通路上的平均噪声电平</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数据通信笔记&quot;&gt;&lt;a href=&quot;#数据通信笔记&quot; class=&quot;headerlink&quot; title=&quot;数据通信笔记&quot;&gt;&lt;/a&gt;数据通信笔记&lt;/h1&gt;&lt;h2 id=&quot;课程介绍&quot;&gt;&lt;a href=&quot;#课程介绍&quot; class=&quot;headerlink&quot; title=&quot;课程介绍&quot;&gt;&lt;/a&gt;课程介绍&lt;/h2&gt;&lt;p&gt;课程主页：&lt;a href=&quot;http://cs.nju.edu.cn/yafeng/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://cs.nju.edu.cn/yafeng/&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;考核形式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;课程习题：考试重点(6-8次)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;课外作业：文档阅读，完成报告(&amp;gt;=6页)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;期中小测验+期末考试&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;成绩：期末(70%)+期中(10%)+课程习题(10%)+课外作业(10%)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>问题求解2019Spring</title>
    <link href="https://ricky-ting.github.io/2019/03/06/%E9%97%AE%E9%A2%98%E6%B1%82%E8%A7%A32019Spring/"/>
    <id>https://ricky-ting.github.io/2019/03/06/问题求解2019Spring/</id>
    <published>2019-03-06T02:26:24.000Z</published>
    <updated>2019-03-24T14:39:59.744Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题求解-2019Spring"><a href="#问题求解-2019Spring" class="headerlink" title="问题求解 2019Spring"></a>问题求解 2019Spring</h1><h2 id="4-1线性规划"><a href="#4-1线性规划" class="headerlink" title="4.1线性规划"></a>4.1线性规划</h2><p>In linear programming, we do not allow strict inequalities.</p><p><strong>minimization linear program</strong> and <strong>maximization program</strong></p><p>The simplex algorithm does not run in polynomial time in the worst case, but it is fairly efficient and widely used in practice.</p><p>We use two forms, <strong>standard</strong> and <strong>slack</strong>.</p><p>Informally, a linear program in standard form is the maximization of a linear function subject to linear inequalities, whereas a linear program in slack form is the maximization of a linear function subject to linear equalities.</p><a id="more"></a><p>We call the feasible region formed by the intersection of these half-spaces a <strong>simplex</strong>.</p><p>The <strong>simplex</strong> algorithm starts at some vertex of the simplex and performs a sequence of iterations. In each iteration, it moves along an edge of the simplex from a current vertex to a neighboring vertex whose objective value is no smaller than that of the current vertex(and usually is larger.) The simplex algorithm terminates when it reaches a local maximum, which is a vertex from which all neighboring vertices have a smaller objective value.</p><p>If we add to a linear program the additional requirement that all variables take on integer values, we have an <strong>integer linear program</strong>.</p><p>An arbitrary linear program need not have nonnegativity constraints, but standard form requires them.</p><p>We say that two maximization linear programs $L$ and $L’$ are <strong>equivalent</strong> if for each feasible solution $\bar{x}$ to $L$ with objective value $z$, there is a corresponding feasible solution $\bar{x}’$ to $L’$  with objective value $z$ and for each feasible solution $\bar{x}’’$ to $L’$ with objective value $z$, there is a corresponding feasible solution $\bar{x}$ to $L$ with objective value $z$.(This definition does not imply a one-to-one correspondence between feasible solutions.)</p><p>How to convert linear programs into standard form?</p><p>如何添加非负限制的设计很精巧</p><p>How to convert linear programs into slack form?</p><p>We call $s$ a <strong>slack variable</strong> because it measures the <strong>slack</strong>, or the difference, between the left-hand and right-hand sides of equation.</p><p>We call the variables on the left-hand side of the equalities <strong>basic variables</strong> and those on the right-hand side <strong>nonbasic variables</strong>.</p><h2 id="4-2-群论初步"><a href="#4-2-群论初步" class="headerlink" title="4.2 群论初步"></a>4.2 群论初步</h2><h3 id="Some-definations"><a href="#Some-definations" class="headerlink" title="Some definations"></a>Some definations</h3><p>A <strong>symmetry</strong> of a geometric figure is a rearrangement of the figure preserving the arrangement of its sides and vertices as well as its distances and angles. </p><p>A map from the plane to itself preserving the symmetry of an object is called a <strong>rigid motion</strong>.</p><p>A <strong>binary operation</strong> or <strong>law of composition</strong> on a set $G$ is a function $G \times G \rightarrow G$ that assigns to each pair $(a,b) \in G \times G$  a unique element  $a \circ b$, or $ab$ in $G$, called the composition of $a$ and $b$. A <strong>group</strong> $(G,\circ)$ is a set $G$ together with a law of composition $(a,b) \mapsto a \circ b$ that satisfies the following axioms.</p><ul><li><p><strong>associative</strong>:     $(a \circ b) \circ c = a \circ (b \circ c)$ </p></li><li><p><strong>identity element</strong>:  $e \circ a = a \circ e =a$</p></li><li><p><strong>inverse element</strong> : $a \circ a^{-1} = a^{-1} \circ a =e$ </p></li></ul><p>A group $G$ with the property that $a \circ b = b \circ a$ for all $a,b \in G$  is called <strong>abelian</strong> or <strong>commutative</strong>. Groups not satisfying this property are said to be <strong>nonabelian</strong> or <strong>noncommutative</strong>.</p><p><img src="/images/" alt=""></p><p>A <strong>Cayley table</strong> .</p><p>Every nonzero $k$ does have an inverse in $Z<em>{n}$ if $k$ is relatively prime to $n$. Denote the set of all such nonzero elements in $Z</em>{n}$ by $U(n)$. Then $U(n)$  is  a group called the <strong>group of units</strong> of $Z_{n}$ .</p><p>The set of invertible matrices forms a group  called the <strong>general linear group</strong>. </p><p>A group is <strong>finite</strong>, or has <strong>finite order</strong>, if it contains a finite number of elements; otherwise, the group is said to be <strong>infinite</strong> or to have <strong>infinite</strong> order. The <strong>order</strong> of a finite group is the number of elements that it contains.</p><h3 id="Basic-Properties-of-Groups"><a href="#Basic-Properties-of-Groups" class="headerlink" title="Basic Properties of Groups"></a>Basic Properties of Groups</h3><p><strong>Proposition 3.17.</strong> The identity element in a group $G$ is unique; that is, there exists only one element $e \in G$</p><p> such that $eg=ge=g$ for all $g \in G$.</p><p><strong>Proposition 3.18.</strong> If $g$ is any element in a group $G$, then the inverse of $g$ , denoted by $g^{-1}$ , is unique.</p><p><strong>Proposition 3.19</strong> Let $G$  be a group. If $a,b \in G$, then $(ab)^{-1} = b^{-1}a^{-1}$.</p><p><strong>Proposition 3.20.</strong> Let $G$ be a group. For any $a \in G$, $(a^{-1})^{-1}=a$.</p><p><strong>Proposition 3.21</strong> Let $G$ be a group and $a$ and $b$ be any two elements in $G$. Then the equations $ax=b$ and $xa=b$ have unique solutions in $G$.</p><p><strong>Proposition 3.22. (right and left cancellation laws)</strong>  If $G$ is a group and $a,b,c\in G$, then $ba=ca$ implies $b=c$ and $ab=ac$ implies $b=c$.</p><p><strong>Theorem 3.23.</strong> In a group, the usual laws of exponents hold; that is, for all $g,h \in G$,</p><ol><li><p>$g^m G^n = g^{m+n}$ for all $m,n \in Z$</p></li><li><p>$(g^m)^n = g^{mn}$ for all $m,n \in Z$ </p></li><li><p>$(gh)^n = (h^{-1} g^{-1})^{-n}$ for all $n\in Z$. Furthermore, if $G$ is abelian, then $(gh)^n = g^n h^n$.</p></li></ol><h3 id="Subgroups"><a href="#Subgroups" class="headerlink" title="Subgroups"></a>Subgroups</h3><p>We define a <strong>subgroup</strong> $H$ of a group $G$ to be a subset $H$ of $G$ such that when the group operation of $G$ is restricted to $H$, $H$ is a group in its own right.</p><p>Every group has at least two subgroups. The subgroup $H={e}$ of a group $G$ is called the <strong>trivial subgroup</strong>. A subgroup that is a proper subset of $G$ is called a <strong>proper subgroup</strong>.</p><h3 id="Some-Subgroup-Theorems"><a href="#Some-Subgroup-Theorems" class="headerlink" title="Some Subgroup Theorems"></a>Some Subgroup Theorems</h3><p><strong>Proposition 3.30</strong> A subset $H$ of $G$ is a subgroup if and only if it satisfies the following conditions.</p><ol><li><p>The identity of $e$ of $G$ is in $H$.</p></li><li><p>If $h_1,h_2 \in H$, thne $h_1h_2 \in H$.</p></li><li><p>If $h \in H$, then $h^{-1} \in H$.</p></li></ol><p><strong>Proposition 3.31</strong> Let $H$ be a subset of a group $G$. Then $H$ is a subgroup of $G$ if and only if $H \not= \emptyset$, and whenever $g,h \in H$ then $gh^{-1}$ is in $H$.</p><h3 id="Cyclic-Subgroups"><a href="#Cyclic-Subgroups" class="headerlink" title="Cyclic Subgroups"></a>Cyclic Subgroups</h3><p><strong>Theorem 4.3</strong> Let $G$ be a group and $a$ be any element in $G$. Then the set $<a> = { a^k : k \in Z }$ is a subgroup of $G$. Furthermore, $<a>$ is the smallest subgroup of $G$ that contains $a$.</a></a></p><p>For  $a\in G$, we call $<a>$ the <strong>cyclic subgroup</strong> generated by $a$. If $G$ contains some element $a$ such that $G=<a>$, then $G$ is a <strong>cyclic group</strong>. In this case $a$ is a <strong>generator</strong> of $G$. If $a$ is an element of a group $G$, we define the <strong>order</strong> of $a$ to be the smallest positive integer $n$ such that $a^n =e$, and we write $|a|=n$. If there is no such integer $n$, we say that the order of $a$ is inifinte and write $|a|= \infty$ to denote the order of $a$.</a></a></p><p><strong>Theorem 4.9.</strong> Every cyclic group is abelian.</p><p><strong>Theorem 4.10</strong> Every subgroup of a cyclic group is cyclic.</p><p><strong>Corollary 4.11</strong> The subgroups of $Z$ are exactly $nZ$ for $n=0,1,2,….$</p><p><strong>Proposition 4.12</strong> Let $G$ be a cyclic group of order $n$ and suppose that $a$ is a generator for $G$. Then $a^k=e$ if and only if $n$ divides $k$.</p><p><strong>Theorem 4.13</strong> Let $G$ be a cyclic group of order $n$ and suppose that $a \in G$ is a generator of the group. If $b= a^k$, then the order of $b$ is $n/d$, where $d=gcd(k,n)$.</p><p><strong>Corollary 4.14</strong> The generators of $Z_n$ are the integers $r$ such that $1 \le r &lt; n$ and $gcd(r,n)=1$.</p><h3 id="置换群与拉格朗日定理"><a href="#置换群与拉格朗日定理" class="headerlink" title="置换群与拉格朗日定理"></a>置换群与拉格朗日定理</h3><p>In general, the permutations of a set $X$ form a group $S_X$. If $X$ is a finite set, we can assume $X={1,2,…,n}$. In this case we write $S_n$ instead of $S_X$.  We call this group the <strong>symmetric group</strong> on $n$ letters.</p><p><strong>Theorem 5.1</strong> The symmetric group on $n$ letters, $S_n$ is a group with $n!$ elements, where the binary operation is the composition of maps.</p><p>A subgroup of $S_n$ is called a <strong>permutation group</strong>.</p><p>Permutation multiplication is not usually commutative.</p><p>A permutation $\sigma \in S_X$ is a <strong>cycle of length</strong> $k$ if there exist elements $a_1, a_2, …, a_k \in X$ such that $ \sigma(a_1)=a_2,\sigma(a_2)=a_3,…,\sigma(a_k)=a_1  $ and $\sigma(x)=x$ for all other elements $x \in X$. We will write $(a_1,a_2,..,a_k)$ to denote the cycle $\sigma$. </p><p>Cycles are the building blocks of all permutations.</p><p>Two cycles in $S_X$ , $\sigma = (a_1, a_2,…,a_k)$ and $\tau = (b_1,b_2,…,b_l)$, are <strong>disjoint</strong> of $a_i \not= b_i$ for all $i$ and $j$.</p><p><strong>Proposition 5.8.</strong> Let $\sigma$ and $\tau$ be two disjoint cycles in $S_X$. Then $\sigma \tau = \tau \sigma$.</p><p><strong>Theorem 5.9</strong> Every permutation in $S_n$ can be written as the product of disjoint cycles.</p><h4 id="Transpositions"><a href="#Transpositions" class="headerlink" title="Transpositions"></a>Transpositions</h4><p>The simplest permutation is a cycle of length $2$. Such cycles are called <strong>transpositions</strong>. Since $(a_1,a_2,…,a_n)=(a_1a_n)(a<em>1 a</em>{n-1})…(a_1a_3)(a_1a_2)$</p><p><strong>Proposition 5.12.</strong> Any permutation of a finite set containing at least two elements can be written as the product of transpositions.</p><p>No permutation can be written as the product of both an even number of transpositions and an odd number of transpositions.</p><p><strong>Lemma 5.14</strong> If the identity is written as the product of $r$ transpositions, $id = \tau_1 \tau_2 \cdot \cdot \cdot \tau_r , $  then $r$ is an even number.   (Proof need to be understood)</p><p><strong>Theorem 5.15</strong> If a permutation $\sigma$ can be expressed as the product of an even number of transpositions, then any other product of transpositions equaling $\sigma$ must also contain an even number of transpositions. Similarly, if $\sigma$ can be expressed as the product of an odd number of transpositions, then any other product of transpositions equaling $\sigma$ must also contain an odd number of transpositions.</p><p><strong>My comment on the proof of 5.14:</strong>  The fact that the inverse of $\sigma$ is $\sigma_m \cdot \cdot \cdot  \sigma_1$ confuses me some time. By introducing the fact that two identity transpositions equals to the identity, it is much clear.  Also note that the inverse of any transposition is itself.</p><p>We define a permutation to be <strong>even</strong> if it can be expressed as an even number of transpostions and <strong>odd</strong> if it can be expressed as an odd number of transpositions.</p><h4 id="The-Alternating-Groups"><a href="#The-Alternating-Groups" class="headerlink" title="The Alternating Groups"></a>The Alternating Groups</h4><p>One of the most important subgroups of $S_n$ is the set of all even permutations, $A_n$. The group $A_n$ is called the <strong>alternating group on $n$ letters</strong>.</p><p><strong>Theorem 5.16</strong> The set $A_n$ is a subgroup of $S_n$.</p><p><strong>Proposition 5.17</strong> The number of even permutations in $S_n, n&gt;2$, is equal to the number of odd permutations; hence, the order of $A_n$ is $n!/2$ .</p><h4 id="Dihedral-Groups"><a href="#Dihedral-Groups" class="headerlink" title="Dihedral Groups"></a>Dihedral Groups</h4><p>For $n=3,4,…,$, we define the $n$<strong>th dihedral group</strong> to be the group of rigid motions of a regular $n$-gon.</p><p><strong>Theorem 5.20.</strong> The dihedral group, $D_n$, is a subgroup of $S_n$ of order $2n$.</p><p><strong>Theorem 5.23.</strong> The group $D_n$ , $n \ge 3$, consists of all products of two elements $r$ and $s$, satisfying the relations $r^n=1, s^2=1, srs=r^{-1}$.</p><p><strong>Proposition 5.27.</strong> The group of rigid motions of a cube contains $24$ elements.</p><p><strong>Theorem 5.28.</strong> The group of rigid motions of a cube is $S_4$.</p><h4 id="Cosets"><a href="#Cosets" class="headerlink" title="Cosets"></a>Cosets</h4><p>Let $G$ be a group and $H$ a subgroup of $G$. Define a <strong>left coset</strong> of $H$ with <strong>representative</strong> $g \in G$ to be the set $gH = { gh : h \in H }$. <strong>Right cosets</strong> can be defined similarly by $Hg = { hg:h \in H }$. </p><p><strong>Lemma 6.3.</strong> Let $H$ be a subgroup of a group $G$ and suppose that $g_1,g_2 \in G$. The following conditions are equivalent.</p><ol><li><p>$g_1 H = g_2 H$</p></li><li><p>$H g_1^{-1} = H g_2^{-1}$</p></li><li><p>$g_1 H \subset g_2 H $</p></li><li><p>$g_2 \in g_1 H$</p></li><li><p>$ g_1^{-1} g_2 \in H$.</p></li></ol><p><strong>Theorem 6.4</strong> Let $H$ be a subgroup of a group $G$. Then the left cosets of $H$ in $G$ partition $G$. That is, the group $G$ is the disjoint union of the left cosets of $H$ in $G$.</p><p>Let $G$ be a group and $H$ be a subgroup of $G$. Define the <strong>index</strong> of $H$ in $G$ to be the number of left cosets of $H$ in $G$. We will denote the index by $[G:H]$.</p><p><strong>Theorem 6.8.</strong>  Let $H$ be a subgroup of a group $G$. The number of left cosets of $H$ in $G$ is the same as the number of right cosets of $H$ in $G$.</p><p><strong>Proposition 6.9.</strong> Let $H$ be a subgroup of $G$ with $g \in G$ and define a map $\phi : H \rightarrow gH$ by $\phi(h) = gh$. The map $\phi$ is bijective; hence, the number of elements in $H$ is the same as the number of elements in $gH$.</p><p><strong>Theorem 6.10 Lagrange.</strong> Let $G$ be a finite group and let $H$ be a subgroup of $G$. Then $|G|/|H|=[G:H]$ is the number of distinct left cosets in $G$. In particular, the number of elements in $H$ must divide the number of elements in $G$.</p><p><strong>Corollary 6.11.</strong> Suppose that $G$ is a finite group and $g \in G$. Then the order of $g$ must divide the number of elements in $G$.</p><p><strong>Corollary 6.12</strong> Let $|G|=p$ with $p$ a prime number. Then $G$ is cyclic and any $g \in G$ such that $g\not= e$ is a generator.</p><p><strong>Corollary 6.13.</strong> Let $H$ and $K$ be subgroups of a finite group $G$ such that $G \supset H \supset K.$ Then $[G:K]=[G:H][H:K].$</p><p><strong>Proposition 6.15</strong> The group $A_4$ has no subgroup of order $6$.</p><p><strong>Theorem 6.16.</strong> Two cycles $\tau$ and $\mu$ in $S_n$ have the same length if and only if there exists $a \sigma \in S_n$ such that $\mu = \sigma \tau \sigma^{-1}$.</p><h4 id="Fermat’s-and-Euler’s-Theorems"><a href="#Fermat’s-and-Euler’s-Theorems" class="headerlink" title="Fermat’s and Euler’s Theorems"></a>Fermat’s and Euler’s Theorems</h4><p>The <strong>Euler</strong> $\phi$ <strong>-function</strong> is the map $\phi:N \rightarrow N$ defined by $\phi(n)=1$ for $n=1$, and, for $n&gt;1$, $\phi(n)$ is the number of positive integers $m$ with $1 \le m &lt; n$ and $gcd(m,n)=1$.</p><p><strong>Theorem 6.17.</strong> Let $U(n)$ be the group of units in $Z_n$. Then $|U(n)| = \phi(n)$.</p><p><strong>Theorem 6.18 Euler’s Theorem.</strong> Let $a$ and $n$ be integers such that $n&gt;0$ and $gcd(a,n)=1$. Then $a^{\phi(n)} \equiv 1$(mod $n$).</p><p><strong>Theorem 6.19. Fermat’s Little Theorem.</strong> Let $p$ be any prime number and suppose that $ p \nmid a$ ($p$ does not divide $a$). Then $a^{p-1} \equiv 1$ (mod $p$). Furthermore, for any integer $b$, $b^p \equiv b$ (mod $p$). </p><h3 id="群同态基本定理与正规子群"><a href="#群同态基本定理与正规子群" class="headerlink" title="群同态基本定理与正规子群"></a>群同态基本定理与正规子群</h3><h4 id="Isomorphisms"><a href="#Isomorphisms" class="headerlink" title="Isomorphisms"></a>Isomorphisms</h4><p>Two groups $(G, \cdot )$ and $(H, \circ)$ are <strong>isomorphic</strong> if there exists a one-to-one and onto map $\phi : G \rightarrow H$ such that the group operation is preserved; that is, $\phi (a \cdot b) = \phi(a) \circ \phi (b)$ for all $a$ and $b$ in $G$. If $G$ is isomorphic to $H$, we write $G \cong H$. The map $\phi$ is called an <strong>isomorphism</strong>.</p><p><strong>Theorem 9.6.</strong> Let $\phi : G \rightarrow H$ be an isomorphism of two subgroups. Then the following statements are true.</p><ol><li><p>$\phi^{-1}: H \rightarrow G$ is an isomorphism.</p></li><li><p>$|G| = |H|.$</p></li><li><p>If $G$ is abelian, then $H$ is abelian.</p></li><li><p>If $G$ is cyclic, then $H$ is cyclic.</p></li><li><p>If $G$ has a subgroup of order $n$, then $H$ has a subgroup of order $n$.</p></li></ol><p><strong>Theorem 9.7.</strong> All cyclic groups of infinite order are isomorphic to $Z$.</p><p><strong>Theorem 9.8.</strong> If $G$ is a cyclic group of order $n$, then $G$ is isomorphic to $Z_n$.</p><p><strong>Corollary 9.9.</strong> If $G$ is a group of order $p$, where $p$ is a prime number, then $G$ is isomorphic to $Z_p$.</p><p><strong>Theorem 9.10.</strong> The isomorphism of groups determines an equivalence relation on the class of all groups.</p><p><strong>Theorem 9.12 Cayley.</strong> Every group is isomorphic to a group of permutations.</p><p>The isomorphism $g \mapsto \lambda_g$ is known as the <strong>left regular representation</strong> of $G$.</p><h4 id="External-Direct-Products"><a href="#External-Direct-Products" class="headerlink" title="External Direct Products"></a>External Direct Products</h4><p>If $(G, \cdot)$ and $(H,\circ)$ are groups, then we can make the Cartesian product of $G$ and $H$ into a new group. As a set, our group is just the ordered pairs $(g,h) \in G \times H$ where $g \in G$ and $h \in H$. We can define a binary operation on $G \times H$ by $(g_1,h_1)(g_2,h_2) = (g_1 \cdot g_2, h_1 \cdot h_2)$.</p><p><strong>Proposition 9.13.</strong> Let $G$ and $H$ be groups. The set $G \times H$ is a group under the operation $(g_1,h_2)(g_2,h_2) = (g_1g_2, h_1h_2)$ where $g_1,g_2 \in G$ and $h_1,h_2 \in H$.</p><p>The group $G \times H$ is called the <strong>external direct product</strong> of $G$ and $H$. </p><p><strong>Theorem 9.17.</strong> Let $(g,h) \in G \times H$. If $g$ and $h$ have finite orders $r$ and $s$ respectively, then the order of $(g,h)$ in $G \times H$ is the least common multiple of $r$ and $s$.</p><p><strong>Corollary 9.18.</strong> Let $(g_1, …, g_n) \in \prod G_i$. If $g_i$ has finite order $r_i$ in $G_i$, then the order of $(g_1,…,g_n) \in \prod G_i$ is the least common multiple of $r_1,…,r_n$.</p><p><strong>Theorem 9.21.</strong> The group $Z_m \times Z<em>n$ is isomorphic to $Z</em>{mn}$ if and only if $gcd(m,n)=1$.</p><p><strong>Corollary 9.22.</strong> Let $n_1,…,n<em>k$ be positive integers. Then $\prod\limits</em>{i=1}^{k}Z_{n<em>i} \cong Z</em>{n_1…n_k}$  if and only if $gcd(n_i,n_j)=1$ for $i \not= j$.</p><p><strong>Corollary 9.23.</strong> If $m = p_1^{e_1} \cdot \cdot \cdot p_k^{e_k}$, where the $p_is$ are distinct primes, then $Z<em>m \cong Z</em>{p_1 ^{e<em>1}} \times \cdot \cdot \cdot \times Z</em>{p_k^{e_k}}$.</p><h4 id="Internal-Direct-Products"><a href="#Internal-Direct-Products" class="headerlink" title="Internal Direct Products"></a>Internal Direct Products</h4><p>Let $G$ be a group with subgroups $H$ and $K$ satisfying the following conditions.</p><ul><li><p>$G = H K = {hk: h\in H , k \in K}$;</p></li><li><p>$H \cap K = {e}$;</p></li><li><p>$hk=kh$ for all $k \in K$ and $h \in H$.</p></li></ul><p>Then $G$ is the <strong>internal direct product</strong> of $H$ and $K$.</p><p><strong>Theorem 9.27.</strong> Let $G$ be the internal direct product of subgroups $H$ and $K$. Then $G$ is isomorphic to $H \times K$. Then $G$ is isomorphic to $H \times K$.</p><p><strong>Theorem 9.29.</strong> Let $G$ be the internal direct product of subgroups $H_i$, where $i = 1,2,…,n$. Then $G$ is isomorphic to $\prod_i H_i$.</p><h4 id="Normal-Subgroups"><a href="#Normal-Subgroups" class="headerlink" title="Normal Subgroups"></a>Normal Subgroups</h4><p>A subgroup $H$ of a group $G$ is <strong>normal</strong> in $G$ if $gH = Hg$ for all $g \in G$. </p><p><strong>Theorem 10.3.</strong> Let $G$ be a group and $N$ be a subgroup of $G$. Then the following statements are equivalent.</p><ol><li><p>The subgroup $N$ is normal in $G$.</p></li><li><p>For all $g \in G$, $g N g^{-1} \subset N$.</p></li><li><p>For all $g \in G$, $gNg^{-1} = N$.</p></li></ol><h4 id="Factor-Groups"><a href="#Factor-Groups" class="headerlink" title="Factor Groups"></a>Factor Groups</h4><p>If $N$ is a normal subgroup of a group $G$, then the cosets of $N$ in $G$ form a group $G/N$ under the operation $(aN)(bN)=abN$. This group is called the <strong>factor</strong> or <strong>quotient group</strong> of $G$ and $N$.</p><p><strong>Theorem 10.4.</strong> Let $N$ be a normal subgroup of a group $G$. The cosets of $N$ in $G$ form a group $G/N$ of order $[G:N]$.</p><h4 id="The-Simplicity-of-the-Alternating-Group"><a href="#The-Simplicity-of-the-Alternating-Group" class="headerlink" title="The Simplicity of the Alternating Group"></a>The Simplicity of the Alternating Group</h4><p>Of special interest are groups with no nontrivial normal subgroups. Such groups are called <strong>simple groups</strong>.</p><p><strong>Lemma 10.8.</strong> The alternating group $A_n$ is generated by $3-$cycles for $n \ge 3$.</p><p><strong>Lemma 10.9.</strong> Let $N$ be a normal subgroup of $A_n$, where $n \ge 3$. If $N$ contains a $3-$cycle, then $N=A_n$.</p><p><strong>Lemma 10.10.</strong> For $n \ge 5$, every nontrivial normal subgroup $N$ of $A_n$ contains a $3-$ cycle.</p><p><strong>Theorem 10.11.</strong> The alternating group, $A_n$, is simple for $n \ge 5$.</p><h4 id="Group-Homomorphisms"><a href="#Group-Homomorphisms" class="headerlink" title="Group Homomorphisms"></a>Group Homomorphisms</h4><p>A <strong>homomorphism</strong> between groups $(G, \cdot)$ and $(H, \circ)$ is a map $\phi: G \rightarrow H$ such that $\phi(g_1 \cdot g_2) = \phi(g_1) \circ \phi(g_2)$ for $g_1, g_2 \in G$. The range of $\phi$ in $H$ is called the <strong>homomorphic image</strong> of $\phi$. </p><p><strong>Proposition 11.4.</strong>  Let $\phi : G_1 \rightarrow G_2$ be a homomorphism of groups. Then </p><ol><li><p>If $e$ is the identity of $G_1$, then $\phi(e)$ is the identity of $G_2$;</p></li><li><p>For any element $g \in G_1$, $\phi(g^{-1}) = [\phi(g)]^{-1}$;</p></li><li><p>If $H_1$ is a subrgoup of $G_1$, then $\phi(H_1)$ is a subrgoup of $G_2$;</p></li><li><p>If $H_2$ is a subgroup of $G_2$, then $\phi^{-1}(H_2) = {g \in G_1 : \phi(g) \in H_2}$ is a subgroup of $G_1$. Furthermore, if $H_2$ is normal in $G_2$, then $\phi^{-1}(H_2)$ is normal in $G_1$.</p></li></ol><p>Let $\phi: G \rightarrow H$ be a group homomorphism and suppose that $e$ is the identity of $H$.  By Proposition 11.4, $\phi^{-1}({e})$ is a subrgoup of $G$. This subgroup is called the <strong>kernel</strong> of $\phi$ and will be denoted by ker $\phi$.</p><p><strong>Theorem 11.5.</strong> Let $\phi : G \rightarrow H$ be a group homomorphism. Then the kernel of $\phi$ is a normal subgroup of $G$.</p><h4 id="The-Isomorphism-Theorems"><a href="#The-Isomorphism-Theorems" class="headerlink" title="The Isomorphism Theorems"></a>The Isomorphism Theorems</h4><p>Let $H$ be a normal subgroup of $G$. Define the <strong>natural</strong> or <strong>canonical homomorphism</strong> $\phi : G \rightarrow G/H$ by $\phi(g) = g H$.</p><p><strong>Theorem 11.10 First Isomorphism Theorem.</strong> If $\psi : G \rightarrow H$ is a group homomorphism with $K = ker \psi$, then $K$ is normal in $G$. Let $\phi: G \rightarrow G/K$ be the canonical homomorphism. Then there exists a unique isomorphism $\eta : G/K \rightarrow \psi(G)$ such that $\psi = \eta \phi$</p><p><strong>Theorem 11.12 Second Isomorphism Theorem.</strong>  Let $H$ be a subgroup of a group $G$ (not necessarily normal in $G$) and $N$ a normal subgroup of $G$. Then $HN$ is a subgroup of $G$, $H \cap N$ is a normal subgroup of $H$, and $H/ H \cap N \cong HN/N$.</p><p><strong>Theorem 11.13 Correspondence Theorem.</strong> Let $N$ be a normal subgroup of a group $G$. Then $H \mapsto H/N$ is a one-to-one correspondence between the set of subgroups $H$ containing $N$ and the set of subgroups of $G/N$. Furthermore, the normal subgroups of $G$ containing $N$ correspond to normal subgroups of $G/N$.</p><p><strong>Theorem 11.14 Third Isomorphism Theorem.</strong> Let $G$ be a group and $N$ and $H$ be normal subgroups of $G$ with $N \subset H.$ Then $G/H \cong \frac{G/N}{H/N}$.</p><h3 id="串匹配"><a href="#串匹配" class="headerlink" title="串匹配"></a>串匹配</h3><h4 id="The-naive-string-matching-algorithm"><a href="#The-naive-string-matching-algorithm" class="headerlink" title="The naive string-matching algorithm"></a>The naive string-matching algorithm</h4>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;问题求解-2019Spring&quot;&gt;&lt;a href=&quot;#问题求解-2019Spring&quot; class=&quot;headerlink&quot; title=&quot;问题求解 2019Spring&quot;&gt;&lt;/a&gt;问题求解 2019Spring&lt;/h1&gt;&lt;h2 id=&quot;4-1线性规划&quot;&gt;&lt;a href=&quot;#4-1线性规划&quot; class=&quot;headerlink&quot; title=&quot;4.1线性规划&quot;&gt;&lt;/a&gt;4.1线性规划&lt;/h2&gt;&lt;p&gt;In linear programming, we do not allow strict inequalities.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;minimization linear program&lt;/strong&gt; and &lt;strong&gt;maximization program&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The simplex algorithm does not run in polynomial time in the worst case, but it is fairly efficient and widely used in practice.&lt;/p&gt;
&lt;p&gt;We use two forms, &lt;strong&gt;standard&lt;/strong&gt; and &lt;strong&gt;slack&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Informally, a linear program in standard form is the maximization of a linear function subject to linear inequalities, whereas a linear program in slack form is the maximization of a linear function subject to linear equalities.&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MATLAB学习笔记</title>
    <link href="https://ricky-ting.github.io/2019/01/19/MATLAB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://ricky-ting.github.io/2019/01/19/MATLAB学习笔记/</id>
    <published>2019-01-19T07:50:56.000Z</published>
    <updated>2019-01-19T11:14:53.890Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MATLAB学习笔记"><a href="#MATLAB学习笔记" class="headerlink" title="MATLAB学习笔记"></a>MATLAB学习笔记</h1> <a id="more"></a><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ul><li><p>quit: 退出命令</p></li><li><p>clc: 擦除MATLAB工作窗中的所有显示内容，相当于命令行中的clear</p></li><li><p>clf: 擦除MATLAB的当前图形窗中的图形</p></li><li><p>clear: 清除内存中的变量和函数</p></li><li><p>dir: 列出指定目录下的文件和子目录清单</p></li><li><p>cd: 改变当前工作子目录</p></li><li><p>disp: (在运行中)显示变量和文字内容</p></li><li><p>who: 检查内存变量</p></li><li><p>whos: 列出内存变量的详细情况</p></li><li><p>save: 关闭前将变量保存到某一文件中</p></li><li><p>load: 从之前保存的文件中恢复变量</p></li><li><p>help: 非常有用</p></li><li><p>lookfor: 查找相关指令</p></li><li><p>!之后可以加操作系统命令，如 !ls, !vim</p></li></ul><p><img src="/images/MATLAB学习笔记/MATLABop.png" alt=""></p><p>求解方程组时，用除法比用逆矩阵好。</p><h2 id="多项式"><a href="#多项式" class="headerlink" title="多项式"></a>多项式</h2><ul><li><p>用系数行向量表示：p=$[a_0 , a<em>1 , … , a</em>{n-1} , a_n ]$, ($p(x)= a_0 x_n + a<em>1 x</em>{n-1} + … + a<em>{n-1} x + a</em>{n} $).</p></li><li><p>可以用指令产生多项式系数向量: p=poly(AR). 如果AR是方阵，则多项式为特征多项式，如果AR为向量，则AR为多项式的解。</p></li><li><p>poly2str函数</p></li></ul><h3 id="一些常用多项式运算指令"><a href="#一些常用多项式运算指令" class="headerlink" title="一些常用多项式运算指令"></a>一些常用多项式运算指令</h3><ul><li><p>R=roots(p)   求多项式向量p的根</p></li><li><p>PA=polyval(p,S)  按照数组运算规则计算多项式值。 p为多项式，S为矩阵。 相当于求值。</p></li><li><p>PM=polyvalm(p;S) 按照矩阵运算规则计算多项式值。p为多项式，S为矩阵。</p></li><li><p>P=polyfit(x,y,n) 用n阶多项式拟合x,y向量给定的数据</p></li></ul><h2 id="数值积分"><a href="#数值积分" class="headerlink" title="数值积分"></a>数值积分</h2><ul><li><p>S=quad(‘fname’,a,b,tol,trace)  自适用递推Simpson数值积分法</p></li><li><p>S=quad8(‘fname’,a,b,tol,trace) 自适用递推Newton-Cotes数值积分法</p></li><li><p>tol是精度，trace是是否画图</p></li><li><p>quad8比quad有更高的积分精度</p></li></ul><h2 id="非线性方程求解"><a href="#非线性方程求解" class="headerlink" title="非线性方程求解"></a>非线性方程求解</h2><ul><li><p>对于多项式函数求根，r=roots(p)</p></li><li><p>单变量非线性方程求解, z=fzero(‘fname’,x0,tol,trace)</p></li><li><p>一般非线性方程(组)求解， X=fsolve(‘fname’,X0)</p></li></ul><h2 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h2><ul><li><p>fopen(“filename”,’specifier’)</p></li><li><p>fread(fd,..)</p></li><li><p>fwrite()</p></li><li><p>fclose</p></li></ul><h2 id="符号计算"><a href="#符号计算" class="headerlink" title="符号计算"></a>符号计算</h2><ul><li><p>可以用sym定义符号,如 sym(‘x’) 也可以用syms定义多个符号 syms a b c d</p></li><li><p>findsym() 来确认符号表达式中的符号</p></li></ul><h3 id="微积分运算"><a href="#微积分运算" class="headerlink" title="微积分运算"></a>微积分运算</h3><ul><li><p>diff(f) 函数f对符号变量x或字母表上最接近字母x的符号变量求导数</p></li><li><p>diff(f,t) 函数f对符号变量t求导数</p></li><li><p>diff(f,2) 和diff(f,t,2)可以用来求二阶导数</p></li><li><p>int(f)</p></li><li><p>int(f,t)</p></li><li><p>int(f,a,b) 和int(f,t,a,b)</p></li><li><p>limit(f) 当符号变量x(或最接近字母x的符号变量) -&gt;0 时，函数f的极限</p></li><li><p>limit(f,t,a)</p></li><li><p>limit(f,t,a,’left’) 左极限 limit(f,t,a,’right’)右极限</p></li><li><p>symsum(s,t,a,b) 表示s中的符号变量t从a到b的级数和(t缺省时，同上)</p></li><li><p>taylor(f,n,a) 函数f对符号变量x(或…)在a点的n-1阶泰勒多项式(n缺省时值为6，a缺省时值为0)</p></li><li><p>solve(f,t) 对f中的符号变量t解方程f=0(t缺省值为x或…)</p></li><li><p>solve(f,g,..)可以求解方程组</p></li><li><p>dsolve(‘S’,’s1’,’s2’,…,’x’)</p></li><li><p>collect 合并同类项</p></li><li><p>expand 将乘积展开为和式</p></li><li><p>horner 把多项式转换为嵌套表示形式</p></li><li><p>simplify 利用各种恒等式化简代数式，更强有力的函数simple</p></li><li><p>subs(S,old,new) 替换</p></li><li><p>subexpr(S) 将表达式S中的公共部分用sigma表示</p></li></ul><h2 id="MATLAB画图"><a href="#MATLAB画图" class="headerlink" title="MATLAB画图"></a>MATLAB画图</h2><ul><li><p>plot(x,y) 以向量x作为X轴，以向量y作为Y轴，绘制X-Y二维曲线</p></li><li><p>plot(x,y1,’k’,x,y2,’b-‘) 每条曲线的线型和颜色由字符串’cs’指定，其中c表示颜色,s表示线型</p></li></ul><p><img src="/images/MATLAB学习笔记/ColorAndLine.png" alt=""></p><ul><li><p>可以加一些图形标记，如title, xlabel, ylabel, text,legend</p></li><li><p>axis([xmin,xmax,ymin,ymax]) 来设定坐标轴范围</p></li><li><p>hold on: 保持原有图形的基础上绘制新的图形</p></li><li><p>fplot(fname,lims,tol) lims为变量取值范围，tol为相对误差</p></li><li><p>loglog(x,y) 绘制双对数坐标图</p></li><li><p>semilogx(x,y) semilogy(x,y) 绘制单对数坐标图</p></li><li><p>polar(theta,rho) 用来绘制极坐标图</p></li></ul><p><img src="/images/MATLAB学习笔记/2D.png" alt=""></p><ul><li><p>plot3(x1,y1,z1,c1,x2,y2,z2,c2,…)</p></li><li><p>mesh(x,y,z,c)绘制三维网格图</p></li><li><p>surf(x,y,z) 绘制三维曲面图</p></li><li><p>view 指定视点</p></li><li><p>contour3 绘制等高线图</p></li></ul><h2 id="MATLAB程序设计"><a href="#MATLAB程序设计" class="headerlink" title="MATLAB程序设计"></a>MATLAB程序设计</h2><p>MATLAB有两种工作方式：一种是交互式的命令行工作方式，另一种是M文件的程序工作方式</p><h3 id="M文件"><a href="#M文件" class="headerlink" title="M文件"></a>M文件</h3><p>M文件有两类：命令文件和函数文件。区别在于：命令文件没有输入参数，也不返回输出参数；而函数文件可以输入参数，也可以返回输出参数。</p><ul><li><p>input函数， A=input(提示信息，选项);</p></li><li><p>pause(延迟秒数)    pause()直接暂停程序</p></li><li><p>Disp(输出项)</p></li></ul><h3 id="if选择语句"><a href="#if选择语句" class="headerlink" title="if选择语句"></a>if选择语句</h3><ul><li><p>结束时要加end，不需要加begin</p></li><li><p>else +if = elseif</p></li></ul><h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><ul><li><p>结束要加end</p></li><li><p>default改为otherwise</p></li><li><p>case 值 后面没有冒号</p></li></ul><h3 id="for循环结构"><a href="#for循环结构" class="headerlink" title="for循环结构"></a>for循环结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for 循环变量= 表达式1: 表达式2 : 表达式3</span><br><span class="line">    循环体</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">% 表达式1为初值， 表达式2为步长，表达式3为终值</span><br><span class="line"></span><br><span class="line">for 循环变量=矩阵表达式 则遍历矩阵元素</span><br></pre></td></tr></table></figure><h3 id="while循环结构"><a href="#while循环结构" class="headerlink" title="while循环结构"></a>while循环结构</h3><ul><li>结尾加end</li></ul><h3 id="函数文件"><a href="#函数文件" class="headerlink" title="函数文件"></a>函数文件</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> 输出形参表=函数名<span class="params">(输入形参表)</span></span></span><br><span class="line">    注释说明部分</span><br><span class="line">    函数体</span><br></pre></td></tr></table></figure><ul><li><p>当输出形参多余1个时，则应该用方括号括起来</p></li><li><p>参数可调， 用nargin和nargout实现</p></li><li><p>支持嵌套调用和递归</p></li><li><p>加global可以声明全局变量</p></li></ul><p>参考资料：MATLAB 数学工具软件实例简明教程</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;MATLAB学习笔记&quot;&gt;&lt;a href=&quot;#MATLAB学习笔记&quot; class=&quot;headerlink&quot; title=&quot;MATLAB学习笔记&quot;&gt;&lt;/a&gt;MATLAB学习笔记&lt;/h1&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>文章集锦</title>
    <link href="https://ricky-ting.github.io/2019/01/18/%E6%96%87%E7%AB%A0%E9%9B%86%E9%94%A6/"/>
    <id>https://ricky-ting.github.io/2019/01/18/文章集锦/</id>
    <published>2019-01-18T14:01:01.000Z</published>
    <updated>2019-02-12T13:54:36.358Z</updated>
    
    <content type="html"><![CDATA[<ul><li>什么是真正的程序员 <a href="https://www.cnblogs.com/xueweihan/p/5220513.html" target="_blank" rel="noopener">原文链接</a> （<a href="https://github.com/Ricky-Ting/ArticleCollection/blob/master/2019.1/什么是真正的程序员？%20-%20削微寒%20-%20博客园.pdf" target="_blank" rel="noopener">文章存档</a>）</li><li>信息消费：从入门到放弃 | 2018 年度征文 <a href="https://sspai.com/post/52832" target="_blank" rel="noopener">原文链接</a> (<a href="https://github.com/Ricky-Ting/ArticleCollection/blob/master/2019.2/信息消费：从入门到放弃%20%7C%202018%20年度征文%20-%20少数派.pdf" target="_blank" rel="noopener">文章存档</a>)</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;什么是真正的程序员 &lt;a href=&quot;https://www.cnblogs.com/xueweihan/p/5220513.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt; （&lt;a href=&quot;https://gith
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>mac下ssh打开X11转发</title>
    <link href="https://ricky-ting.github.io/2019/01/17/mac%E4%B8%8Bssh%E6%89%93%E5%BC%80X11%E8%BD%AC%E5%8F%91/"/>
    <id>https://ricky-ting.github.io/2019/01/17/mac下ssh打开X11转发/</id>
    <published>2019-01-17T07:13:44.000Z</published>
    <updated>2019-01-17T07:17:15.003Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mac下ssh打开X11转发"><a href="#mac下ssh打开X11转发" class="headerlink" title="mac下ssh打开X11转发"></a>mac下ssh打开X11转发</h1><p>1.首先确认linux下已开启X11转发：</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/ssh/sshd_config</span><br><span class="line"></span><br><span class="line">X11Forwarding yes</span><br><span class="line">X11DisplayOffset 10</span><br><span class="line"></span><br><span class="line">service ssh restart</span><br></pre></td></tr></table></figure></code></pre><p>2.安装XQuartz</p><p>3.在mac端下开启：</p><pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/ssh/ssh_config</span><br><span class="line"></span><br><span class="line">ForwardX11 yes</span><br></pre></td></tr></table></figure></code></pre><p>4.ssh登陆</p><pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -X username@ip</span><br></pre></td></tr></table></figure></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;mac下ssh打开X11转发&quot;&gt;&lt;a href=&quot;#mac下ssh打开X11转发&quot; class=&quot;headerlink&quot; title=&quot;mac下ssh打开X11转发&quot;&gt;&lt;/a&gt;mac下ssh打开X11转发&lt;/h1&gt;&lt;p&gt;1.首先确认linux下已开启X11转发：&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>2019寒假计划(flag)</title>
    <link href="https://ricky-ting.github.io/2019/01/16/2019%E5%AF%92%E5%81%87%E8%AE%A1%E5%88%92-flag/"/>
    <id>https://ricky-ting.github.io/2019/01/16/2019寒假计划-flag/</id>
    <published>2019-01-16T09:32:32.000Z</published>
    <updated>2019-01-16T09:33:26.543Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2019-寒假计划-flag"><a href="#2019-寒假计划-flag" class="headerlink" title="2019 寒假计划(flag)"></a>2019 寒假计划(flag)</h1><h2 id="必做"><a href="#必做" class="headerlink" title="必做"></a>必做</h2><ul><li><p>学习数学建模，参加美赛</p></li><li><p>完成经典阅读论文</p></li><li><p>读Spark源码</p></li><li><p>学习线性代数、代数学引论</p></li><li><p>寒假HK项目准备</p></li><li><p>学习MATLAB</p></li></ul><h2 id="可选"><a href="#可选" class="headerlink" title="可选"></a>可选</h2><ul><li><p>学习IOS开发</p></li><li><p>机器学习导论、人工智能、深度学习</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;2019-寒假计划-flag&quot;&gt;&lt;a href=&quot;#2019-寒假计划-flag&quot; class=&quot;headerlink&quot; title=&quot;2019 寒假计划(flag)&quot;&gt;&lt;/a&gt;2019 寒假计划(flag)&lt;/h1&gt;&lt;h2 id=&quot;必做&quot;&gt;&lt;a href=&quot;#必
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>如何解决项目子模块git冲突</title>
    <link href="https://ricky-ting.github.io/2019/01/03/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E9%A1%B9%E7%9B%AE%E5%AD%90%E6%A8%A1%E5%9D%97git%E5%86%B2%E7%AA%81/"/>
    <id>https://ricky-ting.github.io/2019/01/03/如何解决项目子模块git冲突/</id>
    <published>2019-01-03T15:02:20.000Z</published>
    <updated>2019-01-03T15:03:36.198Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何解决项目子模块git冲突"><a href="#如何解决项目子模块git冲突" class="headerlink" title="如何解决项目子模块git冲突"></a>如何解决项目子模块git冲突</h1><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>在将这学期做的PA提交到github时，因为ics2018中原有git与github上创建的git冲突，因此上传之后ics2018的图标为灰。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ul><li><p>git rm –cache ics2018</p></li><li><p>git add ics2018/</p></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://upupming.site/2018/05/31/git-submodules/#解决方案" target="_blank" rel="noopener">参考链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;如何解决项目子模块git冲突&quot;&gt;&lt;a href=&quot;#如何解决项目子模块git冲突&quot; class=&quot;headerlink&quot; title=&quot;如何解决项目子模块git冲突&quot;&gt;&lt;/a&gt;如何解决项目子模块git冲突&lt;/h1&gt;&lt;h2 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Records for Environment Setup for Spark</title>
    <link href="https://ricky-ting.github.io/2018/11/02/Records-for-Environment-Setup-for-Spark/"/>
    <id>https://ricky-ting.github.io/2018/11/02/Records-for-Environment-Setup-for-Spark/</id>
    <published>2018-11-02T15:29:21.000Z</published>
    <updated>2018-11-02T15:42:07.389Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spark搭建记录-2018-11-2"><a href="#Spark搭建记录-2018-11-2" class="headerlink" title="Spark搭建记录(2018.11.2)"></a>Spark搭建记录(2018.11.2)</h1><p>建立在Hadoop的基础上。</p><p><a href="https://www.cnblogs.com/zyrblog/p/8527048.html" target="_blank" rel="noopener">参考教程</a></p><p>Spark版本：2.1.3.</p><p>在官网上下的直接编译好的文件。</p><p>Spark装之前需要装Scala。我的Scala版本是2.11.6。</p><p>然后解压spark压缩包，修改conf目录下的spark-env.sh(备份到github)。 修改slaves文件。</p><p>注意启动后报错，需要加入JAVA_HOME环境变量，也在spark-env.sh中.</p><h1 id="Spark编译记录"><a href="#Spark编译记录" class="headerlink" title="Spark编译记录"></a>Spark编译记录</h1><p><a href="https://blog.csdn.net/babyhuang/article/details/78656093" target="_blank" rel="noopener">参考教程</a></p><p>在官网下载Spark源码，安装maven(我安装的版本是3.3.9) ，添加maven镜像(已备份)，修改dev目录下的make-distribution.sh文件，将Spark，Hadoop，Scala版本都换为自己的。</p><p>然后用README里的命令编译。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Spark搭建记录-2018-11-2&quot;&gt;&lt;a href=&quot;#Spark搭建记录-2018-11-2&quot; class=&quot;headerlink&quot; title=&quot;Spark搭建记录(2018.11.2)&quot;&gt;&lt;/a&gt;Spark搭建记录(2018.11.2)&lt;/h1&gt;&lt;p&gt;
      
    
    </summary>
    
    
      <category term="记录" scheme="https://ricky-ting.github.io/tags/%E8%AE%B0%E5%BD%95/"/>
    
      <category term="创新项目" scheme="https://ricky-ting.github.io/tags/%E5%88%9B%E6%96%B0%E9%A1%B9%E7%9B%AE/"/>
    
      <category term="大数据" scheme="https://ricky-ting.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>Records for Environment Setup for Hadoop</title>
    <link href="https://ricky-ting.github.io/2018/10/24/Records-for-Environment-Setup-for-Hadoop/"/>
    <id>https://ricky-ting.github.io/2018/10/24/Records-for-Environment-Setup-for-Hadoop/</id>
    <published>2018-10-24T03:20:25.000Z</published>
    <updated>2019-07-27T02:21:55.200Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hadoop环境搭建记录"><a href="#Hadoop环境搭建记录" class="headerlink" title="Hadoop环境搭建记录"></a>Hadoop环境搭建记录</h1><h2 id="安装系统"><a href="#安装系统" class="headerlink" title="安装系统"></a>安装系统</h2><p>安装系统的时候出了很多问题，找不到引导，硬盘被锁啊，感觉不懂的还是很多，最后还是请学长帮忙装好了系统。</p><a id="more"></a><h2 id="Hadoop环境的搭建"><a href="#Hadoop环境的搭建" class="headerlink" title="Hadoop环境的搭建"></a>Hadoop环境的搭建</h2><p>Hadoop版本:2.2.0</p><p><a href="https://blog.csdn.net/fanxin_i/article/details/80425461" target="_blank" rel="noopener">参考教程</a></p><p>教程简版： 1.获取IP，添加解析。2.关闭防火墙 3.安装jdk 4.安装ssh，配置免密通信 5. 安装hadoop，在hdfs目录下创建文件夹(tmp,name,data). 6.修改Hadoop配置文件包括以下几个文件(core-site.xml hadoop-env.sh hdfs-site.xml yarn-env.sh yarn-site.xml slaves).(这些配置文件会备份在github中) 7.用scp将文件夹传到slave上。 然后在master上初始化namenode(hdfs namenode -format)</p><p>设置文件路径的时候尽量要绝对路径，不用加file</p><p>注意hosts, 不要127.0.0.1 master</p><p>我的理解是主要在master里执行namenode初始化就好了，初始化之前最好把master和slave里hdfs目录下删干净(以后可以写个脚本干这个事)。</p><h2 id="写脚本"><a href="#写脚本" class="headerlink" title="写脚本"></a>写脚本</h2><p>写脚本实现只运行MapReduce和在HDFS上运行MapReduce。</p><p>我的理解是只要改改配置文件就好，要运行哪一种方式只要把相应的配置文件拷进去就好。 因为不运行yarn，所以要把yarn的相关配置删除。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env bash</span><br><span class="line"></span><br><span class="line">echo &quot;This is to run mapreduce on hdfs&quot;</span><br><span class="line">rm -rf ~/hadoop-2.2.0/etc/hadoop</span><br><span class="line">echo &quot;Original config files in hadoop-2.2.0/ect/hadoop deleted&quot;</span><br><span class="line">cp -r ~/hadoopconfig/hadoop-distributed ~/hadoop-2.2.0/etc/</span><br><span class="line">echo &quot;Copy config files of hdfs to hadoop-2.2.0/etc/hadoop&quot;</span><br><span class="line">mv ~/hadoop-2.2.0/etc/hadoop-distributed ~/hadoop-2.2.0/etc/hadoop</span><br><span class="line">echo &quot;Rename successfully&quot;</span><br><span class="line">cd ~/hadoop-2.2.0</span><br><span class="line">echo &quot;About to run start-dfs.sh&quot;</span><br><span class="line">start-dfs.sh</span><br><span class="line">echo &quot;About to run an example on hdfs&quot;</span><br><span class="line">hadoop jar /home/hadoop/hadoop-2.2.0/share/hadoop/mapreduce/hadoop-mapreduce-examples-2.2.0.jar pi 10 10</span><br><span class="line">jps</span><br><span class="line">echo &quot;About to run stop-dfs.sh&quot;</span><br><span class="line">stop-dfs.sh</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env bash</span><br><span class="line"></span><br><span class="line">echo &quot;This is to run mapreduce without hdfs&quot;</span><br><span class="line">rm -rf ~/hadoop-2.2.0/etc/hadoop</span><br><span class="line">cp -r ~/hadoopconfig/hadoop-native ~/hadoop-2.2.0/etc/</span><br><span class="line">mv ~/hadoop-2.2.0/etc/hadoop-native ~/hadoop-2.2.0/etc/hadoop</span><br><span class="line">cd ~/hadoop-2.2.0</span><br><span class="line">./bin/hadoop jar ./share/hadoop/mapreduce/hadoop-mapreduce-examples-2.2.0.jar pi 10 10</span><br><span class="line">~</span><br><span class="line">~</span><br><span class="line">~</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Hadoop环境搭建记录&quot;&gt;&lt;a href=&quot;#Hadoop环境搭建记录&quot; class=&quot;headerlink&quot; title=&quot;Hadoop环境搭建记录&quot;&gt;&lt;/a&gt;Hadoop环境搭建记录&lt;/h1&gt;&lt;h2 id=&quot;安装系统&quot;&gt;&lt;a href=&quot;#安装系统&quot; class=&quot;headerlink&quot; title=&quot;安装系统&quot;&gt;&lt;/a&gt;安装系统&lt;/h2&gt;&lt;p&gt;安装系统的时候出了很多问题，找不到引导，硬盘被锁啊，感觉不懂的还是很多，最后还是请学长帮忙装好了系统。&lt;/p&gt;
    
    </summary>
    
    
      <category term="记录" scheme="https://ricky-ting.github.io/tags/%E8%AE%B0%E5%BD%95/"/>
    
      <category term="创新项目" scheme="https://ricky-ting.github.io/tags/%E5%88%9B%E6%96%B0%E9%A1%B9%E7%9B%AE/"/>
    
      <category term="大数据" scheme="https://ricky-ting.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>How to make an installation USB for Linux or other OS in Mac OS X</title>
    <link href="https://ricky-ting.github.io/2018/10/17/How-to-make-an-installation-USB-for-Linux-or-other-OS-in-Mac-OS-X/"/>
    <id>https://ricky-ting.github.io/2018/10/17/How-to-make-an-installation-USB-for-Linux-or-other-OS-in-Mac-OS-X/</id>
    <published>2018-10-17T12:55:11.000Z</published>
    <updated>2018-10-17T12:55:47.121Z</updated>
    
    <content type="html"><![CDATA[<h1 id="How-to-make-an-installation-USB-for-Linux-or-other-OS-in-Mac-OS-X"><a href="#How-to-make-an-installation-USB-for-Linux-or-other-OS-in-Mac-OS-X" class="headerlink" title="How to make an installation USB for Linux or other OS in Mac OS X"></a>How to make an installation USB for Linux or other OS in Mac OS X</h1><p>Step1: Download the image(iso) file from the Internet.</p><p>Step2: Open a Terminal(the following command are all completed in a terminal)</p><a id="more"></a><p>Step3: Trun <code>.iso</code> file into <code>.img</code> file by <code>hdiutil convert -format UDRW -o ~/path/to/target.img ~/path/from/src.iso</code>(The file created may end with <code>.dmg</code>)</p><p>Step4: <code>diskutil list</code> to obtain the devices mounted.</p><p>Step5: Insert your USB.</p><p>Step6: <code>diskutil list</code> to see which is added(/dev/diskN).</p><p>Step7: <code>diskutil unmountDisk /dev/diskN</code> to unmount USB</p><p>Step8: <code>sudo dd if=/path/to/target.img of=/dev/rdiskN bs=1m</code> to write the installation file into the USB</p><p>Step9: <code>diskutil eject /dev/diskN</code> to eject your USB.</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;How-to-make-an-installation-USB-for-Linux-or-other-OS-in-Mac-OS-X&quot;&gt;&lt;a href=&quot;#How-to-make-an-installation-USB-for-Linux-or-other-OS-in-Mac-OS-X&quot; class=&quot;headerlink&quot; title=&quot;How to make an installation USB for Linux or other OS in Mac OS X&quot;&gt;&lt;/a&gt;How to make an installation USB for Linux or other OS in Mac OS X&lt;/h1&gt;&lt;p&gt;Step1: Download the image(iso) file from the Internet.&lt;/p&gt;
&lt;p&gt;Step2: Open a Terminal(the following command are all completed in a terminal)&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Summary of definitions and theorems in graph theory</title>
    <link href="https://ricky-ting.github.io/2018/10/15/Summary-of-definitions-and-theorems-in-graph-theory/"/>
    <id>https://ricky-ting.github.io/2018/10/15/Summary-of-definitions-and-theorems-in-graph-theory/</id>
    <published>2018-10-15T14:06:07.000Z</published>
    <updated>2019-01-08T06:11:07.116Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Summary-of-definitions-and-theorems-in-graph-theory"><a href="#Summary-of-definitions-and-theorems-in-graph-theory" class="headerlink" title="Summary of definitions and theorems in graph theory"></a>Summary of definitions and theorems in graph theory</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><h3 id="1-1-Graphs-and-Graph-Models"><a href="#1-1-Graphs-and-Graph-Models" class="headerlink" title="1.1 Graphs and Graph Models"></a>1.1 Graphs and Graph Models</h3><p>A <strong>Graph</strong> G consists of a finite nonempty set $V$ of objects called <strong>vertices</strong> and a set $E$ of 2-element subsets of $V$ called <strong>edges</strong>. The ses $V$ and $E$ are the <strong>vertex set</strong> and <strong>edge set</strong> of $G$, respectively. Write $G=(V,E)$.</p><p>Two graphs $G$ and $H$ are <strong>equal</strong> if $V(G)=V(H)$ and $E(G)=E(H)$, in which case we write $G=H$.</p><p>If $uv$ is an edge of $G$, then $u$ and $v$ are said to be <strong>adjacent</strong> in $G$.</p><p>The number of vertices in $G$ is often called the <strong>order</strong> of $G$, while the number of edges is its <strong>size</strong>.</p><p>A graph with exactly one vertex is called a <strong>trivial graph</strong>, implying that the order of a <strong>nontrivial graph</strong> is at least 2.</p><p><strong>labeled graph</strong> and <strong>unlabeled graph</strong></p><p>A graph $G$ is called a <strong>word graph</strong> if $G$ is the word graph of some set $S$ of 3-letter words.</p><a id="more"></a><h3 id="1-2-Connected-Graphs"><a href="#1-2-Connected-Graphs" class="headerlink" title="1.2 Connected Graphs"></a>1.2 Connected Graphs</h3><p>The adjacent vertices $u$ and $v$ are said to be <strong>joined</strong> by the edge $e$. The vertices $u$ and $v$ are referred to as <strong>neighbors</strong> of each other. </p><p>Distinct edges incident with a common vertex are <strong>adjacent edges</strong>.</p><p>A graph $H$ is called a <strong>subgraph</strong> of a graph $G$, written $H \subseteq G$, if $V(H) \subseteq V(G)$ and $E(H) \subseteq E(G)$. We also say that $G$ contains $H$ as a subgraph. If $H \subseteq G$ and either $V(H)$ is a proper subset of $V(G)$ or $E(H)$ is a proper subset of $E(G)$, then $H$ is a <strong>proper subgraph</strong> of $G$. If a subgraph of a graph $G$ has the same vertex set as $G$, then it is a <strong>spanning subgraph</strong> of $G$.</p><p>A subgraph $F$ of a graph $G$ is called an <strong>induced subgraph</strong> of $G$ if whenever $u$ and $v$ are vertices of $F$ and $uv$ is an edge of $G$, then $uv$ is an edge of $F$ as well.</p><p>If $S$ is a nonempty set of vertices of a graph $G$, then the <strong>subgraph</strong> of $G$ <strong>induced by</strong> $S$ is the induced subgraph with vertex set $S$. This induced subgraph is denoted by $G[S]$.</p><p>For a nonempty set $X$ of edges, the <strong>subgraph G[X] induced by</strong> $X$ has edge set $X$ and consists of all vertices that are incident with at least one edge in $X$. This subgraph is called an <strong>edge-induced subgraph</strong> of $G$.   </p><p>A $u-v$ <strong>walk</strong> $W$ in $G$ is a sequence of vertices in $G$, beginning with $u$ and ending at $v$ such that consecutives vertices in the sequence are adjacent. If $u=v$, then the walk $W$ is <strong>closed</strong>; while if $u\not=v$, then $W$ is <strong>open</strong>. A walk of length 0 is a <strong>trivial walk</strong>.</p><p>We define a $u-v$ <strong>trial</strong> in a graph $G$ to be a $u-v$ walk in which no edges is traversed more than once.</p><p>A $u-v$ walk in a graph in which no vertices are repeated is a $u-v$ <strong>path</strong>. </p><p>A <strong>circuit</strong> in a graph $G$ is a closed trail of length 3 or more. Hence a circuit begins and ends at the same vertex but repeats no edges.</p><p>A circuit that repeats no vertex, except for the first and last, is a <strong>cycle</strong>.</p><p>If $G$ contains a $u-v$ path, then $u$ and $v$ are said to be <strong>connected</strong> and $u$ is <strong>connected to</strong> $v$.</p><p>A graph $G$ is <strong>connected</strong> if every two vertices of $G$ are connected. A graph that is not connected is called <strong>disconnected</strong>. A connected subgraph of $G$ that is not a proper subgraph of any other connected subgraph of $G$ is a <strong>component</strong> of $G$. The number of components of a graph $G$ is denoted by $k(G)$. Every graph is the union of its components.</p><p>The <strong>distance</strong> between $u$ and $v$ is the smallest length of any $u-v$ path in $G$ and is denoted by $d_{G}(u,v)$ or simply $d(u,v)$. A $u-v$ path of length $d(u,v)$ is called a $u-v$ <strong>geodesic</strong>.</p><p>The greatest distance between any two vertices of a connected graph $G$ is called the <strong>diameter</strong> of $G$ and is denoted by $diam(G)$.</p><p><strong>Theorem 1.10</strong> Let $G$ be a graph of order 3 or more. Then $G$  is connected if and only if $G$ contains two distinct vertices $u$  and $v$  such that $G-u$ and $G-v$ are connected.</p><h3 id="1-3-Common-Classes-of-Graphs"><a href="#1-3-Common-Classes-of-Graphs" class="headerlink" title="1.3 Common Classes of Graphs"></a>1.3 Common Classes of Graphs</h3><p>$G$ is called a <strong>path</strong> if …</p><p>$G$ is called a <strong>cycle</strong> if …</p><p>A graph $G$ is <strong>complete</strong> if every two distinct vertices of $G$ are adjacent. A complete graph of order $n$ is denoted by $K_n$.</p><p>The <strong>complement</strong> $\bar{G}$ of a graph $G$ is that graph whose vertex set is $V(G)$ and such that for each pair $u,v$ of distinct vertices of $G$, $uv$ is an edge of $\bar{G}$ if and only if $uv$ is not an edge of $G$.</p><p>The graph $\bar{K_n}$ has $n$ vertices and no edges, it is called the <strong>empty graph</strong> of order $n$.</p><p><strong>Theorem 1.11</strong> If $G$  is a disconnected graph, then $\bar{G}$ is connected.</p><p><strong>Theorem 1.12</strong> A nontrivial graph $G$ is a bipartite graph if and only if $G$ contains no odd cycles.</p><p>A graph $G$ is a <strong>bipartite graph</strong> if $V(G)$ can be partitioned into two subsets $U$ and $W$, called <strong>partite sets</strong>, such that every edge of $G$ joins a vertex of $U$ and a vertex of $W$.</p><p>If every vertex of $U$  is adjacent to every vertex of $W$ , then we call $G$  a <strong>complete bipartite graph</strong> . A complete graph with $|U|=s$  and $|W|=t$ is denoted by $K<em>{s,t}$ or $K</em>{t,s}$. If either $s=1$ or $t=1$, then $K_{s,t}$ is a <strong>star</strong>.</p><p>A graph $G$  is a $k$<strong>-partite graph</strong> if $V(G)$ can be partitioned into $k$ subsets $V_1$,$V_2$,…,$V_k$,(called <strong>partite sets</strong>) such that if $uv$ is an edge of $G$, then $u$ and $v$ belong to different partite sets. If, in addition, every  two vertices in different partite sets are joined by an edge, then $G$ is a <strong>complete k-partite graph</strong>. If $|V_i|=n<em>i$ for $1 \le i \le k$, then we denote this graph by $K</em>{n1,n2,…,nk}$. </p><p>The <strong>join</strong> $G+H$ consists of $G \cup H$ and all edges joining a vertex of $G$ and a vertex of $H$.</p><p>The <strong>Cartesian product</strong> $G \times H$ has vertex set $V(G \times H) = V(G) \times V(H)$ . Two distinct vertices $(u,v$) and $(x,y)$ are adjacent in $G \times H$ if either (1) $u=x$ and $vy\in E(H)$ or (2) $v=y$ and $ux\in E(G)$.</p><p>We define $Q_1 $ to be $ K<em>2 $ and for $n \ge 2$, define $Q</em>{n}$ to be $Q_{n-1} \times K_2 $. The graphs $Q_n $ are then called $n$<strong>-cubes</strong> or <strong>hypercubes</strong>.</p><h3 id="1-4-Multigraphs-and-Digraphs"><a href="#1-4-Multigraphs-and-Digraphs" class="headerlink" title="1.4 Multigraphs and Digraphs"></a>1.4 Multigraphs and Digraphs</h3><p>A <strong>multigraph</strong> $M$ consists of a finite nonempty set $V$ of vertices and a set $E$ of edges, where every two vertices of M are joined by a finite number of edges(possibly zero). If two or more edges join the same pair of (distinct) vertices, then these edges are called <strong>parallel</strong> edges.</p><p>In a <strong>pseudograph</strong>, not only are parallel edges permitted but an edge is also permitted to join a vertex to itself. Such an edge is called a <strong>loop</strong>.</p><p>A <strong>digraph</strong>(or <strong>directed graph</strong>) $D$ is a finite nonempty set $V$ of objects called <strong>vertices</strong> together with a set $E$ of ordered pairs of distinct vertices. The elements of $E$ are called <strong>directed edges</strong> or <strong>arcs</strong>. If $(u,v)$ is a directed edge, then we indicate this in a diagram representing $D$ by drawing a directed line segment or curve from $u$ to $v$. Then u is said to be <strong>adjacent to</strong> v and v is <strong>adjacent from</strong> u.</p><p>If, in the definition of digraph, for each pair $u,v$ of distinct vertices, at most one of $(u,v)$ and $(v,u)$ is a directed edge, then the resulting digraph is an <strong>oriented graph</strong>  </p><h2 id="Degrees"><a href="#Degrees" class="headerlink" title="Degrees"></a>Degrees</h2><h3 id="2-1-The-Degree-of-a-Vertex"><a href="#2-1-The-Degree-of-a-Vertex" class="headerlink" title="2.1 The Degree of a Vertex"></a>2.1 The Degree of a Vertex</h3><p>The <strong>degree of a vertex</strong> $v$ in a graph $G$ is the number of edges incident with $v$ and is denoted by $deg_G \ v$ or simply by $deg \ v$ if the graph $G$ is clear from the context.  The set $N(v)$ of neighbors of a vertex $v$  is called the <strong>neighborhood</strong> of $v$. Thus $deg \ v = |N(v)|$.</p><p>A vertex of degree 0 is referred to as an <strong>isolated vertex</strong> and a vertex of degree 1 is an <strong>end-vertex</strong>(or a <strong>leaf</strong>). </p><p>The <strong>minimum degree</strong> of $G$  is the minimum degree among the vertices of $G$ and is denoted by $\delta(G)$, the <strong>maximum degree</strong> of $G$ is denoted by $\Delta(G)$.</p><p>For $G$ of order $n$, we have $0 \le \delta(G) \le deg \ v \le \Delta(G) \le n-1$.</p><p><strong>Theorem 2.1(The First Theorem of Graph Theory)</strong>  If $G$  is a graph of size $m$, then $\sum \limits_{v\in V(G)} deg \ v =2m$.</p><p>A vertex of even degree is called an <strong>even vertex</strong>, while a vertex of odd degree is an <strong>odd vertex</strong>.</p><p><strong>Corollary 2.3</strong> Every graph has an even number of odd vertices.</p><p>If a graph $G$ order $n$ contains a vertex of degree $n-1$, then $G$ is connected. However, this is not a necessary condition.</p><p><strong>Theorem 2.4</strong> Let $G$ be a graph of order $n$. If $deg \ u + deg \ v \ge n-1$, for every two nonadjacent vertices $u$ and $v$ of $G$ , then $G$ is connected and $diam(G) \le 2$.</p><ul><li><p>The bound of <strong>Theorem 2.4</strong> is sharp.</p></li><li><p><strong>What if there is only one pair?</strong></p></li></ul><p><strong>Corollary 2.5</strong> If $G$  is a graph of order $n$ with $\delta(G) \ge (n-1)/2$, then $G$ is connected.</p><p><strong>outdegree</strong> and <strong>indegree</strong>.</p><h3 id="2-2-Regular-Graphs"><a href="#2-2-Regular-Graphs" class="headerlink" title="2.2 Regular Graphs"></a>2.2 Regular Graphs</h3><p>If $\delta(G)=\Delta(G)$, then the vertices of $G$  have the same degree and $G$  is called <strong>regular</strong>. If $deg \ r=r$ for every vertex $v$  of $G$, where $0 \le r \le n-1$, then $G$  is $r$ <strong>-regular</strong> or <strong>regular of degree r</strong>.</p><p>A 3-regular graph is also referred to as a <strong>cubic graph</strong>. The best known cubic graph may very well be the <strong>Petersen graph</strong>.</p><p><strong>Theorem 2.6</strong> Let $r$ and $n$  be integers with $0 \le r \le n-1$. There exists an r-regular graph of order $n$  if and only if at least one of $r$ and $n$  is even.</p><ul><li><p>How to construct this graph?  </p></li><li><p>The graphs $H_{r,n}$ are called <strong>Harary graph</strong></p></li></ul><p><strong>Theorem 2.7</strong> For every graph $G$ and every integer $r \ge \Delta(G)$, there exists an r-regular graph $H$ containing $G$ as an induced subgraph.</p><h3 id="2-3-Degree-Sequences"><a href="#2-3-Degree-Sequences" class="headerlink" title="2.3 Degree Sequences"></a>2.3 Degree Sequences</h3><p>If the degrees of the vertices of a graph $G$ are listed in a sequence $s$, then $s$  is called a <strong>degree sequence</strong> of $G$.</p><p>A finite sequence of nonnegative integers is called <strong>graphical</strong> if it is a degree sequence of some graph.</p><p><strong>Theorem 2.10</strong> A non-increasing sequence $s$: $d_1 ,d_2 ,…,d_n (n\ge 2)$ of non-negative integers, where $d_1 \ge 1$, is graphical if and only if the sequence $s_1：d<em>2 -1,d</em> 3-1,…,d<em>{d</em> 1 + 1}-1,d<em>{d</em> 1+1}-1,d<em>{d</em> 1+2},…d_ n $ is graphical.</p><h2 id="Isomorphic-Graphs"><a href="#Isomorphic-Graphs" class="headerlink" title="Isomorphic Graphs"></a>Isomorphic Graphs</h2><h3 id="3-1-The-Definition-of-Isomorphism"><a href="#3-1-The-Definition-of-Isomorphism" class="headerlink" title="3.1 The Definition of Isomorphism"></a>3.1 The Definition of Isomorphism</h3><p>We call two graphs $G$ and $H$ “isomorphic” if they have the same structure and write $G \cong H$ to indicate this. </p><p>Formally, two (labeled) graphs $G$ and $H$  are <strong>isomorphic</strong> (have the same structure) if there exists a one-to-one correspondence $\phi$ from $V(G)$ to $V(H)$ such that $uv \in E(G)$ if and only if $\phi(u)\phi(v) \in E(H)$. In this case, $\phi$  is called an <strong>isomorphism</strong> from $G$ to $H$.</p><p><strong>Theorem 3.1</strong> Two graphs $G$ and $H$ are isomorphic if and only if their complements $\bar{G}$ and $\bar{H}$ are isomorphic.</p><p>A graph $G$ is <strong>self-complementary</strong> if $G\cong \bar{G}$ . </p><p><strong>Theorem 3.2</strong> If $G$ and $H$ are isomorphic graphs, then the degrees of the vertices of $G$ are the same as the degrees of the vertices of $H$.</p><p><strong>Note</strong>: Having the same degree sequences don’t necessarily mean two graph are isomorphic.</p><h2 id="Trees"><a href="#Trees" class="headerlink" title="Trees"></a>Trees</h2><h3 id="4-1-Bridges"><a href="#4-1-Bridges" class="headerlink" title="4.1 Bridges"></a>4.1 Bridges</h3><p>An edge $e=uv$ of a connected graph $G$ is called a <strong>bridge</strong> of $G$ if $G-e$ is disconnected.</p><p>An edge $e$ is a <strong>bridge</strong> of a disconnected graph if $e$ is a bridge of some component of $G$.</p><p>An edge $e$ is a bridge of a graph $G$ if and only if $k(G-e)=k(G)+1$</p><p>End-vertice: vertice with degree $1$.</p><p><strong>Theorem 4.1</strong>: <em>An edge $e$ of a graph $G$ is a bridge if and only if $e$ lies on no cycle of $G$</em> </p><h3 id="4-2-Trees"><a href="#4-2-Trees" class="headerlink" title="4.2 Trees"></a>4.2 Trees</h3><p>A graph G is called <strong>acyclic</strong> if it has no cycles.</p><p>A <strong>tree</strong> is an acyclic connected graph.</p><p>Every edge in a tree is a bridge.</p><p>A tree containing exactly two vertices that are not end-vertices(which are necessarily adjacent) is called a <strong>double star</strong>.</p><p>A <strong>caterpillar</strong> is a tree of order 3 or more, the removal of whose end-vertices produces a path called <strong>spine</strong> of the caterpillar.</p><p>Choose a vertex of a tree $T$, and designate this vertex as the <strong>root</strong> of $T$. The tree $T$ then becomes a <strong>rooted tree</strong>. </p><p>Acyclic graphs are also referred to as <strong>forests</strong>. Therefore each component of a forest is a tree.</p><p>The one fact that distinguishes trees from forests is that a tree is required to be connected, while a forest is not required to be connected.</p><p><strong>Theorem 4.2</strong> <em>A graph $G$ is a tree if and only if every two vertices of G are connected by a unique path</em>.</p><p><strong>Theorem 4.3</strong> <em>Every nontrivial tree has at least two end-vertices</em>.</p><p><strong>Theorem 4.4</strong> <em>Every tree of order n has size $n-1$</em></p><p><strong>Corollary 4.6</strong> <em>Every forest of order n with k components has size $n-k$</em></p><p><strong>Theorem 4.7</strong> <em>The size of every connected graph of order $n$ is at least $n-1$</em>.</p><p><strong>Theorem 4.8</strong> <em>Let $G$ be a graph of order $n$ and size $m$. If $G$ satisfies any two of the properties: (1) $G$ is connected, (2)$G$ is acyclic, (3)$m=n-1$, then $G$ is a tree.</em></p><p><strong>Theorem 4.9</strong> <em>Let $T$ be a tree of order $k$. If $G$ is a graph with $\delta(G) \ge k-1$, then $T$ is isomorphic to some subgraph of $G$</em></p><h3 id="4-3-The-Minimum-Spanning-Tree-Problem"><a href="#4-3-The-Minimum-Spanning-Tree-Problem" class="headerlink" title="4.3 The Minimum Spanning Tree Problem"></a>4.3 The Minimum Spanning Tree Problem</h3><p>A spanning subgraph $H$ of a connected graph $G$ such that $H$ is a tree is called a <strong>spanning tree</strong> of $G$.</p><p><strong>Theorem 4.10</strong> <em>Every connected graph contains a spanning tree</em>.</p><p>The <strong>weight</strong> $w(H)$ of $H$ is defined as the sum of the weights of its edges.</p><p>A spanning tree with the minimum weight is called a <strong>minimum spanning tree</strong>.</p><p>The problem of finding a minimum spanning tree in a connected weighted graph is called the <strong>Minimum Spanning Tree Problem</strong>. </p><p><strong>Kruskal’s Algorithm</strong>: For a connected weighted graph $G$, a spanning tree $T$ of $G$ is constructed as follows: For the first edge $e_1$ of $T$, we select any edge of $G$ of minimum weight and for the second edge $e_2$ of $T$, we select any remaining edge of $G$ of minimum weight. For the thrid edge $e_3$ of T, we choose any remaining edge of $G$ of minimum weight that does not produce a cycle with the previously selected edges. We continue in the manner until a spanning tree is produced.</p><p><strong>Theorem 4.11</strong> <em>Kruskal’s Algorithm produces a minimum spanning tree in a connected weighted graph</em>.</p><ul><li>证明思路：取与T共同边数最多的最小生成树为H，取其中第一条不在T的边，构造新的生成树，构造关系，证明相等，矛盾</li></ul><p><strong>Prim’s Algorithm</strong>: For a connected weighted graph $G$, a spanning tree $T$ of $G$ is constructed as follows: For an arbitrary vertex $u$ for $G$, an edge of minimum weight incident with $u$ is selected as the first edge $e_1$ of $T$. For subsequent edges $e_2$, $e<em>3$, ..,$e</em>{n-1}$, we select an edge of minimum weight among those edges having exactly one of its vertices incident with an edge already selected.</p><p><strong>Theorem 4.12</strong> <em>Prim’s Algorithm produces a minimum spanning tree in a connected weighted graph.</em></p><h3 id="4-4-Excursion-The-Number-of-Spanning-Trees"><a href="#4-4-Excursion-The-Number-of-Spanning-Trees" class="headerlink" title="4.4 Excursion: The Number of Spanning Trees"></a>4.4 Excursion: The Number of Spanning Trees</h3><p><strong>THeorem 4.15</strong> <em>The number of distinct trees of order n with a specified vertex set is $n^{n-2}$</em>.</p><p><strong>Matrix Tree Theorem</strong> (to be continued).</p><h2 id="Connectivity"><a href="#Connectivity" class="headerlink" title="Connectivity"></a>Connectivity</h2><h3 id="5-1-Cut-Vertices"><a href="#5-1-Cut-Vertices" class="headerlink" title="5.1 Cut-Vertices"></a>5.1 Cut-Vertices</h3><p>A vertex $v$ in a connected graph $G$ is a <strong>cut-vertex</strong> of $G$ if $G-v$  is disconnected. More generally, a vertex $v$ is a cut-vertex in a graph $G$  if $v$  is a cut-vertex of a component of $G$.</p><p><strong>Theorem 5.1</strong> Let $v$ be a vertex incident with a bridge in a connected graph $G$. Then $v$ is a cut-vertex of $G$ if and only if $deg \ v \ge 2$. </p><p><strong>Corollary 5.2</strong> Let $G$ be a connected graph of order 3 or more. If $G$ contains a bridge, then $G$  contains a cut-vertex.</p><p><strong>Theorem 5.3</strong> Let $v$ be a cut-vertex in a connected graph $G$ and let $u$ and $w$ be vertices in distinct components of $G-v$ . Then $v$ lies on every $u-w$ path in $G$.</p><p><strong>Corollary 5.4</strong> A vertex $v$ of a connected graph $G$  is a cut-vertex of $G$ if and only if there exist vertices $u$ and $w$ distinct from $v$ such that $v$ lies on every $u-w$ path of $G$.</p><p><strong>Theorem 5.5</strong> Let $G$ be a nontrivial connected graph and let $u\in V(G)$ . If $v$ is a vertex that is farthest from $u$ in $G$, then $v$ is not a cut-vertex of $G$.</p><p><strong>Corollary 5.6</strong> Every nontrivial connected graph contains at least two vertices that are not cut-vertices.</p><h3 id="5-2-Blocks"><a href="#5-2-Blocks" class="headerlink" title="5.2 Blocks"></a>5.2 Blocks</h3><p>A nontrivial connected graph with no cut-vertices is called a <strong>nonseparable graph</strong>.</p><p><strong>Theorem 5.7</strong> A graph of order at least 3 is nonseparable if and only if every two vertices lie on a common cycle.</p><p><strong>Theorem 5.8</strong> Let $R$ be the relation defined on the edge set of a nontrivial connected graph $G$ by $e \ R \ f$, where $e,f \in E(G)$, if $e=f$ or $e$ and $f$ lie on a common cycle of $G$. Then $R$ is an equivalence relation.</p><p><strong>Corollary 5.9</strong> Every two distinct blocks $B_1$ and $B_2$ in a nontrivial connected graph $G$ have the following properties: </p><ul><li><p>(a) The blocks $B_1$ and $B_2$ are edge-disjoint.</p></li><li><p>(b) The blocks $B_1$ and $B_2$ have at most one vertex in common.</p></li><li><p>(c) If $B_1$ and $B_2$ have a vertex $v$ in common, then $v$ is a cut-vertex of $G$.</p></li></ul><h3 id="5-3-Connectivity"><a href="#5-3-Connectivity" class="headerlink" title="5.3 Connectivity"></a>5.3 Connectivity</h3><p>By a <strong>vertex-cut</strong> in a graph $G$, we mean a set $U$ of vertices of $G$ such that $G-U$ is disconnected. A vertex-cut of minimum cardinality in $G$ is called a <strong>minimum vertex-cut</strong>.</p><p><strong>Note</strong>: A connected graph contains a vertex-cut if and only if $G$ is not complete.</p><p>For a graph $G$ that is not complete, the <strong>vertex-connectivity</strong>(or simply the <strong>connectivity</strong>) $\kappa(G)$ of $G$ is defined as the cardinality of a minimum vertex-cut of $G$; if $G=K_n$ for some positive integer $n$, then $\kappa(G)$ is defined to be $n-1$. $$0 \le \kappa(G) \le n-1$$.</p><p>For a nonnegative integer $k$, a graph $G$ is said to be $k$<strong>-connected</strong> if $\kappa(G) \ge k$.</p><p>An <strong>edge-cut</strong> in a nontrivial graph $G$  is a set $X$ of edges of $G$ such that $G-X$ is disconnected.</p><p>An edge-cut $X$  of a connected graph $G$  is <strong>minimal</strong> if no proper subset of $X$ is an edge-cut of $G$. If $X$ is a minimal edge-cut of a connected graph $G$, then $G-X$ contains exactly two components $G_1$ and $G_2$. Necessarily  then , $X$ consists of all those edges of $G$  joining $G_1$ and $G_2$.  </p><p>An edge-cut of minimum cardinality is called a <strong>minimum edge-cut</strong>.</p><p>The <strong>edge-connectivity</strong> …….</p><p>For a nonnegative integer $k$, …</p><p><strong>Theorem 5.11</strong> For every graph $G$, $$ \kappa(G) \le \lambda(G) \le \delta(G) $$</p><p><strong>Theorem 5.12</strong> If $G$ is a cubic graph, then $\kappa(G) = \lambda(G)$.</p><p><strong>Theorem 5.13</strong> If $G$ is a graph of order $n$ and size $m \le n-1$, then $\kappa(G) \le \lfloor \frac{2m}{n} \rfloor$ .</p><p>$\kappa(T)=1$</p><p>Let $G$ be a connected graph of diameter $d$. For an integer $k$ with $1 \le k \le d$, the $k$<strong>th power</strong> $G^k $ of $G$  is the graph with $V(G^k ) = V(G)$ such that $uv$ is an edge of $G^k$ if $1 \le d_{G} (u,v) \le k$.</p><p><strong>Theorem 5.14</strong> If $G$ is a connected graph of order at least 3, then its square $G^2$  is 2-connected.</p><p><strong>Theorem 5.15</strong> For every two integers $r$ and $n$ with $2 \le r \le n$, $$\kappa(H_{r,n})=r$$.</p><h3 id="5-4-Menger’s-Theorem"><a href="#5-4-Menger’s-Theorem" class="headerlink" title="5.4 Menger’s Theorem"></a>5.4 Menger’s Theorem</h3><p>TBC.</p><h2 id="Traversability"><a href="#Traversability" class="headerlink" title="Traversability"></a>Traversability</h2><h3 id="6-1-Eulerian-Graphs"><a href="#6-1-Eulerian-Graphs" class="headerlink" title="6.1 Eulerian Graphs"></a>6.1 Eulerian Graphs</h3><p>A circuit $C$ in a graph $G$ is called an <strong>Eulerian circuit</strong> if $C$ contains every edge of $G$. Since no edges is repeated in a circuit, every edge appears exactly once in an Eulerian circuit. A connected graph that contains an Eulerian circuit is called an <strong>Eulerian graph</strong>.</p><p>For a connected graph $G$, we refer to an open trial that contains every edge of $G$ as an <strong>Eulerian trial</strong>.</p><p><strong>Theorem 6.1</strong> A nontrivial connected graph $G$ is Eulerian if and only if every vertex of $G$ has even degree.</p><p><strong>Theorem 6.2</strong> A connected graph $G$ contains an Eulerian trial if and only if exactly two vertices of $G$ have odd degree. Furthermore, each Eulerian trial of $G$ begins at one of these odd vertices and ends at the other.</p><p>We have a conclusion: Let $G$ and $H$ be nontrivial connected graphs. Then $G \times H$ is Eulerian if and only if both $G$ and $H$ are Eulerian or every vertex of $G$ and $H$  is odd.</p><h3 id="6-2-Hamiltonian-Graphs"><a href="#6-2-Hamiltonian-Graphs" class="headerlink" title="6.2 Hamiltonian Graphs"></a>6.2 Hamiltonian Graphs</h3><p>A cycle in a graph $G$ that contains every vertex of $G$ is called a <strong>Hamiltonian cycle</strong> of $G$. A <strong>Hamiltonian graph</strong> is a graph that contains a Hamiltonian cycle.</p><p>A path in a graph $G$ that contains every vertex of $G$ is called a <strong>Hamiltonian path</strong> in $G$.</p><p><strong>Theorem 6.4</strong> The Petersen graph is non-Hamiltonian.</p><p><strong>Theorem 6.5</strong> If $G$ is a Hamiltonian graph, then for every nonempty proper set $S$ of vertices of $G$, $$\kappa(G-S) \le |S|$$</p><p><strong>Theorem 6.6</strong> Let $G$ be a graph of order $n \ge 3$. If $deg \ u + deg \ v \ge n$ for each pair $u$, $v$ of nonadjacent vertices of $G$, then $G$ is Hamiltonian.</p><p><strong>Corollary 6.7</strong> Let $G$ be graph of order $n \ge 3$. If $deg \ v \ge n/2$  for each vertex $v$ of $G$, then $G$ is Hamiltonian.</p><p><strong>Theorem 6.8</strong> Let $u$ and $v$ be nonadjacent vertices in a graph $G$ of order $n$ such that $deg \ u + deg \ v \ge n$ . Then $G+uv$ is Hamiltonian if and only if $G$ is Hamiltonian.</p><p>The <strong>closure</strong> $C(G)$ of a graph $G$ of order $n$ is the graph obtained from $G$ by recursively joining pairs of nonadjacent vertices whose degree sum is at least $n$ (in the resulting graph at each stage) until no such pair remains.</p><p><strong>Theorem 6.9</strong> A graph is Hamiltonian if and only if its closure is Hamiltonian.</p><p><strong>Corollary 6.10</strong> If $G$ is a graph of order at least 3 such that $C(G)$ is complete, the n $G$ is Hamiltonian.</p><p><strong>Theorem 6.11</strong> Let $G$ be a graph of order $n \ge 3$. If for every integer $j$ with $ 1 \le j &lt; \frac{n}{2}$, the number of vertices of $G$ with degree at most $j$ is less than $j$, then $G$ is Hamiltonian.</p><h3 id="6-3-Hamiltonian-Walks"><a href="#6-3-Hamiltonian-Walks" class="headerlink" title="6.3 Hamiltonian Walks"></a>6.3 Hamiltonian Walks</h3><h2 id="Matchings-and-Factorization"><a href="#Matchings-and-Factorization" class="headerlink" title="Matchings and Factorization"></a>Matchings and Factorization</h2><h3 id="8-1-Matchings"><a href="#8-1-Matchings" class="headerlink" title="8.1 Matchings"></a>8.1 Matchings</h3><p>A set of edges in a graph is <strong>independent</strong> if no two edges in the set are adjacent.</p><p>By a <strong>macthing</strong> in a graph $G$ , we mean an independent set of edges in $G$.</p><p>The graph $G$ is said to satisfy <strong>Hall’s condition</strong> if $|N(X)| \ge|X|$ for every nonempty subset $X$ of $U$.</p><p><strong>Theorem 8.3</strong> Let $G$ be a bipartite graph with partite sets $U$ and $W$ such that $r= |U| \le |W|$. Then $G$ contains a matching of cardinality $r$ if and only if $G$ satisfies Hall’s condition.</p><p><strong>Theorem 8.4</strong> A collection ${ S_1 , S_2 , … , S_n}$ of nonempty finite sets has a system of distinct representatives if and only if for each integer $k$ with $1 \le k \le n$, the union of any $k$ of these sets contains at elast $k$ elements.</p><p><strong>Theorem 8.5(The Marriage Theorem)</strong> In a collection of $r$ women and $r$ men, a total of $r$ marriages between acquainted couples is possible if and only if for each integer $k$ with $1 \le k \le r$, every subset of $k$ women is collectively acquainted with at least $k$ men.</p><p>A matching of maximum cardinality is called a <strong>maximum matching</strong>.  </p><p>If a graph $G$ of order $2k$ has a matching $M$ of cardinality $k$, then this (necessarily maximum)  matching $M$ is called a <strong>perfect matching</strong> as $M$ matches every vertex of $G$ to some vertex of $G$ .</p><p><strong>Theorem 8.6</strong> Every r-regular bipartite graph($r \ge 1$)  has a perfect matching.</p><p>The <strong>edge independence number</strong> $\alpha’(G)$ of a graph $G$  is the maximum cardinality of an independent set of edges.</p><p>Furthermore, a graph $G$ of order $n$ has a perfect matching if and only if $n$ is even and $\alpha ‘(G) = n/2$.</p><p>A vertex and an incident edge are said to <strong>cover</strong> each other.</p><p>An <strong>edge cover</strong> of a graph $G$ without isolated vertices is a set of edges of $G$ that covers all vertices of $G$.</p><p>The <strong>edge covering number</strong> $\beta’(G)$ of a graph $G$ is the minimum cardlinality of an edge cover of $G$.  An edge cover of $G$ of cardinality $\beta’(G)$ is a <strong>minimum edge cover</strong> of $G$.</p><p><strong>Theorem 8.7</strong> For every graph $G$ of order $n$ containing no isolated vertices, $$\alpha(G’)+ \beta(G’)=n$$.</p><p>A set of vertices in a graph is <strong>independent</strong> if  no two vertices in the set are adjacent. The <strong>vertex independence number</strong> (or the <strong>independence number</strong>) $\alpha(G)$ of a graph $G$ is the maximum cardinality of an independent set of vertices in $G$. An independent set in $G$ of cardinality $\alpha(G)$ is called a <strong>maximum independent set</strong>. </p><p>A <strong>vertex cover</strong> in a graph $G$ is a set of vertices that covers all edges of $G$. The minimum number of vertices in a vertex cover of $G$  is the <strong>vertex covering number</strong> $\beta(G)$  of $G$. A vertex cover of cardinality $\beta(G)$ is a <strong>minimum vertex cover</strong> in $G$.</p><p><strong>Theorem 8.8</strong> For every graph $G$ of order $n$ containing no isolated vertices, $$\alpha(G) + \beta(G) =n$$. </p><h3 id="8-2-Factorization"><a href="#8-2-Factorization" class="headerlink" title="8.2 Factorization"></a>8.2 Factorization</h3><p>A 1-regular spanning subgraph of a graph $G$ is also called a <strong>1-factor</strong> of $G$. </p><p>A graph $G$ has a 1-factor if and only if $G$ has a perfect matching.</p><p>A component of a graph is <strong>odd</strong> or <strong>even</strong> according to whether its order is odd or even. We write $k_O (G)$ for the number of odd components of a graph $G$.</p><p><strong>Theorem 8.10</strong> A graph $G$ contains a 1-factor if and only if $k_O (G-S) \le |S|$ for every proper subset $S$ of $V(G)$.</p><p><strong>Theorem 8.11(Petersen’s Theorem)</strong> Every 3-regular bridgeless graph contains a 1-factor.</p><p><strong>Theorem 8.12</strong> Every 3-regular graph with at most two bridges contains a 1-factor.</p><p>A graph $G$ is said to be <strong>1-factorable</strong> if there exists 1-factors $F_1,F_2,…,F_r$ of $G$ such that ${E(F_1),E(F_2),..,E(F_r)}$ is a partition of $E(G)$.  We then say that $G$ is <strong>factored</strong> into the 1-factors $F_1.F_2,…,F_r$ , which form a <strong>1-factorization</strong> of $G$.</p><p>Every 1-factorable graph is regular.</p><p><strong>Theorem 8.13</strong> The Petersen graph is not 1-factorable.</p><p><strong>Theorem 8.14</strong> For each positive integer $k$, the complete graph $K_{2k}$ is 1-factorable.</p><p><strong>Theorem 8.15</strong> Every r-regular bipartite graph , $r\ge 1$, is factorable.</p><p>A <strong>2-factor</strong> in a graph $G$ is a spanning 2-regular subgraph of $G$. Every component of a 2-factor is therefore a cycle. A graph $G$ is said to be <strong>2-factorable</strong> if there exist 2-factors $F_1,F_2,..,F_k$ such that ${E(F_1),E(F_2),…,E(F_k)}$ is a partition of $E(G)$.</p><p><strong>Theorem 8.16</strong> A graph $G$ is 2-factorable if and only if $G$ is r-regular for some positive even integer $r$.</p><p>A spanning subgraph $F$ of a graph $G$ is called a <strong>factor</strong> of $G$. The graph $G$ is said to be <strong>factorable</strong> into the factors $F_1,F_2,…,F_k$ if ${E(F_1),E(F_2),…,E(F_k)}$ is a partition of $E(G)$. If each factor $F_i$ is isomorphic to some graph $G$, then $G$ is <strong>F-factorable</strong>.</p><p>TBC.</p><h3 id="8-3-Decompositions-and-Graceful-Labelings"><a href="#8-3-Decompositions-and-Graceful-Labelings" class="headerlink" title="8.3 Decompositions and Graceful Labelings"></a>8.3 Decompositions and Graceful Labelings</h3><p>A graph $G$ is said to be <strong>decomposable</strong> into the subgraphs $H_1,H_2,…,H_k$ if ${E(H_1),E(H_2),…,E(H_k)}$ is a partition of $E(G)$. Such a partition produces a <strong>decomposition</strong> of $G$.  If each $H_i$ is isomorphic to some graph $H$, then the graph $G$ is $H-$ <strong>decomposable</strong>  and the decomposition is an $H-$ <strong>decomposition</strong>. </p><p>A <strong>Steiner triple system</strong> of order $n$ is a set $S$ of cardinality $n$ and a collection $T$ of 3-element subsets, called <strong>triples</strong>, such that every two distinct elements of $S$ belong to a unique triple in $T$.</p><p>TBC</p><h2 id="Planarity"><a href="#Planarity" class="headerlink" title="Planarity"></a>Planarity</h2><h3 id="9-1-Planar-Graphs"><a href="#9-1-Planar-Graphs" class="headerlink" title="9.1 Planar Graphs"></a>9.1 Planar Graphs</h3><p>A graph $G$  is called a <strong>planar graph</strong> if $G$  can be drawn in the plane so that no two of its edges cross each other. A graph that is not planar is called <strong>nonplanar</strong>. A graph $G$ is called a <strong>plane graph</strong>  if it is drawn in the plane so that no two edges of $G$ cross. </p><p>A plane graph divides the plane into connected pieces called <strong>regions</strong>. In every plane graph, there is always one region that is unbounded. This is the <strong>exterior region</strong>.  The subgraph of a plane graph whose vertices and edges are incident with a given region $R$  is the <strong>boundary</strong> of $R$. </p><p><strong>Theorem 9.1(The Euler Identity)</strong> If $G$ is a connected plane graph of order $n$, size $m$ and having $r$ regions, then $n-m+r=2$.</p><p><strong>Theorem 9.2</strong> If $G$ is a planar graph of order $n \ge 3$ and size $m$, then $$m \le 3n-6$$.</p><p><strong>Corollary 9.3</strong> Every planar graph contains a vertex of degree 5 or less.</p><p><strong>Corollary 9.4</strong> The complete graph $K_5$ is nonplanar.</p><p><strong>Theorem 9.5</strong> The graph $K_{3,3}$ is nonplanar.</p><p>A graph $G$ is <strong>maximal planar</strong> if $G$ is planar but the addition of an edge between any two nonadjacent vertices of $G$  results in a nonplanar graph.</p><p>More formally, a graph is called a <strong>subdivision</strong> of a graph $G$ if $G’=G$ or one or more vertices of degree 2 are inserted into one or more edges of $G$.</p><p><strong>Theorem 9.7(Kuratowski’s Theorem)</strong> A graph $G$ is planar if and only if $G$ does not contain a subdivision of $K<em>5$ or $K</em>{3,3}$ as a subgraph. </p><h2 id="Coloring-Graphs"><a href="#Coloring-Graphs" class="headerlink" title="Coloring Graphs"></a>Coloring Graphs</h2><h3 id="10-2-Vertex-Coloring"><a href="#10-2-Vertex-Coloring" class="headerlink" title="10.2 Vertex Coloring"></a>10.2 Vertex Coloring</h3><p>With each map, there is associated a graph $G$  called the  <strong>dual</strong> of the map, whose vertices are the regions of the map and such that two vertices of $G$  are adjacent if the corresponding regions are neighboring regions.</p><p>By a <strong>proper coloring</strong> (or, more simply, a <strong>coloring</strong>)  of a graph $G$  ,  we mean an assignment of colors (elements of some set) to the vertices of $G$ , one color to each vertex, such that adjacent vertices are colored differently.  </p><p>The smallest number of colors in any coloring of a graph $G$  is called the <strong>chromatic number</strong>  of $G$  and is denoted by $\chi(G)$.  If it is possible to color $G$ from a set of $k$  colors, then $G$  is said to be <strong>k-colorable</strong>. A coloring that uses $k$ colors is called a <strong>k-coloring</strong>. If $\chi(G)=k$, then $G$ is said to be <strong>k-chromatic</strong> and every $k-coloring$ of $G$ is a <strong>minimum coloring</strong> of $G$. </p><p><strong>Theorem 10.1(The Four Color Theorem)</strong> The chromatic number of every planargraph is at most 4.</p><p>If $G$ is a k-chromatic graph, then it is possible to partition $V(G)$ into  $k-1$ independent sets $V_1 , V_2 , …., V_k $, called <strong>color classes</strong>, but it is not possible to partition $V(G)$ into $k-1$ independent sets.</p><p><strong>Theorem 10.2</strong> A graph $G$ has chromantic number 2 if and only if $G$ is a nonempty bipartite graph.</p><p>A graph $G$ of order $n$ has chromatic number $n$ if and only if $G =K_n$.</p><p>If $H$ is a subgraph of $G$, then $\chi(H) \le \chi(G)$.</p><p>A <strong>clique</strong> in a graph $G$ is a complete subgraph of $G$. The order of the largest clique ina graph $G$ is its <strong>clique number</strong>, which is denoted by $\omega(G)$.</p><p>In fact,  $\alpha(G)=k$ if and only if $\omega(\bar{G})=k$.</p><p><strong>Theorem 10.5</strong> For every graph $G$ of order $n$, $\chi(G \ge \omega(G))$ and $\chi(G) \ge \frac{n}{\alpha(G)}$.</p><p><strong>Theorem 10.7</strong> For every graph $G$, $$\chi(G) \le 1 + \Delta(G)$$ </p><p><strong>Theorem 10.8(Brooks’ Theorem)</strong> For every connected graph $G$ that is not an odd cycle or a complete graph, $\chi(G) \le \Delta(G)$.</p><p><strong>Theorem 10.9</strong> For every graph $G$, $\chi(G) \le 1+ max{\delta(H)}$, where the maximum is taken over all induced subgraphs $H$ of $G$.</p><p>The <strong>shadow graph</strong> $S(G)$ of a graph $G$ is obtained from $G$ by adding, for each vertex $v$ of $G$, a new vertex $v’$, called the <strong>shadow vertex</strong> of $v$ , and joining $v’$ to the neighbors of $v$ in $G$. Observe that (1) a vertex of $G$ and its shadow vertex are not adjacent in $S(G)$ and (2) no two shadow vertices are adjacent in $S(G)$.</p><p><strong>Theorem 10.10</strong> For every integer $k \ge 3$, there exists a triangle-free graph with chromatic number $k$.</p><p>A graph $G$ is called <strong>perfect</strong> if $\chi(H)=\omega(H)$ for every induced subgraph $H$ of $G$.</p><p><strong>The Perfect Graph Theorem</strong> A graph is perfect if and only if its complement is perfect.</p><p><strong>The Strong Perfect Graph T</strong> A graph $G$ is perfect if and only if neither $G$ nor $\bar{G}$ contains an induced odd cycle of length 5 or more.</p><p>Reference:</p><p>[1] G.Chartrand and P.Zhang, First Course in Graph Theory, New York: Dover Publications, 2012.</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Summary-of-definitions-and-theorems-in-graph-theory&quot;&gt;&lt;a href=&quot;#Summary-of-definitions-and-theorems-in-graph-theory&quot; class=&quot;headerlink&quot; title=&quot;Summary of definitions and theorems in graph theory&quot;&gt;&lt;/a&gt;Summary of definitions and theorems in graph theory&lt;/h1&gt;&lt;h2 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h2&gt;&lt;h3 id=&quot;1-1-Graphs-and-Graph-Models&quot;&gt;&lt;a href=&quot;#1-1-Graphs-and-Graph-Models&quot; class=&quot;headerlink&quot; title=&quot;1.1 Graphs and Graph Models&quot;&gt;&lt;/a&gt;1.1 Graphs and Graph Models&lt;/h3&gt;&lt;p&gt;A &lt;strong&gt;Graph&lt;/strong&gt; G consists of a finite nonempty set $V$ of objects called &lt;strong&gt;vertices&lt;/strong&gt; and a set $E$ of 2-element subsets of $V$ called &lt;strong&gt;edges&lt;/strong&gt;. The ses $V$ and $E$ are the &lt;strong&gt;vertex set&lt;/strong&gt; and &lt;strong&gt;edge set&lt;/strong&gt; of $G$, respectively. Write $G=(V,E)$.&lt;/p&gt;
&lt;p&gt;Two graphs $G$ and $H$ are &lt;strong&gt;equal&lt;/strong&gt; if $V(G)=V(H)$ and $E(G)=E(H)$, in which case we write $G=H$.&lt;/p&gt;
&lt;p&gt;If $uv$ is an edge of $G$, then $u$ and $v$ are said to be &lt;strong&gt;adjacent&lt;/strong&gt; in $G$.&lt;/p&gt;
&lt;p&gt;The number of vertices in $G$ is often called the &lt;strong&gt;order&lt;/strong&gt; of $G$, while the number of edges is its &lt;strong&gt;size&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;A graph with exactly one vertex is called a &lt;strong&gt;trivial graph&lt;/strong&gt;, implying that the order of a &lt;strong&gt;nontrivial graph&lt;/strong&gt; is at least 2.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;labeled graph&lt;/strong&gt; and &lt;strong&gt;unlabeled graph&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A graph $G$ is called a &lt;strong&gt;word graph&lt;/strong&gt; if $G$ is the word graph of some set $S$ of 3-letter words.&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Daily Records for 2018 Oct</title>
    <link href="https://ricky-ting.github.io/2018/10/01/Daily-Records-for-2018-Oct/"/>
    <id>https://ricky-ting.github.io/2018/10/01/Daily-Records-for-2018-Oct/</id>
    <published>2018-10-01T11:48:48.000Z</published>
    <updated>2018-10-07T15:11:45.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Oct-1-7"><a href="#Oct-1-7" class="headerlink" title="Oct 1-7"></a>Oct 1-7</h1><ul><li>Did some Lab1</li><li>Completed PA2.1</li><li>Completed ProblemSolving3-4</li><li>Completed Expr03 and Expr04 of Digital Logical Circuits</li><li>Did some further reading</li></ul><h1 id="Oct-8"><a href="#Oct-8" class="headerlink" title="Oct 8"></a>Oct 8</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Oct-1-7&quot;&gt;&lt;a href=&quot;#Oct-1-7&quot; class=&quot;headerlink&quot; title=&quot;Oct 1-7&quot;&gt;&lt;/a&gt;Oct 1-7&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Did some Lab1&lt;/li&gt;
&lt;li&gt;Completed PA2.1&lt;/li&gt;

      
    
    </summary>
    
    
      <category term="记录" scheme="https://ricky-ting.github.io/tags/%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>PA拾慧</title>
    <link href="https://ricky-ting.github.io/2018/09/16/PA%E6%8B%BE%E6%85%A7/"/>
    <id>https://ricky-ting.github.io/2018/09/16/PA拾慧/</id>
    <published>2018-09-16T15:03:19.000Z</published>
    <updated>2018-10-07T15:30:53.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>天将降PA于斯人也，必先使其STFW,RTFM,RTFSC, 所以动心忍性，曾益其所不能</strong></p><h1 id="tmux-分屏工具"><a href="#tmux-分屏工具" class="headerlink" title="tmux(分屏工具)"></a>tmux(分屏工具)</h1><p>Prefix: <code>Ctrl+B</code></p><p>左右分屏:<code>Prefix + %</code> 上下分屏: <code>Prefix + &quot;</code></p><p>切换: <code>Prefix + 方向键</code></p><h1 id="Vim配置"><a href="#Vim配置" class="headerlink" title="Vim配置"></a>Vim配置</h1><h2 id="vim分屏："><a href="#vim分屏：" class="headerlink" title="vim分屏："></a>vim分屏：</h2><p><code>Ctrl+W s</code>:上下分割当前打开的文件</p><p><code>:sp filename</code>:上下分割，并打开一个新的文件</p><p><code>Ctrl+W v</code>: 左右分割当前打开的文件</p><p><code>:vsp filename</code>: 左右分割，并打开一个新的文件</p><p><code>Ctrl+W l,h,k,j</code>: 在窗格见切换</p><h2 id="vim函数跳转"><a href="#vim函数跳转" class="headerlink" title="vim函数跳转:"></a>vim函数跳转:</h2><ol><li>安装ctags: ‘sudo apt-get install ctags’</li><li>测试ctags是否安装成功: <code>whereis ctags</code></li><li>为源代码生成tags文件，建议在项目根目录下生成: <code>ctags -R</code>,更多高级选项请自行查询或man</li><li>配置vimrc: <code>sudo vim ~/.vimrc</code></li><li>修改vimrc: 加入下面两行 </li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set tags=[path]/tags</span><br><span class="line">set tags=./tags,tags;$HOME</span><br></pre></td></tr></table></figure><h2 id="vim配置选项"><a href="#vim配置选项" class="headerlink" title="vim配置选项"></a>vim配置选项</h2><p><code>set laststatus=2</code></p><p>跳转快捷键: <code>Ctrl+]</code>跳转,  <code>Ctrl+t</code> or <code>Ctrl+o</code>返回.</p><p>在终端里输入<code>vim -t functionname</code> 可以直接跳转至你想跳转的函数.(来自StardustDL的补充)</p><p>vim函数跳转部分参考<a href="https://mengzelev.github.io/2018/09/12/pa-inspirations/" target="_blank" rel="noopener">Mengzelve’s Blog</a> </p><h1 id="C语言相关"><a href="#C语言相关" class="headerlink" title="C语言相关"></a>C语言相关</h1><p>顺时针法则</p><p>strcmp返回值为0是两个字符串相等</p><p>结构体里利用位域实现位级访问</p><h1 id="Linux相关"><a href="#Linux相关" class="headerlink" title="Linux相关"></a>Linux相关</h1><p>linux里的管道(pipeline)将不同程序的输入输出连起来。</p><p><code>time ./a.out</code> 可以测程序运行的时间。</p><p>在shell中使用终端设置别名:<code>alias cdblog=&#39;cd ~/Desktop/Github/Blog&#39;</code></p><p>统计代码行数: <code>find . | grep -E &#39;\.c$|\.h$&#39; | xargs cat | wc -l</code></p><p>统计代码行数(不含空格): <code>find . | grep -E &#39;\.c$|\.h$&#39; | xargs cat | grep -v ‘^$’ | wc -l</code></p><h1 id="一些好的文章："><a href="#一些好的文章：" class="headerlink" title="一些好的文章："></a>一些好的文章：</h1><p><a href="https://i.linuxtoy.org/docs/guide/index.html" target="_blank" rel="noopener">开源世界旅行手册</a></p><p><a href="http://songshuhui.net/archives/70194" target="_blank" rel="noopener">计算的极限</a></p><p><a href="https://eli.thegreenplace.net/2011/01/23/how-debuggers-work-part-1/#id7" target="_blank" rel="noopener">How debuggers work</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;天将降PA于斯人也，必先使其STFW,RTFM,RTFSC, 所以动心忍性，曾益其所不能&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;tmux-分屏工具&quot;&gt;&lt;a href=&quot;#tmux-分屏工具&quot; class=&quot;headerlink&quot; title=&quot;tmux(
      
    
    </summary>
    
    
      <category term="记录" scheme="https://ricky-ting.github.io/tags/%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Debian install sudo</title>
    <link href="https://ricky-ting.github.io/2018/09/06/Debian-install-sudo/"/>
    <id>https://ricky-ting.github.io/2018/09/06/Debian-install-sudo/</id>
    <published>2018-09-06T01:08:13.000Z</published>
    <updated>2018-09-06T07:39:19.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Debian-install-sudo"><a href="#Debian-install-sudo" class="headerlink" title="Debian install sudo"></a>Debian install sudo</h1><ol><li><code>su</code>切换至root</li><li><code>apt-get install sudo</code></li><li><code>visudo</code> 在<code>root ALL(ALL:ALL) ALL</code>后面加入一行<code>&lt;user&gt; ALL=(ALL:ALL) ALL</code></li><li>然后Ctrl-O 保存文件，要把文件名里的<code>.tmp</code>删除，两次yes， Ctrl-X退出编辑</li></ol><p><code>sudoers</code>文件目录为<code>/etc/sudoers</code></p><p><code>su</code>进入root, <code>exit</code>退出root</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Debian-install-sudo&quot;&gt;&lt;a href=&quot;#Debian-install-sudo&quot; class=&quot;headerlink&quot; title=&quot;Debian install sudo&quot;&gt;&lt;/a&gt;Debian install sudo&lt;/h1&gt;&lt;ol&gt;

      
    
    </summary>
    
    
      <category term="bug" scheme="https://ricky-ting.github.io/tags/bug/"/>
    
      <category term="solution" scheme="https://ricky-ting.github.io/tags/solution/"/>
    
  </entry>
  
</feed>
